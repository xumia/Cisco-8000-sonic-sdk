$block{res} = {
  Defines_db => "../verilog/sdb_idb_defines.v,../../global/npu_db_defines.v",
  ProjectName => "Gibraltar",
  InterruptRegister => { #Structure Type: Reg; Skip Register;
    Name => "InterruptRegister",
    RegMem => "Reg",
    Address => "0",
    Description => "Master Interrupt Register",
    Width => "4",
    Type => "Interrupt",
    MemProtectInterruptSummary => { #Structure Type: RegField;
      Name => "MemProtectInterruptSummary",
      RegMem => "RegField",
      Description => "When this bit is set, MemProtectInterrupt has asserted interrupt",
      Width => "1",
      Position => "0",
      Type => "Interrupt",
    },
    ResolutionInterrupts0Summary => { #Structure Type: RegField;
      Name => "ResolutionInterrupts0Summary",
      RegMem => "RegField",
      Description => "When this bit is set, ResolutionInterrupts0 has asserted interrupt",
      Width => "1",
      Position => "1",
      Type => "Interrupt",
    },
    ResolutionInterrupts1Summary => { #Structure Type: RegField;
      Name => "ResolutionInterrupts1Summary",
      RegMem => "RegField",
      Description => "When this bit is set, ResolutionInterrupts1 has asserted interrupt",
      Width => "1",
      Position => "2",
      Type => "Interrupt",
    },
    EmResponseInterruptSummary => { #Structure Type: RegField;
      Name => "EmResponseInterruptSummary",
      RegMem => "RegField",
      Description => "When this bit is set, EmResponseInterrupt has asserted interrupt",
      Width => "1",
      Position => "3",
      Type => "Interrupt",
    },
  },
  MemProtectInterrupt => { #Structure Type: Reg; Skip Register;
    Name => "MemProtectInterrupt",
    RegMem => "Reg",
    Address => "1",
    Description => "ECC/Parity Interrupt Register",
    Width => "3",
    Type => "Interrupt",
    Ecc_1bErrInterrupt => { #Structure Type: RegField;
      Name => "Ecc_1bErrInterrupt",
      RegMem => "RegField",
      Description => "When this bit is set, ECC 1b error was detected",
      Width => "1",
      Position => "0",
      Type => "Interrupt",
      UsedBy => "SER",
    },
    Ecc_2bErrInterrupt => { #Structure Type: RegField;
      Name => "Ecc_2bErrInterrupt",
      RegMem => "RegField",
      Description => "When this bit is set, ECC 2b error was detected",
      Width => "1",
      Position => "1",
      Type => "Interrupt",
      UsedBy => "SER",
    },
    ParityErrInterrupt => { #Structure Type: RegField;
      Name => "ParityErrInterrupt",
      RegMem => "RegField",
      Description => "When this bit is set, Parity error was detected",
      Width => "1",
      Position => "2",
      Type => "Interrupt",
      UsedBy => "SER",
    },
  },
  MemProtectInterruptTest => { #Structure Type: Reg; Skip Register;
    Name => "MemProtectInterruptTest",
    RegMem => "Reg",
    Address => "2",
    Description => "ECC/Parity Interrupt test register",
    Width => "3",
    Type => "InterruptTest",
    Ecc_1bErrInterruptTest => { #Structure Type: RegField;
      Name => "Ecc_1bErrInterruptTest",
      RegMem => "RegField",
      Description => "Setting this filed to 1 triggers an assertion of the interrupt that is associated with this test field",
      Width => "1",
      Position => "0",
      Type => "InterruptTest",
      UsedBy => "",
      DefaultValue => "b0",
    },
    Ecc_2bErrInterruptTest => { #Structure Type: RegField;
      Name => "Ecc_2bErrInterruptTest",
      RegMem => "RegField",
      Description => "Setting this filed to 1 triggers an assertion of the interrupt that is associated with this test field",
      Width => "1",
      Position => "1",
      Type => "InterruptTest",
      UsedBy => "",
      DefaultValue => "b0",
    },
    ParityErrInterruptTest => { #Structure Type: RegField;
      Name => "ParityErrInterruptTest",
      RegMem => "RegField",
      Description => "Setting this filed to 1 triggers an assertion of the interrupt that is associated with this test field",
      Width => "1",
      Position => "2",
      Type => "InterruptTest",
      UsedBy => "",
      DefaultValue => "b0",
    },
  },
  Ecc_1bErrInterruptRegisterMask => { #Structure Type: Reg; Skip Register;
    Name => "Ecc_1bErrInterruptRegisterMask",
    RegMem => "Reg",
    Address => "3",
    Description => "ECC 1b Error Interrupt Mask Register",
    Width => "60",
    Type => "Config",
    protection_table_slice0_stage0Ecc_1bErrInterruptMask => { #Structure Type: RegField;
      Name => "protection_table_slice0_stage0Ecc_1bErrInterruptMask",
      RegMem => "RegField",
      Description => "When this bit is set, ECC 1b Error indication will be masked",
      Width => "1",
      Position => "0",
      Type => "Config",
      UsedBy => "SER",
      DefaultValue => "b1",
    },
    protection_table_slice0_stage1Ecc_1bErrInterruptMask => { #Structure Type: RegField;
      Name => "protection_table_slice0_stage1Ecc_1bErrInterruptMask",
      RegMem => "RegField",
      Description => "When this bit is set, ECC 1b Error indication will be masked",
      Width => "1",
      Position => "1",
      Type => "Config",
      UsedBy => "SER",
      DefaultValue => "b1",
    },
    protection_table_slice0_stage2Ecc_1bErrInterruptMask => { #Structure Type: RegField;
      Name => "protection_table_slice0_stage2Ecc_1bErrInterruptMask",
      RegMem => "RegField",
      Description => "When this bit is set, ECC 1b Error indication will be masked",
      Width => "1",
      Position => "2",
      Type => "Config",
      UsedBy => "SER",
      DefaultValue => "b1",
    },
    protection_table_slice0_stage3Ecc_1bErrInterruptMask => { #Structure Type: RegField;
      Name => "protection_table_slice0_stage3Ecc_1bErrInterruptMask",
      RegMem => "RegField",
      Description => "When this bit is set, ECC 1b Error indication will be masked",
      Width => "1",
      Position => "3",
      Type => "Config",
      UsedBy => "SER",
      DefaultValue => "b1",
    },
    slice0_stage0_lb_consistence_cache_tableEcc_1bErrInterruptMask => { #Structure Type: RegField;
      Name => "slice0_stage0_lb_consistence_cache_tableEcc_1bErrInterruptMask",
      RegMem => "RegField",
      Description => "When this bit is set, ECC 1b Error indication will be masked",
      Width => "1",
      Position => "4",
      Type => "Config",
      UsedBy => "SER",
      DefaultValue => "b1",
    },
    slice0_stage1_lb_consistence_cache_tableEcc_1bErrInterruptMask => { #Structure Type: RegField;
      Name => "slice0_stage1_lb_consistence_cache_tableEcc_1bErrInterruptMask",
      RegMem => "RegField",
      Description => "When this bit is set, ECC 1b Error indication will be masked",
      Width => "1",
      Position => "5",
      Type => "Config",
      UsedBy => "SER",
      DefaultValue => "b1",
    },
    slice0_stage2_lb_consistence_cache_tableEcc_1bErrInterruptMask => { #Structure Type: RegField;
      Name => "slice0_stage2_lb_consistence_cache_tableEcc_1bErrInterruptMask",
      RegMem => "RegField",
      Description => "When this bit is set, ECC 1b Error indication will be masked",
      Width => "1",
      Position => "6",
      Type => "Config",
      UsedBy => "SER",
      DefaultValue => "b1",
    },
    slice0_stage3_lb_consistence_cache_tableEcc_1bErrInterruptMask => { #Structure Type: RegField;
      Name => "slice0_stage3_lb_consistence_cache_tableEcc_1bErrInterruptMask",
      RegMem => "RegField",
      Description => "When this bit is set, ECC 1b Error indication will be masked",
      Width => "1",
      Position => "7",
      Type => "Config",
      UsedBy => "SER",
      DefaultValue => "b1",
    },
    ResolutionStage0AssociatedDataEcc_1bErrInterruptMask => { #Structure Type: RegField;
      Name => "ResolutionStage0AssociatedDataEcc_1bErrInterruptMask",
      RegMem => "RegField",
      Description => "When this bit is set, ECC 1b Error indication will be masked",
      Width => "1",
      Position => "8",
      Type => "Config",
      UsedBy => "SER",
      DefaultValue => "b1",
    },
    FecTableEcc_1bErrInterruptMask => { #Structure Type: RegField;
      Name => "FecTableEcc_1bErrInterruptMask",
      RegMem => "RegField",
      Description => "When this bit is set, ECC 1b Error indication will be masked",
      Width => "1",
      Position => "9",
      Type => "Config",
      UsedBy => "SER",
      DefaultValue => "b1",
    },
    ResolutionStage1AssociatedDataEcc_1bErrInterruptMask => { #Structure Type: RegField;
      Name => "ResolutionStage1AssociatedDataEcc_1bErrInterruptMask",
      RegMem => "RegField",
      Description => "When this bit is set, ECC 1b Error indication will be masked",
      Width => "1",
      Position => "10",
      Type => "Config",
      UsedBy => "SER",
      DefaultValue => "b1",
    },
    ResolutionStage2AssociatedDataEcc_1bErrInterruptMask => { #Structure Type: RegField;
      Name => "ResolutionStage2AssociatedDataEcc_1bErrInterruptMask",
      RegMem => "RegField",
      Description => "When this bit is set, ECC 1b Error indication will be masked",
      Width => "1",
      Position => "11",
      Type => "Config",
      UsedBy => "SER",
      DefaultValue => "b1",
    },
    ResolutionStage3AssociatedDataEcc_1bErrInterruptMask => { #Structure Type: RegField;
      Name => "ResolutionStage3AssociatedDataEcc_1bErrInterruptMask",
      RegMem => "RegField",
      Description => "When this bit is set, ECC 1b Error indication will be masked",
      Width => "1",
      Position => "12",
      Type => "Config",
      UsedBy => "SER",
      DefaultValue => "b1",
    },
    protection_table_slice1_stage0Ecc_1bErrInterruptMask => { #Structure Type: RegField;
      Name => "protection_table_slice1_stage0Ecc_1bErrInterruptMask",
      RegMem => "RegField",
      Description => "When this bit is set, ECC 1b Error indication will be masked",
      Width => "1",
      Position => "13",
      Type => "Config",
      UsedBy => "SER",
      DefaultValue => "b1",
    },
    protection_table_slice1_stage1Ecc_1bErrInterruptMask => { #Structure Type: RegField;
      Name => "protection_table_slice1_stage1Ecc_1bErrInterruptMask",
      RegMem => "RegField",
      Description => "When this bit is set, ECC 1b Error indication will be masked",
      Width => "1",
      Position => "14",
      Type => "Config",
      UsedBy => "SER",
      DefaultValue => "b1",
    },
    protection_table_slice1_stage2Ecc_1bErrInterruptMask => { #Structure Type: RegField;
      Name => "protection_table_slice1_stage2Ecc_1bErrInterruptMask",
      RegMem => "RegField",
      Description => "When this bit is set, ECC 1b Error indication will be masked",
      Width => "1",
      Position => "15",
      Type => "Config",
      UsedBy => "SER",
      DefaultValue => "b1",
    },
    protection_table_slice1_stage3Ecc_1bErrInterruptMask => { #Structure Type: RegField;
      Name => "protection_table_slice1_stage3Ecc_1bErrInterruptMask",
      RegMem => "RegField",
      Description => "When this bit is set, ECC 1b Error indication will be masked",
      Width => "1",
      Position => "16",
      Type => "Config",
      UsedBy => "SER",
      DefaultValue => "b1",
    },
    Slice0Stage0LbGroupSizeTableEcc_1bErrInterruptMask => { #Structure Type: RegField;
      Name => "Slice0Stage0LbGroupSizeTableEcc_1bErrInterruptMask",
      RegMem => "RegField",
      Description => "When this bit is set, ECC 1b Error indication will be masked",
      Width => "1",
      Position => "17",
      Type => "Config",
      UsedBy => "SER",
      DefaultValue => "b1",
    },
    Slice0Stage1LbGroupSizeTableEcc_1bErrInterruptMask => { #Structure Type: RegField;
      Name => "Slice0Stage1LbGroupSizeTableEcc_1bErrInterruptMask",
      RegMem => "RegField",
      Description => "When this bit is set, ECC 1b Error indication will be masked",
      Width => "1",
      Position => "18",
      Type => "Config",
      UsedBy => "SER",
      DefaultValue => "b1",
    },
    Slice0Stage2LbGroupSizeTableEcc_1bErrInterruptMask => { #Structure Type: RegField;
      Name => "Slice0Stage2LbGroupSizeTableEcc_1bErrInterruptMask",
      RegMem => "RegField",
      Description => "When this bit is set, ECC 1b Error indication will be masked",
      Width => "1",
      Position => "19",
      Type => "Config",
      UsedBy => "SER",
      DefaultValue => "b1",
    },
    Slice0Stage3LbGroupSizeTableEcc_1bErrInterruptMask => { #Structure Type: RegField;
      Name => "Slice0Stage3LbGroupSizeTableEcc_1bErrInterruptMask",
      RegMem => "RegField",
      Description => "When this bit is set, ECC 1b Error indication will be masked",
      Width => "1",
      Position => "20",
      Type => "Config",
      UsedBy => "SER",
      DefaultValue => "b1",
    },
    Slice1Stage0LbGroupSizeTableEcc_1bErrInterruptMask => { #Structure Type: RegField;
      Name => "Slice1Stage0LbGroupSizeTableEcc_1bErrInterruptMask",
      RegMem => "RegField",
      Description => "When this bit is set, ECC 1b Error indication will be masked",
      Width => "1",
      Position => "21",
      Type => "Config",
      UsedBy => "SER",
      DefaultValue => "b1",
    },
    Slice1Stage1LbGroupSizeTableEcc_1bErrInterruptMask => { #Structure Type: RegField;
      Name => "Slice1Stage1LbGroupSizeTableEcc_1bErrInterruptMask",
      RegMem => "RegField",
      Description => "When this bit is set, ECC 1b Error indication will be masked",
      Width => "1",
      Position => "22",
      Type => "Config",
      UsedBy => "SER",
      DefaultValue => "b1",
    },
    Slice1Stage2LbGroupSizeTableEcc_1bErrInterruptMask => { #Structure Type: RegField;
      Name => "Slice1Stage2LbGroupSizeTableEcc_1bErrInterruptMask",
      RegMem => "RegField",
      Description => "When this bit is set, ECC 1b Error indication will be masked",
      Width => "1",
      Position => "23",
      Type => "Config",
      UsedBy => "SER",
      DefaultValue => "b1",
    },
    Slice1Stage3LbGroupSizeTableEcc_1bErrInterruptMask => { #Structure Type: RegField;
      Name => "Slice1Stage3LbGroupSizeTableEcc_1bErrInterruptMask",
      RegMem => "RegField",
      Description => "When this bit is set, ECC 1b Error indication will be masked",
      Width => "1",
      Position => "24",
      Type => "Config",
      UsedBy => "SER",
      DefaultValue => "b1",
    },
    slice1_stage0_lb_consistence_cache_tableEcc_1bErrInterruptMask => { #Structure Type: RegField;
      Name => "slice1_stage0_lb_consistence_cache_tableEcc_1bErrInterruptMask",
      RegMem => "RegField",
      Description => "When this bit is set, ECC 1b Error indication will be masked",
      Width => "1",
      Position => "25",
      Type => "Config",
      UsedBy => "SER",
      DefaultValue => "b1",
    },
    slice1_stage1_lb_consistence_cache_tableEcc_1bErrInterruptMask => { #Structure Type: RegField;
      Name => "slice1_stage1_lb_consistence_cache_tableEcc_1bErrInterruptMask",
      RegMem => "RegField",
      Description => "When this bit is set, ECC 1b Error indication will be masked",
      Width => "1",
      Position => "26",
      Type => "Config",
      UsedBy => "SER",
      DefaultValue => "b1",
    },
    slice1_stage2_lb_consistence_cache_tableEcc_1bErrInterruptMask => { #Structure Type: RegField;
      Name => "slice1_stage2_lb_consistence_cache_tableEcc_1bErrInterruptMask",
      RegMem => "RegField",
      Description => "When this bit is set, ECC 1b Error indication will be masked",
      Width => "1",
      Position => "27",
      Type => "Config",
      UsedBy => "SER",
      DefaultValue => "b1",
    },
    slice1_stage3_lb_consistence_cache_tableEcc_1bErrInterruptMask => { #Structure Type: RegField;
      Name => "slice1_stage3_lb_consistence_cache_tableEcc_1bErrInterruptMask",
      RegMem => "RegField",
      Description => "When this bit is set, ECC 1b Error indication will be masked",
      Width => "1",
      Position => "28",
      Type => "Config",
      UsedBy => "SER",
      DefaultValue => "b1",
    },
    ResolutionStage0EmVerifier0Ecc_1bErrInterruptMask => { #Structure Type: RegField;
      Name => "ResolutionStage0EmVerifier0Ecc_1bErrInterruptMask",
      RegMem => "RegField",
      Description => "When this bit is set, ECC 1b Error indication will be masked",
      Width => "1",
      Position => "29",
      Type => "Config",
      UsedBy => "SER",
      DefaultValue => "b1",
    },
    ResolutionStage0EmVerifier1Ecc_1bErrInterruptMask => { #Structure Type: RegField;
      Name => "ResolutionStage0EmVerifier1Ecc_1bErrInterruptMask",
      RegMem => "RegField",
      Description => "When this bit is set, ECC 1b Error indication will be masked",
      Width => "1",
      Position => "30",
      Type => "Config",
      UsedBy => "SER",
      DefaultValue => "b1",
    },
    ResolutionStage0EmVerifier2Ecc_1bErrInterruptMask => { #Structure Type: RegField;
      Name => "ResolutionStage0EmVerifier2Ecc_1bErrInterruptMask",
      RegMem => "RegField",
      Description => "When this bit is set, ECC 1b Error indication will be masked",
      Width => "1",
      Position => "31",
      Type => "Config",
      UsedBy => "SER",
      DefaultValue => "b1",
    },
    ResolutionStage0EmVerifier3Ecc_1bErrInterruptMask => { #Structure Type: RegField;
      Name => "ResolutionStage0EmVerifier3Ecc_1bErrInterruptMask",
      RegMem => "RegField",
      Description => "When this bit is set, ECC 1b Error indication will be masked",
      Width => "1",
      Position => "32",
      Type => "Config",
      UsedBy => "SER",
      DefaultValue => "b1",
    },
    ResolutionStage0EmVerifier4Ecc_1bErrInterruptMask => { #Structure Type: RegField;
      Name => "ResolutionStage0EmVerifier4Ecc_1bErrInterruptMask",
      RegMem => "RegField",
      Description => "When this bit is set, ECC 1b Error indication will be masked",
      Width => "1",
      Position => "33",
      Type => "Config",
      UsedBy => "SER",
      DefaultValue => "b1",
    },
    ResolutionStage0EmVerifier5Ecc_1bErrInterruptMask => { #Structure Type: RegField;
      Name => "ResolutionStage0EmVerifier5Ecc_1bErrInterruptMask",
      RegMem => "RegField",
      Description => "When this bit is set, ECC 1b Error indication will be masked",
      Width => "1",
      Position => "34",
      Type => "Config",
      UsedBy => "SER",
      DefaultValue => "b1",
    },
    ResolutionStage0EmVerifier6Ecc_1bErrInterruptMask => { #Structure Type: RegField;
      Name => "ResolutionStage0EmVerifier6Ecc_1bErrInterruptMask",
      RegMem => "RegField",
      Description => "When this bit is set, ECC 1b Error indication will be masked",
      Width => "1",
      Position => "35",
      Type => "Config",
      UsedBy => "SER",
      DefaultValue => "b1",
    },
    ResolutionStage0EmVerifier7Ecc_1bErrInterruptMask => { #Structure Type: RegField;
      Name => "ResolutionStage0EmVerifier7Ecc_1bErrInterruptMask",
      RegMem => "RegField",
      Description => "When this bit is set, ECC 1b Error indication will be masked",
      Width => "1",
      Position => "36",
      Type => "Config",
      UsedBy => "SER",
      DefaultValue => "b1",
    },
    ResolutionStage0EmVerifier8Ecc_1bErrInterruptMask => { #Structure Type: RegField;
      Name => "ResolutionStage0EmVerifier8Ecc_1bErrInterruptMask",
      RegMem => "RegField",
      Description => "When this bit is set, ECC 1b Error indication will be masked",
      Width => "1",
      Position => "37",
      Type => "Config",
      UsedBy => "SER",
      DefaultValue => "b1",
    },
    ResolutionStage0EmVerifier9Ecc_1bErrInterruptMask => { #Structure Type: RegField;
      Name => "ResolutionStage0EmVerifier9Ecc_1bErrInterruptMask",
      RegMem => "RegField",
      Description => "When this bit is set, ECC 1b Error indication will be masked",
      Width => "1",
      Position => "38",
      Type => "Config",
      UsedBy => "SER",
      DefaultValue => "b1",
    },
    ResolutionStage0EmVerifier10Ecc_1bErrInterruptMask => { #Structure Type: RegField;
      Name => "ResolutionStage0EmVerifier10Ecc_1bErrInterruptMask",
      RegMem => "RegField",
      Description => "When this bit is set, ECC 1b Error indication will be masked",
      Width => "1",
      Position => "39",
      Type => "Config",
      UsedBy => "SER",
      DefaultValue => "b1",
    },
    ResolutionStage0EmVerifier11Ecc_1bErrInterruptMask => { #Structure Type: RegField;
      Name => "ResolutionStage0EmVerifier11Ecc_1bErrInterruptMask",
      RegMem => "RegField",
      Description => "When this bit is set, ECC 1b Error indication will be masked",
      Width => "1",
      Position => "40",
      Type => "Config",
      UsedBy => "SER",
      DefaultValue => "b1",
    },
    LpQueuingEmVerifier0Ecc_1bErrInterruptMask => { #Structure Type: RegField;
      Name => "LpQueuingEmVerifier0Ecc_1bErrInterruptMask",
      RegMem => "RegField",
      Description => "When this bit is set, ECC 1b Error indication will be masked",
      Width => "1",
      Position => "41",
      Type => "Config",
      UsedBy => "SER",
      DefaultValue => "b1",
    },
    LpQueuingEmVerifier1Ecc_1bErrInterruptMask => { #Structure Type: RegField;
      Name => "LpQueuingEmVerifier1Ecc_1bErrInterruptMask",
      RegMem => "RegField",
      Description => "When this bit is set, ECC 1b Error indication will be masked",
      Width => "1",
      Position => "42",
      Type => "Config",
      UsedBy => "SER",
      DefaultValue => "b1",
    },
    LpQueuingEmVerifier2Ecc_1bErrInterruptMask => { #Structure Type: RegField;
      Name => "LpQueuingEmVerifier2Ecc_1bErrInterruptMask",
      RegMem => "RegField",
      Description => "When this bit is set, ECC 1b Error indication will be masked",
      Width => "1",
      Position => "43",
      Type => "Config",
      UsedBy => "SER",
      DefaultValue => "b1",
    },
    LpQueuingEmVerifier3Ecc_1bErrInterruptMask => { #Structure Type: RegField;
      Name => "LpQueuingEmVerifier3Ecc_1bErrInterruptMask",
      RegMem => "RegField",
      Description => "When this bit is set, ECC 1b Error indication will be masked",
      Width => "1",
      Position => "44",
      Type => "Config",
      UsedBy => "SER",
      DefaultValue => "b1",
    },
    LpQueuingEmVerifier4Ecc_1bErrInterruptMask => { #Structure Type: RegField;
      Name => "LpQueuingEmVerifier4Ecc_1bErrInterruptMask",
      RegMem => "RegField",
      Description => "When this bit is set, ECC 1b Error indication will be masked",
      Width => "1",
      Position => "45",
      Type => "Config",
      UsedBy => "SER",
      DefaultValue => "b1",
    },
    ResolutionStage1EmVerifier0Ecc_1bErrInterruptMask => { #Structure Type: RegField;
      Name => "ResolutionStage1EmVerifier0Ecc_1bErrInterruptMask",
      RegMem => "RegField",
      Description => "When this bit is set, ECC 1b Error indication will be masked",
      Width => "1",
      Position => "46",
      Type => "Config",
      UsedBy => "SER",
      DefaultValue => "b1",
    },
    ResolutionStage1EmVerifier1Ecc_1bErrInterruptMask => { #Structure Type: RegField;
      Name => "ResolutionStage1EmVerifier1Ecc_1bErrInterruptMask",
      RegMem => "RegField",
      Description => "When this bit is set, ECC 1b Error indication will be masked",
      Width => "1",
      Position => "47",
      Type => "Config",
      UsedBy => "SER",
      DefaultValue => "b1",
    },
    ResolutionStage1EmVerifier2Ecc_1bErrInterruptMask => { #Structure Type: RegField;
      Name => "ResolutionStage1EmVerifier2Ecc_1bErrInterruptMask",
      RegMem => "RegField",
      Description => "When this bit is set, ECC 1b Error indication will be masked",
      Width => "1",
      Position => "48",
      Type => "Config",
      UsedBy => "SER",
      DefaultValue => "b1",
    },
    ResolutionStage1EmVerifier3Ecc_1bErrInterruptMask => { #Structure Type: RegField;
      Name => "ResolutionStage1EmVerifier3Ecc_1bErrInterruptMask",
      RegMem => "RegField",
      Description => "When this bit is set, ECC 1b Error indication will be masked",
      Width => "1",
      Position => "49",
      Type => "Config",
      UsedBy => "SER",
      DefaultValue => "b1",
    },
    ResolutionStage2EmVerifier0Ecc_1bErrInterruptMask => { #Structure Type: RegField;
      Name => "ResolutionStage2EmVerifier0Ecc_1bErrInterruptMask",
      RegMem => "RegField",
      Description => "When this bit is set, ECC 1b Error indication will be masked",
      Width => "1",
      Position => "50",
      Type => "Config",
      UsedBy => "SER",
      DefaultValue => "b1",
    },
    ResolutionStage2EmVerifier1Ecc_1bErrInterruptMask => { #Structure Type: RegField;
      Name => "ResolutionStage2EmVerifier1Ecc_1bErrInterruptMask",
      RegMem => "RegField",
      Description => "When this bit is set, ECC 1b Error indication will be masked",
      Width => "1",
      Position => "51",
      Type => "Config",
      UsedBy => "SER",
      DefaultValue => "b1",
    },
    ResolutionStage2EmVerifier2Ecc_1bErrInterruptMask => { #Structure Type: RegField;
      Name => "ResolutionStage2EmVerifier2Ecc_1bErrInterruptMask",
      RegMem => "RegField",
      Description => "When this bit is set, ECC 1b Error indication will be masked",
      Width => "1",
      Position => "52",
      Type => "Config",
      UsedBy => "SER",
      DefaultValue => "b1",
    },
    ResolutionStage2EmVerifier3Ecc_1bErrInterruptMask => { #Structure Type: RegField;
      Name => "ResolutionStage2EmVerifier3Ecc_1bErrInterruptMask",
      RegMem => "RegField",
      Description => "When this bit is set, ECC 1b Error indication will be masked",
      Width => "1",
      Position => "53",
      Type => "Config",
      UsedBy => "SER",
      DefaultValue => "b1",
    },
    ResolutionStage3EmVerifier0Ecc_1bErrInterruptMask => { #Structure Type: RegField;
      Name => "ResolutionStage3EmVerifier0Ecc_1bErrInterruptMask",
      RegMem => "RegField",
      Description => "When this bit is set, ECC 1b Error indication will be masked",
      Width => "1",
      Position => "54",
      Type => "Config",
      UsedBy => "SER",
      DefaultValue => "b1",
    },
    ResolutionStage3EmVerifier1Ecc_1bErrInterruptMask => { #Structure Type: RegField;
      Name => "ResolutionStage3EmVerifier1Ecc_1bErrInterruptMask",
      RegMem => "RegField",
      Description => "When this bit is set, ECC 1b Error indication will be masked",
      Width => "1",
      Position => "55",
      Type => "Config",
      UsedBy => "SER",
      DefaultValue => "b1",
    },
    ResolutionStage3EmVerifier2Ecc_1bErrInterruptMask => { #Structure Type: RegField;
      Name => "ResolutionStage3EmVerifier2Ecc_1bErrInterruptMask",
      RegMem => "RegField",
      Description => "When this bit is set, ECC 1b Error indication will be masked",
      Width => "1",
      Position => "56",
      Type => "Config",
      UsedBy => "SER",
      DefaultValue => "b1",
    },
    ResolutionStage3EmVerifier3Ecc_1bErrInterruptMask => { #Structure Type: RegField;
      Name => "ResolutionStage3EmVerifier3Ecc_1bErrInterruptMask",
      RegMem => "RegField",
      Description => "When this bit is set, ECC 1b Error indication will be masked",
      Width => "1",
      Position => "57",
      Type => "Config",
      UsedBy => "SER",
      DefaultValue => "b1",
    },
    ResolutionStage3EmVerifier4Ecc_1bErrInterruptMask => { #Structure Type: RegField;
      Name => "ResolutionStage3EmVerifier4Ecc_1bErrInterruptMask",
      RegMem => "RegField",
      Description => "When this bit is set, ECC 1b Error indication will be masked",
      Width => "1",
      Position => "58",
      Type => "Config",
      UsedBy => "SER",
      DefaultValue => "b1",
    },
    ResolutionStage3EmVerifier5Ecc_1bErrInterruptMask => { #Structure Type: RegField;
      Name => "ResolutionStage3EmVerifier5Ecc_1bErrInterruptMask",
      RegMem => "RegField",
      Description => "When this bit is set, ECC 1b Error indication will be masked",
      Width => "1",
      Position => "59",
      Type => "Config",
      UsedBy => "SER",
      DefaultValue => "b1",
    },
  },
  Ecc_2bErrInterruptRegisterMask => { #Structure Type: Reg; Skip Register;
    Name => "Ecc_2bErrInterruptRegisterMask",
    RegMem => "Reg",
    Address => "4",
    Description => "ECC 2b Error Interrupt Mask Register",
    Width => "60",
    Type => "Config",
    protection_table_slice0_stage0Ecc_2bErrInterruptMask => { #Structure Type: RegField;
      Name => "protection_table_slice0_stage0Ecc_2bErrInterruptMask",
      RegMem => "RegField",
      Description => "When this bit is set, ECC 2b Error indication will be masked",
      Width => "1",
      Position => "0",
      Type => "Config",
      UsedBy => "SER",
      DefaultValue => "b1",
    },
    protection_table_slice0_stage1Ecc_2bErrInterruptMask => { #Structure Type: RegField;
      Name => "protection_table_slice0_stage1Ecc_2bErrInterruptMask",
      RegMem => "RegField",
      Description => "When this bit is set, ECC 2b Error indication will be masked",
      Width => "1",
      Position => "1",
      Type => "Config",
      UsedBy => "SER",
      DefaultValue => "b1",
    },
    protection_table_slice0_stage2Ecc_2bErrInterruptMask => { #Structure Type: RegField;
      Name => "protection_table_slice0_stage2Ecc_2bErrInterruptMask",
      RegMem => "RegField",
      Description => "When this bit is set, ECC 2b Error indication will be masked",
      Width => "1",
      Position => "2",
      Type => "Config",
      UsedBy => "SER",
      DefaultValue => "b1",
    },
    protection_table_slice0_stage3Ecc_2bErrInterruptMask => { #Structure Type: RegField;
      Name => "protection_table_slice0_stage3Ecc_2bErrInterruptMask",
      RegMem => "RegField",
      Description => "When this bit is set, ECC 2b Error indication will be masked",
      Width => "1",
      Position => "3",
      Type => "Config",
      UsedBy => "SER",
      DefaultValue => "b1",
    },
    slice0_stage0_lb_consistence_cache_tableEcc_2bErrInterruptMask => { #Structure Type: RegField;
      Name => "slice0_stage0_lb_consistence_cache_tableEcc_2bErrInterruptMask",
      RegMem => "RegField",
      Description => "When this bit is set, ECC 2b Error indication will be masked",
      Width => "1",
      Position => "4",
      Type => "Config",
      UsedBy => "SER",
      DefaultValue => "b1",
    },
    slice0_stage1_lb_consistence_cache_tableEcc_2bErrInterruptMask => { #Structure Type: RegField;
      Name => "slice0_stage1_lb_consistence_cache_tableEcc_2bErrInterruptMask",
      RegMem => "RegField",
      Description => "When this bit is set, ECC 2b Error indication will be masked",
      Width => "1",
      Position => "5",
      Type => "Config",
      UsedBy => "SER",
      DefaultValue => "b1",
    },
    slice0_stage2_lb_consistence_cache_tableEcc_2bErrInterruptMask => { #Structure Type: RegField;
      Name => "slice0_stage2_lb_consistence_cache_tableEcc_2bErrInterruptMask",
      RegMem => "RegField",
      Description => "When this bit is set, ECC 2b Error indication will be masked",
      Width => "1",
      Position => "6",
      Type => "Config",
      UsedBy => "SER",
      DefaultValue => "b1",
    },
    slice0_stage3_lb_consistence_cache_tableEcc_2bErrInterruptMask => { #Structure Type: RegField;
      Name => "slice0_stage3_lb_consistence_cache_tableEcc_2bErrInterruptMask",
      RegMem => "RegField",
      Description => "When this bit is set, ECC 2b Error indication will be masked",
      Width => "1",
      Position => "7",
      Type => "Config",
      UsedBy => "SER",
      DefaultValue => "b1",
    },
    ResolutionStage0AssociatedDataEcc_2bErrInterruptMask => { #Structure Type: RegField;
      Name => "ResolutionStage0AssociatedDataEcc_2bErrInterruptMask",
      RegMem => "RegField",
      Description => "When this bit is set, ECC 2b Error indication will be masked",
      Width => "1",
      Position => "8",
      Type => "Config",
      UsedBy => "SER",
      DefaultValue => "b1",
    },
    FecTableEcc_2bErrInterruptMask => { #Structure Type: RegField;
      Name => "FecTableEcc_2bErrInterruptMask",
      RegMem => "RegField",
      Description => "When this bit is set, ECC 2b Error indication will be masked",
      Width => "1",
      Position => "9",
      Type => "Config",
      UsedBy => "SER",
      DefaultValue => "b1",
    },
    ResolutionStage1AssociatedDataEcc_2bErrInterruptMask => { #Structure Type: RegField;
      Name => "ResolutionStage1AssociatedDataEcc_2bErrInterruptMask",
      RegMem => "RegField",
      Description => "When this bit is set, ECC 2b Error indication will be masked",
      Width => "1",
      Position => "10",
      Type => "Config",
      UsedBy => "SER",
      DefaultValue => "b1",
    },
    ResolutionStage2AssociatedDataEcc_2bErrInterruptMask => { #Structure Type: RegField;
      Name => "ResolutionStage2AssociatedDataEcc_2bErrInterruptMask",
      RegMem => "RegField",
      Description => "When this bit is set, ECC 2b Error indication will be masked",
      Width => "1",
      Position => "11",
      Type => "Config",
      UsedBy => "SER",
      DefaultValue => "b1",
    },
    ResolutionStage3AssociatedDataEcc_2bErrInterruptMask => { #Structure Type: RegField;
      Name => "ResolutionStage3AssociatedDataEcc_2bErrInterruptMask",
      RegMem => "RegField",
      Description => "When this bit is set, ECC 2b Error indication will be masked",
      Width => "1",
      Position => "12",
      Type => "Config",
      UsedBy => "SER",
      DefaultValue => "b1",
    },
    protection_table_slice1_stage0Ecc_2bErrInterruptMask => { #Structure Type: RegField;
      Name => "protection_table_slice1_stage0Ecc_2bErrInterruptMask",
      RegMem => "RegField",
      Description => "When this bit is set, ECC 2b Error indication will be masked",
      Width => "1",
      Position => "13",
      Type => "Config",
      UsedBy => "SER",
      DefaultValue => "b1",
    },
    protection_table_slice1_stage1Ecc_2bErrInterruptMask => { #Structure Type: RegField;
      Name => "protection_table_slice1_stage1Ecc_2bErrInterruptMask",
      RegMem => "RegField",
      Description => "When this bit is set, ECC 2b Error indication will be masked",
      Width => "1",
      Position => "14",
      Type => "Config",
      UsedBy => "SER",
      DefaultValue => "b1",
    },
    protection_table_slice1_stage2Ecc_2bErrInterruptMask => { #Structure Type: RegField;
      Name => "protection_table_slice1_stage2Ecc_2bErrInterruptMask",
      RegMem => "RegField",
      Description => "When this bit is set, ECC 2b Error indication will be masked",
      Width => "1",
      Position => "15",
      Type => "Config",
      UsedBy => "SER",
      DefaultValue => "b1",
    },
    protection_table_slice1_stage3Ecc_2bErrInterruptMask => { #Structure Type: RegField;
      Name => "protection_table_slice1_stage3Ecc_2bErrInterruptMask",
      RegMem => "RegField",
      Description => "When this bit is set, ECC 2b Error indication will be masked",
      Width => "1",
      Position => "16",
      Type => "Config",
      UsedBy => "SER",
      DefaultValue => "b1",
    },
    Slice0Stage0LbGroupSizeTableEcc_2bErrInterruptMask => { #Structure Type: RegField;
      Name => "Slice0Stage0LbGroupSizeTableEcc_2bErrInterruptMask",
      RegMem => "RegField",
      Description => "When this bit is set, ECC 2b Error indication will be masked",
      Width => "1",
      Position => "17",
      Type => "Config",
      UsedBy => "SER",
      DefaultValue => "b1",
    },
    Slice0Stage1LbGroupSizeTableEcc_2bErrInterruptMask => { #Structure Type: RegField;
      Name => "Slice0Stage1LbGroupSizeTableEcc_2bErrInterruptMask",
      RegMem => "RegField",
      Description => "When this bit is set, ECC 2b Error indication will be masked",
      Width => "1",
      Position => "18",
      Type => "Config",
      UsedBy => "SER",
      DefaultValue => "b1",
    },
    Slice0Stage2LbGroupSizeTableEcc_2bErrInterruptMask => { #Structure Type: RegField;
      Name => "Slice0Stage2LbGroupSizeTableEcc_2bErrInterruptMask",
      RegMem => "RegField",
      Description => "When this bit is set, ECC 2b Error indication will be masked",
      Width => "1",
      Position => "19",
      Type => "Config",
      UsedBy => "SER",
      DefaultValue => "b1",
    },
    Slice0Stage3LbGroupSizeTableEcc_2bErrInterruptMask => { #Structure Type: RegField;
      Name => "Slice0Stage3LbGroupSizeTableEcc_2bErrInterruptMask",
      RegMem => "RegField",
      Description => "When this bit is set, ECC 2b Error indication will be masked",
      Width => "1",
      Position => "20",
      Type => "Config",
      UsedBy => "SER",
      DefaultValue => "b1",
    },
    Slice1Stage0LbGroupSizeTableEcc_2bErrInterruptMask => { #Structure Type: RegField;
      Name => "Slice1Stage0LbGroupSizeTableEcc_2bErrInterruptMask",
      RegMem => "RegField",
      Description => "When this bit is set, ECC 2b Error indication will be masked",
      Width => "1",
      Position => "21",
      Type => "Config",
      UsedBy => "SER",
      DefaultValue => "b1",
    },
    Slice1Stage1LbGroupSizeTableEcc_2bErrInterruptMask => { #Structure Type: RegField;
      Name => "Slice1Stage1LbGroupSizeTableEcc_2bErrInterruptMask",
      RegMem => "RegField",
      Description => "When this bit is set, ECC 2b Error indication will be masked",
      Width => "1",
      Position => "22",
      Type => "Config",
      UsedBy => "SER",
      DefaultValue => "b1",
    },
    Slice1Stage2LbGroupSizeTableEcc_2bErrInterruptMask => { #Structure Type: RegField;
      Name => "Slice1Stage2LbGroupSizeTableEcc_2bErrInterruptMask",
      RegMem => "RegField",
      Description => "When this bit is set, ECC 2b Error indication will be masked",
      Width => "1",
      Position => "23",
      Type => "Config",
      UsedBy => "SER",
      DefaultValue => "b1",
    },
    Slice1Stage3LbGroupSizeTableEcc_2bErrInterruptMask => { #Structure Type: RegField;
      Name => "Slice1Stage3LbGroupSizeTableEcc_2bErrInterruptMask",
      RegMem => "RegField",
      Description => "When this bit is set, ECC 2b Error indication will be masked",
      Width => "1",
      Position => "24",
      Type => "Config",
      UsedBy => "SER",
      DefaultValue => "b1",
    },
    slice1_stage0_lb_consistence_cache_tableEcc_2bErrInterruptMask => { #Structure Type: RegField;
      Name => "slice1_stage0_lb_consistence_cache_tableEcc_2bErrInterruptMask",
      RegMem => "RegField",
      Description => "When this bit is set, ECC 2b Error indication will be masked",
      Width => "1",
      Position => "25",
      Type => "Config",
      UsedBy => "SER",
      DefaultValue => "b1",
    },
    slice1_stage1_lb_consistence_cache_tableEcc_2bErrInterruptMask => { #Structure Type: RegField;
      Name => "slice1_stage1_lb_consistence_cache_tableEcc_2bErrInterruptMask",
      RegMem => "RegField",
      Description => "When this bit is set, ECC 2b Error indication will be masked",
      Width => "1",
      Position => "26",
      Type => "Config",
      UsedBy => "SER",
      DefaultValue => "b1",
    },
    slice1_stage2_lb_consistence_cache_tableEcc_2bErrInterruptMask => { #Structure Type: RegField;
      Name => "slice1_stage2_lb_consistence_cache_tableEcc_2bErrInterruptMask",
      RegMem => "RegField",
      Description => "When this bit is set, ECC 2b Error indication will be masked",
      Width => "1",
      Position => "27",
      Type => "Config",
      UsedBy => "SER",
      DefaultValue => "b1",
    },
    slice1_stage3_lb_consistence_cache_tableEcc_2bErrInterruptMask => { #Structure Type: RegField;
      Name => "slice1_stage3_lb_consistence_cache_tableEcc_2bErrInterruptMask",
      RegMem => "RegField",
      Description => "When this bit is set, ECC 2b Error indication will be masked",
      Width => "1",
      Position => "28",
      Type => "Config",
      UsedBy => "SER",
      DefaultValue => "b1",
    },
    ResolutionStage0EmVerifier0Ecc_2bErrInterruptMask => { #Structure Type: RegField;
      Name => "ResolutionStage0EmVerifier0Ecc_2bErrInterruptMask",
      RegMem => "RegField",
      Description => "When this bit is set, ECC 2b Error indication will be masked",
      Width => "1",
      Position => "29",
      Type => "Config",
      UsedBy => "SER",
      DefaultValue => "b1",
    },
    ResolutionStage0EmVerifier1Ecc_2bErrInterruptMask => { #Structure Type: RegField;
      Name => "ResolutionStage0EmVerifier1Ecc_2bErrInterruptMask",
      RegMem => "RegField",
      Description => "When this bit is set, ECC 2b Error indication will be masked",
      Width => "1",
      Position => "30",
      Type => "Config",
      UsedBy => "SER",
      DefaultValue => "b1",
    },
    ResolutionStage0EmVerifier2Ecc_2bErrInterruptMask => { #Structure Type: RegField;
      Name => "ResolutionStage0EmVerifier2Ecc_2bErrInterruptMask",
      RegMem => "RegField",
      Description => "When this bit is set, ECC 2b Error indication will be masked",
      Width => "1",
      Position => "31",
      Type => "Config",
      UsedBy => "SER",
      DefaultValue => "b1",
    },
    ResolutionStage0EmVerifier3Ecc_2bErrInterruptMask => { #Structure Type: RegField;
      Name => "ResolutionStage0EmVerifier3Ecc_2bErrInterruptMask",
      RegMem => "RegField",
      Description => "When this bit is set, ECC 2b Error indication will be masked",
      Width => "1",
      Position => "32",
      Type => "Config",
      UsedBy => "SER",
      DefaultValue => "b1",
    },
    ResolutionStage0EmVerifier4Ecc_2bErrInterruptMask => { #Structure Type: RegField;
      Name => "ResolutionStage0EmVerifier4Ecc_2bErrInterruptMask",
      RegMem => "RegField",
      Description => "When this bit is set, ECC 2b Error indication will be masked",
      Width => "1",
      Position => "33",
      Type => "Config",
      UsedBy => "SER",
      DefaultValue => "b1",
    },
    ResolutionStage0EmVerifier5Ecc_2bErrInterruptMask => { #Structure Type: RegField;
      Name => "ResolutionStage0EmVerifier5Ecc_2bErrInterruptMask",
      RegMem => "RegField",
      Description => "When this bit is set, ECC 2b Error indication will be masked",
      Width => "1",
      Position => "34",
      Type => "Config",
      UsedBy => "SER",
      DefaultValue => "b1",
    },
    ResolutionStage0EmVerifier6Ecc_2bErrInterruptMask => { #Structure Type: RegField;
      Name => "ResolutionStage0EmVerifier6Ecc_2bErrInterruptMask",
      RegMem => "RegField",
      Description => "When this bit is set, ECC 2b Error indication will be masked",
      Width => "1",
      Position => "35",
      Type => "Config",
      UsedBy => "SER",
      DefaultValue => "b1",
    },
    ResolutionStage0EmVerifier7Ecc_2bErrInterruptMask => { #Structure Type: RegField;
      Name => "ResolutionStage0EmVerifier7Ecc_2bErrInterruptMask",
      RegMem => "RegField",
      Description => "When this bit is set, ECC 2b Error indication will be masked",
      Width => "1",
      Position => "36",
      Type => "Config",
      UsedBy => "SER",
      DefaultValue => "b1",
    },
    ResolutionStage0EmVerifier8Ecc_2bErrInterruptMask => { #Structure Type: RegField;
      Name => "ResolutionStage0EmVerifier8Ecc_2bErrInterruptMask",
      RegMem => "RegField",
      Description => "When this bit is set, ECC 2b Error indication will be masked",
      Width => "1",
      Position => "37",
      Type => "Config",
      UsedBy => "SER",
      DefaultValue => "b1",
    },
    ResolutionStage0EmVerifier9Ecc_2bErrInterruptMask => { #Structure Type: RegField;
      Name => "ResolutionStage0EmVerifier9Ecc_2bErrInterruptMask",
      RegMem => "RegField",
      Description => "When this bit is set, ECC 2b Error indication will be masked",
      Width => "1",
      Position => "38",
      Type => "Config",
      UsedBy => "SER",
      DefaultValue => "b1",
    },
    ResolutionStage0EmVerifier10Ecc_2bErrInterruptMask => { #Structure Type: RegField;
      Name => "ResolutionStage0EmVerifier10Ecc_2bErrInterruptMask",
      RegMem => "RegField",
      Description => "When this bit is set, ECC 2b Error indication will be masked",
      Width => "1",
      Position => "39",
      Type => "Config",
      UsedBy => "SER",
      DefaultValue => "b1",
    },
    ResolutionStage0EmVerifier11Ecc_2bErrInterruptMask => { #Structure Type: RegField;
      Name => "ResolutionStage0EmVerifier11Ecc_2bErrInterruptMask",
      RegMem => "RegField",
      Description => "When this bit is set, ECC 2b Error indication will be masked",
      Width => "1",
      Position => "40",
      Type => "Config",
      UsedBy => "SER",
      DefaultValue => "b1",
    },
    LpQueuingEmVerifier0Ecc_2bErrInterruptMask => { #Structure Type: RegField;
      Name => "LpQueuingEmVerifier0Ecc_2bErrInterruptMask",
      RegMem => "RegField",
      Description => "When this bit is set, ECC 2b Error indication will be masked",
      Width => "1",
      Position => "41",
      Type => "Config",
      UsedBy => "SER",
      DefaultValue => "b1",
    },
    LpQueuingEmVerifier1Ecc_2bErrInterruptMask => { #Structure Type: RegField;
      Name => "LpQueuingEmVerifier1Ecc_2bErrInterruptMask",
      RegMem => "RegField",
      Description => "When this bit is set, ECC 2b Error indication will be masked",
      Width => "1",
      Position => "42",
      Type => "Config",
      UsedBy => "SER",
      DefaultValue => "b1",
    },
    LpQueuingEmVerifier2Ecc_2bErrInterruptMask => { #Structure Type: RegField;
      Name => "LpQueuingEmVerifier2Ecc_2bErrInterruptMask",
      RegMem => "RegField",
      Description => "When this bit is set, ECC 2b Error indication will be masked",
      Width => "1",
      Position => "43",
      Type => "Config",
      UsedBy => "SER",
      DefaultValue => "b1",
    },
    LpQueuingEmVerifier3Ecc_2bErrInterruptMask => { #Structure Type: RegField;
      Name => "LpQueuingEmVerifier3Ecc_2bErrInterruptMask",
      RegMem => "RegField",
      Description => "When this bit is set, ECC 2b Error indication will be masked",
      Width => "1",
      Position => "44",
      Type => "Config",
      UsedBy => "SER",
      DefaultValue => "b1",
    },
    LpQueuingEmVerifier4Ecc_2bErrInterruptMask => { #Structure Type: RegField;
      Name => "LpQueuingEmVerifier4Ecc_2bErrInterruptMask",
      RegMem => "RegField",
      Description => "When this bit is set, ECC 2b Error indication will be masked",
      Width => "1",
      Position => "45",
      Type => "Config",
      UsedBy => "SER",
      DefaultValue => "b1",
    },
    ResolutionStage1EmVerifier0Ecc_2bErrInterruptMask => { #Structure Type: RegField;
      Name => "ResolutionStage1EmVerifier0Ecc_2bErrInterruptMask",
      RegMem => "RegField",
      Description => "When this bit is set, ECC 2b Error indication will be masked",
      Width => "1",
      Position => "46",
      Type => "Config",
      UsedBy => "SER",
      DefaultValue => "b1",
    },
    ResolutionStage1EmVerifier1Ecc_2bErrInterruptMask => { #Structure Type: RegField;
      Name => "ResolutionStage1EmVerifier1Ecc_2bErrInterruptMask",
      RegMem => "RegField",
      Description => "When this bit is set, ECC 2b Error indication will be masked",
      Width => "1",
      Position => "47",
      Type => "Config",
      UsedBy => "SER",
      DefaultValue => "b1",
    },
    ResolutionStage1EmVerifier2Ecc_2bErrInterruptMask => { #Structure Type: RegField;
      Name => "ResolutionStage1EmVerifier2Ecc_2bErrInterruptMask",
      RegMem => "RegField",
      Description => "When this bit is set, ECC 2b Error indication will be masked",
      Width => "1",
      Position => "48",
      Type => "Config",
      UsedBy => "SER",
      DefaultValue => "b1",
    },
    ResolutionStage1EmVerifier3Ecc_2bErrInterruptMask => { #Structure Type: RegField;
      Name => "ResolutionStage1EmVerifier3Ecc_2bErrInterruptMask",
      RegMem => "RegField",
      Description => "When this bit is set, ECC 2b Error indication will be masked",
      Width => "1",
      Position => "49",
      Type => "Config",
      UsedBy => "SER",
      DefaultValue => "b1",
    },
    ResolutionStage2EmVerifier0Ecc_2bErrInterruptMask => { #Structure Type: RegField;
      Name => "ResolutionStage2EmVerifier0Ecc_2bErrInterruptMask",
      RegMem => "RegField",
      Description => "When this bit is set, ECC 2b Error indication will be masked",
      Width => "1",
      Position => "50",
      Type => "Config",
      UsedBy => "SER",
      DefaultValue => "b1",
    },
    ResolutionStage2EmVerifier1Ecc_2bErrInterruptMask => { #Structure Type: RegField;
      Name => "ResolutionStage2EmVerifier1Ecc_2bErrInterruptMask",
      RegMem => "RegField",
      Description => "When this bit is set, ECC 2b Error indication will be masked",
      Width => "1",
      Position => "51",
      Type => "Config",
      UsedBy => "SER",
      DefaultValue => "b1",
    },
    ResolutionStage2EmVerifier2Ecc_2bErrInterruptMask => { #Structure Type: RegField;
      Name => "ResolutionStage2EmVerifier2Ecc_2bErrInterruptMask",
      RegMem => "RegField",
      Description => "When this bit is set, ECC 2b Error indication will be masked",
      Width => "1",
      Position => "52",
      Type => "Config",
      UsedBy => "SER",
      DefaultValue => "b1",
    },
    ResolutionStage2EmVerifier3Ecc_2bErrInterruptMask => { #Structure Type: RegField;
      Name => "ResolutionStage2EmVerifier3Ecc_2bErrInterruptMask",
      RegMem => "RegField",
      Description => "When this bit is set, ECC 2b Error indication will be masked",
      Width => "1",
      Position => "53",
      Type => "Config",
      UsedBy => "SER",
      DefaultValue => "b1",
    },
    ResolutionStage3EmVerifier0Ecc_2bErrInterruptMask => { #Structure Type: RegField;
      Name => "ResolutionStage3EmVerifier0Ecc_2bErrInterruptMask",
      RegMem => "RegField",
      Description => "When this bit is set, ECC 2b Error indication will be masked",
      Width => "1",
      Position => "54",
      Type => "Config",
      UsedBy => "SER",
      DefaultValue => "b1",
    },
    ResolutionStage3EmVerifier1Ecc_2bErrInterruptMask => { #Structure Type: RegField;
      Name => "ResolutionStage3EmVerifier1Ecc_2bErrInterruptMask",
      RegMem => "RegField",
      Description => "When this bit is set, ECC 2b Error indication will be masked",
      Width => "1",
      Position => "55",
      Type => "Config",
      UsedBy => "SER",
      DefaultValue => "b1",
    },
    ResolutionStage3EmVerifier2Ecc_2bErrInterruptMask => { #Structure Type: RegField;
      Name => "ResolutionStage3EmVerifier2Ecc_2bErrInterruptMask",
      RegMem => "RegField",
      Description => "When this bit is set, ECC 2b Error indication will be masked",
      Width => "1",
      Position => "56",
      Type => "Config",
      UsedBy => "SER",
      DefaultValue => "b1",
    },
    ResolutionStage3EmVerifier3Ecc_2bErrInterruptMask => { #Structure Type: RegField;
      Name => "ResolutionStage3EmVerifier3Ecc_2bErrInterruptMask",
      RegMem => "RegField",
      Description => "When this bit is set, ECC 2b Error indication will be masked",
      Width => "1",
      Position => "57",
      Type => "Config",
      UsedBy => "SER",
      DefaultValue => "b1",
    },
    ResolutionStage3EmVerifier4Ecc_2bErrInterruptMask => { #Structure Type: RegField;
      Name => "ResolutionStage3EmVerifier4Ecc_2bErrInterruptMask",
      RegMem => "RegField",
      Description => "When this bit is set, ECC 2b Error indication will be masked",
      Width => "1",
      Position => "58",
      Type => "Config",
      UsedBy => "SER",
      DefaultValue => "b1",
    },
    ResolutionStage3EmVerifier5Ecc_2bErrInterruptMask => { #Structure Type: RegField;
      Name => "ResolutionStage3EmVerifier5Ecc_2bErrInterruptMask",
      RegMem => "RegField",
      Description => "When this bit is set, ECC 2b Error indication will be masked",
      Width => "1",
      Position => "59",
      Type => "Config",
      UsedBy => "SER",
      DefaultValue => "b1",
    },
  },

  Ecc_1bErrInitiateRegister => { #Structure Type: Reg; Skip Register;
    Name => "Ecc_1bErrInitiateRegister",
    RegMem => "Reg",
    Address => "30",
    Description => "ECC 1b Error Initiator Register",
    Width => "60",
    Type => "Config",
    protection_table_slice0_stage0Ecc_1bErrInitiate => { #Structure Type: RegField;
      Name => "protection_table_slice0_stage0Ecc_1bErrInitiate",
      RegMem => "RegField",
      Description => "When this bit is set, ECC 1b Error will be initiated",
      Width => "1",
      Position => "0",
      Type => "Config",
      UsedBy => "MEM",
      DefaultValue => "b0",
    },
    protection_table_slice0_stage1Ecc_1bErrInitiate => { #Structure Type: RegField;
      Name => "protection_table_slice0_stage1Ecc_1bErrInitiate",
      RegMem => "RegField",
      Description => "When this bit is set, ECC 1b Error will be initiated",
      Width => "1",
      Position => "1",
      Type => "Config",
      UsedBy => "MEM",
      DefaultValue => "b0",
    },
    protection_table_slice0_stage2Ecc_1bErrInitiate => { #Structure Type: RegField;
      Name => "protection_table_slice0_stage2Ecc_1bErrInitiate",
      RegMem => "RegField",
      Description => "When this bit is set, ECC 1b Error will be initiated",
      Width => "1",
      Position => "2",
      Type => "Config",
      UsedBy => "MEM",
      DefaultValue => "b0",
    },
    protection_table_slice0_stage3Ecc_1bErrInitiate => { #Structure Type: RegField;
      Name => "protection_table_slice0_stage3Ecc_1bErrInitiate",
      RegMem => "RegField",
      Description => "When this bit is set, ECC 1b Error will be initiated",
      Width => "1",
      Position => "3",
      Type => "Config",
      UsedBy => "MEM",
      DefaultValue => "b0",
    },
    slice0_stage0_lb_consistence_cache_tableEcc_1bErrInitiate => { #Structure Type: RegField;
      Name => "slice0_stage0_lb_consistence_cache_tableEcc_1bErrInitiate",
      RegMem => "RegField",
      Description => "When this bit is set, ECC 1b Error will be initiated",
      Width => "1",
      Position => "4",
      Type => "Config",
      UsedBy => "MEM",
      DefaultValue => "b0",
    },
    slice0_stage1_lb_consistence_cache_tableEcc_1bErrInitiate => { #Structure Type: RegField;
      Name => "slice0_stage1_lb_consistence_cache_tableEcc_1bErrInitiate",
      RegMem => "RegField",
      Description => "When this bit is set, ECC 1b Error will be initiated",
      Width => "1",
      Position => "5",
      Type => "Config",
      UsedBy => "MEM",
      DefaultValue => "b0",
    },
    slice0_stage2_lb_consistence_cache_tableEcc_1bErrInitiate => { #Structure Type: RegField;
      Name => "slice0_stage2_lb_consistence_cache_tableEcc_1bErrInitiate",
      RegMem => "RegField",
      Description => "When this bit is set, ECC 1b Error will be initiated",
      Width => "1",
      Position => "6",
      Type => "Config",
      UsedBy => "MEM",
      DefaultValue => "b0",
    },
    slice0_stage3_lb_consistence_cache_tableEcc_1bErrInitiate => { #Structure Type: RegField;
      Name => "slice0_stage3_lb_consistence_cache_tableEcc_1bErrInitiate",
      RegMem => "RegField",
      Description => "When this bit is set, ECC 1b Error will be initiated",
      Width => "1",
      Position => "7",
      Type => "Config",
      UsedBy => "MEM",
      DefaultValue => "b0",
    },
    ResolutionStage0AssociatedDataEcc_1bErrInitiate => { #Structure Type: RegField;
      Name => "ResolutionStage0AssociatedDataEcc_1bErrInitiate",
      RegMem => "RegField",
      Description => "When this bit is set, ECC 1b Error will be initiated",
      Width => "1",
      Position => "8",
      Type => "Config",
      UsedBy => "MEM",
      DefaultValue => "b0",
    },
    FecTableEcc_1bErrInitiate => { #Structure Type: RegField;
      Name => "FecTableEcc_1bErrInitiate",
      RegMem => "RegField",
      Description => "When this bit is set, ECC 1b Error will be initiated",
      Width => "1",
      Position => "9",
      Type => "Config",
      UsedBy => "MEM",
      DefaultValue => "b0",
    },
    ResolutionStage1AssociatedDataEcc_1bErrInitiate => { #Structure Type: RegField;
      Name => "ResolutionStage1AssociatedDataEcc_1bErrInitiate",
      RegMem => "RegField",
      Description => "When this bit is set, ECC 1b Error will be initiated",
      Width => "1",
      Position => "10",
      Type => "Config",
      UsedBy => "MEM",
      DefaultValue => "b0",
    },
    ResolutionStage2AssociatedDataEcc_1bErrInitiate => { #Structure Type: RegField;
      Name => "ResolutionStage2AssociatedDataEcc_1bErrInitiate",
      RegMem => "RegField",
      Description => "When this bit is set, ECC 1b Error will be initiated",
      Width => "1",
      Position => "11",
      Type => "Config",
      UsedBy => "MEM",
      DefaultValue => "b0",
    },
    ResolutionStage3AssociatedDataEcc_1bErrInitiate => { #Structure Type: RegField;
      Name => "ResolutionStage3AssociatedDataEcc_1bErrInitiate",
      RegMem => "RegField",
      Description => "When this bit is set, ECC 1b Error will be initiated",
      Width => "1",
      Position => "12",
      Type => "Config",
      UsedBy => "MEM",
      DefaultValue => "b0",
    },
    protection_table_slice1_stage0Ecc_1bErrInitiate => { #Structure Type: RegField;
      Name => "protection_table_slice1_stage0Ecc_1bErrInitiate",
      RegMem => "RegField",
      Description => "When this bit is set, ECC 1b Error will be initiated",
      Width => "1",
      Position => "13",
      Type => "Config",
      UsedBy => "MEM",
      DefaultValue => "b0",
    },
    protection_table_slice1_stage1Ecc_1bErrInitiate => { #Structure Type: RegField;
      Name => "protection_table_slice1_stage1Ecc_1bErrInitiate",
      RegMem => "RegField",
      Description => "When this bit is set, ECC 1b Error will be initiated",
      Width => "1",
      Position => "14",
      Type => "Config",
      UsedBy => "MEM",
      DefaultValue => "b0",
    },
    protection_table_slice1_stage2Ecc_1bErrInitiate => { #Structure Type: RegField;
      Name => "protection_table_slice1_stage2Ecc_1bErrInitiate",
      RegMem => "RegField",
      Description => "When this bit is set, ECC 1b Error will be initiated",
      Width => "1",
      Position => "15",
      Type => "Config",
      UsedBy => "MEM",
      DefaultValue => "b0",
    },
    protection_table_slice1_stage3Ecc_1bErrInitiate => { #Structure Type: RegField;
      Name => "protection_table_slice1_stage3Ecc_1bErrInitiate",
      RegMem => "RegField",
      Description => "When this bit is set, ECC 1b Error will be initiated",
      Width => "1",
      Position => "16",
      Type => "Config",
      UsedBy => "MEM",
      DefaultValue => "b0",
    },
    Slice0Stage0LbGroupSizeTableEcc_1bErrInitiate => { #Structure Type: RegField;
      Name => "Slice0Stage0LbGroupSizeTableEcc_1bErrInitiate",
      RegMem => "RegField",
      Description => "When this bit is set, ECC 1b Error will be initiated",
      Width => "1",
      Position => "17",
      Type => "Config",
      UsedBy => "MEM",
      DefaultValue => "b0",
    },
    Slice0Stage1LbGroupSizeTableEcc_1bErrInitiate => { #Structure Type: RegField;
      Name => "Slice0Stage1LbGroupSizeTableEcc_1bErrInitiate",
      RegMem => "RegField",
      Description => "When this bit is set, ECC 1b Error will be initiated",
      Width => "1",
      Position => "18",
      Type => "Config",
      UsedBy => "MEM",
      DefaultValue => "b0",
    },
    Slice0Stage2LbGroupSizeTableEcc_1bErrInitiate => { #Structure Type: RegField;
      Name => "Slice0Stage2LbGroupSizeTableEcc_1bErrInitiate",
      RegMem => "RegField",
      Description => "When this bit is set, ECC 1b Error will be initiated",
      Width => "1",
      Position => "19",
      Type => "Config",
      UsedBy => "MEM",
      DefaultValue => "b0",
    },
    Slice0Stage3LbGroupSizeTableEcc_1bErrInitiate => { #Structure Type: RegField;
      Name => "Slice0Stage3LbGroupSizeTableEcc_1bErrInitiate",
      RegMem => "RegField",
      Description => "When this bit is set, ECC 1b Error will be initiated",
      Width => "1",
      Position => "20",
      Type => "Config",
      UsedBy => "MEM",
      DefaultValue => "b0",
    },
    Slice1Stage0LbGroupSizeTableEcc_1bErrInitiate => { #Structure Type: RegField;
      Name => "Slice1Stage0LbGroupSizeTableEcc_1bErrInitiate",
      RegMem => "RegField",
      Description => "When this bit is set, ECC 1b Error will be initiated",
      Width => "1",
      Position => "21",
      Type => "Config",
      UsedBy => "MEM",
      DefaultValue => "b0",
    },
    Slice1Stage1LbGroupSizeTableEcc_1bErrInitiate => { #Structure Type: RegField;
      Name => "Slice1Stage1LbGroupSizeTableEcc_1bErrInitiate",
      RegMem => "RegField",
      Description => "When this bit is set, ECC 1b Error will be initiated",
      Width => "1",
      Position => "22",
      Type => "Config",
      UsedBy => "MEM",
      DefaultValue => "b0",
    },
    Slice1Stage2LbGroupSizeTableEcc_1bErrInitiate => { #Structure Type: RegField;
      Name => "Slice1Stage2LbGroupSizeTableEcc_1bErrInitiate",
      RegMem => "RegField",
      Description => "When this bit is set, ECC 1b Error will be initiated",
      Width => "1",
      Position => "23",
      Type => "Config",
      UsedBy => "MEM",
      DefaultValue => "b0",
    },
    Slice1Stage3LbGroupSizeTableEcc_1bErrInitiate => { #Structure Type: RegField;
      Name => "Slice1Stage3LbGroupSizeTableEcc_1bErrInitiate",
      RegMem => "RegField",
      Description => "When this bit is set, ECC 1b Error will be initiated",
      Width => "1",
      Position => "24",
      Type => "Config",
      UsedBy => "MEM",
      DefaultValue => "b0",
    },
    slice1_stage0_lb_consistence_cache_tableEcc_1bErrInitiate => { #Structure Type: RegField;
      Name => "slice1_stage0_lb_consistence_cache_tableEcc_1bErrInitiate",
      RegMem => "RegField",
      Description => "When this bit is set, ECC 1b Error will be initiated",
      Width => "1",
      Position => "25",
      Type => "Config",
      UsedBy => "MEM",
      DefaultValue => "b0",
    },
    slice1_stage1_lb_consistence_cache_tableEcc_1bErrInitiate => { #Structure Type: RegField;
      Name => "slice1_stage1_lb_consistence_cache_tableEcc_1bErrInitiate",
      RegMem => "RegField",
      Description => "When this bit is set, ECC 1b Error will be initiated",
      Width => "1",
      Position => "26",
      Type => "Config",
      UsedBy => "MEM",
      DefaultValue => "b0",
    },
    slice1_stage2_lb_consistence_cache_tableEcc_1bErrInitiate => { #Structure Type: RegField;
      Name => "slice1_stage2_lb_consistence_cache_tableEcc_1bErrInitiate",
      RegMem => "RegField",
      Description => "When this bit is set, ECC 1b Error will be initiated",
      Width => "1",
      Position => "27",
      Type => "Config",
      UsedBy => "MEM",
      DefaultValue => "b0",
    },
    slice1_stage3_lb_consistence_cache_tableEcc_1bErrInitiate => { #Structure Type: RegField;
      Name => "slice1_stage3_lb_consistence_cache_tableEcc_1bErrInitiate",
      RegMem => "RegField",
      Description => "When this bit is set, ECC 1b Error will be initiated",
      Width => "1",
      Position => "28",
      Type => "Config",
      UsedBy => "MEM",
      DefaultValue => "b0",
    },
    ResolutionStage0EmVerifier0Ecc_1bErrInitiate => { #Structure Type: RegField;
      Name => "ResolutionStage0EmVerifier0Ecc_1bErrInitiate",
      RegMem => "RegField",
      Description => "When this bit is set, ECC 1b Error will be initiated",
      Width => "1",
      Position => "29",
      Type => "Config",
      UsedBy => "MEM",
      DefaultValue => "b0",
    },
    ResolutionStage0EmVerifier1Ecc_1bErrInitiate => { #Structure Type: RegField;
      Name => "ResolutionStage0EmVerifier1Ecc_1bErrInitiate",
      RegMem => "RegField",
      Description => "When this bit is set, ECC 1b Error will be initiated",
      Width => "1",
      Position => "30",
      Type => "Config",
      UsedBy => "MEM",
      DefaultValue => "b0",
    },
    ResolutionStage0EmVerifier2Ecc_1bErrInitiate => { #Structure Type: RegField;
      Name => "ResolutionStage0EmVerifier2Ecc_1bErrInitiate",
      RegMem => "RegField",
      Description => "When this bit is set, ECC 1b Error will be initiated",
      Width => "1",
      Position => "31",
      Type => "Config",
      UsedBy => "MEM",
      DefaultValue => "b0",
    },
    ResolutionStage0EmVerifier3Ecc_1bErrInitiate => { #Structure Type: RegField;
      Name => "ResolutionStage0EmVerifier3Ecc_1bErrInitiate",
      RegMem => "RegField",
      Description => "When this bit is set, ECC 1b Error will be initiated",
      Width => "1",
      Position => "32",
      Type => "Config",
      UsedBy => "MEM",
      DefaultValue => "b0",
    },
    ResolutionStage0EmVerifier4Ecc_1bErrInitiate => { #Structure Type: RegField;
      Name => "ResolutionStage0EmVerifier4Ecc_1bErrInitiate",
      RegMem => "RegField",
      Description => "When this bit is set, ECC 1b Error will be initiated",
      Width => "1",
      Position => "33",
      Type => "Config",
      UsedBy => "MEM",
      DefaultValue => "b0",
    },
    ResolutionStage0EmVerifier5Ecc_1bErrInitiate => { #Structure Type: RegField;
      Name => "ResolutionStage0EmVerifier5Ecc_1bErrInitiate",
      RegMem => "RegField",
      Description => "When this bit is set, ECC 1b Error will be initiated",
      Width => "1",
      Position => "34",
      Type => "Config",
      UsedBy => "MEM",
      DefaultValue => "b0",
    },
    ResolutionStage0EmVerifier6Ecc_1bErrInitiate => { #Structure Type: RegField;
      Name => "ResolutionStage0EmVerifier6Ecc_1bErrInitiate",
      RegMem => "RegField",
      Description => "When this bit is set, ECC 1b Error will be initiated",
      Width => "1",
      Position => "35",
      Type => "Config",
      UsedBy => "MEM",
      DefaultValue => "b0",
    },
    ResolutionStage0EmVerifier7Ecc_1bErrInitiate => { #Structure Type: RegField;
      Name => "ResolutionStage0EmVerifier7Ecc_1bErrInitiate",
      RegMem => "RegField",
      Description => "When this bit is set, ECC 1b Error will be initiated",
      Width => "1",
      Position => "36",
      Type => "Config",
      UsedBy => "MEM",
      DefaultValue => "b0",
    },
    ResolutionStage0EmVerifier8Ecc_1bErrInitiate => { #Structure Type: RegField;
      Name => "ResolutionStage0EmVerifier8Ecc_1bErrInitiate",
      RegMem => "RegField",
      Description => "When this bit is set, ECC 1b Error will be initiated",
      Width => "1",
      Position => "37",
      Type => "Config",
      UsedBy => "MEM",
      DefaultValue => "b0",
    },
    ResolutionStage0EmVerifier9Ecc_1bErrInitiate => { #Structure Type: RegField;
      Name => "ResolutionStage0EmVerifier9Ecc_1bErrInitiate",
      RegMem => "RegField",
      Description => "When this bit is set, ECC 1b Error will be initiated",
      Width => "1",
      Position => "38",
      Type => "Config",
      UsedBy => "MEM",
      DefaultValue => "b0",
    },
    ResolutionStage0EmVerifier10Ecc_1bErrInitiate => { #Structure Type: RegField;
      Name => "ResolutionStage0EmVerifier10Ecc_1bErrInitiate",
      RegMem => "RegField",
      Description => "When this bit is set, ECC 1b Error will be initiated",
      Width => "1",
      Position => "39",
      Type => "Config",
      UsedBy => "MEM",
      DefaultValue => "b0",
    },
    ResolutionStage0EmVerifier11Ecc_1bErrInitiate => { #Structure Type: RegField;
      Name => "ResolutionStage0EmVerifier11Ecc_1bErrInitiate",
      RegMem => "RegField",
      Description => "When this bit is set, ECC 1b Error will be initiated",
      Width => "1",
      Position => "40",
      Type => "Config",
      UsedBy => "MEM",
      DefaultValue => "b0",
    },
    LpQueuingEmVerifier0Ecc_1bErrInitiate => { #Structure Type: RegField;
      Name => "LpQueuingEmVerifier0Ecc_1bErrInitiate",
      RegMem => "RegField",
      Description => "When this bit is set, ECC 1b Error will be initiated",
      Width => "1",
      Position => "41",
      Type => "Config",
      UsedBy => "MEM",
      DefaultValue => "b0",
    },
    LpQueuingEmVerifier1Ecc_1bErrInitiate => { #Structure Type: RegField;
      Name => "LpQueuingEmVerifier1Ecc_1bErrInitiate",
      RegMem => "RegField",
      Description => "When this bit is set, ECC 1b Error will be initiated",
      Width => "1",
      Position => "42",
      Type => "Config",
      UsedBy => "MEM",
      DefaultValue => "b0",
    },
    LpQueuingEmVerifier2Ecc_1bErrInitiate => { #Structure Type: RegField;
      Name => "LpQueuingEmVerifier2Ecc_1bErrInitiate",
      RegMem => "RegField",
      Description => "When this bit is set, ECC 1b Error will be initiated",
      Width => "1",
      Position => "43",
      Type => "Config",
      UsedBy => "MEM",
      DefaultValue => "b0",
    },
    LpQueuingEmVerifier3Ecc_1bErrInitiate => { #Structure Type: RegField;
      Name => "LpQueuingEmVerifier3Ecc_1bErrInitiate",
      RegMem => "RegField",
      Description => "When this bit is set, ECC 1b Error will be initiated",
      Width => "1",
      Position => "44",
      Type => "Config",
      UsedBy => "MEM",
      DefaultValue => "b0",
    },
    LpQueuingEmVerifier4Ecc_1bErrInitiate => { #Structure Type: RegField;
      Name => "LpQueuingEmVerifier4Ecc_1bErrInitiate",
      RegMem => "RegField",
      Description => "When this bit is set, ECC 1b Error will be initiated",
      Width => "1",
      Position => "45",
      Type => "Config",
      UsedBy => "MEM",
      DefaultValue => "b0",
    },
    ResolutionStage1EmVerifier0Ecc_1bErrInitiate => { #Structure Type: RegField;
      Name => "ResolutionStage1EmVerifier0Ecc_1bErrInitiate",
      RegMem => "RegField",
      Description => "When this bit is set, ECC 1b Error will be initiated",
      Width => "1",
      Position => "46",
      Type => "Config",
      UsedBy => "MEM",
      DefaultValue => "b0",
    },
    ResolutionStage1EmVerifier1Ecc_1bErrInitiate => { #Structure Type: RegField;
      Name => "ResolutionStage1EmVerifier1Ecc_1bErrInitiate",
      RegMem => "RegField",
      Description => "When this bit is set, ECC 1b Error will be initiated",
      Width => "1",
      Position => "47",
      Type => "Config",
      UsedBy => "MEM",
      DefaultValue => "b0",
    },
    ResolutionStage1EmVerifier2Ecc_1bErrInitiate => { #Structure Type: RegField;
      Name => "ResolutionStage1EmVerifier2Ecc_1bErrInitiate",
      RegMem => "RegField",
      Description => "When this bit is set, ECC 1b Error will be initiated",
      Width => "1",
      Position => "48",
      Type => "Config",
      UsedBy => "MEM",
      DefaultValue => "b0",
    },
    ResolutionStage1EmVerifier3Ecc_1bErrInitiate => { #Structure Type: RegField;
      Name => "ResolutionStage1EmVerifier3Ecc_1bErrInitiate",
      RegMem => "RegField",
      Description => "When this bit is set, ECC 1b Error will be initiated",
      Width => "1",
      Position => "49",
      Type => "Config",
      UsedBy => "MEM",
      DefaultValue => "b0",
    },
    ResolutionStage2EmVerifier0Ecc_1bErrInitiate => { #Structure Type: RegField;
      Name => "ResolutionStage2EmVerifier0Ecc_1bErrInitiate",
      RegMem => "RegField",
      Description => "When this bit is set, ECC 1b Error will be initiated",
      Width => "1",
      Position => "50",
      Type => "Config",
      UsedBy => "MEM",
      DefaultValue => "b0",
    },
    ResolutionStage2EmVerifier1Ecc_1bErrInitiate => { #Structure Type: RegField;
      Name => "ResolutionStage2EmVerifier1Ecc_1bErrInitiate",
      RegMem => "RegField",
      Description => "When this bit is set, ECC 1b Error will be initiated",
      Width => "1",
      Position => "51",
      Type => "Config",
      UsedBy => "MEM",
      DefaultValue => "b0",
    },
    ResolutionStage2EmVerifier2Ecc_1bErrInitiate => { #Structure Type: RegField;
      Name => "ResolutionStage2EmVerifier2Ecc_1bErrInitiate",
      RegMem => "RegField",
      Description => "When this bit is set, ECC 1b Error will be initiated",
      Width => "1",
      Position => "52",
      Type => "Config",
      UsedBy => "MEM",
      DefaultValue => "b0",
    },
    ResolutionStage2EmVerifier3Ecc_1bErrInitiate => { #Structure Type: RegField;
      Name => "ResolutionStage2EmVerifier3Ecc_1bErrInitiate",
      RegMem => "RegField",
      Description => "When this bit is set, ECC 1b Error will be initiated",
      Width => "1",
      Position => "53",
      Type => "Config",
      UsedBy => "MEM",
      DefaultValue => "b0",
    },
    ResolutionStage3EmVerifier0Ecc_1bErrInitiate => { #Structure Type: RegField;
      Name => "ResolutionStage3EmVerifier0Ecc_1bErrInitiate",
      RegMem => "RegField",
      Description => "When this bit is set, ECC 1b Error will be initiated",
      Width => "1",
      Position => "54",
      Type => "Config",
      UsedBy => "MEM",
      DefaultValue => "b0",
    },
    ResolutionStage3EmVerifier1Ecc_1bErrInitiate => { #Structure Type: RegField;
      Name => "ResolutionStage3EmVerifier1Ecc_1bErrInitiate",
      RegMem => "RegField",
      Description => "When this bit is set, ECC 1b Error will be initiated",
      Width => "1",
      Position => "55",
      Type => "Config",
      UsedBy => "MEM",
      DefaultValue => "b0",
    },
    ResolutionStage3EmVerifier2Ecc_1bErrInitiate => { #Structure Type: RegField;
      Name => "ResolutionStage3EmVerifier2Ecc_1bErrInitiate",
      RegMem => "RegField",
      Description => "When this bit is set, ECC 1b Error will be initiated",
      Width => "1",
      Position => "56",
      Type => "Config",
      UsedBy => "MEM",
      DefaultValue => "b0",
    },
    ResolutionStage3EmVerifier3Ecc_1bErrInitiate => { #Structure Type: RegField;
      Name => "ResolutionStage3EmVerifier3Ecc_1bErrInitiate",
      RegMem => "RegField",
      Description => "When this bit is set, ECC 1b Error will be initiated",
      Width => "1",
      Position => "57",
      Type => "Config",
      UsedBy => "MEM",
      DefaultValue => "b0",
    },
    ResolutionStage3EmVerifier4Ecc_1bErrInitiate => { #Structure Type: RegField;
      Name => "ResolutionStage3EmVerifier4Ecc_1bErrInitiate",
      RegMem => "RegField",
      Description => "When this bit is set, ECC 1b Error will be initiated",
      Width => "1",
      Position => "58",
      Type => "Config",
      UsedBy => "MEM",
      DefaultValue => "b0",
    },
    ResolutionStage3EmVerifier5Ecc_1bErrInitiate => { #Structure Type: RegField;
      Name => "ResolutionStage3EmVerifier5Ecc_1bErrInitiate",
      RegMem => "RegField",
      Description => "When this bit is set, ECC 1b Error will be initiated",
      Width => "1",
      Position => "59",
      Type => "Config",
      UsedBy => "MEM",
      DefaultValue => "b0",
    },
  },
  Ecc_2bErrInitiateRegister => { #Structure Type: Reg; Skip Register;
    Name => "Ecc_2bErrInitiateRegister",
    RegMem => "Reg",
    Address => "31",
    Description => "ECC 2b Error Initiator Register",
    Width => "60",
    Type => "Config",
    protection_table_slice0_stage0Ecc_2bErrInitiate => { #Structure Type: RegField;
      Name => "protection_table_slice0_stage0Ecc_2bErrInitiate",
      RegMem => "RegField",
      Description => "When this bit is set, ECC 2b Error will be initiated",
      Width => "1",
      Position => "0",
      Type => "Config",
      UsedBy => "MEM",
      DefaultValue => "b0",
    },
    protection_table_slice0_stage1Ecc_2bErrInitiate => { #Structure Type: RegField;
      Name => "protection_table_slice0_stage1Ecc_2bErrInitiate",
      RegMem => "RegField",
      Description => "When this bit is set, ECC 2b Error will be initiated",
      Width => "1",
      Position => "1",
      Type => "Config",
      UsedBy => "MEM",
      DefaultValue => "b0",
    },
    protection_table_slice0_stage2Ecc_2bErrInitiate => { #Structure Type: RegField;
      Name => "protection_table_slice0_stage2Ecc_2bErrInitiate",
      RegMem => "RegField",
      Description => "When this bit is set, ECC 2b Error will be initiated",
      Width => "1",
      Position => "2",
      Type => "Config",
      UsedBy => "MEM",
      DefaultValue => "b0",
    },
    protection_table_slice0_stage3Ecc_2bErrInitiate => { #Structure Type: RegField;
      Name => "protection_table_slice0_stage3Ecc_2bErrInitiate",
      RegMem => "RegField",
      Description => "When this bit is set, ECC 2b Error will be initiated",
      Width => "1",
      Position => "3",
      Type => "Config",
      UsedBy => "MEM",
      DefaultValue => "b0",
    },
    slice0_stage0_lb_consistence_cache_tableEcc_2bErrInitiate => { #Structure Type: RegField;
      Name => "slice0_stage0_lb_consistence_cache_tableEcc_2bErrInitiate",
      RegMem => "RegField",
      Description => "When this bit is set, ECC 2b Error will be initiated",
      Width => "1",
      Position => "4",
      Type => "Config",
      UsedBy => "MEM",
      DefaultValue => "b0",
    },
    slice0_stage1_lb_consistence_cache_tableEcc_2bErrInitiate => { #Structure Type: RegField;
      Name => "slice0_stage1_lb_consistence_cache_tableEcc_2bErrInitiate",
      RegMem => "RegField",
      Description => "When this bit is set, ECC 2b Error will be initiated",
      Width => "1",
      Position => "5",
      Type => "Config",
      UsedBy => "MEM",
      DefaultValue => "b0",
    },
    slice0_stage2_lb_consistence_cache_tableEcc_2bErrInitiate => { #Structure Type: RegField;
      Name => "slice0_stage2_lb_consistence_cache_tableEcc_2bErrInitiate",
      RegMem => "RegField",
      Description => "When this bit is set, ECC 2b Error will be initiated",
      Width => "1",
      Position => "6",
      Type => "Config",
      UsedBy => "MEM",
      DefaultValue => "b0",
    },
    slice0_stage3_lb_consistence_cache_tableEcc_2bErrInitiate => { #Structure Type: RegField;
      Name => "slice0_stage3_lb_consistence_cache_tableEcc_2bErrInitiate",
      RegMem => "RegField",
      Description => "When this bit is set, ECC 2b Error will be initiated",
      Width => "1",
      Position => "7",
      Type => "Config",
      UsedBy => "MEM",
      DefaultValue => "b0",
    },
    ResolutionStage0AssociatedDataEcc_2bErrInitiate => { #Structure Type: RegField;
      Name => "ResolutionStage0AssociatedDataEcc_2bErrInitiate",
      RegMem => "RegField",
      Description => "When this bit is set, ECC 2b Error will be initiated",
      Width => "1",
      Position => "8",
      Type => "Config",
      UsedBy => "MEM",
      DefaultValue => "b0",
    },
    FecTableEcc_2bErrInitiate => { #Structure Type: RegField;
      Name => "FecTableEcc_2bErrInitiate",
      RegMem => "RegField",
      Description => "When this bit is set, ECC 2b Error will be initiated",
      Width => "1",
      Position => "9",
      Type => "Config",
      UsedBy => "MEM",
      DefaultValue => "b0",
    },
    ResolutionStage1AssociatedDataEcc_2bErrInitiate => { #Structure Type: RegField;
      Name => "ResolutionStage1AssociatedDataEcc_2bErrInitiate",
      RegMem => "RegField",
      Description => "When this bit is set, ECC 2b Error will be initiated",
      Width => "1",
      Position => "10",
      Type => "Config",
      UsedBy => "MEM",
      DefaultValue => "b0",
    },
    ResolutionStage2AssociatedDataEcc_2bErrInitiate => { #Structure Type: RegField;
      Name => "ResolutionStage2AssociatedDataEcc_2bErrInitiate",
      RegMem => "RegField",
      Description => "When this bit is set, ECC 2b Error will be initiated",
      Width => "1",
      Position => "11",
      Type => "Config",
      UsedBy => "MEM",
      DefaultValue => "b0",
    },
    ResolutionStage3AssociatedDataEcc_2bErrInitiate => { #Structure Type: RegField;
      Name => "ResolutionStage3AssociatedDataEcc_2bErrInitiate",
      RegMem => "RegField",
      Description => "When this bit is set, ECC 2b Error will be initiated",
      Width => "1",
      Position => "12",
      Type => "Config",
      UsedBy => "MEM",
      DefaultValue => "b0",
    },
    protection_table_slice1_stage0Ecc_2bErrInitiate => { #Structure Type: RegField;
      Name => "protection_table_slice1_stage0Ecc_2bErrInitiate",
      RegMem => "RegField",
      Description => "When this bit is set, ECC 2b Error will be initiated",
      Width => "1",
      Position => "13",
      Type => "Config",
      UsedBy => "MEM",
      DefaultValue => "b0",
    },
    protection_table_slice1_stage1Ecc_2bErrInitiate => { #Structure Type: RegField;
      Name => "protection_table_slice1_stage1Ecc_2bErrInitiate",
      RegMem => "RegField",
      Description => "When this bit is set, ECC 2b Error will be initiated",
      Width => "1",
      Position => "14",
      Type => "Config",
      UsedBy => "MEM",
      DefaultValue => "b0",
    },
    protection_table_slice1_stage2Ecc_2bErrInitiate => { #Structure Type: RegField;
      Name => "protection_table_slice1_stage2Ecc_2bErrInitiate",
      RegMem => "RegField",
      Description => "When this bit is set, ECC 2b Error will be initiated",
      Width => "1",
      Position => "15",
      Type => "Config",
      UsedBy => "MEM",
      DefaultValue => "b0",
    },
    protection_table_slice1_stage3Ecc_2bErrInitiate => { #Structure Type: RegField;
      Name => "protection_table_slice1_stage3Ecc_2bErrInitiate",
      RegMem => "RegField",
      Description => "When this bit is set, ECC 2b Error will be initiated",
      Width => "1",
      Position => "16",
      Type => "Config",
      UsedBy => "MEM",
      DefaultValue => "b0",
    },
    Slice0Stage0LbGroupSizeTableEcc_2bErrInitiate => { #Structure Type: RegField;
      Name => "Slice0Stage0LbGroupSizeTableEcc_2bErrInitiate",
      RegMem => "RegField",
      Description => "When this bit is set, ECC 2b Error will be initiated",
      Width => "1",
      Position => "17",
      Type => "Config",
      UsedBy => "MEM",
      DefaultValue => "b0",
    },
    Slice0Stage1LbGroupSizeTableEcc_2bErrInitiate => { #Structure Type: RegField;
      Name => "Slice0Stage1LbGroupSizeTableEcc_2bErrInitiate",
      RegMem => "RegField",
      Description => "When this bit is set, ECC 2b Error will be initiated",
      Width => "1",
      Position => "18",
      Type => "Config",
      UsedBy => "MEM",
      DefaultValue => "b0",
    },
    Slice0Stage2LbGroupSizeTableEcc_2bErrInitiate => { #Structure Type: RegField;
      Name => "Slice0Stage2LbGroupSizeTableEcc_2bErrInitiate",
      RegMem => "RegField",
      Description => "When this bit is set, ECC 2b Error will be initiated",
      Width => "1",
      Position => "19",
      Type => "Config",
      UsedBy => "MEM",
      DefaultValue => "b0",
    },
    Slice0Stage3LbGroupSizeTableEcc_2bErrInitiate => { #Structure Type: RegField;
      Name => "Slice0Stage3LbGroupSizeTableEcc_2bErrInitiate",
      RegMem => "RegField",
      Description => "When this bit is set, ECC 2b Error will be initiated",
      Width => "1",
      Position => "20",
      Type => "Config",
      UsedBy => "MEM",
      DefaultValue => "b0",
    },
    Slice1Stage0LbGroupSizeTableEcc_2bErrInitiate => { #Structure Type: RegField;
      Name => "Slice1Stage0LbGroupSizeTableEcc_2bErrInitiate",
      RegMem => "RegField",
      Description => "When this bit is set, ECC 2b Error will be initiated",
      Width => "1",
      Position => "21",
      Type => "Config",
      UsedBy => "MEM",
      DefaultValue => "b0",
    },
    Slice1Stage1LbGroupSizeTableEcc_2bErrInitiate => { #Structure Type: RegField;
      Name => "Slice1Stage1LbGroupSizeTableEcc_2bErrInitiate",
      RegMem => "RegField",
      Description => "When this bit is set, ECC 2b Error will be initiated",
      Width => "1",
      Position => "22",
      Type => "Config",
      UsedBy => "MEM",
      DefaultValue => "b0",
    },
    Slice1Stage2LbGroupSizeTableEcc_2bErrInitiate => { #Structure Type: RegField;
      Name => "Slice1Stage2LbGroupSizeTableEcc_2bErrInitiate",
      RegMem => "RegField",
      Description => "When this bit is set, ECC 2b Error will be initiated",
      Width => "1",
      Position => "23",
      Type => "Config",
      UsedBy => "MEM",
      DefaultValue => "b0",
    },
    Slice1Stage3LbGroupSizeTableEcc_2bErrInitiate => { #Structure Type: RegField;
      Name => "Slice1Stage3LbGroupSizeTableEcc_2bErrInitiate",
      RegMem => "RegField",
      Description => "When this bit is set, ECC 2b Error will be initiated",
      Width => "1",
      Position => "24",
      Type => "Config",
      UsedBy => "MEM",
      DefaultValue => "b0",
    },
    slice1_stage0_lb_consistence_cache_tableEcc_2bErrInitiate => { #Structure Type: RegField;
      Name => "slice1_stage0_lb_consistence_cache_tableEcc_2bErrInitiate",
      RegMem => "RegField",
      Description => "When this bit is set, ECC 2b Error will be initiated",
      Width => "1",
      Position => "25",
      Type => "Config",
      UsedBy => "MEM",
      DefaultValue => "b0",
    },
    slice1_stage1_lb_consistence_cache_tableEcc_2bErrInitiate => { #Structure Type: RegField;
      Name => "slice1_stage1_lb_consistence_cache_tableEcc_2bErrInitiate",
      RegMem => "RegField",
      Description => "When this bit is set, ECC 2b Error will be initiated",
      Width => "1",
      Position => "26",
      Type => "Config",
      UsedBy => "MEM",
      DefaultValue => "b0",
    },
    slice1_stage2_lb_consistence_cache_tableEcc_2bErrInitiate => { #Structure Type: RegField;
      Name => "slice1_stage2_lb_consistence_cache_tableEcc_2bErrInitiate",
      RegMem => "RegField",
      Description => "When this bit is set, ECC 2b Error will be initiated",
      Width => "1",
      Position => "27",
      Type => "Config",
      UsedBy => "MEM",
      DefaultValue => "b0",
    },
    slice1_stage3_lb_consistence_cache_tableEcc_2bErrInitiate => { #Structure Type: RegField;
      Name => "slice1_stage3_lb_consistence_cache_tableEcc_2bErrInitiate",
      RegMem => "RegField",
      Description => "When this bit is set, ECC 2b Error will be initiated",
      Width => "1",
      Position => "28",
      Type => "Config",
      UsedBy => "MEM",
      DefaultValue => "b0",
    },
    ResolutionStage0EmVerifier0Ecc_2bErrInitiate => { #Structure Type: RegField;
      Name => "ResolutionStage0EmVerifier0Ecc_2bErrInitiate",
      RegMem => "RegField",
      Description => "When this bit is set, ECC 2b Error will be initiated",
      Width => "1",
      Position => "29",
      Type => "Config",
      UsedBy => "MEM",
      DefaultValue => "b0",
    },
    ResolutionStage0EmVerifier1Ecc_2bErrInitiate => { #Structure Type: RegField;
      Name => "ResolutionStage0EmVerifier1Ecc_2bErrInitiate",
      RegMem => "RegField",
      Description => "When this bit is set, ECC 2b Error will be initiated",
      Width => "1",
      Position => "30",
      Type => "Config",
      UsedBy => "MEM",
      DefaultValue => "b0",
    },
    ResolutionStage0EmVerifier2Ecc_2bErrInitiate => { #Structure Type: RegField;
      Name => "ResolutionStage0EmVerifier2Ecc_2bErrInitiate",
      RegMem => "RegField",
      Description => "When this bit is set, ECC 2b Error will be initiated",
      Width => "1",
      Position => "31",
      Type => "Config",
      UsedBy => "MEM",
      DefaultValue => "b0",
    },
    ResolutionStage0EmVerifier3Ecc_2bErrInitiate => { #Structure Type: RegField;
      Name => "ResolutionStage0EmVerifier3Ecc_2bErrInitiate",
      RegMem => "RegField",
      Description => "When this bit is set, ECC 2b Error will be initiated",
      Width => "1",
      Position => "32",
      Type => "Config",
      UsedBy => "MEM",
      DefaultValue => "b0",
    },
    ResolutionStage0EmVerifier4Ecc_2bErrInitiate => { #Structure Type: RegField;
      Name => "ResolutionStage0EmVerifier4Ecc_2bErrInitiate",
      RegMem => "RegField",
      Description => "When this bit is set, ECC 2b Error will be initiated",
      Width => "1",
      Position => "33",
      Type => "Config",
      UsedBy => "MEM",
      DefaultValue => "b0",
    },
    ResolutionStage0EmVerifier5Ecc_2bErrInitiate => { #Structure Type: RegField;
      Name => "ResolutionStage0EmVerifier5Ecc_2bErrInitiate",
      RegMem => "RegField",
      Description => "When this bit is set, ECC 2b Error will be initiated",
      Width => "1",
      Position => "34",
      Type => "Config",
      UsedBy => "MEM",
      DefaultValue => "b0",
    },
    ResolutionStage0EmVerifier6Ecc_2bErrInitiate => { #Structure Type: RegField;
      Name => "ResolutionStage0EmVerifier6Ecc_2bErrInitiate",
      RegMem => "RegField",
      Description => "When this bit is set, ECC 2b Error will be initiated",
      Width => "1",
      Position => "35",
      Type => "Config",
      UsedBy => "MEM",
      DefaultValue => "b0",
    },
    ResolutionStage0EmVerifier7Ecc_2bErrInitiate => { #Structure Type: RegField;
      Name => "ResolutionStage0EmVerifier7Ecc_2bErrInitiate",
      RegMem => "RegField",
      Description => "When this bit is set, ECC 2b Error will be initiated",
      Width => "1",
      Position => "36",
      Type => "Config",
      UsedBy => "MEM",
      DefaultValue => "b0",
    },
    ResolutionStage0EmVerifier8Ecc_2bErrInitiate => { #Structure Type: RegField;
      Name => "ResolutionStage0EmVerifier8Ecc_2bErrInitiate",
      RegMem => "RegField",
      Description => "When this bit is set, ECC 2b Error will be initiated",
      Width => "1",
      Position => "37",
      Type => "Config",
      UsedBy => "MEM",
      DefaultValue => "b0",
    },
    ResolutionStage0EmVerifier9Ecc_2bErrInitiate => { #Structure Type: RegField;
      Name => "ResolutionStage0EmVerifier9Ecc_2bErrInitiate",
      RegMem => "RegField",
      Description => "When this bit is set, ECC 2b Error will be initiated",
      Width => "1",
      Position => "38",
      Type => "Config",
      UsedBy => "MEM",
      DefaultValue => "b0",
    },
    ResolutionStage0EmVerifier10Ecc_2bErrInitiate => { #Structure Type: RegField;
      Name => "ResolutionStage0EmVerifier10Ecc_2bErrInitiate",
      RegMem => "RegField",
      Description => "When this bit is set, ECC 2b Error will be initiated",
      Width => "1",
      Position => "39",
      Type => "Config",
      UsedBy => "MEM",
      DefaultValue => "b0",
    },
    ResolutionStage0EmVerifier11Ecc_2bErrInitiate => { #Structure Type: RegField;
      Name => "ResolutionStage0EmVerifier11Ecc_2bErrInitiate",
      RegMem => "RegField",
      Description => "When this bit is set, ECC 2b Error will be initiated",
      Width => "1",
      Position => "40",
      Type => "Config",
      UsedBy => "MEM",
      DefaultValue => "b0",
    },
    LpQueuingEmVerifier0Ecc_2bErrInitiate => { #Structure Type: RegField;
      Name => "LpQueuingEmVerifier0Ecc_2bErrInitiate",
      RegMem => "RegField",
      Description => "When this bit is set, ECC 2b Error will be initiated",
      Width => "1",
      Position => "41",
      Type => "Config",
      UsedBy => "MEM",
      DefaultValue => "b0",
    },
    LpQueuingEmVerifier1Ecc_2bErrInitiate => { #Structure Type: RegField;
      Name => "LpQueuingEmVerifier1Ecc_2bErrInitiate",
      RegMem => "RegField",
      Description => "When this bit is set, ECC 2b Error will be initiated",
      Width => "1",
      Position => "42",
      Type => "Config",
      UsedBy => "MEM",
      DefaultValue => "b0",
    },
    LpQueuingEmVerifier2Ecc_2bErrInitiate => { #Structure Type: RegField;
      Name => "LpQueuingEmVerifier2Ecc_2bErrInitiate",
      RegMem => "RegField",
      Description => "When this bit is set, ECC 2b Error will be initiated",
      Width => "1",
      Position => "43",
      Type => "Config",
      UsedBy => "MEM",
      DefaultValue => "b0",
    },
    LpQueuingEmVerifier3Ecc_2bErrInitiate => { #Structure Type: RegField;
      Name => "LpQueuingEmVerifier3Ecc_2bErrInitiate",
      RegMem => "RegField",
      Description => "When this bit is set, ECC 2b Error will be initiated",
      Width => "1",
      Position => "44",
      Type => "Config",
      UsedBy => "MEM",
      DefaultValue => "b0",
    },
    LpQueuingEmVerifier4Ecc_2bErrInitiate => { #Structure Type: RegField;
      Name => "LpQueuingEmVerifier4Ecc_2bErrInitiate",
      RegMem => "RegField",
      Description => "When this bit is set, ECC 2b Error will be initiated",
      Width => "1",
      Position => "45",
      Type => "Config",
      UsedBy => "MEM",
      DefaultValue => "b0",
    },
    ResolutionStage1EmVerifier0Ecc_2bErrInitiate => { #Structure Type: RegField;
      Name => "ResolutionStage1EmVerifier0Ecc_2bErrInitiate",
      RegMem => "RegField",
      Description => "When this bit is set, ECC 2b Error will be initiated",
      Width => "1",
      Position => "46",
      Type => "Config",
      UsedBy => "MEM",
      DefaultValue => "b0",
    },
    ResolutionStage1EmVerifier1Ecc_2bErrInitiate => { #Structure Type: RegField;
      Name => "ResolutionStage1EmVerifier1Ecc_2bErrInitiate",
      RegMem => "RegField",
      Description => "When this bit is set, ECC 2b Error will be initiated",
      Width => "1",
      Position => "47",
      Type => "Config",
      UsedBy => "MEM",
      DefaultValue => "b0",
    },
    ResolutionStage1EmVerifier2Ecc_2bErrInitiate => { #Structure Type: RegField;
      Name => "ResolutionStage1EmVerifier2Ecc_2bErrInitiate",
      RegMem => "RegField",
      Description => "When this bit is set, ECC 2b Error will be initiated",
      Width => "1",
      Position => "48",
      Type => "Config",
      UsedBy => "MEM",
      DefaultValue => "b0",
    },
    ResolutionStage1EmVerifier3Ecc_2bErrInitiate => { #Structure Type: RegField;
      Name => "ResolutionStage1EmVerifier3Ecc_2bErrInitiate",
      RegMem => "RegField",
      Description => "When this bit is set, ECC 2b Error will be initiated",
      Width => "1",
      Position => "49",
      Type => "Config",
      UsedBy => "MEM",
      DefaultValue => "b0",
    },
    ResolutionStage2EmVerifier0Ecc_2bErrInitiate => { #Structure Type: RegField;
      Name => "ResolutionStage2EmVerifier0Ecc_2bErrInitiate",
      RegMem => "RegField",
      Description => "When this bit is set, ECC 2b Error will be initiated",
      Width => "1",
      Position => "50",
      Type => "Config",
      UsedBy => "MEM",
      DefaultValue => "b0",
    },
    ResolutionStage2EmVerifier1Ecc_2bErrInitiate => { #Structure Type: RegField;
      Name => "ResolutionStage2EmVerifier1Ecc_2bErrInitiate",
      RegMem => "RegField",
      Description => "When this bit is set, ECC 2b Error will be initiated",
      Width => "1",
      Position => "51",
      Type => "Config",
      UsedBy => "MEM",
      DefaultValue => "b0",
    },
    ResolutionStage2EmVerifier2Ecc_2bErrInitiate => { #Structure Type: RegField;
      Name => "ResolutionStage2EmVerifier2Ecc_2bErrInitiate",
      RegMem => "RegField",
      Description => "When this bit is set, ECC 2b Error will be initiated",
      Width => "1",
      Position => "52",
      Type => "Config",
      UsedBy => "MEM",
      DefaultValue => "b0",
    },
    ResolutionStage2EmVerifier3Ecc_2bErrInitiate => { #Structure Type: RegField;
      Name => "ResolutionStage2EmVerifier3Ecc_2bErrInitiate",
      RegMem => "RegField",
      Description => "When this bit is set, ECC 2b Error will be initiated",
      Width => "1",
      Position => "53",
      Type => "Config",
      UsedBy => "MEM",
      DefaultValue => "b0",
    },
    ResolutionStage3EmVerifier0Ecc_2bErrInitiate => { #Structure Type: RegField;
      Name => "ResolutionStage3EmVerifier0Ecc_2bErrInitiate",
      RegMem => "RegField",
      Description => "When this bit is set, ECC 2b Error will be initiated",
      Width => "1",
      Position => "54",
      Type => "Config",
      UsedBy => "MEM",
      DefaultValue => "b0",
    },
    ResolutionStage3EmVerifier1Ecc_2bErrInitiate => { #Structure Type: RegField;
      Name => "ResolutionStage3EmVerifier1Ecc_2bErrInitiate",
      RegMem => "RegField",
      Description => "When this bit is set, ECC 2b Error will be initiated",
      Width => "1",
      Position => "55",
      Type => "Config",
      UsedBy => "MEM",
      DefaultValue => "b0",
    },
    ResolutionStage3EmVerifier2Ecc_2bErrInitiate => { #Structure Type: RegField;
      Name => "ResolutionStage3EmVerifier2Ecc_2bErrInitiate",
      RegMem => "RegField",
      Description => "When this bit is set, ECC 2b Error will be initiated",
      Width => "1",
      Position => "56",
      Type => "Config",
      UsedBy => "MEM",
      DefaultValue => "b0",
    },
    ResolutionStage3EmVerifier3Ecc_2bErrInitiate => { #Structure Type: RegField;
      Name => "ResolutionStage3EmVerifier3Ecc_2bErrInitiate",
      RegMem => "RegField",
      Description => "When this bit is set, ECC 2b Error will be initiated",
      Width => "1",
      Position => "57",
      Type => "Config",
      UsedBy => "MEM",
      DefaultValue => "b0",
    },
    ResolutionStage3EmVerifier4Ecc_2bErrInitiate => { #Structure Type: RegField;
      Name => "ResolutionStage3EmVerifier4Ecc_2bErrInitiate",
      RegMem => "RegField",
      Description => "When this bit is set, ECC 2b Error will be initiated",
      Width => "1",
      Position => "58",
      Type => "Config",
      UsedBy => "MEM",
      DefaultValue => "b0",
    },
    ResolutionStage3EmVerifier5Ecc_2bErrInitiate => { #Structure Type: RegField;
      Name => "ResolutionStage3EmVerifier5Ecc_2bErrInitiate",
      RegMem => "RegField",
      Description => "When this bit is set, ECC 2b Error will be initiated",
      Width => "1",
      Position => "59",
      Type => "Config",
      UsedBy => "MEM",
      DefaultValue => "b0",
    },
  },
  MemProtectErrStatus => { #Structure Type: Reg; Skip Register;
    Name => "MemProtectErrStatus",
    RegMem => "Reg",
    Address => "33",
    Description => "Memory SER protected error status",
    Width => "60",
    Type => "ReadOnly",
    protection_table_slice0_stage0ErrInt => { #Structure Type: RegField;
      Name => "protection_table_slice0_stage0ErrInt",
      RegMem => "RegField",
      Description => "When this bit is set, SER Error occured",
      Width => "1",
      Position => "0",
      Type => "Status",
      UsedBy => "SER",
    },
    protection_table_slice0_stage1ErrInt => { #Structure Type: RegField;
      Name => "protection_table_slice0_stage1ErrInt",
      RegMem => "RegField",
      Description => "When this bit is set, SER Error occured",
      Width => "1",
      Position => "1",
      Type => "Status",
      UsedBy => "SER",
    },
    protection_table_slice0_stage2ErrInt => { #Structure Type: RegField;
      Name => "protection_table_slice0_stage2ErrInt",
      RegMem => "RegField",
      Description => "When this bit is set, SER Error occured",
      Width => "1",
      Position => "2",
      Type => "Status",
      UsedBy => "SER",
    },
    protection_table_slice0_stage3ErrInt => { #Structure Type: RegField;
      Name => "protection_table_slice0_stage3ErrInt",
      RegMem => "RegField",
      Description => "When this bit is set, SER Error occured",
      Width => "1",
      Position => "3",
      Type => "Status",
      UsedBy => "SER",
    },
    slice0_stage0_lb_consistence_cache_tableErrInt => { #Structure Type: RegField;
      Name => "slice0_stage0_lb_consistence_cache_tableErrInt",
      RegMem => "RegField",
      Description => "When this bit is set, SER Error occured",
      Width => "1",
      Position => "4",
      Type => "Status",
      UsedBy => "SER",
    },
    slice0_stage1_lb_consistence_cache_tableErrInt => { #Structure Type: RegField;
      Name => "slice0_stage1_lb_consistence_cache_tableErrInt",
      RegMem => "RegField",
      Description => "When this bit is set, SER Error occured",
      Width => "1",
      Position => "5",
      Type => "Status",
      UsedBy => "SER",
    },
    slice0_stage2_lb_consistence_cache_tableErrInt => { #Structure Type: RegField;
      Name => "slice0_stage2_lb_consistence_cache_tableErrInt",
      RegMem => "RegField",
      Description => "When this bit is set, SER Error occured",
      Width => "1",
      Position => "6",
      Type => "Status",
      UsedBy => "SER",
    },
    slice0_stage3_lb_consistence_cache_tableErrInt => { #Structure Type: RegField;
      Name => "slice0_stage3_lb_consistence_cache_tableErrInt",
      RegMem => "RegField",
      Description => "When this bit is set, SER Error occured",
      Width => "1",
      Position => "7",
      Type => "Status",
      UsedBy => "SER",
    },
    ResolutionStage0AssociatedDataErrInt => { #Structure Type: RegField;
      Name => "ResolutionStage0AssociatedDataErrInt",
      RegMem => "RegField",
      Description => "When this bit is set, SER Error occured",
      Width => "1",
      Position => "8",
      Type => "Status",
      UsedBy => "SER",
    },
    FecTableErrInt => { #Structure Type: RegField;
      Name => "FecTableErrInt",
      RegMem => "RegField",
      Description => "When this bit is set, SER Error occured",
      Width => "1",
      Position => "9",
      Type => "Status",
      UsedBy => "SER",
    },
    ResolutionStage1AssociatedDataErrInt => { #Structure Type: RegField;
      Name => "ResolutionStage1AssociatedDataErrInt",
      RegMem => "RegField",
      Description => "When this bit is set, SER Error occured",
      Width => "1",
      Position => "10",
      Type => "Status",
      UsedBy => "SER",
    },
    ResolutionStage2AssociatedDataErrInt => { #Structure Type: RegField;
      Name => "ResolutionStage2AssociatedDataErrInt",
      RegMem => "RegField",
      Description => "When this bit is set, SER Error occured",
      Width => "1",
      Position => "11",
      Type => "Status",
      UsedBy => "SER",
    },
    ResolutionStage3AssociatedDataErrInt => { #Structure Type: RegField;
      Name => "ResolutionStage3AssociatedDataErrInt",
      RegMem => "RegField",
      Description => "When this bit is set, SER Error occured",
      Width => "1",
      Position => "12",
      Type => "Status",
      UsedBy => "SER",
    },
    protection_table_slice1_stage0ErrInt => { #Structure Type: RegField;
      Name => "protection_table_slice1_stage0ErrInt",
      RegMem => "RegField",
      Description => "When this bit is set, SER Error occured",
      Width => "1",
      Position => "13",
      Type => "Status",
      UsedBy => "SER",
    },
    protection_table_slice1_stage1ErrInt => { #Structure Type: RegField;
      Name => "protection_table_slice1_stage1ErrInt",
      RegMem => "RegField",
      Description => "When this bit is set, SER Error occured",
      Width => "1",
      Position => "14",
      Type => "Status",
      UsedBy => "SER",
    },
    protection_table_slice1_stage2ErrInt => { #Structure Type: RegField;
      Name => "protection_table_slice1_stage2ErrInt",
      RegMem => "RegField",
      Description => "When this bit is set, SER Error occured",
      Width => "1",
      Position => "15",
      Type => "Status",
      UsedBy => "SER",
    },
    protection_table_slice1_stage3ErrInt => { #Structure Type: RegField;
      Name => "protection_table_slice1_stage3ErrInt",
      RegMem => "RegField",
      Description => "When this bit is set, SER Error occured",
      Width => "1",
      Position => "16",
      Type => "Status",
      UsedBy => "SER",
    },
    Slice0Stage0LbGroupSizeTableErrInt => { #Structure Type: RegField;
      Name => "Slice0Stage0LbGroupSizeTableErrInt",
      RegMem => "RegField",
      Description => "When this bit is set, SER Error occured",
      Width => "1",
      Position => "17",
      Type => "Status",
      UsedBy => "SER",
    },
    Slice0Stage1LbGroupSizeTableErrInt => { #Structure Type: RegField;
      Name => "Slice0Stage1LbGroupSizeTableErrInt",
      RegMem => "RegField",
      Description => "When this bit is set, SER Error occured",
      Width => "1",
      Position => "18",
      Type => "Status",
      UsedBy => "SER",
    },
    Slice0Stage2LbGroupSizeTableErrInt => { #Structure Type: RegField;
      Name => "Slice0Stage2LbGroupSizeTableErrInt",
      RegMem => "RegField",
      Description => "When this bit is set, SER Error occured",
      Width => "1",
      Position => "19",
      Type => "Status",
      UsedBy => "SER",
    },
    Slice0Stage3LbGroupSizeTableErrInt => { #Structure Type: RegField;
      Name => "Slice0Stage3LbGroupSizeTableErrInt",
      RegMem => "RegField",
      Description => "When this bit is set, SER Error occured",
      Width => "1",
      Position => "20",
      Type => "Status",
      UsedBy => "SER",
    },
    Slice1Stage0LbGroupSizeTableErrInt => { #Structure Type: RegField;
      Name => "Slice1Stage0LbGroupSizeTableErrInt",
      RegMem => "RegField",
      Description => "When this bit is set, SER Error occured",
      Width => "1",
      Position => "21",
      Type => "Status",
      UsedBy => "SER",
    },
    Slice1Stage1LbGroupSizeTableErrInt => { #Structure Type: RegField;
      Name => "Slice1Stage1LbGroupSizeTableErrInt",
      RegMem => "RegField",
      Description => "When this bit is set, SER Error occured",
      Width => "1",
      Position => "22",
      Type => "Status",
      UsedBy => "SER",
    },
    Slice1Stage2LbGroupSizeTableErrInt => { #Structure Type: RegField;
      Name => "Slice1Stage2LbGroupSizeTableErrInt",
      RegMem => "RegField",
      Description => "When this bit is set, SER Error occured",
      Width => "1",
      Position => "23",
      Type => "Status",
      UsedBy => "SER",
    },
    Slice1Stage3LbGroupSizeTableErrInt => { #Structure Type: RegField;
      Name => "Slice1Stage3LbGroupSizeTableErrInt",
      RegMem => "RegField",
      Description => "When this bit is set, SER Error occured",
      Width => "1",
      Position => "24",
      Type => "Status",
      UsedBy => "SER",
    },
    slice1_stage0_lb_consistence_cache_tableErrInt => { #Structure Type: RegField;
      Name => "slice1_stage0_lb_consistence_cache_tableErrInt",
      RegMem => "RegField",
      Description => "When this bit is set, SER Error occured",
      Width => "1",
      Position => "25",
      Type => "Status",
      UsedBy => "SER",
    },
    slice1_stage1_lb_consistence_cache_tableErrInt => { #Structure Type: RegField;
      Name => "slice1_stage1_lb_consistence_cache_tableErrInt",
      RegMem => "RegField",
      Description => "When this bit is set, SER Error occured",
      Width => "1",
      Position => "26",
      Type => "Status",
      UsedBy => "SER",
    },
    slice1_stage2_lb_consistence_cache_tableErrInt => { #Structure Type: RegField;
      Name => "slice1_stage2_lb_consistence_cache_tableErrInt",
      RegMem => "RegField",
      Description => "When this bit is set, SER Error occured",
      Width => "1",
      Position => "27",
      Type => "Status",
      UsedBy => "SER",
    },
    slice1_stage3_lb_consistence_cache_tableErrInt => { #Structure Type: RegField;
      Name => "slice1_stage3_lb_consistence_cache_tableErrInt",
      RegMem => "RegField",
      Description => "When this bit is set, SER Error occured",
      Width => "1",
      Position => "28",
      Type => "Status",
      UsedBy => "SER",
    },
    ResolutionStage0EmVerifier0ErrInt => { #Structure Type: RegField;
      Name => "ResolutionStage0EmVerifier0ErrInt",
      RegMem => "RegField",
      Description => "When this bit is set, SER Error occured",
      Width => "1",
      Position => "29",
      Type => "Status",
      UsedBy => "SER",
    },
    ResolutionStage0EmVerifier1ErrInt => { #Structure Type: RegField;
      Name => "ResolutionStage0EmVerifier1ErrInt",
      RegMem => "RegField",
      Description => "When this bit is set, SER Error occured",
      Width => "1",
      Position => "30",
      Type => "Status",
      UsedBy => "SER",
    },
    ResolutionStage0EmVerifier2ErrInt => { #Structure Type: RegField;
      Name => "ResolutionStage0EmVerifier2ErrInt",
      RegMem => "RegField",
      Description => "When this bit is set, SER Error occured",
      Width => "1",
      Position => "31",
      Type => "Status",
      UsedBy => "SER",
    },
    ResolutionStage0EmVerifier3ErrInt => { #Structure Type: RegField;
      Name => "ResolutionStage0EmVerifier3ErrInt",
      RegMem => "RegField",
      Description => "When this bit is set, SER Error occured",
      Width => "1",
      Position => "32",
      Type => "Status",
      UsedBy => "SER",
    },
    ResolutionStage0EmVerifier4ErrInt => { #Structure Type: RegField;
      Name => "ResolutionStage0EmVerifier4ErrInt",
      RegMem => "RegField",
      Description => "When this bit is set, SER Error occured",
      Width => "1",
      Position => "33",
      Type => "Status",
      UsedBy => "SER",
    },
    ResolutionStage0EmVerifier5ErrInt => { #Structure Type: RegField;
      Name => "ResolutionStage0EmVerifier5ErrInt",
      RegMem => "RegField",
      Description => "When this bit is set, SER Error occured",
      Width => "1",
      Position => "34",
      Type => "Status",
      UsedBy => "SER",
    },
    ResolutionStage0EmVerifier6ErrInt => { #Structure Type: RegField;
      Name => "ResolutionStage0EmVerifier6ErrInt",
      RegMem => "RegField",
      Description => "When this bit is set, SER Error occured",
      Width => "1",
      Position => "35",
      Type => "Status",
      UsedBy => "SER",
    },
    ResolutionStage0EmVerifier7ErrInt => { #Structure Type: RegField;
      Name => "ResolutionStage0EmVerifier7ErrInt",
      RegMem => "RegField",
      Description => "When this bit is set, SER Error occured",
      Width => "1",
      Position => "36",
      Type => "Status",
      UsedBy => "SER",
    },
    ResolutionStage0EmVerifier8ErrInt => { #Structure Type: RegField;
      Name => "ResolutionStage0EmVerifier8ErrInt",
      RegMem => "RegField",
      Description => "When this bit is set, SER Error occured",
      Width => "1",
      Position => "37",
      Type => "Status",
      UsedBy => "SER",
    },
    ResolutionStage0EmVerifier9ErrInt => { #Structure Type: RegField;
      Name => "ResolutionStage0EmVerifier9ErrInt",
      RegMem => "RegField",
      Description => "When this bit is set, SER Error occured",
      Width => "1",
      Position => "38",
      Type => "Status",
      UsedBy => "SER",
    },
    ResolutionStage0EmVerifier10ErrInt => { #Structure Type: RegField;
      Name => "ResolutionStage0EmVerifier10ErrInt",
      RegMem => "RegField",
      Description => "When this bit is set, SER Error occured",
      Width => "1",
      Position => "39",
      Type => "Status",
      UsedBy => "SER",
    },
    ResolutionStage0EmVerifier11ErrInt => { #Structure Type: RegField;
      Name => "ResolutionStage0EmVerifier11ErrInt",
      RegMem => "RegField",
      Description => "When this bit is set, SER Error occured",
      Width => "1",
      Position => "40",
      Type => "Status",
      UsedBy => "SER",
    },
    LpQueuingEmVerifier0ErrInt => { #Structure Type: RegField;
      Name => "LpQueuingEmVerifier0ErrInt",
      RegMem => "RegField",
      Description => "When this bit is set, SER Error occured",
      Width => "1",
      Position => "41",
      Type => "Status",
      UsedBy => "SER",
    },
    LpQueuingEmVerifier1ErrInt => { #Structure Type: RegField;
      Name => "LpQueuingEmVerifier1ErrInt",
      RegMem => "RegField",
      Description => "When this bit is set, SER Error occured",
      Width => "1",
      Position => "42",
      Type => "Status",
      UsedBy => "SER",
    },
    LpQueuingEmVerifier2ErrInt => { #Structure Type: RegField;
      Name => "LpQueuingEmVerifier2ErrInt",
      RegMem => "RegField",
      Description => "When this bit is set, SER Error occured",
      Width => "1",
      Position => "43",
      Type => "Status",
      UsedBy => "SER",
    },
    LpQueuingEmVerifier3ErrInt => { #Structure Type: RegField;
      Name => "LpQueuingEmVerifier3ErrInt",
      RegMem => "RegField",
      Description => "When this bit is set, SER Error occured",
      Width => "1",
      Position => "44",
      Type => "Status",
      UsedBy => "SER",
    },
    LpQueuingEmVerifier4ErrInt => { #Structure Type: RegField;
      Name => "LpQueuingEmVerifier4ErrInt",
      RegMem => "RegField",
      Description => "When this bit is set, SER Error occured",
      Width => "1",
      Position => "45",
      Type => "Status",
      UsedBy => "SER",
    },
    ResolutionStage1EmVerifier0ErrInt => { #Structure Type: RegField;
      Name => "ResolutionStage1EmVerifier0ErrInt",
      RegMem => "RegField",
      Description => "When this bit is set, SER Error occured",
      Width => "1",
      Position => "46",
      Type => "Status",
      UsedBy => "SER",
    },
    ResolutionStage1EmVerifier1ErrInt => { #Structure Type: RegField;
      Name => "ResolutionStage1EmVerifier1ErrInt",
      RegMem => "RegField",
      Description => "When this bit is set, SER Error occured",
      Width => "1",
      Position => "47",
      Type => "Status",
      UsedBy => "SER",
    },
    ResolutionStage1EmVerifier2ErrInt => { #Structure Type: RegField;
      Name => "ResolutionStage1EmVerifier2ErrInt",
      RegMem => "RegField",
      Description => "When this bit is set, SER Error occured",
      Width => "1",
      Position => "48",
      Type => "Status",
      UsedBy => "SER",
    },
    ResolutionStage1EmVerifier3ErrInt => { #Structure Type: RegField;
      Name => "ResolutionStage1EmVerifier3ErrInt",
      RegMem => "RegField",
      Description => "When this bit is set, SER Error occured",
      Width => "1",
      Position => "49",
      Type => "Status",
      UsedBy => "SER",
    },
    ResolutionStage2EmVerifier0ErrInt => { #Structure Type: RegField;
      Name => "ResolutionStage2EmVerifier0ErrInt",
      RegMem => "RegField",
      Description => "When this bit is set, SER Error occured",
      Width => "1",
      Position => "50",
      Type => "Status",
      UsedBy => "SER",
    },
    ResolutionStage2EmVerifier1ErrInt => { #Structure Type: RegField;
      Name => "ResolutionStage2EmVerifier1ErrInt",
      RegMem => "RegField",
      Description => "When this bit is set, SER Error occured",
      Width => "1",
      Position => "51",
      Type => "Status",
      UsedBy => "SER",
    },
    ResolutionStage2EmVerifier2ErrInt => { #Structure Type: RegField;
      Name => "ResolutionStage2EmVerifier2ErrInt",
      RegMem => "RegField",
      Description => "When this bit is set, SER Error occured",
      Width => "1",
      Position => "52",
      Type => "Status",
      UsedBy => "SER",
    },
    ResolutionStage2EmVerifier3ErrInt => { #Structure Type: RegField;
      Name => "ResolutionStage2EmVerifier3ErrInt",
      RegMem => "RegField",
      Description => "When this bit is set, SER Error occured",
      Width => "1",
      Position => "53",
      Type => "Status",
      UsedBy => "SER",
    },
    ResolutionStage3EmVerifier0ErrInt => { #Structure Type: RegField;
      Name => "ResolutionStage3EmVerifier0ErrInt",
      RegMem => "RegField",
      Description => "When this bit is set, SER Error occured",
      Width => "1",
      Position => "54",
      Type => "Status",
      UsedBy => "SER",
    },
    ResolutionStage3EmVerifier1ErrInt => { #Structure Type: RegField;
      Name => "ResolutionStage3EmVerifier1ErrInt",
      RegMem => "RegField",
      Description => "When this bit is set, SER Error occured",
      Width => "1",
      Position => "55",
      Type => "Status",
      UsedBy => "SER",
    },
    ResolutionStage3EmVerifier2ErrInt => { #Structure Type: RegField;
      Name => "ResolutionStage3EmVerifier2ErrInt",
      RegMem => "RegField",
      Description => "When this bit is set, SER Error occured",
      Width => "1",
      Position => "56",
      Type => "Status",
      UsedBy => "SER",
    },
    ResolutionStage3EmVerifier3ErrInt => { #Structure Type: RegField;
      Name => "ResolutionStage3EmVerifier3ErrInt",
      RegMem => "RegField",
      Description => "When this bit is set, SER Error occured",
      Width => "1",
      Position => "57",
      Type => "Status",
      UsedBy => "SER",
    },
    ResolutionStage3EmVerifier4ErrInt => { #Structure Type: RegField;
      Name => "ResolutionStage3EmVerifier4ErrInt",
      RegMem => "RegField",
      Description => "When this bit is set, SER Error occured",
      Width => "1",
      Position => "58",
      Type => "Status",
      UsedBy => "SER",
    },
    ResolutionStage3EmVerifier5ErrInt => { #Structure Type: RegField;
      Name => "ResolutionStage3EmVerifier5ErrInt",
      RegMem => "RegField",
      Description => "When this bit is set, SER Error occured",
      Width => "1",
      Position => "59",
      Type => "Status",
      UsedBy => "SER",
    },
  },
  SelectedSerErrorInfo => { #Structure Type: Reg; Skip Register;
    Name => "SelectedSerErrorInfo",
    RegMem => "Reg",
    Address => "34",
    Description => "Address and Type of SER error of selected memory",
    Width => "19",
    Type => "ReadOnly",
    MemErrAddr => { #Structure Type: RegField;
      Name => "MemErrAddr",
      RegMem => "RegField",
      Description => "Address of SER error of selected memory",
      Width => "17",
      Position => "16:0",
      Type => "Status",
      UsedBy => "SER",
    },
    MemErrType => { #Structure Type: RegField;
      Name => "MemErrType",
      RegMem => "RegField",
      Description => "0 = ECC 1b, 1 = ECC 2b, 2 = Parity",
      Width => "2",
      Position => "18:17",
      Type => "Status",
      UsedBy => "SER",
    },
  },
  SerErrorDebugConfiguration => { #Structure Type: Reg; Skip Register;
    Name => "SerErrorDebugConfiguration",
    RegMem => "Reg",
    Address => "35",
    Description => "Address and Type of SER error of selected memory",
    Width => "7",
    Type => "Config",
    ErroneousMemorySelector => { #Structure Type: RegField;
      Name => "ErroneousMemorySelector",
      RegMem => "RegField",
      Description => "Selects which memory error address and error type to set on the status register",
      Width => "6",
      Position => "5:0",
      Type => "Config",
      UsedBy => "SER",
      DefaultValue => "b0",
    },
    ResetMemoryErrors => { #Structure Type: RegField;
      Name => "ResetMemoryErrors",
      RegMem => "RegField",
      Description => "When set to 1 - all the memory SER errors are reset. Need to set back to 0 to resume error recording",
      Width => "1",
      Position => "6",
      Type => "Config",
      UsedBy => "SER",
      DefaultValue => "b0",
    },
  },
  Ecc_1bErrDebug => { #Structure Type: Reg; Skip Register;
    Name => "Ecc_1bErrDebug",
    RegMem => "Reg",
    Address => "36",
    Description => "ECC 1b Error Counter",
    Width => "16",
    Type => "ReadOnly",
    Ecc_1bErrCounter => { #Structure Type: RegField;
      Name => "Ecc_1bErrCounter",
      RegMem => "RegField",
      Description => "Counts number of ECC 1b errors",
      Width => "16",
      Position => "15:0",
      Type => "Counter",
      UsedBy => "SER",
      AdditionalInfo => "CounterIncrWidth=1",
    },
  },
  Ecc_2bErrDebug => { #Structure Type: Reg; Skip Register;
    Name => "Ecc_2bErrDebug",
    RegMem => "Reg",
    Address => "37",
    Description => "ECC 2b Error Counter",
    Width => "16",
    Type => "ReadOnly",
    Ecc_2bErrCounter => { #Structure Type: RegField;
      Name => "Ecc_2bErrCounter",
      RegMem => "RegField",
      Description => "Counts number of ECC 2b errors",
      Width => "16",
      Position => "15:0",
      Type => "Counter",
      UsedBy => "SER",
      AdditionalInfo => "CounterIncrWidth=1",
    },
  },
  TcamScanPeriodCfg => { #Structure Type: Reg; Skip Register;
    Name => "TcamScanPeriodCfg",
    RegMem => "Reg",
    Address => "3B",
    Description => "Configures period of TCAM scan for SER, set 0 to disable",
    Width => "32",
    Type => "Config",
    TcamScanPeriod => { #Structure Type: RegField;
      Name => "TcamScanPeriod",
      RegMem => "RegField",
      Description => "Configures period of TCAM scan for SER, set 0 to disable",
      Width => "32",
      Position => "31:0",
      Type => "Config",
      UsedBy => "TCAM",
      DefaultValue => "d120000000",
    },
  },

  CounterTimer => { #Structure Type: Reg; Skip Register;
    Name => "CounterTimer",
    RegMem => "Reg",
    Address => "40",
    Description => "Defines Counter Timer parameters",
    Width => "33", # Excel Formula: =calc_reg_width(E8:E9,F9)
    Type => "Config",
    CounterTimerEnable => { #Structure Type: RegField;
      Name => "CounterTimerEnable",
      RegMem => "RegField",
      Description => "If set, Counter Timer will applied for the counters, otherwise the counters are free running",
      Width => "1",
      Position => "0", # Excel Formula: =calc_position(F7,E8,TRUE)
      Type => "Config",
      UsedBy => "CIF",
      DefaultValue => "b0",
    },
    CounterTimerCycle => { #Structure Type: RegField;
      Name => "CounterTimerCycle",
      RegMem => "RegField",
      Description => "When activated, CounterTimer will count for CounterTimerCycle",
      Width => "32",
      Position => "32:1", # Excel Formula: =calc_position(F8,E9)
      Type => "Config",
      UsedBy => "CIF",
      DefaultValue => "h3B9ACA00",
    },
  },
  CounterTimerTriggerReg => { #Structure Type: Reg; Skip Register;
    Name => "CounterTimerTriggerReg",
    RegMem => "Reg",
    Address => "41", # Excel Formula: =calc_reg_address(C7,A7,G7)
    Description => "Activates Counter Timer",
    Width => "1", # Excel Formula: =calc_reg_width(E11:E11,F11)
    Type => "External",
    UsedBy => "CIF",
    CounterTimerTrigger => { #Structure Type: RegField;
      Name => "CounterTimerTrigger",
      RegMem => "RegField",
      Description => "When activated, CounterTimer will count for CounterTimerCycle",
      Width => "1",
      Position => "0", # Excel Formula: =calc_position(F10,E11,TRUE)
      Type => "External",
    },
  },
  MemoryAccessTimeout => { #Structure Type: Reg; Skip Register;
    Name => "MemoryAccessTimeout",
    RegMem => "Reg",
    Address => "42", # Excel Formula: =calc_reg_address(C10,A10,G10)
    Description => "Defines parameters for memory access timer expiry",
    Width => "38", # Excel Formula: =calc_reg_width(E13:E15,F15)
    Type => "Config",
    BubbleCounterThr => { #Structure Type: RegField;
      Name => "BubbleCounterThr",
      RegMem => "RegField",
      Description => "When BubbleCounterThr clocks passed from CIF memory access without grant, Bubble Request signal raised towards the block ",
      Width => "16",
      Position => "15:0", # Excel Formula: =calc_position(F12,E13,TRUE)
      Type => "Config",
      UsedBy => "CIF",
      DefaultValue => "d256",
    },
    TimeoutCounterThr => { #Structure Type: RegField;
      Name => "TimeoutCounterThr",
      RegMem => "RegField",
      Description => "When TimeoutCounterThr clocks passed from CIF memory access without grant, the access is terminated with error ",
      Width => "16",
      Position => "31:16", # Excel Formula: =calc_position(F13,E14)
      Type => "Config",
      UsedBy => "CIF",
      DefaultValue => "d4096",
    },
    AnsWindowCounterThr => { #Structure Type: RegField;
      Name => "AnsWindowCounterThr",
      RegMem => "RegField",
      Description => "When memory access is terminated because of  TimeoutCounterThr, the CIF waits AnsWindowCounterThr clocks for access termination",
      Width => "6",
      Position => "37:32", # Excel Formula: =calc_position(F14,E15)
      Type => "Config",
      UsedBy => "CIF",
      DefaultValue => "d16",
    },
  },
  BroadcastConfigReg => { #Structure Type: Reg; Skip Register;
    Name => "BroadcastConfigReg",
    RegMem => "Reg",
    Address => "43", # Excel Formula: =calc_reg_address(C12,A12,G12)
    Description => "Config Top broadcast parameters",
    Width => "12", # Excel Formula: =calc_reg_width(E17:E17,F17)
    Type => "Config",
    BroadcastId => { #Structure Type: RegField;
      Name => "BroadcastId",
      RegMem => "RegField",
      Description => "Broadcast ID used by Config Top protocol for broadcast messages",
      Width => "12",
      Position => "11:0", # Excel Formula: =calc_position(F16,E17,TRUE)
      Type => "Config",
      UsedBy => "CIF",
      DefaultValue => "hFFF",
    },
  },
  MemoryProtBypass => { #Structure Type: Reg; Skip Register;
    Name => "MemoryProtBypass",
    RegMem => "Reg",
    Address => "44", # Excel Formula: =calc_reg_address(C16,A16,G16)
    Description => "Bypass for ECC/Parity, used for debug",
    Width => "3", # Excel Formula: =calc_reg_width(E19:E21,F21)
    Type => "Config",
    DisableEcc => { #Structure Type: RegField;
      Name => "DisableEcc",
      RegMem => "RegField",
      Description => "If set, ECC fix is bypassed and is taken from payload",
      Width => "1",
      Position => "0", # Excel Formula: =calc_position(F18,E19,TRUE)
      Type => "Config",
      UsedBy => "MEM",
      DefaultValue => "b0",
    },
    CifProtGenBypass => { #Structure Type: RegField;
      Name => "CifProtGenBypass",
      RegMem => "RegField",
      Description => "If set, ECC/Parity generation is bypassed and is taken from payload for CIF access",
      Width => "1",
      Position => "1", # Excel Formula: =calc_position(F19,E20)
      Type => "Config",
      UsedBy => "MEM",
      DefaultValue => "b0",
    },
    CifProtFixBypass => { #Structure Type: RegField;
      Name => "CifProtFixBypass",
      RegMem => "RegField",
      Description => "If set, ECC/Parity fix is bypassed and original ECC/Parity is forwarded towards the CIF",
      Width => "1",
      Position => "2", # Excel Formula: =calc_position(F20,E21)
      Type => "Config",
      UsedBy => "MEM",
      DefaultValue => "b0",
    },
  },
  SoftResetConfiguration => { #Structure Type: Reg; Skip Register;
    Name => "SoftResetConfiguration",
    RegMem => "Reg",
    Address => "45", # Excel Formula: =calc_reg_address(C18,A18,G18)
    Description => "Soft Reset Configuration for the block",
    Width => "1", # Excel Formula: =calc_reg_width(E23:E23,F23)
    Type => "Config",
    SoftRstn => { #Structure Type: RegField;
      Name => "SoftRstn",
      RegMem => "RegField",
      Description => "Triggers soft reset signal for the block, active low register",
      Width => "1",
      Position => "0", # Excel Formula: =calc_position(F22,E23,TRUE)
      Type => "Config",
      UsedBy => "CIF",
      DefaultValue => "b0",
    },
  },
  MbistConfiguration => { #Structure Type: Reg; Skip Register;
    Name => "MbistConfiguration",
    RegMem => "Reg",
    Address => "46", # Excel Formula: =calc_reg_address(C22,A22,G22)
    Description => "MBIST Configuration for the block",
    Width => "73", # Excel Formula: =calc_reg_width(E25:E53,F53)
    Type => "Config",
    SACR1P_RME => { #Structure Type: RegField;
      Name => "SACR1P_RME",
      RegMem => "RegField",
      Description => "MBIST logic - Read Margin Enable",
      Width => "1",
      Position => "0", # Excel Formula: =calc_position(F24,E25,TRUE)
      Type => "Config",
      UsedBy => "MEM",
      DefaultValue => "b0",
    },
    SACR1P_RM => { #Structure Type: RegField;
      Name => "SACR1P_RM",
      RegMem => "RegField",
      Description => "MBIST logic - Read Margin",
      Width => "4",
      Position => "4:1", # Excel Formula: =calc_position(F25,E26)
      Type => "Config",
      UsedBy => "MEM",
      DefaultValue => "b0",
    },
    SACU2P_RME => { #Structure Type: RegField;
      Name => "SACU2P_RME",
      RegMem => "RegField",
      Description => "MBIST logic - Read Margin Enable",
      Width => "1",
      Position => "5", # Excel Formula: =calc_position(F26,E27)
      Type => "Config",
      UsedBy => "MEM",
      DefaultValue => "b0",
    },
    SACU2P_RM => { #Structure Type: RegField;
      Name => "SACU2P_RM",
      RegMem => "RegField",
      Description => "MBIST logic - Read Margin",
      Width => "4",
      Position => "9:6", # Excel Formula: =calc_position(F27,E28)
      Type => "Config",
      UsedBy => "MEM",
      DefaultValue => "b0",
    },
    SADC1P_RME => { #Structure Type: RegField;
      Name => "SADC1P_RME",
      RegMem => "RegField",
      Description => "MBIST logic - Read Margin Enable",
      Width => "1",
      Position => "10", # Excel Formula: =calc_position(F28,E29)
      Type => "Config",
      UsedBy => "MEM",
      DefaultValue => "b0",
    },
    SADC1P_RM => { #Structure Type: RegField;
      Name => "SADC1P_RM",
      RegMem => "RegField",
      Description => "MBIST logic - Read Margin",
      Width => "4",
      Position => "14:11", # Excel Formula: =calc_position(F29,E30)
      Type => "Config",
      UsedBy => "MEM",
      DefaultValue => "b0",
    },
    SADR2P_RMEA => { #Structure Type: RegField;
      Name => "SADR2P_RMEA",
      RegMem => "RegField",
      Description => "MBIST logic - Read Margin Enable port A",
      Width => "1",
      Position => "15", # Excel Formula: =calc_position(F30,E31)
      Type => "Config",
      UsedBy => "MEM",
      DefaultValue => "b0",
    },
    SADR2P_RMA => { #Structure Type: RegField;
      Name => "SADR2P_RMA",
      RegMem => "RegField",
      Description => "MBIST logic - Read Margin port A",
      Width => "4",
      Position => "19:16", # Excel Formula: =calc_position(F31,E32)
      Type => "Config",
      UsedBy => "MEM",
      DefaultValue => "b0",
    },
    SADR2P_RMEB => { #Structure Type: RegField;
      Name => "SADR2P_RMEB",
      RegMem => "RegField",
      Description => "MBIST logic - Read Margin Enable port B",
      Width => "1",
      Position => "20", # Excel Formula: =calc_position(F32,E33)
      Type => "Config",
      UsedBy => "MEM",
      DefaultValue => "b0",
    },
    SADR2P_RMB => { #Structure Type: RegField;
      Name => "SADR2P_RMB",
      RegMem => "RegField",
      Description => "MBIST logic - Read Margin port B",
      Width => "4",
      Position => "24:21", # Excel Formula: =calc_position(F33,E34)
      Type => "Config",
      UsedBy => "MEM",
      DefaultValue => "b0",
    },
    SADS2P_RMEA => { #Structure Type: RegField;
      Name => "SADS2P_RMEA",
      RegMem => "RegField",
      Description => "MBIST logic - Read Margin Enable port A",
      Width => "1",
      Position => "25", # Excel Formula: =calc_position(F34,E35)
      Type => "Config",
      UsedBy => "MEM",
      DefaultValue => "b0",
    },
    SADS2P_RMA => { #Structure Type: RegField;
      Name => "SADS2P_RMA",
      RegMem => "RegField",
      Description => "MBIST logic - Read Margin port A",
      Width => "4",
      Position => "29:26", # Excel Formula: =calc_position(F35,E36)
      Type => "Config",
      UsedBy => "MEM",
      DefaultValue => "b0",
    },
    SADS2P_RMEB => { #Structure Type: RegField;
      Name => "SADS2P_RMEB",
      RegMem => "RegField",
      Description => "MBIST logic - Read Margin Enable port B",
      Width => "1",
      Position => "30", # Excel Formula: =calc_position(F36,E37)
      Type => "Config",
      UsedBy => "MEM",
      DefaultValue => "b0",
    },
    SADS2P_RMB => { #Structure Type: RegField;
      Name => "SADS2P_RMB",
      RegMem => "RegField",
      Description => "MBIST logic - Read Margin port B",
      Width => "4",
      Position => "34:31", # Excel Formula: =calc_position(F37,E38)
      Type => "Config",
      UsedBy => "MEM",
      DefaultValue => "b0",
    },
    SASR1P_RME => { #Structure Type: RegField;
      Name => "SASR1P_RME",
      RegMem => "RegField",
      Description => "MBIST logic - Read Margin Enable",
      Width => "1",
      Position => "35", # Excel Formula: =calc_position(F38,E39)
      Type => "Config",
      UsedBy => "MEM",
      DefaultValue => "b0",
    },
    SASR1P_RM => { #Structure Type: RegField;
      Name => "SASR1P_RM",
      RegMem => "RegField",
      Description => "MBIST logic - Read Margin",
      Width => "4",
      Position => "39:36", # Excel Formula: =calc_position(F39,E40)
      Type => "Config",
      UsedBy => "MEM",
      DefaultValue => "b0",
    },
    SASS1P_RME => { #Structure Type: RegField;
      Name => "SASS1P_RME",
      RegMem => "RegField",
      Description => "MBIST logic - Read Margin Enable",
      Width => "1",
      Position => "40", # Excel Formula: =calc_position(F40,E41)
      Type => "Config",
      UsedBy => "MEM",
      DefaultValue => "b0",
    },
    SASS1P_RM => { #Structure Type: RegField;
      Name => "SASS1P_RM",
      RegMem => "RegField",
      Description => "MBIST logic - Read Margin",
      Width => "4",
      Position => "44:41", # Excel Formula: =calc_position(F41,E42)
      Type => "Config",
      UsedBy => "MEM",
      DefaultValue => "b0",
    },
    SASS2P_RMEA => { #Structure Type: RegField;
      Name => "SASS2P_RMEA",
      RegMem => "RegField",
      Description => "MBIST logic - Read Margin Enable port A",
      Width => "1",
      Position => "45", # Excel Formula: =calc_position(F42,E43)
      Type => "Config",
      UsedBy => "MEM",
      DefaultValue => "b0",
    },
    SASS2P_RMA => { #Structure Type: RegField;
      Name => "SASS2P_RMA",
      RegMem => "RegField",
      Description => "MBIST logic - Read Margin port A",
      Width => "4",
      Position => "49:46", # Excel Formula: =calc_position(F43,E44)
      Type => "Config",
      UsedBy => "MEM",
      DefaultValue => "b0",
    },
    SASS2P_RMEB => { #Structure Type: RegField;
      Name => "SASS2P_RMEB",
      RegMem => "RegField",
      Description => "MBIST logic - Read Margin Enable port B",
      Width => "1",
      Position => "50", # Excel Formula: =calc_position(F44,E45)
      Type => "Config",
      UsedBy => "MEM",
      DefaultValue => "b0",
    },
    SASS2P_RMB => { #Structure Type: RegField;
      Name => "SASS2P_RMB",
      RegMem => "RegField",
      Description => "MBIST logic - Read Margin port B",
      Width => "4",
      Position => "54:51", # Excel Formula: =calc_position(F45,E46)
      Type => "Config",
      UsedBy => "MEM",
      DefaultValue => "b0",
    },
    SASU2P_RME => { #Structure Type: RegField;
      Name => "SASU2P_RME",
      RegMem => "RegField",
      Description => "MBIST logic - Read Margin Enable",
      Width => "1",
      Position => "55", # Excel Formula: =calc_position(F46,E47)
      Type => "Config",
      UsedBy => "MEM",
      DefaultValue => "b0",
    },
    SASU2P_RM => { #Structure Type: RegField;
      Name => "SASU2P_RM",
      RegMem => "RegField",
      Description => "MBIST logic - Read Margin",
      Width => "4",
      Position => "59:56", # Excel Formula: =calc_position(F47,E48)
      Type => "Config",
      UsedBy => "MEM",
      DefaultValue => "b0",
    },
    SADU1P_RME => { #Structure Type: RegField;
      Name => "SADU1P_RME",
      RegMem => "RegField",
      Description => "MBIST logic - Read Margin Enable",
      Width => "1",
      Position => "60", # Excel Formula: =calc_position(F48,E49)
      Type => "Config",
      UsedBy => "MEM",
      DefaultValue => "b0",
    },
    SADU1P_RM => { #Structure Type: RegField;
      Name => "SADU1P_RM",
      RegMem => "RegField",
      Description => "MBIST logic - Read Margin",
      Width => "4",
      Position => "64:61", # Excel Formula: =calc_position(F49,E50)
      Type => "Config",
      UsedBy => "MEM",
      DefaultValue => "b0",
    },
    SADS2P_RA => { #Structure Type: RegField;
      Name => "SADS2P_RA",
      RegMem => "RegField",
      Description => "MBIST logic - Read Assist for Dual port",
      Width => "2",
      Position => "66:65", # Excel Formula: =calc_position(F50,E51)
      Type => "Config",
      UsedBy => "MEM",
      DefaultValue => "b0",
    },
    SADU1P_WA => { #Structure Type: RegField;
      Name => "SADU1P_WA",
      RegMem => "RegField",
      Description => "Write-Assist configuration for the SP SADU compiler",
      Width => "3",
      Position => "69:67", # Excel Formula: =calc_position(F51,E52)
      Type => "Config",
      UsedBy => "MEM",
      DefaultValue => "d5",
    },
    SADU1P_WPULSE => { #Structure Type: RegField;
      Name => "SADU1P_WPULSE",
      RegMem => "RegField",
      Description => "Write-Assist-Pulse configuration for the SP SADU compiler",
      Width => "3",
      Position => "72:70", # Excel Formula: =calc_position(F52,E53)
      Type => "Config",
      UsedBy => "MEM",
      DefaultValue => "b0",
    },
  },
  PowerDownConfiguration => { #Structure Type: Reg; Skip Register;
    Name => "PowerDownConfiguration",
    RegMem => "Reg",
    Address => "47", # Excel Formula: =calc_reg_address(C24,A24,G24)
    Description => "Power Down Configuration for the block",
    Width => "1", # Excel Formula: =calc_reg_width(E55:E55,F55)
    Type => "Config",
    PowerDown => { #Structure Type: RegField;
      Name => "PowerDown",
      RegMem => "RegField",
      Description => "If set, disables the clock of the block",
      Width => "1",
      Position => "0", # Excel Formula: =calc_position(F54,E55,TRUE)
      Type => "Config",
      UsedBy => "CIF",
      DefaultValue => "b0",
      Comments => "Default value should always be 0",
    },
  },
  SpareReg => { #Structure Type: Reg; Skip Register;
    Name => "SpareReg",
    RegMem => "Reg",
    Address => "48", # Excel Formula: =calc_reg_address(C54,A54,G54)
    Description => "Spare register",
    Width => "128", # Excel Formula: =calc_reg_width(E57:E57,F57)
    Type => "Config",
    SpareRegister => { #Structure Type: RegField;
      Name => "SpareRegister",
      RegMem => "RegField",
      Description => "Spare register ",
      Width => "128",
      Position => "127:0", # Excel Formula: =calc_position(F56,E57,TRUE)
      Type => "Config",
      UsedBy => "CIF",
      DefaultValue => "hffffffffffffffff",
    },
  },
  PmroCtrl => { #Structure Type: Reg; Skip Register;
    Name => "PmroCtrl",
    RegMem => "Reg",
    Address => "49", # Excel Formula: =calc_reg_address(C56,A56,G56)
    Description => "PMRO controller configuration",
    Width => "32", # Excel Formula: =calc_reg_width(E59:E63,F63)
    Type => "Config",
    PmroRstn => { #Structure Type: RegField;
      Name => "PmroRstn",
      RegMem => "RegField",
      Description => "PMRO reset, active low",
      Width => "1",
      Position => "0", # Excel Formula: =calc_position(F58,E59,TRUE)
      Type => "Config",
      UsedBy => "pmro",
      DefaultValue => "d0",
    },
    PmroConfigEn => { #Structure Type: RegField;
      Name => "PmroConfigEn",
      RegMem => "RegField",
      Description => "Enable pmro configuration, when equals to 0 configurations are locked",
      Width => "1",
      Position => "1", # Excel Formula: =calc_position(F59,E60)
      Type => "Config",
      UsedBy => "pmro",
      DefaultValue => "d0",
    },
    PmroStart => { #Structure Type: RegField;
      Name => "PmroStart",
      RegMem => "RegField",
      Description => "Start the pmro operation",
      Width => "1",
      Position => "2", # Excel Formula: =calc_position(F60,E61)
      Type => "Config",
      UsedBy => "pmro",
      DefaultValue => "d0",
    },
    PmroRingEn => { #Structure Type: RegField;
      Name => "PmroRingEn",
      RegMem => "RegField",
      Description => "Determines which PMRO ring to activate, should be configured as one hot",
      Width => "7",
      Position => "9:3", # Excel Formula: =calc_position(F61,E62)
      Type => "Config",
      UsedBy => "pmro",
      DefaultValue => "d1",
    },
    PmroCntPeriod => { #Structure Type: RegField;
      Name => "PmroCntPeriod",
      RegMem => "RegField",
      Description => "Number of core clock cycles on which PMRO is measured",
      Width => "22",
      Position => "31:10", # Excel Formula: =calc_position(F62,E63)
      Type => "Config",
      UsedBy => "pmro",
      DefaultValue => "h3FFFFF",
    },
  },
  PmroStatus => { #Structure Type: Reg; Skip Register;
    Name => "PmroStatus",
    RegMem => "Reg",
    Address => "4A", # Excel Formula: =calc_reg_address(C58,A58,G58)
    Description => "PMRO status configuration",
    Width => "23", # Excel Formula: =calc_reg_width(E65:E66,F66)
    Type => "ReadOnly",
    PmroCountOut => { #Structure Type: RegField;
      Name => "PmroCountOut",
      RegMem => "RegField",
      Description => "The ring oscilator counter value.",
      Width => "22",
      Position => "21:0", # Excel Formula: =calc_position(F64,E65,TRUE)
      Type => "Status",
      UsedBy => "pmro",
    },
    PmroDone => { #Structure Type: RegField;
      Name => "PmroDone",
      RegMem => "RegField",
      Description => "Pmro operation done, PmroCountOut is valid.",
      Width => "1",
      Position => "22", # Excel Formula: =calc_position(F65,E66)
      Type => "Status",
      UsedBy => "pmro",
    },
  },
  MirrorBusConfReg => { #Structure Type: Reg; Skip Register;
    Name => "MirrorBusConfReg",
    RegMem => "Reg",
    Address => "4B", # Excel Formula: =calc_reg_address(C64,A64,G64)
    Description => "Mirror Bus configurations",
    Width => "11", # Excel Formula: =calc_reg_width(E68:E69,F69)
    Type => "Config",
    MirrorBusEn => { #Structure Type: RegField;
      Name => "MirrorBusEn",
      RegMem => "RegField",
      Description => "Enable Mirror Bus",
      Width => "1",
      Position => "0", # Excel Formula: =calc_position(F67,E68,TRUE)
      Type => "Config",
      UsedBy => "BLOCK",
      DefaultValue => "h0",
    },
    MirrorBusSel => { #Structure Type: RegField;
      Name => "MirrorBusSel",
      RegMem => "RegField",
      Description => "Mirror Bus selector",
      Width => "10",
      Position => "10:1", # Excel Formula: =calc_position(F68,E69)
      Type => "Config",
      UsedBy => "BLOCK",
      DefaultValue => "h0",
    },
  },
  MirrorBusStatus => { #Structure Type: Reg; Skip Register;
    Name => "MirrorBusStatus",
    RegMem => "Reg",
    Address => "4C", # Excel Formula: =calc_reg_address(C67,A67,G67)
    Description => "Mirror Bus status result",
    Width => "32", # Excel Formula: =calc_reg_width(E71:E71,F71)
    Type => "ReadOnly",
    MirrorBus => { #Structure Type: RegField;
      Name => "MirrorBus",
      RegMem => "RegField",
      Description => "Mirror Bus status result",
      Width => "32",
      Position => "31:0", # Excel Formula: =calc_position(F70,E71,TRUE)
      Type => "Status",
      UsedBy => "BLOCK",
    },
  },
  DeviceTimeOffsetCfg => { #Structure Type: Reg; Skip Register;
    Name => "DeviceTimeOffsetCfg",
    RegMem => "Reg",
    Address => "4D", # Excel Formula: =calc_reg_address(C70,A70,G70)
    Description => "Define time offset configuration",
    Width => "10", # Excel Formula: =calc_reg_width(E73:E73,F73)
    Type => "Config",
    DeviceTimeOffset => { #Structure Type: RegField;
      Name => "DeviceTimeOffset",
      RegMem => "RegField",
      Description => "Define time offset",
      Width => "10",
      Position => "9:0", # Excel Formula: =calc_position(F72,E73,TRUE)
      Type => "Config",
      UsedBy => "CIF",
      DefaultValue => "h0",
    },
  },
  debug_data_bus_register => { #Structure Type: Reg;
    Name => "debug_data_bus_register",
    RegMem => "Reg",
    Address => "100",
    Description => "This register will contain selected-data-bus for debug. The selected data is taken from a full data-bus which can be seen in idb_res_dbg.v file. ",
    Width => "32", # Excel Formula: =calc_reg_width(E8:E8,F8)
    Type => "ReadOnly",
    DocName => "DebugDataBusRegister",
    debug_data_bus => { #Structure Type: RegField;
      Name => "debug_data_bus",
      RegMem => "RegField",
      Description => "Selected debug-data from offset according to the 'debug_data_select' register.",
      Width => "32",
      Position => "31:0", # Excel Formula: =calc_position(F7,E8,TRUE)
      Type => "Status",
      UsedBy => "idb_res",
      DocName => "DebugDataBus",
    },
  },
  debug_data_select_register => { #Structure Type: Reg;
    Name => "debug_data_select_register",
    RegMem => "Reg",
    Address => "101", # Excel Formula: =calc_reg_address(C7,A7,G7)
    Description => "This reg is the selector of the debug_data_bus",
    Width => "8", # Excel Formula: =calc_reg_width(E10:E10,F10)
    Type => "Config",
    DocName => "DebugDataSelectRegister",
    debug_data_select => { #Structure Type: RegField;
      Name => "debug_data_select",
      RegMem => "RegField",
      Description => "debug_data_select",
      Width => "8",
      Position => "7:0", # Excel Formula: =calc_position(F9,E10,TRUE)
      Type => "Config",
      UsedBy => "resolution",
      DefaultValue => "d0",
      DocName => "DebugDataSelect",
    },
  },
  init_done_status_register => { #Structure Type: Reg;
    Name => "init_done_status_register",
    RegMem => "Reg",
    Address => "102", # Excel Formula: =calc_reg_address(C9,A9,G9)
    Description => "res_init_done_status_reg",
    Width => "1", # Excel Formula: =calc_reg_width(E12:E12,F12)
    Type => "ReadOnly",
    init_done => { #Structure Type: RegField;
      Name => "init_done",
      RegMem => "RegField",
      Description => "res_init_done",
      Width => "1",
      Position => "0", # Excel Formula: =calc_position(F11,E12,TRUE)
      Type => "Status",
      UsedBy => "res",
    },
  },
  CfgEnable32kEmGroup => { #Structure Type: Reg;
    Name => "CfgEnable32kEmGroup",
    RegMem => "Reg",
    Address => "103", # Excel Formula: =calc_reg_address(C11,A11,G11)
    Description => "configuration that enables the usage of 32k in the 1st stage of the IDB resolution",
    Width => "1", # Excel Formula: =calc_reg_width(E14:E14,F14)
    Type => "Config",
    Enable32kEmGroup => { #Structure Type: RegField;
      Name => "Enable32kEmGroup",
      RegMem => "RegField",
      Description => "Cfg Enable 32k EM group is set:
LB key = {1'b0, Member-ID(8), Group-ID(15)}
Else:
LB key = {1'b0, Member-ID(9), Group-ID(14)}",
      Width => "1",
      Position => "0", # Excel Formula: =calc_position(F13,E14,TRUE)
      Type => "Config",
      UsedBy => "res",
      DefaultValue => "d0",
      InitValueAllModes => "0",
    },
  },
  slice0_stage0_lb_Consistence_cache_clk_and_timer_attr => { #Structure Type: Reg; ArrayLength: 4; ArrayIndex: 0; ArrayLocationInName: 13;
    Name => "slice0_stage[4]_lb_Consistence_cache_clk_and_timer_attr",
    RegMem => "Reg",
    Address => "104", # Excel Formula: =calc_reg_address(C13,A13,G13)
    Description => "This register Controls the cache-time-stamp resolution/scale
The design contains 32b counter which counts clock-cycles:
* Initialize on reset: clks-counter = 0
* Increment every clk

This register defines the desired time-scale out of this reg.
The picked time-scale is used for both the following:
1. The time-stamp that be taken and wrriten to the cache-table.
2. The threshold in which the cache-entry will be aged.",
    Width => "15", # Excel Formula: =calc_reg_width(E16:E17,F17)
    Type => "Config",
    DocName => "Slice[2]PortDspLbConsistenceCacheClkAndTimerAttr",
    ArrayLength => "4",
    ArrayIndex => "0",
    slice0_stage0_lb_Consistence_cache_clock_offset => { #Structure Type: RegField; ArrayLength: 4; ArrayIndex: 0; ArrayLocationInName: 13;
      Name => "slice0_stage[n]_lb_Consistence_cache_clock_offset",
      RegMem => "RegField",
      Description => "Desired offset from the 32b clocks-counter:
Curr-time = clks-counter[Cfg-offset +: 4]
For example: if the clock-cycle is 1ns, and the desired resolution is 1us, than the offset should be 10
",
      Width => "5",
      Position => "4:0", # Excel Formula: =calc_position(F15,E16,TRUE)
      Type => "Config",
      UsedBy => "res",
      DefaultValue => "d10",
      DocName => "Slice[n]PortDspLbConsistenceCacheClockOffset",
      Comments => "counts number of valid members currently in cache",
    },
    slice0_stage0_lb_Consistence_cache_clock_threshold => { #Structure Type: RegField; ArrayLength: 4; ArrayIndex: 0; ArrayLocationInName: 13;
      Name => "slice0_stage[n]_lb_Consistence_cache_clock_threshold",
      RegMem => "RegField",
      Description => "Cache-entry will be erased only if read by the design, and:
(Curr-time - Cache-payload.Time-stamp) > Cfg-Threshold",
      Width => "10",
      Position => "14:5", # Excel Formula: =calc_position(F16,E17)
      Type => "Config",
      UsedBy => "res",
      DefaultValue => "d1000",
      DocName => "Slice[n]PortDspLbConsistenceCacheClockThreshold",
      Comments => "counts number of valid members currently in cache",
    },
  },
  slice0_stage1_lb_Consistence_cache_clk_and_timer_attr => { #Structure Type: Reg; ArrayLength: 4; ArrayIndex: 1; ArrayLocationInName: 13;
    Name => "slice0_stage[4]_lb_Consistence_cache_clk_and_timer_attr",
    RegMem => "Reg",
    Address => "105",
    Description => "This register Controls the cache-time-stamp resolution/scale
The design contains 32b counter which counts clock-cycles:
* Initialize on reset: clks-counter = 0
* Increment every clk

This register defines the desired time-scale out of this reg.
The picked time-scale is used for both the following:
1. The time-stamp that be taken and wrriten to the cache-table.
2. The threshold in which the cache-entry will be aged.",
    Width => "15", # Excel Formula: =calc_reg_width(E16:E17,F17)
    Type => "Config",
    DocName => "Slice[2]PortDspLbConsistenceCacheClkAndTimerAttr",
    ArrayLength => "4",
    ArrayIndex => "1",
    slice0_stage1_lb_Consistence_cache_clock_offset => { #Structure Type: RegField; ArrayLength: 4; ArrayIndex: 1; ArrayLocationInName: 13;
      Name => "slice0_stage[n]_lb_Consistence_cache_clock_offset",
      RegMem => "RegField",
      Description => "Desired offset from the 32b clocks-counter:
Curr-time = clks-counter[Cfg-offset +: 4]
For example: if the clock-cycle is 1ns, and the desired resolution is 1us, than the offset should be 10
",
      Width => "5",
      Position => "4:0", # Excel Formula: =calc_position(F15,E16,TRUE)
      Type => "Config",
      UsedBy => "res",
      DefaultValue => "d10",
      DocName => "Slice[n]PortDspLbConsistenceCacheClockOffset",
      Comments => "counts number of valid members currently in cache",
    },
    slice0_stage1_lb_Consistence_cache_clock_threshold => { #Structure Type: RegField; ArrayLength: 4; ArrayIndex: 1; ArrayLocationInName: 13;
      Name => "slice0_stage[n]_lb_Consistence_cache_clock_threshold",
      RegMem => "RegField",
      Description => "Cache-entry will be erased only if read by the design, and:
(Curr-time - Cache-payload.Time-stamp) > Cfg-Threshold",
      Width => "10",
      Position => "14:5", # Excel Formula: =calc_position(F16,E17)
      Type => "Config",
      UsedBy => "res",
      DefaultValue => "d1000",
      DocName => "Slice[n]PortDspLbConsistenceCacheClockThreshold",
      Comments => "counts number of valid members currently in cache",
    },
  },
  slice0_stage2_lb_Consistence_cache_clk_and_timer_attr => { #Structure Type: Reg; ArrayLength: 4; ArrayIndex: 2; ArrayLocationInName: 13;
    Name => "slice0_stage[4]_lb_Consistence_cache_clk_and_timer_attr",
    RegMem => "Reg",
    Address => "106",
    Description => "This register Controls the cache-time-stamp resolution/scale
The design contains 32b counter which counts clock-cycles:
* Initialize on reset: clks-counter = 0
* Increment every clk

This register defines the desired time-scale out of this reg.
The picked time-scale is used for both the following:
1. The time-stamp that be taken and wrriten to the cache-table.
2. The threshold in which the cache-entry will be aged.",
    Width => "15", # Excel Formula: =calc_reg_width(E16:E17,F17)
    Type => "Config",
    DocName => "Slice[2]PortDspLbConsistenceCacheClkAndTimerAttr",
    ArrayLength => "4",
    ArrayIndex => "2",
    slice0_stage2_lb_Consistence_cache_clock_offset => { #Structure Type: RegField; ArrayLength: 4; ArrayIndex: 2; ArrayLocationInName: 13;
      Name => "slice0_stage[n]_lb_Consistence_cache_clock_offset",
      RegMem => "RegField",
      Description => "Desired offset from the 32b clocks-counter:
Curr-time = clks-counter[Cfg-offset +: 4]
For example: if the clock-cycle is 1ns, and the desired resolution is 1us, than the offset should be 10
",
      Width => "5",
      Position => "4:0", # Excel Formula: =calc_position(F15,E16,TRUE)
      Type => "Config",
      UsedBy => "res",
      DefaultValue => "d10",
      DocName => "Slice[n]PortDspLbConsistenceCacheClockOffset",
      Comments => "counts number of valid members currently in cache",
    },
    slice0_stage2_lb_Consistence_cache_clock_threshold => { #Structure Type: RegField; ArrayLength: 4; ArrayIndex: 2; ArrayLocationInName: 13;
      Name => "slice0_stage[n]_lb_Consistence_cache_clock_threshold",
      RegMem => "RegField",
      Description => "Cache-entry will be erased only if read by the design, and:
(Curr-time - Cache-payload.Time-stamp) > Cfg-Threshold",
      Width => "10",
      Position => "14:5", # Excel Formula: =calc_position(F16,E17)
      Type => "Config",
      UsedBy => "res",
      DefaultValue => "d1000",
      DocName => "Slice[n]PortDspLbConsistenceCacheClockThreshold",
      Comments => "counts number of valid members currently in cache",
    },
  },
  slice0_stage3_lb_Consistence_cache_clk_and_timer_attr => { #Structure Type: Reg; ArrayLength: 4; ArrayIndex: 3; ArrayLocationInName: 13;
    Name => "slice0_stage[4]_lb_Consistence_cache_clk_and_timer_attr",
    RegMem => "Reg",
    Address => "107",
    Description => "This register Controls the cache-time-stamp resolution/scale
The design contains 32b counter which counts clock-cycles:
* Initialize on reset: clks-counter = 0
* Increment every clk

This register defines the desired time-scale out of this reg.
The picked time-scale is used for both the following:
1. The time-stamp that be taken and wrriten to the cache-table.
2. The threshold in which the cache-entry will be aged.",
    Width => "15", # Excel Formula: =calc_reg_width(E16:E17,F17)
    Type => "Config",
    DocName => "Slice[2]PortDspLbConsistenceCacheClkAndTimerAttr",
    ArrayLength => "4",
    ArrayIndex => "3",
    slice0_stage3_lb_Consistence_cache_clock_offset => { #Structure Type: RegField; ArrayLength: 4; ArrayIndex: 3; ArrayLocationInName: 13;
      Name => "slice0_stage[n]_lb_Consistence_cache_clock_offset",
      RegMem => "RegField",
      Description => "Desired offset from the 32b clocks-counter:
Curr-time = clks-counter[Cfg-offset +: 4]
For example: if the clock-cycle is 1ns, and the desired resolution is 1us, than the offset should be 10
",
      Width => "5",
      Position => "4:0", # Excel Formula: =calc_position(F15,E16,TRUE)
      Type => "Config",
      UsedBy => "res",
      DefaultValue => "d10",
      DocName => "Slice[n]PortDspLbConsistenceCacheClockOffset",
      Comments => "counts number of valid members currently in cache",
    },
    slice0_stage3_lb_Consistence_cache_clock_threshold => { #Structure Type: RegField; ArrayLength: 4; ArrayIndex: 3; ArrayLocationInName: 13;
      Name => "slice0_stage[n]_lb_Consistence_cache_clock_threshold",
      RegMem => "RegField",
      Description => "Cache-entry will be erased only if read by the design, and:
(Curr-time - Cache-payload.Time-stamp) > Cfg-Threshold",
      Width => "10",
      Position => "14:5", # Excel Formula: =calc_position(F16,E17)
      Type => "Config",
      UsedBy => "res",
      DefaultValue => "d1000",
      DocName => "Slice[n]PortDspLbConsistenceCacheClockThreshold",
      Comments => "counts number of valid members currently in cache",
    },
  },
  slice0_stage0_lb_Consistence_cache_count => { #Structure Type: Reg; ArrayLength: 4; ArrayIndex: 0; ArrayLocationInName: 13;
    Name => "slice0_stage[4]_lb_Consistence_cache_count",
    RegMem => "Reg",
    Address => "108", # Excel Formula: =calc_reg_address(C15,A15,G15)
    Description => "Number of elements currently in cache. When cache is active, this register is managed by the Design. Because each cahce is read only when packet arrives with the corresponding LB-Key, it is posibble that before changing another group-size, the cache-count will not be 0. for this reason:
Before changing Group-size of another gourp-id, If (cache-counter =! 0) then the User should do the following:
a. Write 0 to all entries in the cache-table (thats done for reser the valid bit in the table)
b. Write 0 to this registen (cache-count = 0)",
    Width => "13", # Excel Formula: =calc_reg_width(E19:E19,F19)
    Type => "External",
    UsedBy => "res",
    DocName => "Slice[2]PortDspLbConsistenceCacheCount",
    ArrayLength => "4",
    ArrayIndex => "0",
    slice0_stage0_lb_Consistence_cache_count_r => { #Structure Type: RegField; ArrayLength: 4; ArrayIndex: 0; ArrayLocationInName: 13;
      Name => "slice0_stage[n]_lb_Consistence_cache_count_r",
      RegMem => "RegField",
      Description => "counts number of elements currently in cache. Can be zeroize by CPU after empting the consistency-table by the CPU.",
      Width => "13", # Excel Formula: =calc_field_width_define("RES_REDUCED_LB_KEY_WIDTH")+1
      Position => "12:0", # Excel Formula: =calc_position(F18,E19,TRUE)
      Type => "External",
      DocName => "Slice[n]PortDspLbConsistenceCacheCountR",
      Comments => "counts number of valid members currently in cache",
    },
  },
  slice0_stage1_lb_Consistence_cache_count => { #Structure Type: Reg; ArrayLength: 4; ArrayIndex: 1; ArrayLocationInName: 13;
    Name => "slice0_stage[4]_lb_Consistence_cache_count",
    RegMem => "Reg",
    Address => "109",
    Description => "Number of elements currently in cache. When cache is active, this register is managed by the Design. Because each cahce is read only when packet arrives with the corresponding LB-Key, it is posibble that before changing another group-size, the cache-count will not be 0. for this reason:
Before changing Group-size of another gourp-id, If (cache-counter =! 0) then the User should do the following:
a. Write 0 to all entries in the cache-table (thats done for reser the valid bit in the table)
b. Write 0 to this registen (cache-count = 0)",
    Width => "13", # Excel Formula: =calc_reg_width(E19:E19,F19)
    Type => "External",
    UsedBy => "res",
    DocName => "Slice[2]PortDspLbConsistenceCacheCount",
    ArrayLength => "4",
    ArrayIndex => "1",
    slice0_stage1_lb_Consistence_cache_count_r => { #Structure Type: RegField; ArrayLength: 4; ArrayIndex: 1; ArrayLocationInName: 13;
      Name => "slice0_stage[n]_lb_Consistence_cache_count_r",
      RegMem => "RegField",
      Description => "counts number of elements currently in cache. Can be zeroize by CPU after empting the consistency-table by the CPU.",
      Width => "13", # Excel Formula: =calc_field_width_define("RES_REDUCED_LB_KEY_WIDTH")+1
      Position => "12:0", # Excel Formula: =calc_position(F18,E19,TRUE)
      Type => "External",
      DocName => "Slice[n]PortDspLbConsistenceCacheCountR",
      Comments => "counts number of valid members currently in cache",
    },
  },
  slice0_stage2_lb_Consistence_cache_count => { #Structure Type: Reg; ArrayLength: 4; ArrayIndex: 2; ArrayLocationInName: 13;
    Name => "slice0_stage[4]_lb_Consistence_cache_count",
    RegMem => "Reg",
    Address => "10A",
    Description => "Number of elements currently in cache. When cache is active, this register is managed by the Design. Because each cahce is read only when packet arrives with the corresponding LB-Key, it is posibble that before changing another group-size, the cache-count will not be 0. for this reason:
Before changing Group-size of another gourp-id, If (cache-counter =! 0) then the User should do the following:
a. Write 0 to all entries in the cache-table (thats done for reser the valid bit in the table)
b. Write 0 to this registen (cache-count = 0)",
    Width => "13", # Excel Formula: =calc_reg_width(E19:E19,F19)
    Type => "External",
    UsedBy => "res",
    DocName => "Slice[2]PortDspLbConsistenceCacheCount",
    ArrayLength => "4",
    ArrayIndex => "2",
    slice0_stage2_lb_Consistence_cache_count_r => { #Structure Type: RegField; ArrayLength: 4; ArrayIndex: 2; ArrayLocationInName: 13;
      Name => "slice0_stage[n]_lb_Consistence_cache_count_r",
      RegMem => "RegField",
      Description => "counts number of elements currently in cache. Can be zeroize by CPU after empting the consistency-table by the CPU.",
      Width => "13", # Excel Formula: =calc_field_width_define("RES_REDUCED_LB_KEY_WIDTH")+1
      Position => "12:0", # Excel Formula: =calc_position(F18,E19,TRUE)
      Type => "External",
      DocName => "Slice[n]PortDspLbConsistenceCacheCountR",
      Comments => "counts number of valid members currently in cache",
    },
  },
  slice0_stage3_lb_Consistence_cache_count => { #Structure Type: Reg; ArrayLength: 4; ArrayIndex: 3; ArrayLocationInName: 13;
    Name => "slice0_stage[4]_lb_Consistence_cache_count",
    RegMem => "Reg",
    Address => "10B",
    Description => "Number of elements currently in cache. When cache is active, this register is managed by the Design. Because each cahce is read only when packet arrives with the corresponding LB-Key, it is posibble that before changing another group-size, the cache-count will not be 0. for this reason:
Before changing Group-size of another gourp-id, If (cache-counter =! 0) then the User should do the following:
a. Write 0 to all entries in the cache-table (thats done for reser the valid bit in the table)
b. Write 0 to this registen (cache-count = 0)",
    Width => "13", # Excel Formula: =calc_reg_width(E19:E19,F19)
    Type => "External",
    UsedBy => "res",
    DocName => "Slice[2]PortDspLbConsistenceCacheCount",
    ArrayLength => "4",
    ArrayIndex => "3",
    slice0_stage3_lb_Consistence_cache_count_r => { #Structure Type: RegField; ArrayLength: 4; ArrayIndex: 3; ArrayLocationInName: 13;
      Name => "slice0_stage[n]_lb_Consistence_cache_count_r",
      RegMem => "RegField",
      Description => "counts number of elements currently in cache. Can be zeroize by CPU after empting the consistency-table by the CPU.",
      Width => "13", # Excel Formula: =calc_field_width_define("RES_REDUCED_LB_KEY_WIDTH")+1
      Position => "12:0", # Excel Formula: =calc_position(F18,E19,TRUE)
      Type => "External",
      DocName => "Slice[n]PortDspLbConsistenceCacheCountR",
      Comments => "counts number of valid members currently in cache",
    },
  },
  LpQueuingDestinationMask => { #Structure Type: Reg;
    Name => "LpQueuingDestinationMask",
    RegMem => "Reg",
    Address => "10C", # Excel Formula: =calc_reg_address(C18,A18,G18)
    Description => "LP Queuing Destination Mask",
    Width => "20", # Excel Formula: =calc_reg_width(E21:E21,F21)
    Type => "Config",
    DestinationMask => { #Structure Type: RegField;
      Name => "DestinationMask",
      RegMem => "RegField",
      Description => "The value that would be used to mask the calculated BVN when putting it on the destination",
      Width => "20",
      Position => "19:0", # Excel Formula: =calc_position(F20,E21,TRUE)
      Type => "Config",
      UsedBy => "res",
      DefaultValue => "h0",
      Comments => "counts number of valid members currently in cache",
      InitValueAllModes => "0",
    },
  },
  ResolutionInterrupts0 => { #Structure Type: Reg; ArrayLength: 2; ArrayIndex: 0; ArrayLocationInName: 21;
    Name => "ResolutionInterrupts[2]",
    RegMem => "Reg",
    Address => "10D", # Excel Formula: =calc_reg_address(C20,A20,G20)
    Width => "11", # Excel Formula: =calc_reg_width(E23:E33,F33)
    Type => "Interrupt",
    ArrayLength => "2",
    ArrayIndex => "0",
    Slice0LpQueuingEmMissInterrupt => { #Structure Type: RegField; ArrayLength: 2; ArrayIndex: 0; ArrayLocationInName: 6;
      Name => "Slice[n]LpQueuingEmMissInterrupt",
      RegMem => "RegField",
      Description => "Interrupt that would be set once a LU would get a miss in the LP queuing exact match, a missconfiguration that should be handled by the host CPU.",
      Width => "1",
      Position => "0", # Excel Formula: =calc_position(F22,E23,TRUE)
      Type => "Interrupt",
      UsedBy => "res",
      Comments => "counts number of valid members currently in cache",
    },
    Slice0Stage0EmMissInterrupt => { #Structure Type: RegField; ArrayLength: 2; ArrayIndex: 0; ArrayLocationInName: 6;
      Name => "Slice[n]Stage0EmMissInterrupt",
      RegMem => "RegField",
      Description => "Interrupt that would be set once a LU would get a miss in the Stage 0 exact match, a missconfiguration that should be handled by the host CPU.",
      Width => "1",
      Position => "1", # Excel Formula: =calc_position(F23,E24)
      Type => "Interrupt",
      UsedBy => "res",
      Comments => "counts number of valid members currently in cache",
    },
    Slice0Stage1EmMissInterrupt => { #Structure Type: RegField; ArrayLength: 2; ArrayIndex: 0; ArrayLocationInName: 6;
      Name => "Slice[n]Stage1EmMissInterrupt",
      RegMem => "RegField",
      Description => "Interrupt that would be set once a LU getts a miss in the Stage 1 exact match, a missconfiguration that should be handled by the host CPU.",
      Width => "1",
      Position => "2", # Excel Formula: =calc_position(F24,E25)
      Type => "Interrupt",
      UsedBy => "res",
      Comments => "counts number of valid members currently in cache",
    },
    Slice0Stage2EmMissInterrupt => { #Structure Type: RegField; ArrayLength: 2; ArrayIndex: 0; ArrayLocationInName: 6;
      Name => "Slice[n]Stage2EmMissInterrupt",
      RegMem => "RegField",
      Description => "Interrupt that would be set once a LU would get a miss in the Stage 2 exact match, a missconfiguration that should be handled by the host CPU.",
      Width => "1",
      Position => "3", # Excel Formula: =calc_position(F25,E26)
      Type => "Interrupt",
      UsedBy => "res",
      Comments => "counts number of valid members currently in cache",
    },
    Slice0Stage3EmMissInterrupt => { #Structure Type: RegField; ArrayLength: 2; ArrayIndex: 0; ArrayLocationInName: 6;
      Name => "Slice[n]Stage3EmMissInterrupt",
      RegMem => "RegField",
      Description => "Interrupt that would be set once a LU would get a miss in the Stage 3 exact match, a missconfiguration that should be handled by the host CPU.",
      Width => "1",
      Position => "4", # Excel Formula: =calc_position(F26,E27)
      Type => "Interrupt",
      UsedBy => "res",
      Comments => "counts number of valid members currently in cache",
    },
    Slice0LpQueuingPrevCorePushToFullInterrupt => { #Structure Type: RegField; ArrayLength: 2; ArrayIndex: 0; ArrayLocationInName: 6;
      Name => "Slice[n]LpQueuingPrevCorePushToFullInterrupt",
      RegMem => "RegField",
      Width => "1",
      Position => "5", # Excel Formula: =calc_position(F27,E28)
      Type => "Interrupt",
      UsedBy => "res",
      Comments => "counts number of valid members currently in cache",
    },
    Slice0Stage0PrevCorePushToFullInterrupt => { #Structure Type: RegField; ArrayLength: 2; ArrayIndex: 0; ArrayLocationInName: 6;
      Name => "Slice[n]Stage0PrevCorePushToFullInterrupt",
      RegMem => "RegField",
      Width => "1",
      Position => "6", # Excel Formula: =calc_position(F28,E29)
      Type => "Interrupt",
      UsedBy => "res",
      Comments => "counts number of valid members currently in cache",
    },
    Slice0Stage1PrevCorePushToFullInterrupt => { #Structure Type: RegField; ArrayLength: 2; ArrayIndex: 0; ArrayLocationInName: 6;
      Name => "Slice[n]Stage1PrevCorePushToFullInterrupt",
      RegMem => "RegField",
      Width => "1",
      Position => "7", # Excel Formula: =calc_position(F29,E30)
      Type => "Interrupt",
      UsedBy => "res",
      Comments => "counts number of valid members currently in cache",
    },
    Slice0Stage2PrevCorePushToFullInterrupt => { #Structure Type: RegField; ArrayLength: 2; ArrayIndex: 0; ArrayLocationInName: 6;
      Name => "Slice[n]Stage2PrevCorePushToFullInterrupt",
      RegMem => "RegField",
      Width => "1",
      Position => "8", # Excel Formula: =calc_position(F30,E31)
      Type => "Interrupt",
      UsedBy => "res",
      Comments => "counts number of valid members currently in cache",
    },
    Slice0Stage3PrevCorePushToFullInterrupt => { #Structure Type: RegField; ArrayLength: 2; ArrayIndex: 0; ArrayLocationInName: 6;
      Name => "Slice[n]Stage3PrevCorePushToFullInterrupt",
      RegMem => "RegField",
      Width => "1",
      Position => "9", # Excel Formula: =calc_position(F31,E32)
      Type => "Interrupt",
      UsedBy => "res",
      Comments => "counts number of valid members currently in cache",
    },
    Slice0ResolutionTtl => { #Structure Type: RegField; ArrayLength: 2; ArrayIndex: 0; ArrayLocationInName: 6;
      Name => "Slice[n]ResolutionTtl",
      RegMem => "RegField",
      Description => "Interrupt indicating that the max TTL (max amount of stages executed) inside the resolution has been reached.",
      Width => "1",
      Position => "10", # Excel Formula: =calc_position(F32,E33)
      Type => "Interrupt",
      UsedBy => "res",
    },
  },
  ResolutionInterrupts1 => { #Structure Type: Reg; ArrayLength: 2; ArrayIndex: 1; ArrayLocationInName: 21;
    Name => "ResolutionInterrupts[2]",
    RegMem => "Reg",
    Address => "10E",
    Width => "11", # Excel Formula: =calc_reg_width(E23:E33,F33)
    Type => "Interrupt",
    ArrayLength => "2",
    ArrayIndex => "1",
    Slice1LpQueuingEmMissInterrupt => { #Structure Type: RegField; ArrayLength: 2; ArrayIndex: 1; ArrayLocationInName: 6;
      Name => "Slice[n]LpQueuingEmMissInterrupt",
      RegMem => "RegField",
      Description => "Interrupt that would be set once a LU would get a miss in the LP queuing exact match, a missconfiguration that should be handled by the host CPU.",
      Width => "1",
      Position => "0", # Excel Formula: =calc_position(F22,E23,TRUE)
      Type => "Interrupt",
      UsedBy => "res",
      Comments => "counts number of valid members currently in cache",
    },
    Slice1Stage0EmMissInterrupt => { #Structure Type: RegField; ArrayLength: 2; ArrayIndex: 1; ArrayLocationInName: 6;
      Name => "Slice[n]Stage0EmMissInterrupt",
      RegMem => "RegField",
      Description => "Interrupt that would be set once a LU would get a miss in the Stage 0 exact match, a missconfiguration that should be handled by the host CPU.",
      Width => "1",
      Position => "1", # Excel Formula: =calc_position(F23,E24)
      Type => "Interrupt",
      UsedBy => "res",
      Comments => "counts number of valid members currently in cache",
    },
    Slice1Stage1EmMissInterrupt => { #Structure Type: RegField; ArrayLength: 2; ArrayIndex: 1; ArrayLocationInName: 6;
      Name => "Slice[n]Stage1EmMissInterrupt",
      RegMem => "RegField",
      Description => "Interrupt that would be set once a LU getts a miss in the Stage 1 exact match, a missconfiguration that should be handled by the host CPU.",
      Width => "1",
      Position => "2", # Excel Formula: =calc_position(F24,E25)
      Type => "Interrupt",
      UsedBy => "res",
      Comments => "counts number of valid members currently in cache",
    },
    Slice1Stage2EmMissInterrupt => { #Structure Type: RegField; ArrayLength: 2; ArrayIndex: 1; ArrayLocationInName: 6;
      Name => "Slice[n]Stage2EmMissInterrupt",
      RegMem => "RegField",
      Description => "Interrupt that would be set once a LU would get a miss in the Stage 2 exact match, a missconfiguration that should be handled by the host CPU.",
      Width => "1",
      Position => "3", # Excel Formula: =calc_position(F25,E26)
      Type => "Interrupt",
      UsedBy => "res",
      Comments => "counts number of valid members currently in cache",
    },
    Slice1Stage3EmMissInterrupt => { #Structure Type: RegField; ArrayLength: 2; ArrayIndex: 1; ArrayLocationInName: 6;
      Name => "Slice[n]Stage3EmMissInterrupt",
      RegMem => "RegField",
      Description => "Interrupt that would be set once a LU would get a miss in the Stage 3 exact match, a missconfiguration that should be handled by the host CPU.",
      Width => "1",
      Position => "4", # Excel Formula: =calc_position(F26,E27)
      Type => "Interrupt",
      UsedBy => "res",
      Comments => "counts number of valid members currently in cache",
    },
    Slice1LpQueuingPrevCorePushToFullInterrupt => { #Structure Type: RegField; ArrayLength: 2; ArrayIndex: 1; ArrayLocationInName: 6;
      Name => "Slice[n]LpQueuingPrevCorePushToFullInterrupt",
      RegMem => "RegField",
      Width => "1",
      Position => "5", # Excel Formula: =calc_position(F27,E28)
      Type => "Interrupt",
      UsedBy => "res",
      Comments => "counts number of valid members currently in cache",
    },
    Slice1Stage0PrevCorePushToFullInterrupt => { #Structure Type: RegField; ArrayLength: 2; ArrayIndex: 1; ArrayLocationInName: 6;
      Name => "Slice[n]Stage0PrevCorePushToFullInterrupt",
      RegMem => "RegField",
      Width => "1",
      Position => "6", # Excel Formula: =calc_position(F28,E29)
      Type => "Interrupt",
      UsedBy => "res",
      Comments => "counts number of valid members currently in cache",
    },
    Slice1Stage1PrevCorePushToFullInterrupt => { #Structure Type: RegField; ArrayLength: 2; ArrayIndex: 1; ArrayLocationInName: 6;
      Name => "Slice[n]Stage1PrevCorePushToFullInterrupt",
      RegMem => "RegField",
      Width => "1",
      Position => "7", # Excel Formula: =calc_position(F29,E30)
      Type => "Interrupt",
      UsedBy => "res",
      Comments => "counts number of valid members currently in cache",
    },
    Slice1Stage2PrevCorePushToFullInterrupt => { #Structure Type: RegField; ArrayLength: 2; ArrayIndex: 1; ArrayLocationInName: 6;
      Name => "Slice[n]Stage2PrevCorePushToFullInterrupt",
      RegMem => "RegField",
      Width => "1",
      Position => "8", # Excel Formula: =calc_position(F30,E31)
      Type => "Interrupt",
      UsedBy => "res",
      Comments => "counts number of valid members currently in cache",
    },
    Slice1Stage3PrevCorePushToFullInterrupt => { #Structure Type: RegField; ArrayLength: 2; ArrayIndex: 1; ArrayLocationInName: 6;
      Name => "Slice[n]Stage3PrevCorePushToFullInterrupt",
      RegMem => "RegField",
      Width => "1",
      Position => "9", # Excel Formula: =calc_position(F31,E32)
      Type => "Interrupt",
      UsedBy => "res",
      Comments => "counts number of valid members currently in cache",
    },
    Slice1ResolutionTtl => { #Structure Type: RegField; ArrayLength: 2; ArrayIndex: 1; ArrayLocationInName: 6;
      Name => "Slice[n]ResolutionTtl",
      RegMem => "RegField",
      Description => "Interrupt indicating that the max TTL (max amount of stages executed) inside the resolution has been reached.",
      Width => "1",
      Position => "10", # Excel Formula: =calc_position(F32,E33)
      Type => "Interrupt",
      UsedBy => "res",
    },
  },
  ResolutionInterrupts0Mask => { #Structure Type: Reg; ArrayLength: 2; ArrayIndex: 0; ArrayLocationInName: 21; Skip Register;
    Name => "ResolutionInterrupts[2]Mask",
    RegMem => "Reg",
    Address => "10F",
    Width => "11", # Excel Formula: =calc_reg_width(E23:E33,F33)
    Type => "InterruptMask",
    ArrayLength => "2",
    ArrayIndex => "0",
    Slice0LpQueuingEmMissInterruptMask => { #Structure Type: RegField; ArrayLength: 2; ArrayIndex: 0; ArrayLocationInName: 6;
      Name => "Slice[n]LpQueuingEmMissInterruptMask",
      RegMem => "RegField",
      Description => "This field masks Slice[n]LpQueuingEmMissInterrupt interrupt",
      Width => "1",
      Position => "0", # Excel Formula: =calc_position(F22,E23,TRUE)
      Type => "InterruptMask",
      UsedBy => "",
      DefaultValue => "b1",
      Comments => "counts number of valid members currently in cache",
    },
    Slice0Stage0EmMissInterruptMask => { #Structure Type: RegField; ArrayLength: 2; ArrayIndex: 0; ArrayLocationInName: 6;
      Name => "Slice[n]Stage0EmMissInterruptMask",
      RegMem => "RegField",
      Description => "This field masks Slice[n]Stage0EmMissInterrupt interrupt",
      Width => "1",
      Position => "1", # Excel Formula: =calc_position(F23,E24)
      Type => "InterruptMask",
      UsedBy => "",
      DefaultValue => "b1",
      Comments => "counts number of valid members currently in cache",
    },
    Slice0Stage1EmMissInterruptMask => { #Structure Type: RegField; ArrayLength: 2; ArrayIndex: 0; ArrayLocationInName: 6;
      Name => "Slice[n]Stage1EmMissInterruptMask",
      RegMem => "RegField",
      Description => "This field masks Slice[n]Stage1EmMissInterrupt interrupt",
      Width => "1",
      Position => "2", # Excel Formula: =calc_position(F24,E25)
      Type => "InterruptMask",
      UsedBy => "",
      DefaultValue => "b1",
      Comments => "counts number of valid members currently in cache",
    },
    Slice0Stage2EmMissInterruptMask => { #Structure Type: RegField; ArrayLength: 2; ArrayIndex: 0; ArrayLocationInName: 6;
      Name => "Slice[n]Stage2EmMissInterruptMask",
      RegMem => "RegField",
      Description => "This field masks Slice[n]Stage2EmMissInterrupt interrupt",
      Width => "1",
      Position => "3", # Excel Formula: =calc_position(F25,E26)
      Type => "InterruptMask",
      UsedBy => "",
      DefaultValue => "b1",
      Comments => "counts number of valid members currently in cache",
    },
    Slice0Stage3EmMissInterruptMask => { #Structure Type: RegField; ArrayLength: 2; ArrayIndex: 0; ArrayLocationInName: 6;
      Name => "Slice[n]Stage3EmMissInterruptMask",
      RegMem => "RegField",
      Description => "This field masks Slice[n]Stage3EmMissInterrupt interrupt",
      Width => "1",
      Position => "4", # Excel Formula: =calc_position(F26,E27)
      Type => "InterruptMask",
      UsedBy => "",
      DefaultValue => "b1",
      Comments => "counts number of valid members currently in cache",
    },
    Slice0LpQueuingPrevCorePushToFullInterruptMask => { #Structure Type: RegField; ArrayLength: 2; ArrayIndex: 0; ArrayLocationInName: 6;
      Name => "Slice[n]LpQueuingPrevCorePushToFullInterruptMask",
      RegMem => "RegField",
      Width => "1",
      Position => "5", # Excel Formula: =calc_position(F27,E28)
      Type => "InterruptMask",
      UsedBy => "",
      DefaultValue => "b1",
      Comments => "counts number of valid members currently in cache",
    },
    Slice0Stage0PrevCorePushToFullInterruptMask => { #Structure Type: RegField; ArrayLength: 2; ArrayIndex: 0; ArrayLocationInName: 6;
      Name => "Slice[n]Stage0PrevCorePushToFullInterruptMask",
      RegMem => "RegField",
      Width => "1",
      Position => "6", # Excel Formula: =calc_position(F28,E29)
      Type => "InterruptMask",
      UsedBy => "",
      DefaultValue => "b1",
      Comments => "counts number of valid members currently in cache",
    },
    Slice0Stage1PrevCorePushToFullInterruptMask => { #Structure Type: RegField; ArrayLength: 2; ArrayIndex: 0; ArrayLocationInName: 6;
      Name => "Slice[n]Stage1PrevCorePushToFullInterruptMask",
      RegMem => "RegField",
      Width => "1",
      Position => "7", # Excel Formula: =calc_position(F29,E30)
      Type => "InterruptMask",
      UsedBy => "",
      DefaultValue => "b1",
      Comments => "counts number of valid members currently in cache",
    },
    Slice0Stage2PrevCorePushToFullInterruptMask => { #Structure Type: RegField; ArrayLength: 2; ArrayIndex: 0; ArrayLocationInName: 6;
      Name => "Slice[n]Stage2PrevCorePushToFullInterruptMask",
      RegMem => "RegField",
      Width => "1",
      Position => "8", # Excel Formula: =calc_position(F30,E31)
      Type => "InterruptMask",
      UsedBy => "",
      DefaultValue => "b1",
      Comments => "counts number of valid members currently in cache",
    },
    Slice0Stage3PrevCorePushToFullInterruptMask => { #Structure Type: RegField; ArrayLength: 2; ArrayIndex: 0; ArrayLocationInName: 6;
      Name => "Slice[n]Stage3PrevCorePushToFullInterruptMask",
      RegMem => "RegField",
      Width => "1",
      Position => "9", # Excel Formula: =calc_position(F31,E32)
      Type => "InterruptMask",
      UsedBy => "",
      DefaultValue => "b1",
      Comments => "counts number of valid members currently in cache",
    },
    Slice0ResolutionTtlMask => { #Structure Type: RegField; ArrayLength: 2; ArrayIndex: 0; ArrayLocationInName: 6;
      Name => "Slice[n]ResolutionTtlMask",
      RegMem => "RegField",
      Description => "This field masks Slice[n]ResolutionTtl interrupt",
      Width => "1",
      Position => "10", # Excel Formula: =calc_position(F32,E33)
      Type => "InterruptMask",
      UsedBy => "",
      DefaultValue => "b1",
    },
  },
  ResolutionInterrupts1Mask => { #Structure Type: Reg; ArrayLength: 2; ArrayIndex: 1; ArrayLocationInName: 21; Skip Register;
    Name => "ResolutionInterrupts[2]Mask",
    RegMem => "Reg",
    Address => "110",
    Width => "11", # Excel Formula: =calc_reg_width(E23:E33,F33)
    Type => "InterruptMask",
    ArrayLength => "2",
    ArrayIndex => "1",
    Slice1LpQueuingEmMissInterruptMask => { #Structure Type: RegField; ArrayLength: 2; ArrayIndex: 1; ArrayLocationInName: 6;
      Name => "Slice[n]LpQueuingEmMissInterruptMask",
      RegMem => "RegField",
      Description => "This field masks Slice[n]LpQueuingEmMissInterrupt interrupt",
      Width => "1",
      Position => "0", # Excel Formula: =calc_position(F22,E23,TRUE)
      Type => "InterruptMask",
      UsedBy => "",
      DefaultValue => "b1",
      Comments => "counts number of valid members currently in cache",
    },
    Slice1Stage0EmMissInterruptMask => { #Structure Type: RegField; ArrayLength: 2; ArrayIndex: 1; ArrayLocationInName: 6;
      Name => "Slice[n]Stage0EmMissInterruptMask",
      RegMem => "RegField",
      Description => "This field masks Slice[n]Stage0EmMissInterrupt interrupt",
      Width => "1",
      Position => "1", # Excel Formula: =calc_position(F23,E24)
      Type => "InterruptMask",
      UsedBy => "",
      DefaultValue => "b1",
      Comments => "counts number of valid members currently in cache",
    },
    Slice1Stage1EmMissInterruptMask => { #Structure Type: RegField; ArrayLength: 2; ArrayIndex: 1; ArrayLocationInName: 6;
      Name => "Slice[n]Stage1EmMissInterruptMask",
      RegMem => "RegField",
      Description => "This field masks Slice[n]Stage1EmMissInterrupt interrupt",
      Width => "1",
      Position => "2", # Excel Formula: =calc_position(F24,E25)
      Type => "InterruptMask",
      UsedBy => "",
      DefaultValue => "b1",
      Comments => "counts number of valid members currently in cache",
    },
    Slice1Stage2EmMissInterruptMask => { #Structure Type: RegField; ArrayLength: 2; ArrayIndex: 1; ArrayLocationInName: 6;
      Name => "Slice[n]Stage2EmMissInterruptMask",
      RegMem => "RegField",
      Description => "This field masks Slice[n]Stage2EmMissInterrupt interrupt",
      Width => "1",
      Position => "3", # Excel Formula: =calc_position(F25,E26)
      Type => "InterruptMask",
      UsedBy => "",
      DefaultValue => "b1",
      Comments => "counts number of valid members currently in cache",
    },
    Slice1Stage3EmMissInterruptMask => { #Structure Type: RegField; ArrayLength: 2; ArrayIndex: 1; ArrayLocationInName: 6;
      Name => "Slice[n]Stage3EmMissInterruptMask",
      RegMem => "RegField",
      Description => "This field masks Slice[n]Stage3EmMissInterrupt interrupt",
      Width => "1",
      Position => "4", # Excel Formula: =calc_position(F26,E27)
      Type => "InterruptMask",
      UsedBy => "",
      DefaultValue => "b1",
      Comments => "counts number of valid members currently in cache",
    },
    Slice1LpQueuingPrevCorePushToFullInterruptMask => { #Structure Type: RegField; ArrayLength: 2; ArrayIndex: 1; ArrayLocationInName: 6;
      Name => "Slice[n]LpQueuingPrevCorePushToFullInterruptMask",
      RegMem => "RegField",
      Width => "1",
      Position => "5", # Excel Formula: =calc_position(F27,E28)
      Type => "InterruptMask",
      UsedBy => "",
      DefaultValue => "b1",
      Comments => "counts number of valid members currently in cache",
    },
    Slice1Stage0PrevCorePushToFullInterruptMask => { #Structure Type: RegField; ArrayLength: 2; ArrayIndex: 1; ArrayLocationInName: 6;
      Name => "Slice[n]Stage0PrevCorePushToFullInterruptMask",
      RegMem => "RegField",
      Width => "1",
      Position => "6", # Excel Formula: =calc_position(F28,E29)
      Type => "InterruptMask",
      UsedBy => "",
      DefaultValue => "b1",
      Comments => "counts number of valid members currently in cache",
    },
    Slice1Stage1PrevCorePushToFullInterruptMask => { #Structure Type: RegField; ArrayLength: 2; ArrayIndex: 1; ArrayLocationInName: 6;
      Name => "Slice[n]Stage1PrevCorePushToFullInterruptMask",
      RegMem => "RegField",
      Width => "1",
      Position => "7", # Excel Formula: =calc_position(F29,E30)
      Type => "InterruptMask",
      UsedBy => "",
      DefaultValue => "b1",
      Comments => "counts number of valid members currently in cache",
    },
    Slice1Stage2PrevCorePushToFullInterruptMask => { #Structure Type: RegField; ArrayLength: 2; ArrayIndex: 1; ArrayLocationInName: 6;
      Name => "Slice[n]Stage2PrevCorePushToFullInterruptMask",
      RegMem => "RegField",
      Width => "1",
      Position => "8", # Excel Formula: =calc_position(F30,E31)
      Type => "InterruptMask",
      UsedBy => "",
      DefaultValue => "b1",
      Comments => "counts number of valid members currently in cache",
    },
    Slice1Stage3PrevCorePushToFullInterruptMask => { #Structure Type: RegField; ArrayLength: 2; ArrayIndex: 1; ArrayLocationInName: 6;
      Name => "Slice[n]Stage3PrevCorePushToFullInterruptMask",
      RegMem => "RegField",
      Width => "1",
      Position => "9", # Excel Formula: =calc_position(F31,E32)
      Type => "InterruptMask",
      UsedBy => "",
      DefaultValue => "b1",
      Comments => "counts number of valid members currently in cache",
    },
    Slice1ResolutionTtlMask => { #Structure Type: RegField; ArrayLength: 2; ArrayIndex: 1; ArrayLocationInName: 6;
      Name => "Slice[n]ResolutionTtlMask",
      RegMem => "RegField",
      Description => "This field masks Slice[n]ResolutionTtl interrupt",
      Width => "1",
      Position => "10", # Excel Formula: =calc_position(F32,E33)
      Type => "InterruptMask",
      UsedBy => "",
      DefaultValue => "b1",
    },
  },
  ResolutionInterrupts0Test => { #Structure Type: Reg; ArrayLength: 2; ArrayIndex: 0; ArrayLocationInName: 21; Skip Register;
    Name => "ResolutionInterrupts[2]Test",
    RegMem => "Reg",
    Address => "111",
    Width => "11", # Excel Formula: =calc_reg_width(E23:E33,F33)
    Type => "InterruptTest",
    ArrayLength => "2",
    ArrayIndex => "0",
    Slice0LpQueuingEmMissInterruptTest => { #Structure Type: RegField; ArrayLength: 2; ArrayIndex: 0; ArrayLocationInName: 6;
      Name => "Slice[n]LpQueuingEmMissInterruptTest",
      RegMem => "RegField",
      Description => "This field tests Slice[n]LpQueuingEmMissInterrupt interrupt",
      Width => "1",
      Position => "0", # Excel Formula: =calc_position(F22,E23,TRUE)
      Type => "InterruptTest",
      UsedBy => "",
      DefaultValue => "b0",
      Comments => "counts number of valid members currently in cache",
    },
    Slice0Stage0EmMissInterruptTest => { #Structure Type: RegField; ArrayLength: 2; ArrayIndex: 0; ArrayLocationInName: 6;
      Name => "Slice[n]Stage0EmMissInterruptTest",
      RegMem => "RegField",
      Description => "This field tests Slice[n]Stage0EmMissInterrupt interrupt",
      Width => "1",
      Position => "1", # Excel Formula: =calc_position(F23,E24)
      Type => "InterruptTest",
      UsedBy => "",
      DefaultValue => "b0",
      Comments => "counts number of valid members currently in cache",
    },
    Slice0Stage1EmMissInterruptTest => { #Structure Type: RegField; ArrayLength: 2; ArrayIndex: 0; ArrayLocationInName: 6;
      Name => "Slice[n]Stage1EmMissInterruptTest",
      RegMem => "RegField",
      Description => "This field tests Slice[n]Stage1EmMissInterrupt interrupt",
      Width => "1",
      Position => "2", # Excel Formula: =calc_position(F24,E25)
      Type => "InterruptTest",
      UsedBy => "",
      DefaultValue => "b0",
      Comments => "counts number of valid members currently in cache",
    },
    Slice0Stage2EmMissInterruptTest => { #Structure Type: RegField; ArrayLength: 2; ArrayIndex: 0; ArrayLocationInName: 6;
      Name => "Slice[n]Stage2EmMissInterruptTest",
      RegMem => "RegField",
      Description => "This field tests Slice[n]Stage2EmMissInterrupt interrupt",
      Width => "1",
      Position => "3", # Excel Formula: =calc_position(F25,E26)
      Type => "InterruptTest",
      UsedBy => "",
      DefaultValue => "b0",
      Comments => "counts number of valid members currently in cache",
    },
    Slice0Stage3EmMissInterruptTest => { #Structure Type: RegField; ArrayLength: 2; ArrayIndex: 0; ArrayLocationInName: 6;
      Name => "Slice[n]Stage3EmMissInterruptTest",
      RegMem => "RegField",
      Description => "This field tests Slice[n]Stage3EmMissInterrupt interrupt",
      Width => "1",
      Position => "4", # Excel Formula: =calc_position(F26,E27)
      Type => "InterruptTest",
      UsedBy => "",
      DefaultValue => "b0",
      Comments => "counts number of valid members currently in cache",
    },
    Slice0LpQueuingPrevCorePushToFullInterruptTest => { #Structure Type: RegField; ArrayLength: 2; ArrayIndex: 0; ArrayLocationInName: 6;
      Name => "Slice[n]LpQueuingPrevCorePushToFullInterruptTest",
      RegMem => "RegField",
      Width => "1",
      Position => "5", # Excel Formula: =calc_position(F27,E28)
      Type => "InterruptTest",
      UsedBy => "",
      DefaultValue => "b0",
      Comments => "counts number of valid members currently in cache",
    },
    Slice0Stage0PrevCorePushToFullInterruptTest => { #Structure Type: RegField; ArrayLength: 2; ArrayIndex: 0; ArrayLocationInName: 6;
      Name => "Slice[n]Stage0PrevCorePushToFullInterruptTest",
      RegMem => "RegField",
      Width => "1",
      Position => "6", # Excel Formula: =calc_position(F28,E29)
      Type => "InterruptTest",
      UsedBy => "",
      DefaultValue => "b0",
      Comments => "counts number of valid members currently in cache",
    },
    Slice0Stage1PrevCorePushToFullInterruptTest => { #Structure Type: RegField; ArrayLength: 2; ArrayIndex: 0; ArrayLocationInName: 6;
      Name => "Slice[n]Stage1PrevCorePushToFullInterruptTest",
      RegMem => "RegField",
      Width => "1",
      Position => "7", # Excel Formula: =calc_position(F29,E30)
      Type => "InterruptTest",
      UsedBy => "",
      DefaultValue => "b0",
      Comments => "counts number of valid members currently in cache",
    },
    Slice0Stage2PrevCorePushToFullInterruptTest => { #Structure Type: RegField; ArrayLength: 2; ArrayIndex: 0; ArrayLocationInName: 6;
      Name => "Slice[n]Stage2PrevCorePushToFullInterruptTest",
      RegMem => "RegField",
      Width => "1",
      Position => "8", # Excel Formula: =calc_position(F30,E31)
      Type => "InterruptTest",
      UsedBy => "",
      DefaultValue => "b0",
      Comments => "counts number of valid members currently in cache",
    },
    Slice0Stage3PrevCorePushToFullInterruptTest => { #Structure Type: RegField; ArrayLength: 2; ArrayIndex: 0; ArrayLocationInName: 6;
      Name => "Slice[n]Stage3PrevCorePushToFullInterruptTest",
      RegMem => "RegField",
      Width => "1",
      Position => "9", # Excel Formula: =calc_position(F31,E32)
      Type => "InterruptTest",
      UsedBy => "",
      DefaultValue => "b0",
      Comments => "counts number of valid members currently in cache",
    },
    Slice0ResolutionTtlTest => { #Structure Type: RegField; ArrayLength: 2; ArrayIndex: 0; ArrayLocationInName: 6;
      Name => "Slice[n]ResolutionTtlTest",
      RegMem => "RegField",
      Description => "This field tests Slice[n]ResolutionTtl interrupt",
      Width => "1",
      Position => "10", # Excel Formula: =calc_position(F32,E33)
      Type => "InterruptTest",
      UsedBy => "",
      DefaultValue => "b0",
    },
  },
  ResolutionInterrupts1Test => { #Structure Type: Reg; ArrayLength: 2; ArrayIndex: 1; ArrayLocationInName: 21; Skip Register;
    Name => "ResolutionInterrupts[2]Test",
    RegMem => "Reg",
    Address => "112",
    Width => "11", # Excel Formula: =calc_reg_width(E23:E33,F33)
    Type => "InterruptTest",
    ArrayLength => "2",
    ArrayIndex => "1",
    Slice1LpQueuingEmMissInterruptTest => { #Structure Type: RegField; ArrayLength: 2; ArrayIndex: 1; ArrayLocationInName: 6;
      Name => "Slice[n]LpQueuingEmMissInterruptTest",
      RegMem => "RegField",
      Description => "This field tests Slice[n]LpQueuingEmMissInterrupt interrupt",
      Width => "1",
      Position => "0", # Excel Formula: =calc_position(F22,E23,TRUE)
      Type => "InterruptTest",
      UsedBy => "",
      DefaultValue => "b0",
      Comments => "counts number of valid members currently in cache",
    },
    Slice1Stage0EmMissInterruptTest => { #Structure Type: RegField; ArrayLength: 2; ArrayIndex: 1; ArrayLocationInName: 6;
      Name => "Slice[n]Stage0EmMissInterruptTest",
      RegMem => "RegField",
      Description => "This field tests Slice[n]Stage0EmMissInterrupt interrupt",
      Width => "1",
      Position => "1", # Excel Formula: =calc_position(F23,E24)
      Type => "InterruptTest",
      UsedBy => "",
      DefaultValue => "b0",
      Comments => "counts number of valid members currently in cache",
    },
    Slice1Stage1EmMissInterruptTest => { #Structure Type: RegField; ArrayLength: 2; ArrayIndex: 1; ArrayLocationInName: 6;
      Name => "Slice[n]Stage1EmMissInterruptTest",
      RegMem => "RegField",
      Description => "This field tests Slice[n]Stage1EmMissInterrupt interrupt",
      Width => "1",
      Position => "2", # Excel Formula: =calc_position(F24,E25)
      Type => "InterruptTest",
      UsedBy => "",
      DefaultValue => "b0",
      Comments => "counts number of valid members currently in cache",
    },
    Slice1Stage2EmMissInterruptTest => { #Structure Type: RegField; ArrayLength: 2; ArrayIndex: 1; ArrayLocationInName: 6;
      Name => "Slice[n]Stage2EmMissInterruptTest",
      RegMem => "RegField",
      Description => "This field tests Slice[n]Stage2EmMissInterrupt interrupt",
      Width => "1",
      Position => "3", # Excel Formula: =calc_position(F25,E26)
      Type => "InterruptTest",
      UsedBy => "",
      DefaultValue => "b0",
      Comments => "counts number of valid members currently in cache",
    },
    Slice1Stage3EmMissInterruptTest => { #Structure Type: RegField; ArrayLength: 2; ArrayIndex: 1; ArrayLocationInName: 6;
      Name => "Slice[n]Stage3EmMissInterruptTest",
      RegMem => "RegField",
      Description => "This field tests Slice[n]Stage3EmMissInterrupt interrupt",
      Width => "1",
      Position => "4", # Excel Formula: =calc_position(F26,E27)
      Type => "InterruptTest",
      UsedBy => "",
      DefaultValue => "b0",
      Comments => "counts number of valid members currently in cache",
    },
    Slice1LpQueuingPrevCorePushToFullInterruptTest => { #Structure Type: RegField; ArrayLength: 2; ArrayIndex: 1; ArrayLocationInName: 6;
      Name => "Slice[n]LpQueuingPrevCorePushToFullInterruptTest",
      RegMem => "RegField",
      Width => "1",
      Position => "5", # Excel Formula: =calc_position(F27,E28)
      Type => "InterruptTest",
      UsedBy => "",
      DefaultValue => "b0",
      Comments => "counts number of valid members currently in cache",
    },
    Slice1Stage0PrevCorePushToFullInterruptTest => { #Structure Type: RegField; ArrayLength: 2; ArrayIndex: 1; ArrayLocationInName: 6;
      Name => "Slice[n]Stage0PrevCorePushToFullInterruptTest",
      RegMem => "RegField",
      Width => "1",
      Position => "6", # Excel Formula: =calc_position(F28,E29)
      Type => "InterruptTest",
      UsedBy => "",
      DefaultValue => "b0",
      Comments => "counts number of valid members currently in cache",
    },
    Slice1Stage1PrevCorePushToFullInterruptTest => { #Structure Type: RegField; ArrayLength: 2; ArrayIndex: 1; ArrayLocationInName: 6;
      Name => "Slice[n]Stage1PrevCorePushToFullInterruptTest",
      RegMem => "RegField",
      Width => "1",
      Position => "7", # Excel Formula: =calc_position(F29,E30)
      Type => "InterruptTest",
      UsedBy => "",
      DefaultValue => "b0",
      Comments => "counts number of valid members currently in cache",
    },
    Slice1Stage2PrevCorePushToFullInterruptTest => { #Structure Type: RegField; ArrayLength: 2; ArrayIndex: 1; ArrayLocationInName: 6;
      Name => "Slice[n]Stage2PrevCorePushToFullInterruptTest",
      RegMem => "RegField",
      Width => "1",
      Position => "8", # Excel Formula: =calc_position(F30,E31)
      Type => "InterruptTest",
      UsedBy => "",
      DefaultValue => "b0",
      Comments => "counts number of valid members currently in cache",
    },
    Slice1Stage3PrevCorePushToFullInterruptTest => { #Structure Type: RegField; ArrayLength: 2; ArrayIndex: 1; ArrayLocationInName: 6;
      Name => "Slice[n]Stage3PrevCorePushToFullInterruptTest",
      RegMem => "RegField",
      Width => "1",
      Position => "9", # Excel Formula: =calc_position(F31,E32)
      Type => "InterruptTest",
      UsedBy => "",
      DefaultValue => "b0",
      Comments => "counts number of valid members currently in cache",
    },
    Slice1ResolutionTtlTest => { #Structure Type: RegField; ArrayLength: 2; ArrayIndex: 1; ArrayLocationInName: 6;
      Name => "Slice[n]ResolutionTtlTest",
      RegMem => "RegField",
      Description => "This field tests Slice[n]ResolutionTtl interrupt",
      Width => "1",
      Position => "10", # Excel Formula: =calc_position(F32,E33)
      Type => "InterruptTest",
      UsedBy => "",
      DefaultValue => "b0",
    },
  },
  Core0BubbleLogicCounterCfg => { #Structure Type: Reg; ArrayLength: 3; ArrayIndex: 0; ArrayLocationInName: 5;
    Name => "Core[3]BubbleLogicCounterCfg",
    RegMem => "Reg",
    Address => "113", # Excel Formula: =calc_reg_address(C22,A22,G22)
    Description => "Core Bubble Logic Counter Configuration",
    Width => "67", # Excel Formula: =calc_reg_width(E35:E43,F43)
    Type => "Config",
    ArrayLength => "3",
    ArrayIndex => "0",
    Core0PrevCoreOrdyNumOfClksBeforeBubble => { #Structure Type: RegField; ArrayLength: 3; ArrayIndex: 0; ArrayLocationInName: 5;
      Name => "Core[n]PrevCoreOrdyNumOfClksBeforeBubble",
      RegMem => "RegField",
      Description => "Amount of concecutive cycles that data from prev core is waiting inside a core's FIFO before requesting a bubble.",
      Width => "10",
      Position => "9:0", # Excel Formula: =calc_position(F34,E35,TRUE)
      Type => "Config",
      UsedBy => "res",
      DefaultValue => "d4",
    },
    Core0PrevCoreAlmFullNumOfClksBeforeBubble => { #Structure Type: RegField; ArrayLength: 3; ArrayIndex: 0; ArrayLocationInName: 5;
      Name => "Core[n]PrevCoreAlmFullNumOfClksBeforeBubble",
      RegMem => "RegField",
      Description => "Amount of concecutive cycles that data from prev core is waiting inside a core's FIFO before requesting a bubble.",
      Width => "10",
      Position => "19:10", # Excel Formula: =calc_position(F35,E36)
      Type => "Config",
      UsedBy => "res",
      DefaultValue => "d1",
    },
    Core0TopAlmFullNumOfClksBeforeBubble => { #Structure Type: RegField; ArrayLength: 3; ArrayIndex: 0; ArrayLocationInName: 5;
      Name => "Core[n]TopAlmFullNumOfClksBeforeBubble",
      RegMem => "RegField",
      Description => "Amount of concecutive cycles that data from prev core is waiting inside a core's FIFO before requesting a bubble.",
      Width => "10",
      Position => "29:20", # Excel Formula: =calc_position(F36,E37)
      Type => "Config",
      UsedBy => "res",
      DefaultValue => "d32",
      InitValueAllModes => "(instance<2) ? 1 :32",
    },
    Core0PrevCore0AlmFullCfg => { #Structure Type: RegField; ArrayLength: 3; ArrayIndex: 0; ArrayLocationInName: 5;
      Name => "Core[n]PrevCore0AlmFullCfg",
      RegMem => "RegField",
      Description => "Amount of concecutive cycles that data from prev core is waiting inside a core's FIFO before requesting a bubble.",
      Width => "6",
      Position => "35:30", # Excel Formula: =calc_position(F37,E38)
      Type => "Config",
      UsedBy => "res",
      DefaultValue => "d3",
    },
    Core0PrevCore1AlmFullCfg => { #Structure Type: RegField; ArrayLength: 3; ArrayIndex: 0; ArrayLocationInName: 5;
      Name => "Core[n]PrevCore1AlmFullCfg",
      RegMem => "RegField",
      Description => "Amount of concecutive cycles that data from prev core is waiting inside a core's FIFO before requesting a bubble.",
      Width => "6",
      Position => "41:36", # Excel Formula: =calc_position(F38,E39)
      Type => "Config",
      UsedBy => "res",
      DefaultValue => "d3",
    },
    Core0TopAlmFullCfg => { #Structure Type: RegField; ArrayLength: 3; ArrayIndex: 0; ArrayLocationInName: 5;
      Name => "Core[n]TopAlmFullCfg",
      RegMem => "RegField",
      Description => "Amount of concecutive cycles that data from prev core is waiting inside a core's FIFO before requesting a bubble.",
      Width => "3",
      Position => "44:42", # Excel Formula: =calc_position(F39,E40)
      Type => "Config",
      UsedBy => "res",
      DefaultValue => "d1",
      InitValueAllModes => "2",
    },
    Core0PrevCoreToPrevCoreNumOfClksBeforeBubble => { #Structure Type: RegField; ArrayLength: 3; ArrayIndex: 0; ArrayLocationInName: 5;
      Name => "Core[n]PrevCoreToPrevCoreNumOfClksBeforeBubble",
      RegMem => "RegField",
      Description => "Amount of concecutive cycles that data from prev core is waiting inside a core's FIFO before requesting a bubble.",
      Width => "10",
      Position => "54:45", # Excel Formula: =calc_position(F40,E41)
      Type => "Config",
      UsedBy => "res",
      DefaultValue => "d8",
    },
    Core0PrevCore0ToPrevCoreAlmFullCfg => { #Structure Type: RegField; ArrayLength: 3; ArrayIndex: 0; ArrayLocationInName: 5;
      Name => "Core[n]PrevCore0ToPrevCoreAlmFullCfg",
      RegMem => "RegField",
      Description => "Amount of concecutive cycles that data from prev core is waiting inside a core's FIFO before requesting a bubble.",
      Width => "6",
      Position => "60:55", # Excel Formula: =calc_position(F41,E42)
      Type => "Config",
      UsedBy => "res",
      DefaultValue => "d12",
      InitValueAllModes => "3",
    },
    Core0PrevCore1ToPrevCoreAlmFullCfg => { #Structure Type: RegField; ArrayLength: 3; ArrayIndex: 0; ArrayLocationInName: 5;
      Name => "Core[n]PrevCore1ToPrevCoreAlmFullCfg",
      RegMem => "RegField",
      Description => "Amount of concecutive cycles that data from prev core is waiting inside a core's FIFO before requesting a bubble.",
      Width => "6",
      Position => "66:61", # Excel Formula: =calc_position(F42,E43)
      Type => "Config",
      UsedBy => "res",
      DefaultValue => "d12",
    },
  },
  Core1BubbleLogicCounterCfg => { #Structure Type: Reg; ArrayLength: 3; ArrayIndex: 1; ArrayLocationInName: 5;
    Name => "Core[3]BubbleLogicCounterCfg",
    RegMem => "Reg",
    Address => "114",
    Description => "Core Bubble Logic Counter Configuration",
    Width => "67", # Excel Formula: =calc_reg_width(E35:E43,F43)
    Type => "Config",
    ArrayLength => "3",
    ArrayIndex => "1",
    Core1PrevCoreOrdyNumOfClksBeforeBubble => { #Structure Type: RegField; ArrayLength: 3; ArrayIndex: 1; ArrayLocationInName: 5;
      Name => "Core[n]PrevCoreOrdyNumOfClksBeforeBubble",
      RegMem => "RegField",
      Description => "Amount of concecutive cycles that data from prev core is waiting inside a core's FIFO before requesting a bubble.",
      Width => "10",
      Position => "9:0", # Excel Formula: =calc_position(F34,E35,TRUE)
      Type => "Config",
      UsedBy => "res",
      DefaultValue => "d4",
    },
    Core1PrevCoreAlmFullNumOfClksBeforeBubble => { #Structure Type: RegField; ArrayLength: 3; ArrayIndex: 1; ArrayLocationInName: 5;
      Name => "Core[n]PrevCoreAlmFullNumOfClksBeforeBubble",
      RegMem => "RegField",
      Description => "Amount of concecutive cycles that data from prev core is waiting inside a core's FIFO before requesting a bubble.",
      Width => "10",
      Position => "19:10", # Excel Formula: =calc_position(F35,E36)
      Type => "Config",
      UsedBy => "res",
      DefaultValue => "d1",
    },
    Core1TopAlmFullNumOfClksBeforeBubble => { #Structure Type: RegField; ArrayLength: 3; ArrayIndex: 1; ArrayLocationInName: 5;
      Name => "Core[n]TopAlmFullNumOfClksBeforeBubble",
      RegMem => "RegField",
      Description => "Amount of concecutive cycles that data from prev core is waiting inside a core's FIFO before requesting a bubble.",
      Width => "10",
      Position => "29:20", # Excel Formula: =calc_position(F36,E37)
      Type => "Config",
      UsedBy => "res",
      DefaultValue => "d32",
      InitValueAllModes => "(instance<2) ? 1 :32",
    },
    Core1PrevCore0AlmFullCfg => { #Structure Type: RegField; ArrayLength: 3; ArrayIndex: 1; ArrayLocationInName: 5;
      Name => "Core[n]PrevCore0AlmFullCfg",
      RegMem => "RegField",
      Description => "Amount of concecutive cycles that data from prev core is waiting inside a core's FIFO before requesting a bubble.",
      Width => "6",
      Position => "35:30", # Excel Formula: =calc_position(F37,E38)
      Type => "Config",
      UsedBy => "res",
      DefaultValue => "d3",
    },
    Core1PrevCore1AlmFullCfg => { #Structure Type: RegField; ArrayLength: 3; ArrayIndex: 1; ArrayLocationInName: 5;
      Name => "Core[n]PrevCore1AlmFullCfg",
      RegMem => "RegField",
      Description => "Amount of concecutive cycles that data from prev core is waiting inside a core's FIFO before requesting a bubble.",
      Width => "6",
      Position => "41:36", # Excel Formula: =calc_position(F38,E39)
      Type => "Config",
      UsedBy => "res",
      DefaultValue => "d3",
    },
    Core1TopAlmFullCfg => { #Structure Type: RegField; ArrayLength: 3; ArrayIndex: 1; ArrayLocationInName: 5;
      Name => "Core[n]TopAlmFullCfg",
      RegMem => "RegField",
      Description => "Amount of concecutive cycles that data from prev core is waiting inside a core's FIFO before requesting a bubble.",
      Width => "3",
      Position => "44:42", # Excel Formula: =calc_position(F39,E40)
      Type => "Config",
      UsedBy => "res",
      DefaultValue => "d1",
      InitValueAllModes => "2",
    },
    Core1PrevCoreToPrevCoreNumOfClksBeforeBubble => { #Structure Type: RegField; ArrayLength: 3; ArrayIndex: 1; ArrayLocationInName: 5;
      Name => "Core[n]PrevCoreToPrevCoreNumOfClksBeforeBubble",
      RegMem => "RegField",
      Description => "Amount of concecutive cycles that data from prev core is waiting inside a core's FIFO before requesting a bubble.",
      Width => "10",
      Position => "54:45", # Excel Formula: =calc_position(F40,E41)
      Type => "Config",
      UsedBy => "res",
      DefaultValue => "d8",
    },
    Core1PrevCore0ToPrevCoreAlmFullCfg => { #Structure Type: RegField; ArrayLength: 3; ArrayIndex: 1; ArrayLocationInName: 5;
      Name => "Core[n]PrevCore0ToPrevCoreAlmFullCfg",
      RegMem => "RegField",
      Description => "Amount of concecutive cycles that data from prev core is waiting inside a core's FIFO before requesting a bubble.",
      Width => "6",
      Position => "60:55", # Excel Formula: =calc_position(F41,E42)
      Type => "Config",
      UsedBy => "res",
      DefaultValue => "d12",
      InitValueAllModes => "3",
    },
    Core1PrevCore1ToPrevCoreAlmFullCfg => { #Structure Type: RegField; ArrayLength: 3; ArrayIndex: 1; ArrayLocationInName: 5;
      Name => "Core[n]PrevCore1ToPrevCoreAlmFullCfg",
      RegMem => "RegField",
      Description => "Amount of concecutive cycles that data from prev core is waiting inside a core's FIFO before requesting a bubble.",
      Width => "6",
      Position => "66:61", # Excel Formula: =calc_position(F42,E43)
      Type => "Config",
      UsedBy => "res",
      DefaultValue => "d12",
    },
  },
  Core2BubbleLogicCounterCfg => { #Structure Type: Reg; ArrayLength: 3; ArrayIndex: 2; ArrayLocationInName: 5;
    Name => "Core[3]BubbleLogicCounterCfg",
    RegMem => "Reg",
    Address => "115",
    Description => "Core Bubble Logic Counter Configuration",
    Width => "67", # Excel Formula: =calc_reg_width(E35:E43,F43)
    Type => "Config",
    ArrayLength => "3",
    ArrayIndex => "2",
    Core2PrevCoreOrdyNumOfClksBeforeBubble => { #Structure Type: RegField; ArrayLength: 3; ArrayIndex: 2; ArrayLocationInName: 5;
      Name => "Core[n]PrevCoreOrdyNumOfClksBeforeBubble",
      RegMem => "RegField",
      Description => "Amount of concecutive cycles that data from prev core is waiting inside a core's FIFO before requesting a bubble.",
      Width => "10",
      Position => "9:0", # Excel Formula: =calc_position(F34,E35,TRUE)
      Type => "Config",
      UsedBy => "res",
      DefaultValue => "d4",
    },
    Core2PrevCoreAlmFullNumOfClksBeforeBubble => { #Structure Type: RegField; ArrayLength: 3; ArrayIndex: 2; ArrayLocationInName: 5;
      Name => "Core[n]PrevCoreAlmFullNumOfClksBeforeBubble",
      RegMem => "RegField",
      Description => "Amount of concecutive cycles that data from prev core is waiting inside a core's FIFO before requesting a bubble.",
      Width => "10",
      Position => "19:10", # Excel Formula: =calc_position(F35,E36)
      Type => "Config",
      UsedBy => "res",
      DefaultValue => "d1",
    },
    Core2TopAlmFullNumOfClksBeforeBubble => { #Structure Type: RegField; ArrayLength: 3; ArrayIndex: 2; ArrayLocationInName: 5;
      Name => "Core[n]TopAlmFullNumOfClksBeforeBubble",
      RegMem => "RegField",
      Description => "Amount of concecutive cycles that data from prev core is waiting inside a core's FIFO before requesting a bubble.",
      Width => "10",
      Position => "29:20", # Excel Formula: =calc_position(F36,E37)
      Type => "Config",
      UsedBy => "res",
      DefaultValue => "d32",
      InitValueAllModes => "(instance<2) ? 1 :32",
    },
    Core2PrevCore0AlmFullCfg => { #Structure Type: RegField; ArrayLength: 3; ArrayIndex: 2; ArrayLocationInName: 5;
      Name => "Core[n]PrevCore0AlmFullCfg",
      RegMem => "RegField",
      Description => "Amount of concecutive cycles that data from prev core is waiting inside a core's FIFO before requesting a bubble.",
      Width => "6",
      Position => "35:30", # Excel Formula: =calc_position(F37,E38)
      Type => "Config",
      UsedBy => "res",
      DefaultValue => "d3",
    },
    Core2PrevCore1AlmFullCfg => { #Structure Type: RegField; ArrayLength: 3; ArrayIndex: 2; ArrayLocationInName: 5;
      Name => "Core[n]PrevCore1AlmFullCfg",
      RegMem => "RegField",
      Description => "Amount of concecutive cycles that data from prev core is waiting inside a core's FIFO before requesting a bubble.",
      Width => "6",
      Position => "41:36", # Excel Formula: =calc_position(F38,E39)
      Type => "Config",
      UsedBy => "res",
      DefaultValue => "d3",
    },
    Core2TopAlmFullCfg => { #Structure Type: RegField; ArrayLength: 3; ArrayIndex: 2; ArrayLocationInName: 5;
      Name => "Core[n]TopAlmFullCfg",
      RegMem => "RegField",
      Description => "Amount of concecutive cycles that data from prev core is waiting inside a core's FIFO before requesting a bubble.",
      Width => "3",
      Position => "44:42", # Excel Formula: =calc_position(F39,E40)
      Type => "Config",
      UsedBy => "res",
      DefaultValue => "d1",
      InitValueAllModes => "2",
    },
    Core2PrevCoreToPrevCoreNumOfClksBeforeBubble => { #Structure Type: RegField; ArrayLength: 3; ArrayIndex: 2; ArrayLocationInName: 5;
      Name => "Core[n]PrevCoreToPrevCoreNumOfClksBeforeBubble",
      RegMem => "RegField",
      Description => "Amount of concecutive cycles that data from prev core is waiting inside a core's FIFO before requesting a bubble.",
      Width => "10",
      Position => "54:45", # Excel Formula: =calc_position(F40,E41)
      Type => "Config",
      UsedBy => "res",
      DefaultValue => "d8",
    },
    Core2PrevCore0ToPrevCoreAlmFullCfg => { #Structure Type: RegField; ArrayLength: 3; ArrayIndex: 2; ArrayLocationInName: 5;
      Name => "Core[n]PrevCore0ToPrevCoreAlmFullCfg",
      RegMem => "RegField",
      Description => "Amount of concecutive cycles that data from prev core is waiting inside a core's FIFO before requesting a bubble.",
      Width => "6",
      Position => "60:55", # Excel Formula: =calc_position(F41,E42)
      Type => "Config",
      UsedBy => "res",
      DefaultValue => "d12",
      InitValueAllModes => "3",
    },
    Core2PrevCore1ToPrevCoreAlmFullCfg => { #Structure Type: RegField; ArrayLength: 3; ArrayIndex: 2; ArrayLocationInName: 5;
      Name => "Core[n]PrevCore1ToPrevCoreAlmFullCfg",
      RegMem => "RegField",
      Description => "Amount of concecutive cycles that data from prev core is waiting inside a core's FIFO before requesting a bubble.",
      Width => "6",
      Position => "66:61", # Excel Formula: =calc_position(F42,E43)
      Type => "Config",
      UsedBy => "res",
      DefaultValue => "d12",
    },
  },
  Core3BubbleLogicCounterCfg => { #Structure Type: Reg;
    Name => "Core3BubbleLogicCounterCfg",
    RegMem => "Reg",
    Address => "116", # Excel Formula: =calc_reg_address(C34,A34,G34)
    Description => "Core Bubble Logic Counter Configuration",
    Width => "67", # Excel Formula: =calc_reg_width(E45:E53,F53)
    Type => "Config",
    Core3PrevCoreOrdyNumOfClksBeforeBubble => { #Structure Type: RegField;
      Name => "Core3PrevCoreOrdyNumOfClksBeforeBubble",
      RegMem => "RegField",
      Description => "Amount of concecutive cycles that data from prev core is waiting inside a core's FIFO before requesting a bubble.",
      Width => "10",
      Position => "9:0", # Excel Formula: =calc_position(F44,E45,TRUE)
      Type => "Config",
      UsedBy => "res",
      DefaultValue => "d4",
    },
    Core3PrevCoreAlmFullNumOfClksBeforeBubble => { #Structure Type: RegField;
      Name => "Core3PrevCoreAlmFullNumOfClksBeforeBubble",
      RegMem => "RegField",
      Description => "Amount of concecutive cycles that data from prev core is waiting inside a core's FIFO before requesting a bubble.",
      Width => "10",
      Position => "19:10", # Excel Formula: =calc_position(F45,E46)
      Type => "Config",
      UsedBy => "res",
      DefaultValue => "d1",
    },
    Core3TopAlmFullNumOfClksBeforeBubble => { #Structure Type: RegField;
      Name => "Core3TopAlmFullNumOfClksBeforeBubble",
      RegMem => "RegField",
      Description => "Amount of concecutive cycles that data from prev core is waiting inside a core's FIFO before requesting a bubble.",
      Width => "10",
      Position => "29:20", # Excel Formula: =calc_position(F46,E47)
      Type => "Config",
      UsedBy => "res",
      DefaultValue => "d32",
    },
    Core3PrevCore0AlmFullCfg => { #Structure Type: RegField;
      Name => "Core3PrevCore0AlmFullCfg",
      RegMem => "RegField",
      Description => "Amount of concecutive cycles that data from prev core is waiting inside a core's FIFO before requesting a bubble.",
      Width => "6",
      Position => "35:30", # Excel Formula: =calc_position(F47,E48)
      Type => "Config",
      UsedBy => "res",
      DefaultValue => "d3",
    },
    Core3PrevCore1AlmFullCfg => { #Structure Type: RegField;
      Name => "Core3PrevCore1AlmFullCfg",
      RegMem => "RegField",
      Description => "Amount of concecutive cycles that data from prev core is waiting inside a core's FIFO before requesting a bubble.",
      Width => "6",
      Position => "41:36", # Excel Formula: =calc_position(F48,E49)
      Type => "Config",
      UsedBy => "res",
      DefaultValue => "d0",
    },
    Core3TopAlmFullCfg => { #Structure Type: RegField;
      Name => "Core3TopAlmFullCfg",
      RegMem => "RegField",
      Description => "Amount of concecutive cycles that data from prev core is waiting inside a core's FIFO before requesting a bubble.",
      Width => "3",
      Position => "44:42", # Excel Formula: =calc_position(F49,E50)
      Type => "Config",
      UsedBy => "res",
      DefaultValue => "d1",
      InitValueAllModes => "2",
    },
    Core3PrevCoreToPrevCoreNumOfClksBeforeBubble => { #Structure Type: RegField;
      Name => "Core3PrevCoreToPrevCoreNumOfClksBeforeBubble",
      RegMem => "RegField",
      Description => "Amount of concecutive cycles that data from prev core is waiting inside a core's FIFO before requesting a bubble.",
      Width => "10",
      Position => "54:45", # Excel Formula: =calc_position(F50,E51)
      Type => "Config",
      UsedBy => "res",
      DefaultValue => "d8",
    },
    Core3PrevCore0ToPrevCoreAlmFullCfg => { #Structure Type: RegField;
      Name => "Core3PrevCore0ToPrevCoreAlmFullCfg",
      RegMem => "RegField",
      Description => "Amount of concecutive cycles that data from prev core is waiting inside a core's FIFO before requesting a bubble.",
      Width => "6",
      Position => "60:55", # Excel Formula: =calc_position(F51,E52)
      Type => "Config",
      UsedBy => "res",
      DefaultValue => "d8",
    },
    Core3PrevCore1ToPrevCoreAlmFullCfg => { #Structure Type: RegField;
      Name => "Core3PrevCore1ToPrevCoreAlmFullCfg",
      RegMem => "RegField",
      Description => "Amount of concecutive cycles that data from prev core is waiting inside a core's FIFO before requesting a bubble.",
      Width => "6",
      Position => "66:61", # Excel Formula: =calc_position(F52,E53)
      Type => "Config",
      UsedBy => "res",
      DefaultValue => "d0",
    },
  },
  LPQueuingBubbleLogicCounterCfg => { #Structure Type: Reg;
    Name => "LPQueuingBubbleLogicCounterCfg",
    RegMem => "Reg",
    Address => "117", # Excel Formula: =calc_reg_address(C44,A44,G44)
    Description => "Core Bubble Logic Counter Configuration",
    Width => "39", # Excel Formula: =calc_reg_width(E55:E59,F59)
    Type => "Config",
    LpQueuingPrevCoreOrdyNumOfClksBeforeBubble => { #Structure Type: RegField;
      Name => "LpQueuingPrevCoreOrdyNumOfClksBeforeBubble",
      RegMem => "RegField",
      Description => "Amount of concecutive cycles that data from prev core is waiting inside a core's FIFO before requesting a bubble.",
      Width => "10",
      Position => "9:0", # Excel Formula: =calc_position(F54,E55,TRUE)
      Type => "Config",
      UsedBy => "res",
      DefaultValue => "d4",
    },
    LpQueuingPrevCoreAlmFullNumOfClksBeforeBubble => { #Structure Type: RegField;
      Name => "LpQueuingPrevCoreAlmFullNumOfClksBeforeBubble",
      RegMem => "RegField",
      Description => "Amount of concecutive cycles that data from prev core is waiting inside a core's FIFO before requesting a bubble.",
      Width => "10",
      Position => "19:10", # Excel Formula: =calc_position(F55,E56)
      Type => "Config",
      UsedBy => "res",
      DefaultValue => "d1",
    },
    LpQueuingTopAlmFullNumOfClksBeforeBubble => { #Structure Type: RegField;
      Name => "LpQueuingTopAlmFullNumOfClksBeforeBubble",
      RegMem => "RegField",
      Description => "Amount of concecutive cycles that data from prev core is waiting inside a core's FIFO before requesting a bubble.",
      Width => "10",
      Position => "29:20", # Excel Formula: =calc_position(F56,E57)
      Type => "Config",
      UsedBy => "res",
      DefaultValue => "d32",
    },
    LpQueuingPrevCoreAlmFullCfg => { #Structure Type: RegField;
      Name => "LpQueuingPrevCoreAlmFullCfg",
      RegMem => "RegField",
      Description => "Amount of concecutive cycles that data from prev core is waiting inside a core's FIFO before requesting a bubble.",
      Width => "6",
      Position => "35:30", # Excel Formula: =calc_position(F57,E58)
      Type => "Config",
      UsedBy => "res",
      DefaultValue => "d3",
    },
    LpQueuingTopAlmFullCfg => { #Structure Type: RegField;
      Name => "LpQueuingTopAlmFullCfg",
      RegMem => "RegField",
      Description => "Amount of concecutive cycles that data from prev core is waiting inside a core's FIFO before requesting a bubble.",
      Width => "3",
      Position => "38:36", # Excel Formula: =calc_position(F58,E59)
      Type => "Config",
      UsedBy => "res",
      DefaultValue => "d1",
    },
  },
  PipeBehaviorCfg => { #Structure Type: Reg;
    Name => "PipeBehaviorCfg",
    RegMem => "Reg",
    Address => "118", # Excel Formula: =calc_reg_address(C54,A54,G54)
    Width => "7", # Excel Formula: =calc_reg_width(E61:E64,F64)
    Type => "Config",
    ResolutionSliceSendAllToFec => { #Structure Type: RegField;
      Name => "ResolutionSliceSendAllToFec",
      RegMem => "RegField",
      Description => "When set, this configuration will result in all traffic being initially sent to the FEC stage (thus creating less complext pipe structure in the resolution). This mode will result in higher latency in some cases, but may reduce skew.",
      Width => "1",
      Position => "0", # Excel Formula: =calc_position(F60,E61,TRUE)
      Type => "Config",
      UsedBy => "res",
      DefaultValue => "b0",
      InitValueAllModes => "0",
    },
    ResolutionFecNextStageMode => { #Structure Type: RegField;
      Name => "ResolutionFecNextStageMode",
      RegMem => "RegField",
      Description => "This field will determine the next core:
2'b00 : next core0
2'b01 : next core1
2'b10 : dynamic (according the the dest mapping stage id)",
      Width => "2",
      Position => "2:1", # Excel Formula: =calc_position(F61,E62)
      Type => "Config",
      UsedBy => "res",
      DefaultValue => "b10",
      InitValueAllModes => "2",
    },
    ResolutionCore0NextStageMode => { #Structure Type: RegField;
      Name => "ResolutionCore0NextStageMode",
      RegMem => "RegField",
      Description => "This field will determine the next core:
2'b00 : next core0
2'b01 : next core1
2'b10 : dynamic (according the the dest mapping stage id)",
      Width => "2",
      Position => "4:3", # Excel Formula: =calc_position(F62,E63)
      Type => "Config",
      UsedBy => "res",
      DefaultValue => "b10",
      InitValueAllModes => "2",
    },
    ResolutionCore1NextStageMode => { #Structure Type: RegField;
      Name => "ResolutionCore1NextStageMode",
      RegMem => "RegField",
      Description => "This field will determine the next core:
2'b00 : next core0
2'b01 : next core1
2'b10 : dynamic (according the the dest mapping stage id)",
      Width => "2",
      Position => "6:5", # Excel Formula: =calc_position(F63,E64)
      Type => "Config",
      UsedBy => "res",
      DefaultValue => "b10",
      InitValueAllModes => "2",
    },
  },
  slice1_stage0_lb_Consistence_cache_clk_and_timer_attr => { #Structure Type: Reg; ArrayLength: 4; ArrayIndex: 0; ArrayLocationInName: 13;
    Name => "slice1_stage[4]_lb_Consistence_cache_clk_and_timer_attr",
    RegMem => "Reg",
    Address => "119", # Excel Formula: =calc_reg_address(C60,A60,G60)
    Description => "This register Controls the cache-time-stamp resolution/scale
The design contains 32b counter which counts clock-cycles:
* Initialize on reset: clks-counter = 0
* Increment every clk

This register defines the desired time-scale out of this reg.
The picked time-scale is used for both the following:
1. The time-stamp that be taken and wrriten to the cache-table.
2. The threshold in which the cache-entry will be aged.",
    Width => "15", # Excel Formula: =calc_reg_width(E66:E67,F67)
    Type => "Config",
    DocName => "Slice[2]PortDspLbConsistenceCacheClkAndTimerAttr",
    ArrayLength => "4",
    ArrayIndex => "0",
    slice1_stage0_lb_Consistence_cache_clock_offset => { #Structure Type: RegField; ArrayLength: 4; ArrayIndex: 0; ArrayLocationInName: 13;
      Name => "slice1_stage[n]_lb_Consistence_cache_clock_offset",
      RegMem => "RegField",
      Description => "Desired offset from the 32b clocks-counter:
Curr-time = clks-counter[Cfg-offset +: 4]
For example: if the clock-cycle is 1ns, and the desired resolution is 1us, than the offset should be 10
",
      Width => "5",
      Position => "4:0", # Excel Formula: =calc_position(F65,E66,TRUE)
      Type => "Config",
      UsedBy => "res",
      DefaultValue => "d10",
      DocName => "Slice[n]PortDspLbConsistenceCacheClockOffset",
      Comments => "counts number of valid members currently in cache",
    },
    slice1_stage0_lb_Consistence_cache_clock_threshold => { #Structure Type: RegField; ArrayLength: 4; ArrayIndex: 0; ArrayLocationInName: 13;
      Name => "slice1_stage[n]_lb_Consistence_cache_clock_threshold",
      RegMem => "RegField",
      Description => "Cache-entry will be erased only if read by the design, and:
(Curr-time - Cache-payload.Time-stamp) > Cfg-Threshold",
      Width => "10",
      Position => "14:5", # Excel Formula: =calc_position(F66,E67)
      Type => "Config",
      UsedBy => "res",
      DefaultValue => "d1000",
      DocName => "Slice[n]PortDspLbConsistenceCacheClockThreshold",
      Comments => "counts number of valid members currently in cache",
    },
  },
  slice1_stage1_lb_Consistence_cache_clk_and_timer_attr => { #Structure Type: Reg; ArrayLength: 4; ArrayIndex: 1; ArrayLocationInName: 13;
    Name => "slice1_stage[4]_lb_Consistence_cache_clk_and_timer_attr",
    RegMem => "Reg",
    Address => "11A",
    Description => "This register Controls the cache-time-stamp resolution/scale
The design contains 32b counter which counts clock-cycles:
* Initialize on reset: clks-counter = 0
* Increment every clk

This register defines the desired time-scale out of this reg.
The picked time-scale is used for both the following:
1. The time-stamp that be taken and wrriten to the cache-table.
2. The threshold in which the cache-entry will be aged.",
    Width => "15", # Excel Formula: =calc_reg_width(E66:E67,F67)
    Type => "Config",
    DocName => "Slice[2]PortDspLbConsistenceCacheClkAndTimerAttr",
    ArrayLength => "4",
    ArrayIndex => "1",
    slice1_stage1_lb_Consistence_cache_clock_offset => { #Structure Type: RegField; ArrayLength: 4; ArrayIndex: 1; ArrayLocationInName: 13;
      Name => "slice1_stage[n]_lb_Consistence_cache_clock_offset",
      RegMem => "RegField",
      Description => "Desired offset from the 32b clocks-counter:
Curr-time = clks-counter[Cfg-offset +: 4]
For example: if the clock-cycle is 1ns, and the desired resolution is 1us, than the offset should be 10
",
      Width => "5",
      Position => "4:0", # Excel Formula: =calc_position(F65,E66,TRUE)
      Type => "Config",
      UsedBy => "res",
      DefaultValue => "d10",
      DocName => "Slice[n]PortDspLbConsistenceCacheClockOffset",
      Comments => "counts number of valid members currently in cache",
    },
    slice1_stage1_lb_Consistence_cache_clock_threshold => { #Structure Type: RegField; ArrayLength: 4; ArrayIndex: 1; ArrayLocationInName: 13;
      Name => "slice1_stage[n]_lb_Consistence_cache_clock_threshold",
      RegMem => "RegField",
      Description => "Cache-entry will be erased only if read by the design, and:
(Curr-time - Cache-payload.Time-stamp) > Cfg-Threshold",
      Width => "10",
      Position => "14:5", # Excel Formula: =calc_position(F66,E67)
      Type => "Config",
      UsedBy => "res",
      DefaultValue => "d1000",
      DocName => "Slice[n]PortDspLbConsistenceCacheClockThreshold",
      Comments => "counts number of valid members currently in cache",
    },
  },
  slice1_stage2_lb_Consistence_cache_clk_and_timer_attr => { #Structure Type: Reg; ArrayLength: 4; ArrayIndex: 2; ArrayLocationInName: 13;
    Name => "slice1_stage[4]_lb_Consistence_cache_clk_and_timer_attr",
    RegMem => "Reg",
    Address => "11B",
    Description => "This register Controls the cache-time-stamp resolution/scale
The design contains 32b counter which counts clock-cycles:
* Initialize on reset: clks-counter = 0
* Increment every clk

This register defines the desired time-scale out of this reg.
The picked time-scale is used for both the following:
1. The time-stamp that be taken and wrriten to the cache-table.
2. The threshold in which the cache-entry will be aged.",
    Width => "15", # Excel Formula: =calc_reg_width(E66:E67,F67)
    Type => "Config",
    DocName => "Slice[2]PortDspLbConsistenceCacheClkAndTimerAttr",
    ArrayLength => "4",
    ArrayIndex => "2",
    slice1_stage2_lb_Consistence_cache_clock_offset => { #Structure Type: RegField; ArrayLength: 4; ArrayIndex: 2; ArrayLocationInName: 13;
      Name => "slice1_stage[n]_lb_Consistence_cache_clock_offset",
      RegMem => "RegField",
      Description => "Desired offset from the 32b clocks-counter:
Curr-time = clks-counter[Cfg-offset +: 4]
For example: if the clock-cycle is 1ns, and the desired resolution is 1us, than the offset should be 10
",
      Width => "5",
      Position => "4:0", # Excel Formula: =calc_position(F65,E66,TRUE)
      Type => "Config",
      UsedBy => "res",
      DefaultValue => "d10",
      DocName => "Slice[n]PortDspLbConsistenceCacheClockOffset",
      Comments => "counts number of valid members currently in cache",
    },
    slice1_stage2_lb_Consistence_cache_clock_threshold => { #Structure Type: RegField; ArrayLength: 4; ArrayIndex: 2; ArrayLocationInName: 13;
      Name => "slice1_stage[n]_lb_Consistence_cache_clock_threshold",
      RegMem => "RegField",
      Description => "Cache-entry will be erased only if read by the design, and:
(Curr-time - Cache-payload.Time-stamp) > Cfg-Threshold",
      Width => "10",
      Position => "14:5", # Excel Formula: =calc_position(F66,E67)
      Type => "Config",
      UsedBy => "res",
      DefaultValue => "d1000",
      DocName => "Slice[n]PortDspLbConsistenceCacheClockThreshold",
      Comments => "counts number of valid members currently in cache",
    },
  },
  slice1_stage3_lb_Consistence_cache_clk_and_timer_attr => { #Structure Type: Reg; ArrayLength: 4; ArrayIndex: 3; ArrayLocationInName: 13;
    Name => "slice1_stage[4]_lb_Consistence_cache_clk_and_timer_attr",
    RegMem => "Reg",
    Address => "11C",
    Description => "This register Controls the cache-time-stamp resolution/scale
The design contains 32b counter which counts clock-cycles:
* Initialize on reset: clks-counter = 0
* Increment every clk

This register defines the desired time-scale out of this reg.
The picked time-scale is used for both the following:
1. The time-stamp that be taken and wrriten to the cache-table.
2. The threshold in which the cache-entry will be aged.",
    Width => "15", # Excel Formula: =calc_reg_width(E66:E67,F67)
    Type => "Config",
    DocName => "Slice[2]PortDspLbConsistenceCacheClkAndTimerAttr",
    ArrayLength => "4",
    ArrayIndex => "3",
    slice1_stage3_lb_Consistence_cache_clock_offset => { #Structure Type: RegField; ArrayLength: 4; ArrayIndex: 3; ArrayLocationInName: 13;
      Name => "slice1_stage[n]_lb_Consistence_cache_clock_offset",
      RegMem => "RegField",
      Description => "Desired offset from the 32b clocks-counter:
Curr-time = clks-counter[Cfg-offset +: 4]
For example: if the clock-cycle is 1ns, and the desired resolution is 1us, than the offset should be 10
",
      Width => "5",
      Position => "4:0", # Excel Formula: =calc_position(F65,E66,TRUE)
      Type => "Config",
      UsedBy => "res",
      DefaultValue => "d10",
      DocName => "Slice[n]PortDspLbConsistenceCacheClockOffset",
      Comments => "counts number of valid members currently in cache",
    },
    slice1_stage3_lb_Consistence_cache_clock_threshold => { #Structure Type: RegField; ArrayLength: 4; ArrayIndex: 3; ArrayLocationInName: 13;
      Name => "slice1_stage[n]_lb_Consistence_cache_clock_threshold",
      RegMem => "RegField",
      Description => "Cache-entry will be erased only if read by the design, and:
(Curr-time - Cache-payload.Time-stamp) > Cfg-Threshold",
      Width => "10",
      Position => "14:5", # Excel Formula: =calc_position(F66,E67)
      Type => "Config",
      UsedBy => "res",
      DefaultValue => "d1000",
      DocName => "Slice[n]PortDspLbConsistenceCacheClockThreshold",
      Comments => "counts number of valid members currently in cache",
    },
  },
  slice1_stage0_lb_Consistence_cache_count => { #Structure Type: Reg; ArrayLength: 4; ArrayIndex: 0; ArrayLocationInName: 13;
    Name => "slice1_stage[4]_lb_Consistence_cache_count",
    RegMem => "Reg",
    Address => "11D", # Excel Formula: =calc_reg_address(C65,A65,G65)
    Description => "Number of elements currently in cache. When cache is active, this register is managed by the Design. Because each cahce is read only when packet arrives with the corresponding LB-Key, it is posibble that before changing another group-size, the cache-count will not be 0. for this reason:
Before changing Group-size of another gourp-id, If (cache-counter =! 0) then the User should do the following:
a. Write 0 to all entries in the cache-table (thats done for reser the valid bit in the table)
b. Write 0 to this registen (cache-count = 0)",
    Width => "13", # Excel Formula: =calc_reg_width(E69:E69,F69)
    Type => "External",
    UsedBy => "res",
    DocName => "Slice[2]PortDspLbConsistenceCacheCount",
    ArrayLength => "4",
    ArrayIndex => "0",
    slice1_stage0_lb_Consistence_cache_count_r => { #Structure Type: RegField; ArrayLength: 4; ArrayIndex: 0; ArrayLocationInName: 13;
      Name => "slice1_stage[n]_lb_Consistence_cache_count_r",
      RegMem => "RegField",
      Description => "counts number of elements currently in cache. Can be zeroize by CPU after empting the consistency-table by the CPU.",
      Width => "13", # Excel Formula: =calc_field_width_define("RES_REDUCED_LB_KEY_WIDTH")+1
      Position => "12:0", # Excel Formula: =calc_position(F68,E69,TRUE)
      Type => "External",
      DocName => "Slice[n]PortDspLbConsistenceCacheCountR",
      Comments => "counts number of valid members currently in cache",
    },
  },
  slice1_stage1_lb_Consistence_cache_count => { #Structure Type: Reg; ArrayLength: 4; ArrayIndex: 1; ArrayLocationInName: 13;
    Name => "slice1_stage[4]_lb_Consistence_cache_count",
    RegMem => "Reg",
    Address => "11E",
    Description => "Number of elements currently in cache. When cache is active, this register is managed by the Design. Because each cahce is read only when packet arrives with the corresponding LB-Key, it is posibble that before changing another group-size, the cache-count will not be 0. for this reason:
Before changing Group-size of another gourp-id, If (cache-counter =! 0) then the User should do the following:
a. Write 0 to all entries in the cache-table (thats done for reser the valid bit in the table)
b. Write 0 to this registen (cache-count = 0)",
    Width => "13", # Excel Formula: =calc_reg_width(E69:E69,F69)
    Type => "External",
    UsedBy => "res",
    DocName => "Slice[2]PortDspLbConsistenceCacheCount",
    ArrayLength => "4",
    ArrayIndex => "1",
    slice1_stage1_lb_Consistence_cache_count_r => { #Structure Type: RegField; ArrayLength: 4; ArrayIndex: 1; ArrayLocationInName: 13;
      Name => "slice1_stage[n]_lb_Consistence_cache_count_r",
      RegMem => "RegField",
      Description => "counts number of elements currently in cache. Can be zeroize by CPU after empting the consistency-table by the CPU.",
      Width => "13", # Excel Formula: =calc_field_width_define("RES_REDUCED_LB_KEY_WIDTH")+1
      Position => "12:0", # Excel Formula: =calc_position(F68,E69,TRUE)
      Type => "External",
      DocName => "Slice[n]PortDspLbConsistenceCacheCountR",
      Comments => "counts number of valid members currently in cache",
    },
  },
  slice1_stage2_lb_Consistence_cache_count => { #Structure Type: Reg; ArrayLength: 4; ArrayIndex: 2; ArrayLocationInName: 13;
    Name => "slice1_stage[4]_lb_Consistence_cache_count",
    RegMem => "Reg",
    Address => "11F",
    Description => "Number of elements currently in cache. When cache is active, this register is managed by the Design. Because each cahce is read only when packet arrives with the corresponding LB-Key, it is posibble that before changing another group-size, the cache-count will not be 0. for this reason:
Before changing Group-size of another gourp-id, If (cache-counter =! 0) then the User should do the following:
a. Write 0 to all entries in the cache-table (thats done for reser the valid bit in the table)
b. Write 0 to this registen (cache-count = 0)",
    Width => "13", # Excel Formula: =calc_reg_width(E69:E69,F69)
    Type => "External",
    UsedBy => "res",
    DocName => "Slice[2]PortDspLbConsistenceCacheCount",
    ArrayLength => "4",
    ArrayIndex => "2",
    slice1_stage2_lb_Consistence_cache_count_r => { #Structure Type: RegField; ArrayLength: 4; ArrayIndex: 2; ArrayLocationInName: 13;
      Name => "slice1_stage[n]_lb_Consistence_cache_count_r",
      RegMem => "RegField",
      Description => "counts number of elements currently in cache. Can be zeroize by CPU after empting the consistency-table by the CPU.",
      Width => "13", # Excel Formula: =calc_field_width_define("RES_REDUCED_LB_KEY_WIDTH")+1
      Position => "12:0", # Excel Formula: =calc_position(F68,E69,TRUE)
      Type => "External",
      DocName => "Slice[n]PortDspLbConsistenceCacheCountR",
      Comments => "counts number of valid members currently in cache",
    },
  },
  slice1_stage3_lb_Consistence_cache_count => { #Structure Type: Reg; ArrayLength: 4; ArrayIndex: 3; ArrayLocationInName: 13;
    Name => "slice1_stage[4]_lb_Consistence_cache_count",
    RegMem => "Reg",
    Address => "120",
    Description => "Number of elements currently in cache. When cache is active, this register is managed by the Design. Because each cahce is read only when packet arrives with the corresponding LB-Key, it is posibble that before changing another group-size, the cache-count will not be 0. for this reason:
Before changing Group-size of another gourp-id, If (cache-counter =! 0) then the User should do the following:
a. Write 0 to all entries in the cache-table (thats done for reser the valid bit in the table)
b. Write 0 to this registen (cache-count = 0)",
    Width => "13", # Excel Formula: =calc_reg_width(E69:E69,F69)
    Type => "External",
    UsedBy => "res",
    DocName => "Slice[2]PortDspLbConsistenceCacheCount",
    ArrayLength => "4",
    ArrayIndex => "3",
    slice1_stage3_lb_Consistence_cache_count_r => { #Structure Type: RegField; ArrayLength: 4; ArrayIndex: 3; ArrayLocationInName: 13;
      Name => "slice1_stage[n]_lb_Consistence_cache_count_r",
      RegMem => "RegField",
      Description => "counts number of elements currently in cache. Can be zeroize by CPU after empting the consistency-table by the CPU.",
      Width => "13", # Excel Formula: =calc_field_width_define("RES_REDUCED_LB_KEY_WIDTH")+1
      Position => "12:0", # Excel Formula: =calc_position(F68,E69,TRUE)
      Type => "External",
      DocName => "Slice[n]PortDspLbConsistenceCacheCountR",
      Comments => "counts number of valid members currently in cache",
    },
  },
  slice1_stage0_lb_Consistence_attr => { #Structure Type: Reg;
    Name => "slice1_stage0_lb_Consistence_attr",
    RegMem => "Reg",
    Address => "121", # Excel Formula: =calc_reg_address(C68,A68,G68)
    Description => "Consistence attributes is an external register used to inform the design that a group-size had been changed, and start a consistency sequence.
1. When Group-size changed, the user should write to the external regs the following:
a. Valid = 1'b1
b. Cache-Group-id (the group which had changed)
c. Prev-group-size (the value which is found in the group-size-table)
d. Current-group-size (the new group-size = Prev-group-size1)
e. Timer-value (32b in clks resolution) //this starts the learn timer
f. Removed-member-id + valid (if group-size decreased)
2. Before changing Group-size of another gourp-id, write to the external regs the following:
a. Valid = 1'b0
",
    Width => "76", # Excel Formula: =calc_reg_width(E71:E77,F77)
    Type => "External",
    UsedBy => "res",
    DocName => "Slice[2]PortDspLbConsistenceAttr",
    AdditionalInfo => "ExternalBackdoorWriteEnable",
    slice1_stage0_lb_Consistence_group_id_r => { #Structure Type: RegField;
      Name => "slice1_stage0_lb_Consistence_group_id_r",
      RegMem => "RegField",
      Description => "The group-id which is currently used for consistence (the group that had been changed)",
      Width => "15",
      Position => "14:0", # Excel Formula: =calc_position(F70,E71,TRUE)
      Type => "External",
      DocName => "Slice[n]PortDspLbConsistenceGroupIdR",
    },
    slice1_stage0_lb_Consistence_valid_r => { #Structure Type: RegField;
      Name => "slice1_stage0_lb_Consistence_valid_r",
      RegMem => "RegField",
      Description => "when set, current and prev group-size will be taken from the value wrriten in those external-regs.
Should be set by CPU when group-size changed, and reset by CPU after consistence process has done",
      Width => "1",
      Position => "15", # Excel Formula: =calc_position(F71,E72)
      Type => "External",
      DocName => "Slice[n]PortDspLbConsistenceValidR",
    },
    slice1_stage0_lb_Consistence_prev_group_size_r => { #Structure Type: RegField;
      Name => "slice1_stage0_lb_Consistence_prev_group_size_r",
      RegMem => "RegField",
      Description => "prev-group-size of the consistence-group-id",
      Width => "9",
      Position => "24:16", # Excel Formula: =calc_position(F72,E73)
      Type => "External",
      DocName => "Slice[n]PortDspLbConsistencePrevGroupSizeR",
    },
    slice1_stage0_lb_Consistence_curr_group_size_r => { #Structure Type: RegField;
      Name => "slice1_stage0_lb_Consistence_curr_group_size_r",
      RegMem => "RegField",
      Description => "The new group-size of the cache-group-id. 
Valid values are prev-group-size1.",
      Width => "9",
      Position => "33:25", # Excel Formula: =calc_position(F73,E74)
      Type => "External",
      DocName => "Slice[n]PortDspLbConsistenceCurrGroupSizeR",
    },
    slice1_stage0_lb_Consistence_removed_member_id_r => { #Structure Type: RegField;
      Name => "slice1_stage0_lb_Consistence_removed_member_id_r",
      RegMem => "RegField",
      Description => "The removed-member-id (when valid is set)",
      Width => "9",
      Position => "42:34", # Excel Formula: =calc_position(F74,E75)
      Type => "External",
      DocName => "Slice[n]PortDspLbConsistenceRemovedMemberIdR",
    },
    slice1_stage0_lb_Consistence_removed_member_id_valid_r => { #Structure Type: RegField;
      Name => "slice1_stage0_lb_Consistence_removed_member_id_valid_r",
      RegMem => "RegField",
      Description => "Removed member ID field is valid. If valid it means that the group-size decreased by one",
      Width => "1",
      Position => "43", # Excel Formula: =calc_position(F75,E76)
      Type => "External",
      DocName => "Slice[n]PortDspLbConsistenceRemovedMemberIdValidR",
    },
    slice1_stage0_lb_Consistence_timer_value_r => { #Structure Type: RegField;
      Name => "slice1_stage0_lb_Consistence_timer_value_r",
      RegMem => "RegField",
      Description => "holds the current timer value. If equals 0 it mean the timer is not currently active. When consistence is valid:
Timer-is-active: learn
Timer is not active: use-cached",
      Width => "32", # Excel Formula: =calc_field_width_define("RES_LB_CONSISTENCE_TIMER_WIDTH")
      Position => "75:44", # Excel Formula: =calc_position(F76,E77)
      Type => "External",
      DocName => "Slice[n]PortDspLbConsistenceTimerValueR",
    },
  },
  slice0_stage0_lb_Consistence_attr => { #Structure Type: Reg;
    Name => "slice0_stage0_lb_Consistence_attr",
    RegMem => "Reg",
    Address => "122", # Excel Formula: =calc_reg_address(C70,A70,G70)
    Description => "Consistence attributes is an external register used to inform the design that a group-size had been changed, and start a consistency sequence.
1. When Group-size changed, the user should write to the external regs the following:
a. Valid = 1'b1
b. Cache-Group-id (the group which had changed)
c. Prev-group-size (the value which is found in the group-size-table)
d. Current-group-size (the new group-size = Prev-group-size1)
e. Timer-value (32b in clks resolution) //this starts the learn timer
f. Removed-member-id + valid (if group-size decreased)
2. Before changing Group-size of another gourp-id, write to the external regs the following:
a. Valid = 1'b0
",
    Width => "76", # Excel Formula: =calc_reg_width(E79:E85,F85)
    Type => "External",
    UsedBy => "res",
    DocName => "Slice[2]PortDspLbConsistenceAttr",
    AdditionalInfo => "ExternalBackdoorWriteEnable",
    slice0_stage0_lb_Consistence_group_id_r => { #Structure Type: RegField;
      Name => "slice0_stage0_lb_Consistence_group_id_r",
      RegMem => "RegField",
      Description => "The group-id which is currently used for consistence (the group that had been changed)",
      Width => "15",
      Position => "14:0", # Excel Formula: =calc_position(F78,E79,TRUE)
      Type => "External",
      DocName => "Slice[n]PortDspLbConsistenceGroupIdR",
    },
    slice0_stage0_lb_Consistence_valid_r => { #Structure Type: RegField;
      Name => "slice0_stage0_lb_Consistence_valid_r",
      RegMem => "RegField",
      Description => "when set, current and prev group-size will be taken from the value wrriten in those external-regs.
Should be set by CPU when group-size changed, and reset by CPU after consistence process has done",
      Width => "1",
      Position => "15", # Excel Formula: =calc_position(F79,E80)
      Type => "External",
      DocName => "Slice[n]PortDspLbConsistenceValidR",
    },
    slice0_stage0_lb_Consistence_prev_group_size_r => { #Structure Type: RegField;
      Name => "slice0_stage0_lb_Consistence_prev_group_size_r",
      RegMem => "RegField",
      Description => "prev-group-size of the consistence-group-id",
      Width => "9",
      Position => "24:16", # Excel Formula: =calc_position(F80,E81)
      Type => "External",
      DocName => "Slice[n]PortDspLbConsistencePrevGroupSizeR",
    },
    slice0_stage0_lb_Consistence_curr_group_size_r => { #Structure Type: RegField;
      Name => "slice0_stage0_lb_Consistence_curr_group_size_r",
      RegMem => "RegField",
      Description => "The new group-size of the cache-group-id. 
Valid values are prev-group-size1.",
      Width => "9",
      Position => "33:25", # Excel Formula: =calc_position(F81,E82)
      Type => "External",
      DocName => "Slice[n]PortDspLbConsistenceCurrGroupSizeR",
    },
    slice0_stage0_lb_Consistence_removed_member_id_r => { #Structure Type: RegField;
      Name => "slice0_stage0_lb_Consistence_removed_member_id_r",
      RegMem => "RegField",
      Description => "The removed-member-id (when valid is set)",
      Width => "9",
      Position => "42:34", # Excel Formula: =calc_position(F82,E83)
      Type => "External",
      DocName => "Slice[n]PortDspLbConsistenceRemovedMemberIdR",
    },
    slice0_stage0_lb_Consistence_removed_member_id_valid_r => { #Structure Type: RegField;
      Name => "slice0_stage0_lb_Consistence_removed_member_id_valid_r",
      RegMem => "RegField",
      Description => "Removed member ID field is valid. If valid it means that the group-size decreased by one",
      Width => "1",
      Position => "43", # Excel Formula: =calc_position(F83,E84)
      Type => "External",
      DocName => "Slice[n]PortDspLbConsistenceRemovedMemberIdValidR",
    },
    slice0_stage0_lb_Consistence_timer_value_r => { #Structure Type: RegField;
      Name => "slice0_stage0_lb_Consistence_timer_value_r",
      RegMem => "RegField",
      Description => "holds the current timer value. If equals 0 it mean the timer is not currently active. When consistence is valid:
Timer-is-active: learn
Timer is not active: use-cached",
      Width => "32", # Excel Formula: =calc_field_width_define("RES_LB_CONSISTENCE_TIMER_WIDTH")
      Position => "75:44", # Excel Formula: =calc_position(F84,E85)
      Type => "External",
      DocName => "Slice[n]PortDspLbConsistenceTimerValueR",
    },
  },
  slice1_stage1_lb_Consistence_attr => { #Structure Type: Reg;
    Name => "slice1_stage1_lb_Consistence_attr",
    RegMem => "Reg",
    Address => "123", # Excel Formula: =calc_reg_address(C78,A78,G78)
    Description => "Consistence attributes is an external register used to inform the design that a group-size had been changed, and start a consistency sequence.
1. When Group-size changed, the user should write to the external regs the following:
a. Valid = 1'b1
b. Cache-Group-id (the group which had changed)
c. Prev-group-size (the value which is found in the group-size-table)
d. Current-group-size (the new group-size = Prev-group-size1)
e. Timer-value (32b in clks resolution) //this starts the learn timer
f. Removed-member-id + valid (if group-size decreased)
2. Before changing Group-size of another gourp-id, write to the external regs the following:
a. Valid = 1'b0
",
    Width => "75", # Excel Formula: =calc_reg_width(E87:E93,F93)
    Type => "External",
    UsedBy => "res",
    DocName => "Slice[2]PortDspLbConsistenceAttr",
    AdditionalInfo => "ExternalBackdoorWriteEnable",
    slice1_stage1_lb_Consistence_group_id_r => { #Structure Type: RegField;
      Name => "slice1_stage1_lb_Consistence_group_id_r",
      RegMem => "RegField",
      Description => "The group-id which is currently used for consistence (the group that had been changed)",
      Width => "14",
      Position => "13:0", # Excel Formula: =calc_position(F86,E87,TRUE)
      Type => "External",
      DocName => "Slice[n]PortDspLbConsistenceGroupIdR",
    },
    slice1_stage1_lb_Consistence_valid_r => { #Structure Type: RegField;
      Name => "slice1_stage1_lb_Consistence_valid_r",
      RegMem => "RegField",
      Description => "when set, current and prev group-size will be taken from the value wrriten in those external-regs.
Should be set by CPU when group-size changed, and reset by CPU after consistence process has done",
      Width => "1",
      Position => "14", # Excel Formula: =calc_position(F87,E88)
      Type => "External",
      DocName => "Slice[n]PortDspLbConsistenceValidR",
    },
    slice1_stage1_lb_Consistence_prev_group_size_r => { #Structure Type: RegField;
      Name => "slice1_stage1_lb_Consistence_prev_group_size_r",
      RegMem => "RegField",
      Description => "prev-group-size of the consistence-group-id",
      Width => "9",
      Position => "23:15", # Excel Formula: =calc_position(F88,E89)
      Type => "External",
      DocName => "Slice[n]PortDspLbConsistencePrevGroupSizeR",
    },
    slice1_stage1_lb_Consistence_curr_group_size_r => { #Structure Type: RegField;
      Name => "slice1_stage1_lb_Consistence_curr_group_size_r",
      RegMem => "RegField",
      Description => "The new group-size of the cache-group-id. 
Valid values are prev-group-size1.",
      Width => "9",
      Position => "32:24", # Excel Formula: =calc_position(F89,E90)
      Type => "External",
      DocName => "Slice[n]PortDspLbConsistenceCurrGroupSizeR",
    },
    slice1_stage1_lb_Consistence_removed_member_id_r => { #Structure Type: RegField;
      Name => "slice1_stage1_lb_Consistence_removed_member_id_r",
      RegMem => "RegField",
      Description => "The removed-member-id (when valid is set)",
      Width => "9",
      Position => "41:33", # Excel Formula: =calc_position(F90,E91)
      Type => "External",
      DocName => "Slice[n]PortDspLbConsistenceRemovedMemberIdR",
    },
    slice1_stage1_lb_Consistence_removed_member_id_valid_r => { #Structure Type: RegField;
      Name => "slice1_stage1_lb_Consistence_removed_member_id_valid_r",
      RegMem => "RegField",
      Description => "Removed member ID field is valid. If valid it means that the group-size decreased by one",
      Width => "1",
      Position => "42", # Excel Formula: =calc_position(F91,E92)
      Type => "External",
      DocName => "Slice[n]PortDspLbConsistenceRemovedMemberIdValidR",
    },
    slice1_stage1_lb_Consistence_timer_value_r => { #Structure Type: RegField;
      Name => "slice1_stage1_lb_Consistence_timer_value_r",
      RegMem => "RegField",
      Description => "holds the current timer value. If equals 0 it mean the timer is not currently active. When consistence is valid:
Timer-is-active: learn
Timer is not active: use-cached",
      Width => "32", # Excel Formula: =calc_field_width_define("RES_LB_CONSISTENCE_TIMER_WIDTH")
      Position => "74:43", # Excel Formula: =calc_position(F92,E93)
      Type => "External",
      DocName => "Slice[n]PortDspLbConsistenceTimerValueR",
    },
  },
  slice0_stage1_lb_Consistence_attr => { #Structure Type: Reg;
    Name => "slice0_stage1_lb_Consistence_attr",
    RegMem => "Reg",
    Address => "124", # Excel Formula: =calc_reg_address(C86,A86,G86)
    Description => "Consistence attributes is an external register used to inform the design that a group-size had been changed, and start a consistency sequence.
1. When Group-size changed, the user should write to the external regs the following:
a. Valid = 1'b1
b. Cache-Group-id (the group which had changed)
c. Prev-group-size (the value which is found in the group-size-table)
d. Current-group-size (the new group-size = Prev-group-size1)
e. Timer-value (32b in clks resolution) //this starts the learn timer
f. Removed-member-id + valid (if group-size decreased)
2. Before changing Group-size of another gourp-id, write to the external regs the following:
a. Valid = 1'b0
",
    Width => "75", # Excel Formula: =calc_reg_width(E95:E101,F101)
    Type => "External",
    UsedBy => "res",
    DocName => "Slice[2]PortDspLbConsistenceAttr",
    AdditionalInfo => "ExternalBackdoorWriteEnable",
    slice0_stage1_lb_Consistence_group_id_r => { #Structure Type: RegField;
      Name => "slice0_stage1_lb_Consistence_group_id_r",
      RegMem => "RegField",
      Description => "The group-id which is currently used for consistence (the group that had been changed)",
      Width => "14",
      Position => "13:0", # Excel Formula: =calc_position(F94,E95,TRUE)
      Type => "External",
      DocName => "Slice[n]PortDspLbConsistenceGroupIdR",
    },
    slice0_stage1_lb_Consistence_valid_r => { #Structure Type: RegField;
      Name => "slice0_stage1_lb_Consistence_valid_r",
      RegMem => "RegField",
      Description => "when set, current and prev group-size will be taken from the value wrriten in those external-regs.
Should be set by CPU when group-size changed, and reset by CPU after consistence process has done",
      Width => "1",
      Position => "14", # Excel Formula: =calc_position(F95,E96)
      Type => "External",
      DocName => "Slice[n]PortDspLbConsistenceValidR",
    },
    slice0_stage1_lb_Consistence_prev_group_size_r => { #Structure Type: RegField;
      Name => "slice0_stage1_lb_Consistence_prev_group_size_r",
      RegMem => "RegField",
      Description => "prev-group-size of the consistence-group-id",
      Width => "9",
      Position => "23:15", # Excel Formula: =calc_position(F96,E97)
      Type => "External",
      DocName => "Slice[n]PortDspLbConsistencePrevGroupSizeR",
    },
    slice0_stage1_lb_Consistence_curr_group_size_r => { #Structure Type: RegField;
      Name => "slice0_stage1_lb_Consistence_curr_group_size_r",
      RegMem => "RegField",
      Description => "The new group-size of the cache-group-id. 
Valid values are prev-group-size1.",
      Width => "9",
      Position => "32:24", # Excel Formula: =calc_position(F97,E98)
      Type => "External",
      DocName => "Slice[n]PortDspLbConsistenceCurrGroupSizeR",
    },
    slice0_stage1_lb_Consistence_removed_member_id_r => { #Structure Type: RegField;
      Name => "slice0_stage1_lb_Consistence_removed_member_id_r",
      RegMem => "RegField",
      Description => "The removed-member-id (when valid is set)",
      Width => "9",
      Position => "41:33", # Excel Formula: =calc_position(F98,E99)
      Type => "External",
      DocName => "Slice[n]PortDspLbConsistenceRemovedMemberIdR",
    },
    slice0_stage1_lb_Consistence_removed_member_id_valid_r => { #Structure Type: RegField;
      Name => "slice0_stage1_lb_Consistence_removed_member_id_valid_r",
      RegMem => "RegField",
      Description => "Removed member ID field is valid. If valid it means that the group-size decreased by one",
      Width => "1",
      Position => "42", # Excel Formula: =calc_position(F99,E100)
      Type => "External",
      DocName => "Slice[n]PortDspLbConsistenceRemovedMemberIdValidR",
    },
    slice0_stage1_lb_Consistence_timer_value_r => { #Structure Type: RegField;
      Name => "slice0_stage1_lb_Consistence_timer_value_r",
      RegMem => "RegField",
      Description => "holds the current timer value. If equals 0 it mean the timer is not currently active. When consistence is valid:
Timer-is-active: learn
Timer is not active: use-cached",
      Width => "32", # Excel Formula: =calc_field_width_define("RES_LB_CONSISTENCE_TIMER_WIDTH")
      Position => "74:43", # Excel Formula: =calc_position(F100,E101)
      Type => "External",
      DocName => "Slice[n]PortDspLbConsistenceTimerValueR",
    },
  },
  slice1_stage2_lb_Consistence_attr => { #Structure Type: Reg;
    Name => "slice1_stage2_lb_Consistence_attr",
    RegMem => "Reg",
    Address => "125", # Excel Formula: =calc_reg_address(C94,A94,G94)
    Description => "Consistence attributes is an external register used to inform the design that a group-size had been changed, and start a consistency sequence.
1. When Group-size changed, the user should write to the external regs the following:
a. Valid = 1'b1
b. Cache-Group-id (the group which had changed)
c. Prev-group-size (the value which is found in the group-size-table)
d. Current-group-size (the new group-size = Prev-group-size1)
e. Timer-value (32b in clks resolution) //this starts the learn timer
f. Removed-member-id + valid (if group-size decreased)
2. Before changing Group-size of another gourp-id, write to the external regs the following:
a. Valid = 1'b0
",
    Width => "75", # Excel Formula: =calc_reg_width(E103:E109,F109)
    Type => "External",
    UsedBy => "res",
    DocName => "Slice[2]PortDspLbConsistenceAttr",
    AdditionalInfo => "ExternalBackdoorWriteEnable",
    slice1_stage2_lb_Consistence_group_id_r => { #Structure Type: RegField;
      Name => "slice1_stage2_lb_Consistence_group_id_r",
      RegMem => "RegField",
      Description => "The group-id which is currently used for consistence (the group that had been changed)",
      Width => "14",
      Position => "13:0", # Excel Formula: =calc_position(F102,E103,TRUE)
      Type => "External",
      DocName => "Slice[n]PortDspLbConsistenceGroupIdR",
    },
    slice1_stage2_lb_Consistence_valid_r => { #Structure Type: RegField;
      Name => "slice1_stage2_lb_Consistence_valid_r",
      RegMem => "RegField",
      Description => "when set, current and prev group-size will be taken from the value wrriten in those external-regs.
Should be set by CPU when group-size changed, and reset by CPU after consistence process has done",
      Width => "1",
      Position => "14", # Excel Formula: =calc_position(F103,E104)
      Type => "External",
      DocName => "Slice[n]PortDspLbConsistenceValidR",
    },
    slice1_stage2_lb_Consistence_prev_group_size_r => { #Structure Type: RegField;
      Name => "slice1_stage2_lb_Consistence_prev_group_size_r",
      RegMem => "RegField",
      Description => "prev-group-size of the consistence-group-id",
      Width => "9",
      Position => "23:15", # Excel Formula: =calc_position(F104,E105)
      Type => "External",
      DocName => "Slice[n]PortDspLbConsistencePrevGroupSizeR",
    },
    slice1_stage2_lb_Consistence_curr_group_size_r => { #Structure Type: RegField;
      Name => "slice1_stage2_lb_Consistence_curr_group_size_r",
      RegMem => "RegField",
      Description => "The new group-size of the cache-group-id. 
Valid values are prev-group-size1.",
      Width => "9",
      Position => "32:24", # Excel Formula: =calc_position(F105,E106)
      Type => "External",
      DocName => "Slice[n]PortDspLbConsistenceCurrGroupSizeR",
    },
    slice1_stage2_lb_Consistence_removed_member_id_r => { #Structure Type: RegField;
      Name => "slice1_stage2_lb_Consistence_removed_member_id_r",
      RegMem => "RegField",
      Description => "The removed-member-id (when valid is set)",
      Width => "9",
      Position => "41:33", # Excel Formula: =calc_position(F106,E107)
      Type => "External",
      DocName => "Slice[n]PortDspLbConsistenceRemovedMemberIdR",
    },
    slice1_stage2_lb_Consistence_removed_member_id_valid_r => { #Structure Type: RegField;
      Name => "slice1_stage2_lb_Consistence_removed_member_id_valid_r",
      RegMem => "RegField",
      Description => "Removed member ID field is valid. If valid it means that the group-size decreased by one",
      Width => "1",
      Position => "42", # Excel Formula: =calc_position(F107,E108)
      Type => "External",
      DocName => "Slice[n]PortDspLbConsistenceRemovedMemberIdValidR",
    },
    slice1_stage2_lb_Consistence_timer_value_r => { #Structure Type: RegField;
      Name => "slice1_stage2_lb_Consistence_timer_value_r",
      RegMem => "RegField",
      Description => "holds the current timer value. If equals 0 it mean the timer is not currently active. When consistence is valid:
Timer-is-active: learn
Timer is not active: use-cached",
      Width => "32", # Excel Formula: =calc_field_width_define("RES_LB_CONSISTENCE_TIMER_WIDTH")
      Position => "74:43", # Excel Formula: =calc_position(F108,E109)
      Type => "External",
      DocName => "Slice[n]PortDspLbConsistenceTimerValueR",
    },
  },
  slice0_stage2_lb_Consistence_attr => { #Structure Type: Reg;
    Name => "slice0_stage2_lb_Consistence_attr",
    RegMem => "Reg",
    Address => "126", # Excel Formula: =calc_reg_address(C102,A102,G102)
    Description => "Consistence attributes is an external register used to inform the design that a group-size had been changed, and start a consistency sequence.
1. When Group-size changed, the user should write to the external regs the following:
a. Valid = 1'b1
b. Cache-Group-id (the group which had changed)
c. Prev-group-size (the value which is found in the group-size-table)
d. Current-group-size (the new group-size = Prev-group-size1)
e. Timer-value (32b in clks resolution) //this starts the learn timer
f. Removed-member-id + valid (if group-size decreased)
2. Before changing Group-size of another gourp-id, write to the external regs the following:
a. Valid = 1'b0
",
    Width => "75", # Excel Formula: =calc_reg_width(E111:E117,F117)
    Type => "External",
    UsedBy => "res",
    DocName => "Slice[2]PortDspLbConsistenceAttr",
    AdditionalInfo => "ExternalBackdoorWriteEnable",
    slice0_stage2_lb_Consistence_group_id_r => { #Structure Type: RegField;
      Name => "slice0_stage2_lb_Consistence_group_id_r",
      RegMem => "RegField",
      Description => "The group-id which is currently used for consistence (the group that had been changed)",
      Width => "14",
      Position => "13:0", # Excel Formula: =calc_position(F110,E111,TRUE)
      Type => "External",
      DocName => "Slice[n]PortDspLbConsistenceGroupIdR",
    },
    slice0_stage2_lb_Consistence_valid_r => { #Structure Type: RegField;
      Name => "slice0_stage2_lb_Consistence_valid_r",
      RegMem => "RegField",
      Description => "when set, current and prev group-size will be taken from the value wrriten in those external-regs.
Should be set by CPU when group-size changed, and reset by CPU after consistence process has done",
      Width => "1",
      Position => "14", # Excel Formula: =calc_position(F111,E112)
      Type => "External",
      DocName => "Slice[n]PortDspLbConsistenceValidR",
    },
    slice0_stage2_lb_Consistence_prev_group_size_r => { #Structure Type: RegField;
      Name => "slice0_stage2_lb_Consistence_prev_group_size_r",
      RegMem => "RegField",
      Description => "prev-group-size of the consistence-group-id",
      Width => "9",
      Position => "23:15", # Excel Formula: =calc_position(F112,E113)
      Type => "External",
      DocName => "Slice[n]PortDspLbConsistencePrevGroupSizeR",
    },
    slice0_stage2_lb_Consistence_curr_group_size_r => { #Structure Type: RegField;
      Name => "slice0_stage2_lb_Consistence_curr_group_size_r",
      RegMem => "RegField",
      Description => "The new group-size of the cache-group-id. 
Valid values are prev-group-size1.",
      Width => "9",
      Position => "32:24", # Excel Formula: =calc_position(F113,E114)
      Type => "External",
      DocName => "Slice[n]PortDspLbConsistenceCurrGroupSizeR",
    },
    slice0_stage2_lb_Consistence_removed_member_id_r => { #Structure Type: RegField;
      Name => "slice0_stage2_lb_Consistence_removed_member_id_r",
      RegMem => "RegField",
      Description => "The removed-member-id (when valid is set)",
      Width => "9",
      Position => "41:33", # Excel Formula: =calc_position(F114,E115)
      Type => "External",
      DocName => "Slice[n]PortDspLbConsistenceRemovedMemberIdR",
    },
    slice0_stage2_lb_Consistence_removed_member_id_valid_r => { #Structure Type: RegField;
      Name => "slice0_stage2_lb_Consistence_removed_member_id_valid_r",
      RegMem => "RegField",
      Description => "Removed member ID field is valid. If valid it means that the group-size decreased by one",
      Width => "1",
      Position => "42", # Excel Formula: =calc_position(F115,E116)
      Type => "External",
      DocName => "Slice[n]PortDspLbConsistenceRemovedMemberIdValidR",
    },
    slice0_stage2_lb_Consistence_timer_value_r => { #Structure Type: RegField;
      Name => "slice0_stage2_lb_Consistence_timer_value_r",
      RegMem => "RegField",
      Description => "holds the current timer value. If equals 0 it mean the timer is not currently active. When consistence is valid:
Timer-is-active: learn
Timer is not active: use-cached",
      Width => "32", # Excel Formula: =calc_field_width_define("RES_LB_CONSISTENCE_TIMER_WIDTH")
      Position => "74:43", # Excel Formula: =calc_position(F116,E117)
      Type => "External",
      DocName => "Slice[n]PortDspLbConsistenceTimerValueR",
    },
  },
  slice1_stage3_lb_Consistence_attr => { #Structure Type: Reg;
    Name => "slice1_stage3_lb_Consistence_attr",
    RegMem => "Reg",
    Address => "127", # Excel Formula: =calc_reg_address(C110,A110,G110)
    Description => "Consistence attributes is an external register used to inform the design that a group-size had been changed, and start a consistency sequence.
1. When Group-size changed, the user should write to the external regs the following:
a. Valid = 1'b1
b. Cache-Group-id (the group which had changed)
c. Prev-group-size (the value which is found in the group-size-table)
d. Current-group-size (the new group-size = Prev-group-size1)
e. Timer-value (32b in clks resolution) //this starts the learn timer
f. Removed-member-id + valid (if group-size decreased)
2. Before changing Group-size of another gourp-id, write to the external regs the following:
a. Valid = 1'b0
",
    Width => "75", # Excel Formula: =calc_reg_width(E119:E125,F125)
    Type => "External",
    UsedBy => "res",
    DocName => "Slice[2]PortDspLbConsistenceAttr",
    AdditionalInfo => "ExternalBackdoorWriteEnable",
    slice1_stage3_lb_Consistence_group_id_r => { #Structure Type: RegField;
      Name => "slice1_stage3_lb_Consistence_group_id_r",
      RegMem => "RegField",
      Description => "The group-id which is currently used for consistence (the group that had been changed)",
      Width => "14",
      Position => "13:0", # Excel Formula: =calc_position(F118,E119,TRUE)
      Type => "External",
      DocName => "Slice[n]PortDspLbConsistenceGroupIdR",
    },
    slice1_stage3_lb_Consistence_valid_r => { #Structure Type: RegField;
      Name => "slice1_stage3_lb_Consistence_valid_r",
      RegMem => "RegField",
      Description => "when set, current and prev group-size will be taken from the value wrriten in those external-regs.
Should be set by CPU when group-size changed, and reset by CPU after consistence process has done",
      Width => "1",
      Position => "14", # Excel Formula: =calc_position(F119,E120)
      Type => "External",
      DocName => "Slice[n]PortDspLbConsistenceValidR",
    },
    slice1_stage3_lb_Consistence_prev_group_size_r => { #Structure Type: RegField;
      Name => "slice1_stage3_lb_Consistence_prev_group_size_r",
      RegMem => "RegField",
      Description => "prev-group-size of the consistence-group-id",
      Width => "9",
      Position => "23:15", # Excel Formula: =calc_position(F120,E121)
      Type => "External",
      DocName => "Slice[n]PortDspLbConsistencePrevGroupSizeR",
    },
    slice1_stage3_lb_Consistence_curr_group_size_r => { #Structure Type: RegField;
      Name => "slice1_stage3_lb_Consistence_curr_group_size_r",
      RegMem => "RegField",
      Description => "The new group-size of the cache-group-id. 
Valid values are prev-group-size1.",
      Width => "9",
      Position => "32:24", # Excel Formula: =calc_position(F121,E122)
      Type => "External",
      DocName => "Slice[n]PortDspLbConsistenceCurrGroupSizeR",
    },
    slice1_stage3_lb_Consistence_removed_member_id_r => { #Structure Type: RegField;
      Name => "slice1_stage3_lb_Consistence_removed_member_id_r",
      RegMem => "RegField",
      Description => "The removed-member-id (when valid is set)",
      Width => "9",
      Position => "41:33", # Excel Formula: =calc_position(F122,E123)
      Type => "External",
      DocName => "Slice[n]PortDspLbConsistenceRemovedMemberIdR",
    },
    slice1_stage3_lb_Consistence_removed_member_id_valid_r => { #Structure Type: RegField;
      Name => "slice1_stage3_lb_Consistence_removed_member_id_valid_r",
      RegMem => "RegField",
      Description => "Removed member ID field is valid. If valid it means that the group-size decreased by one",
      Width => "1",
      Position => "42", # Excel Formula: =calc_position(F123,E124)
      Type => "External",
      DocName => "Slice[n]PortDspLbConsistenceRemovedMemberIdValidR",
    },
    slice1_stage3_lb_Consistence_timer_value_r => { #Structure Type: RegField;
      Name => "slice1_stage3_lb_Consistence_timer_value_r",
      RegMem => "RegField",
      Description => "holds the current timer value. If equals 0 it mean the timer is not currently active. When consistence is valid:
Timer-is-active: learn
Timer is not active: use-cached",
      Width => "32", # Excel Formula: =calc_field_width_define("RES_LB_CONSISTENCE_TIMER_WIDTH")
      Position => "74:43", # Excel Formula: =calc_position(F124,E125)
      Type => "External",
      DocName => "Slice[n]PortDspLbConsistenceTimerValueR",
    },
  },
  slice0_stage3_lb_Consistence_attr => { #Structure Type: Reg;
    Name => "slice0_stage3_lb_Consistence_attr",
    RegMem => "Reg",
    Address => "128", # Excel Formula: =calc_reg_address(C118,A118,G118)
    Description => "Consistence attributes is an external register used to inform the design that a group-size had been changed, and start a consistency sequence.
1. When Group-size changed, the user should write to the external regs the following:
a. Valid = 1'b1
b. Cache-Group-id (the group which had changed)
c. Prev-group-size (the value which is found in the group-size-table)
d. Current-group-size (the new group-size = Prev-group-size1)
e. Timer-value (32b in clks resolution) //this starts the learn timer
f. Removed-member-id + valid (if group-size decreased)
2. Before changing Group-size of another gourp-id, write to the external regs the following:
a. Valid = 1'b0
",
    Width => "75", # Excel Formula: =calc_reg_width(E127:E133,F133)
    Type => "External",
    UsedBy => "res",
    DocName => "Slice[2]PortDspLbConsistenceAttr",
    AdditionalInfo => "ExternalBackdoorWriteEnable",
    slice0_stage3_lb_Consistence_group_id_r => { #Structure Type: RegField;
      Name => "slice0_stage3_lb_Consistence_group_id_r",
      RegMem => "RegField",
      Description => "The group-id which is currently used for consistence (the group that had been changed)",
      Width => "14",
      Position => "13:0", # Excel Formula: =calc_position(F126,E127,TRUE)
      Type => "External",
      DocName => "Slice[n]PortDspLbConsistenceGroupIdR",
    },
    slice0_stage3_lb_Consistence_valid_r => { #Structure Type: RegField;
      Name => "slice0_stage3_lb_Consistence_valid_r",
      RegMem => "RegField",
      Description => "when set, current and prev group-size will be taken from the value wrriten in those external-regs.
Should be set by CPU when group-size changed, and reset by CPU after consistence process has done",
      Width => "1",
      Position => "14", # Excel Formula: =calc_position(F127,E128)
      Type => "External",
      DocName => "Slice[n]PortDspLbConsistenceValidR",
    },
    slice0_stage3_lb_Consistence_prev_group_size_r => { #Structure Type: RegField;
      Name => "slice0_stage3_lb_Consistence_prev_group_size_r",
      RegMem => "RegField",
      Description => "prev-group-size of the consistence-group-id",
      Width => "9",
      Position => "23:15", # Excel Formula: =calc_position(F128,E129)
      Type => "External",
      DocName => "Slice[n]PortDspLbConsistencePrevGroupSizeR",
    },
    slice0_stage3_lb_Consistence_curr_group_size_r => { #Structure Type: RegField;
      Name => "slice0_stage3_lb_Consistence_curr_group_size_r",
      RegMem => "RegField",
      Description => "The new group-size of the cache-group-id. 
Valid values are prev-group-size1.",
      Width => "9",
      Position => "32:24", # Excel Formula: =calc_position(F129,E130)
      Type => "External",
      DocName => "Slice[n]PortDspLbConsistenceCurrGroupSizeR",
    },
    slice0_stage3_lb_Consistence_removed_member_id_r => { #Structure Type: RegField;
      Name => "slice0_stage3_lb_Consistence_removed_member_id_r",
      RegMem => "RegField",
      Description => "The removed-member-id (when valid is set)",
      Width => "9",
      Position => "41:33", # Excel Formula: =calc_position(F130,E131)
      Type => "External",
      DocName => "Slice[n]PortDspLbConsistenceRemovedMemberIdR",
    },
    slice0_stage3_lb_Consistence_removed_member_id_valid_r => { #Structure Type: RegField;
      Name => "slice0_stage3_lb_Consistence_removed_member_id_valid_r",
      RegMem => "RegField",
      Description => "Removed member ID field is valid. If valid it means that the group-size decreased by one",
      Width => "1",
      Position => "42", # Excel Formula: =calc_position(F131,E132)
      Type => "External",
      DocName => "Slice[n]PortDspLbConsistenceRemovedMemberIdValidR",
    },
    slice0_stage3_lb_Consistence_timer_value_r => { #Structure Type: RegField;
      Name => "slice0_stage3_lb_Consistence_timer_value_r",
      RegMem => "RegField",
      Description => "holds the current timer value. If equals 0 it mean the timer is not currently active. When consistence is valid:
Timer-is-active: learn
Timer is not active: use-cached",
      Width => "32", # Excel Formula: =calc_field_width_define("RES_LB_CONSISTENCE_TIMER_WIDTH")
      Position => "74:43", # Excel Formula: =calc_position(F132,E133)
      Type => "External",
      DocName => "Slice[n]PortDspLbConsistenceTimerValueR",
    },
  },
  ResolutionMaxAmountOfLuCfg => { #Structure Type: Reg;
    Name => "ResolutionMaxAmountOfLuCfg",
    RegMem => "Reg",
    Address => "129", # Excel Formula: =calc_reg_address(C126,A126,G126)
    Width => "8", # Excel Formula: =calc_reg_width(E135:E135,F135)
    Type => "Config",
    SliceMaxAmountOfLuCfg => { #Structure Type: RegField;
      Name => "SliceMaxAmountOfLuCfg",
      RegMem => "RegField",
      Description => "Configuration that sets the number of stages after which the LU will be dropped and ResolutionTtl Interrupt will be set",
      Width => "8",
      Position => "7:0", # Excel Formula: =calc_position(F134,E135,TRUE)
      Type => "Config",
      UsedBy => "res",
      DefaultValue => "hb0",
      Comments => "counts number of valid members currently in cache",
      InitValueAllModes => "176",
    },
  },
  ResolutionTtlCfg => { #Structure Type: Reg;
    Name => "ResolutionTtlCfg",
    RegMem => "Reg",
    Address => "12A", # Excel Formula: =calc_reg_address(C134,A134,G134)
    Width => "4", # Excel Formula: =calc_reg_width(E137:E137,F137)
    Type => "Config",
    MaxStagesAllowed => { #Structure Type: RegField;
      Name => "MaxStagesAllowed",
      RegMem => "RegField",
      Description => "Configuration that sets the number of stages after which the LU will be dropped and ResolutionTtl Interrupt will be set",
      Width => "4",
      Position => "3:0", # Excel Formula: =calc_position(F136,E137,TRUE)
      Type => "Config",
      UsedBy => "res",
      DefaultValue => "h5",
      Comments => "counts number of valid members currently in cache",
      InitValueAllModes => "6",
    },
  },
  ResolutionDebugNextCoreCntWm0 => { #Structure Type: Reg; ArrayLength: 2; ArrayIndex: 0; ArrayLocationInName: 29;
    Name => "ResolutionDebugNextCoreCntWm[2]",
    RegMem => "Reg",
    Address => "12B", # Excel Formula: =calc_reg_address(C136,A136,G136)
    Width => "68", # Excel Formula: =calc_reg_width(E139:E148,F148)
    Type => "ReadOnly",
    ArrayLength => "2",
    ArrayIndex => "0",
    Slice0FecNextCore0CounterWm => { #Structure Type: RegField; ArrayLength: 2; ArrayIndex: 0; ArrayLocationInName: 6;
      Name => "Slice[n]FecNextCore0CounterWm",
      RegMem => "RegField",
      Width => "6",
      Position => "5:0", # Excel Formula: =calc_position(F138,E139,TRUE)
      Type => "MaxWmk",
      UsedBy => "res",
      Comments => "counts number of valid members currently in cache",
    },
    Slice0FecNextCore1CounterWm => { #Structure Type: RegField; ArrayLength: 2; ArrayIndex: 0; ArrayLocationInName: 6;
      Name => "Slice[n]FecNextCore1CounterWm",
      RegMem => "RegField",
      Width => "6",
      Position => "11:6", # Excel Formula: =calc_position(F139,E140)
      Type => "MaxWmk",
      UsedBy => "res",
      Comments => "counts number of valid members currently in cache",
    },
    Slice0Core0NextCore0CounterWm => { #Structure Type: RegField; ArrayLength: 2; ArrayIndex: 0; ArrayLocationInName: 6;
      Name => "Slice[n]Core0NextCore0CounterWm",
      RegMem => "RegField",
      Width => "7",
      Position => "18:12", # Excel Formula: =calc_position(F140,E141)
      Type => "MaxWmk",
      UsedBy => "res",
      Comments => "counts number of valid members currently in cache",
    },
    Slice0Core0NextCore1CounterWm => { #Structure Type: RegField; ArrayLength: 2; ArrayIndex: 0; ArrayLocationInName: 6;
      Name => "Slice[n]Core0NextCore1CounterWm",
      RegMem => "RegField",
      Width => "7",
      Position => "25:19", # Excel Formula: =calc_position(F141,E142)
      Type => "MaxWmk",
      UsedBy => "res",
      Comments => "counts number of valid members currently in cache",
    },
    Slice0Core1NextCore0CounterWm => { #Structure Type: RegField; ArrayLength: 2; ArrayIndex: 0; ArrayLocationInName: 6;
      Name => "Slice[n]Core1NextCore0CounterWm",
      RegMem => "RegField",
      Width => "7",
      Position => "32:26", # Excel Formula: =calc_position(F142,E143)
      Type => "MaxWmk",
      UsedBy => "res",
      Comments => "counts number of valid members currently in cache",
    },
    Slice0Core1NextCore1CounterWm => { #Structure Type: RegField; ArrayLength: 2; ArrayIndex: 0; ArrayLocationInName: 6;
      Name => "Slice[n]Core1NextCore1CounterWm",
      RegMem => "RegField",
      Width => "7",
      Position => "39:33", # Excel Formula: =calc_position(F143,E144)
      Type => "MaxWmk",
      UsedBy => "res",
      Comments => "counts number of valid members currently in cache",
    },
    Slice0Core2NextCore0CounterWm => { #Structure Type: RegField; ArrayLength: 2; ArrayIndex: 0; ArrayLocationInName: 6;
      Name => "Slice[n]Core2NextCore0CounterWm",
      RegMem => "RegField",
      Width => "7",
      Position => "46:40", # Excel Formula: =calc_position(F144,E145)
      Type => "MaxWmk",
      UsedBy => "res",
      Comments => "counts number of valid members currently in cache",
    },
    Slice0Core2NextCore1CounterWm => { #Structure Type: RegField; ArrayLength: 2; ArrayIndex: 0; ArrayLocationInName: 6;
      Name => "Slice[n]Core2NextCore1CounterWm",
      RegMem => "RegField",
      Width => "7",
      Position => "53:47", # Excel Formula: =calc_position(F145,E146)
      Type => "MaxWmk",
      UsedBy => "res",
      Comments => "counts number of valid members currently in cache",
    },
    Slice0Core3NextCore0CounterWm => { #Structure Type: RegField; ArrayLength: 2; ArrayIndex: 0; ArrayLocationInName: 6;
      Name => "Slice[n]Core3NextCore0CounterWm",
      RegMem => "RegField",
      Width => "7",
      Position => "60:54", # Excel Formula: =calc_position(F146,E147)
      Type => "MaxWmk",
      UsedBy => "res",
      Comments => "counts number of valid members currently in cache",
    },
    Slice0Core3NextCore1CounterWm => { #Structure Type: RegField; ArrayLength: 2; ArrayIndex: 0; ArrayLocationInName: 6;
      Name => "Slice[n]Core3NextCore1CounterWm",
      RegMem => "RegField",
      Width => "7",
      Position => "67:61", # Excel Formula: =calc_position(F147,E148)
      Type => "MaxWmk",
      UsedBy => "res",
      Comments => "counts number of valid members currently in cache",
    },
  },
  ResolutionDebugNextCoreCntWm1 => { #Structure Type: Reg; ArrayLength: 2; ArrayIndex: 1; ArrayLocationInName: 29;
    Name => "ResolutionDebugNextCoreCntWm[2]",
    RegMem => "Reg",
    Address => "12C",
    Width => "68", # Excel Formula: =calc_reg_width(E139:E148,F148)
    Type => "ReadOnly",
    ArrayLength => "2",
    ArrayIndex => "1",
    Slice1FecNextCore0CounterWm => { #Structure Type: RegField; ArrayLength: 2; ArrayIndex: 1; ArrayLocationInName: 6;
      Name => "Slice[n]FecNextCore0CounterWm",
      RegMem => "RegField",
      Width => "6",
      Position => "5:0", # Excel Formula: =calc_position(F138,E139,TRUE)
      Type => "MaxWmk",
      UsedBy => "res",
      Comments => "counts number of valid members currently in cache",
    },
    Slice1FecNextCore1CounterWm => { #Structure Type: RegField; ArrayLength: 2; ArrayIndex: 1; ArrayLocationInName: 6;
      Name => "Slice[n]FecNextCore1CounterWm",
      RegMem => "RegField",
      Width => "6",
      Position => "11:6", # Excel Formula: =calc_position(F139,E140)
      Type => "MaxWmk",
      UsedBy => "res",
      Comments => "counts number of valid members currently in cache",
    },
    Slice1Core0NextCore0CounterWm => { #Structure Type: RegField; ArrayLength: 2; ArrayIndex: 1; ArrayLocationInName: 6;
      Name => "Slice[n]Core0NextCore0CounterWm",
      RegMem => "RegField",
      Width => "7",
      Position => "18:12", # Excel Formula: =calc_position(F140,E141)
      Type => "MaxWmk",
      UsedBy => "res",
      Comments => "counts number of valid members currently in cache",
    },
    Slice1Core0NextCore1CounterWm => { #Structure Type: RegField; ArrayLength: 2; ArrayIndex: 1; ArrayLocationInName: 6;
      Name => "Slice[n]Core0NextCore1CounterWm",
      RegMem => "RegField",
      Width => "7",
      Position => "25:19", # Excel Formula: =calc_position(F141,E142)
      Type => "MaxWmk",
      UsedBy => "res",
      Comments => "counts number of valid members currently in cache",
    },
    Slice1Core1NextCore0CounterWm => { #Structure Type: RegField; ArrayLength: 2; ArrayIndex: 1; ArrayLocationInName: 6;
      Name => "Slice[n]Core1NextCore0CounterWm",
      RegMem => "RegField",
      Width => "7",
      Position => "32:26", # Excel Formula: =calc_position(F142,E143)
      Type => "MaxWmk",
      UsedBy => "res",
      Comments => "counts number of valid members currently in cache",
    },
    Slice1Core1NextCore1CounterWm => { #Structure Type: RegField; ArrayLength: 2; ArrayIndex: 1; ArrayLocationInName: 6;
      Name => "Slice[n]Core1NextCore1CounterWm",
      RegMem => "RegField",
      Width => "7",
      Position => "39:33", # Excel Formula: =calc_position(F143,E144)
      Type => "MaxWmk",
      UsedBy => "res",
      Comments => "counts number of valid members currently in cache",
    },
    Slice1Core2NextCore0CounterWm => { #Structure Type: RegField; ArrayLength: 2; ArrayIndex: 1; ArrayLocationInName: 6;
      Name => "Slice[n]Core2NextCore0CounterWm",
      RegMem => "RegField",
      Width => "7",
      Position => "46:40", # Excel Formula: =calc_position(F144,E145)
      Type => "MaxWmk",
      UsedBy => "res",
      Comments => "counts number of valid members currently in cache",
    },
    Slice1Core2NextCore1CounterWm => { #Structure Type: RegField; ArrayLength: 2; ArrayIndex: 1; ArrayLocationInName: 6;
      Name => "Slice[n]Core2NextCore1CounterWm",
      RegMem => "RegField",
      Width => "7",
      Position => "53:47", # Excel Formula: =calc_position(F145,E146)
      Type => "MaxWmk",
      UsedBy => "res",
      Comments => "counts number of valid members currently in cache",
    },
    Slice1Core3NextCore0CounterWm => { #Structure Type: RegField; ArrayLength: 2; ArrayIndex: 1; ArrayLocationInName: 6;
      Name => "Slice[n]Core3NextCore0CounterWm",
      RegMem => "RegField",
      Width => "7",
      Position => "60:54", # Excel Formula: =calc_position(F146,E147)
      Type => "MaxWmk",
      UsedBy => "res",
      Comments => "counts number of valid members currently in cache",
    },
    Slice1Core3NextCore1CounterWm => { #Structure Type: RegField; ArrayLength: 2; ArrayIndex: 1; ArrayLocationInName: 6;
      Name => "Slice[n]Core3NextCore1CounterWm",
      RegMem => "RegField",
      Width => "7",
      Position => "67:61", # Excel Formula: =calc_position(F147,E148)
      Type => "MaxWmk",
      UsedBy => "res",
      Comments => "counts number of valid members currently in cache",
    },
  },
  ResolutionDebugBypassFifoWm0 => { #Structure Type: Reg; ArrayLength: 2; ArrayIndex: 0; ArrayLocationInName: 28;
    Name => "ResolutionDebugBypassFifoWm[2]",
    RegMem => "Reg",
    Address => "12D", # Excel Formula: =calc_reg_address(C138,A138,G138)
    Width => "24", # Excel Formula: =calc_reg_width(E150:E153,F153)
    Type => "ReadOnly",
    ArrayLength => "2",
    ArrayIndex => "0",
    Slice0Core0BypassFifoWm => { #Structure Type: RegField; ArrayLength: 2; ArrayIndex: 0; ArrayLocationInName: 6;
      Name => "Slice[n]Core0BypassFifoWm",
      RegMem => "RegField",
      Width => "6",
      Position => "5:0", # Excel Formula: =calc_position(F149,E150,TRUE)
      Type => "MaxWmk",
      UsedBy => "res",
      Comments => "counts number of valid members currently in cache",
    },
    Slice0Core1BypassFifoWm => { #Structure Type: RegField; ArrayLength: 2; ArrayIndex: 0; ArrayLocationInName: 6;
      Name => "Slice[n]Core1BypassFifoWm",
      RegMem => "RegField",
      Width => "6",
      Position => "11:6", # Excel Formula: =calc_position(F150,E151)
      Type => "MaxWmk",
      UsedBy => "res",
      Comments => "counts number of valid members currently in cache",
    },
    Slice0Core2BypassFifoWm => { #Structure Type: RegField; ArrayLength: 2; ArrayIndex: 0; ArrayLocationInName: 6;
      Name => "Slice[n]Core2BypassFifoWm",
      RegMem => "RegField",
      Width => "6",
      Position => "17:12", # Excel Formula: =calc_position(F151,E152)
      Type => "MaxWmk",
      UsedBy => "res",
      Comments => "counts number of valid members currently in cache",
    },
    Slice0Core3BypassFifoWm => { #Structure Type: RegField; ArrayLength: 2; ArrayIndex: 0; ArrayLocationInName: 6;
      Name => "Slice[n]Core3BypassFifoWm",
      RegMem => "RegField",
      Width => "6",
      Position => "23:18", # Excel Formula: =calc_position(F152,E153)
      Type => "MaxWmk",
      UsedBy => "res",
      Comments => "counts number of valid members currently in cache",
    },
  },
  ResolutionDebugBypassFifoWm1 => { #Structure Type: Reg; ArrayLength: 2; ArrayIndex: 1; ArrayLocationInName: 28;
    Name => "ResolutionDebugBypassFifoWm[2]",
    RegMem => "Reg",
    Address => "12E",
    Width => "24", # Excel Formula: =calc_reg_width(E150:E153,F153)
    Type => "ReadOnly",
    ArrayLength => "2",
    ArrayIndex => "1",
    Slice1Core0BypassFifoWm => { #Structure Type: RegField; ArrayLength: 2; ArrayIndex: 1; ArrayLocationInName: 6;
      Name => "Slice[n]Core0BypassFifoWm",
      RegMem => "RegField",
      Width => "6",
      Position => "5:0", # Excel Formula: =calc_position(F149,E150,TRUE)
      Type => "MaxWmk",
      UsedBy => "res",
      Comments => "counts number of valid members currently in cache",
    },
    Slice1Core1BypassFifoWm => { #Structure Type: RegField; ArrayLength: 2; ArrayIndex: 1; ArrayLocationInName: 6;
      Name => "Slice[n]Core1BypassFifoWm",
      RegMem => "RegField",
      Width => "6",
      Position => "11:6", # Excel Formula: =calc_position(F150,E151)
      Type => "MaxWmk",
      UsedBy => "res",
      Comments => "counts number of valid members currently in cache",
    },
    Slice1Core2BypassFifoWm => { #Structure Type: RegField; ArrayLength: 2; ArrayIndex: 1; ArrayLocationInName: 6;
      Name => "Slice[n]Core2BypassFifoWm",
      RegMem => "RegField",
      Width => "6",
      Position => "17:12", # Excel Formula: =calc_position(F151,E152)
      Type => "MaxWmk",
      UsedBy => "res",
      Comments => "counts number of valid members currently in cache",
    },
    Slice1Core3BypassFifoWm => { #Structure Type: RegField; ArrayLength: 2; ArrayIndex: 1; ArrayLocationInName: 6;
      Name => "Slice[n]Core3BypassFifoWm",
      RegMem => "RegField",
      Width => "6",
      Position => "23:18", # Excel Formula: =calc_position(F152,E153)
      Type => "MaxWmk",
      UsedBy => "res",
      Comments => "counts number of valid members currently in cache",
    },
  },
  ResolutionDebugCounters0 => { #Structure Type: Reg; ArrayLength: 2; ArrayIndex: 0; ArrayLocationInName: 24;
    Name => "ResolutionDebugCounters[2]",
    RegMem => "Reg",
    Address => "12F", # Excel Formula: =calc_reg_address(C149,A149,G149)
    Width => "128", # Excel Formula: =calc_reg_width(E155:E156,F156)
    Type => "ReadOnly",
    ArrayLength => "2",
    ArrayIndex => "0",
    Slice0ResolutionInput => { #Structure Type: RegField; ArrayLength: 2; ArrayIndex: 0; ArrayLocationInName: 6;
      Name => "Slice[n]ResolutionInput",
      RegMem => "RegField",
      Width => "64",
      Position => "63:0", # Excel Formula: =calc_position(F154,E155,TRUE)
      Type => "Counter",
      UsedBy => "res",
      AdditionalInfo => "CounterIncrWidth=1",
      Comments => "counts number of valid members currently in cache",
    },
    Slice0ResolutionOutput => { #Structure Type: RegField; ArrayLength: 2; ArrayIndex: 0; ArrayLocationInName: 6;
      Name => "Slice[n]ResolutionOutput",
      RegMem => "RegField",
      Width => "64",
      Position => "127:64", # Excel Formula: =calc_position(F155,E156)
      Type => "Counter",
      UsedBy => "res",
      AdditionalInfo => "CounterIncrWidth=1",
      Comments => "counts number of valid members currently in cache",
    },
  },
  ResolutionDebugCounters1 => { #Structure Type: Reg; ArrayLength: 2; ArrayIndex: 1; ArrayLocationInName: 24;
    Name => "ResolutionDebugCounters[2]",
    RegMem => "Reg",
    Address => "130",
    Width => "128", # Excel Formula: =calc_reg_width(E155:E156,F156)
    Type => "ReadOnly",
    ArrayLength => "2",
    ArrayIndex => "1",
    Slice1ResolutionInput => { #Structure Type: RegField; ArrayLength: 2; ArrayIndex: 1; ArrayLocationInName: 6;
      Name => "Slice[n]ResolutionInput",
      RegMem => "RegField",
      Width => "64",
      Position => "63:0", # Excel Formula: =calc_position(F154,E155,TRUE)
      Type => "Counter",
      UsedBy => "res",
      AdditionalInfo => "CounterIncrWidth=1",
      Comments => "counts number of valid members currently in cache",
    },
    Slice1ResolutionOutput => { #Structure Type: RegField; ArrayLength: 2; ArrayIndex: 1; ArrayLocationInName: 6;
      Name => "Slice[n]ResolutionOutput",
      RegMem => "RegField",
      Width => "64",
      Position => "127:64", # Excel Formula: =calc_position(F155,E156)
      Type => "Counter",
      UsedBy => "res",
      AdditionalInfo => "CounterIncrWidth=1",
      Comments => "counts number of valid members currently in cache",
    },
  },
  ResolutionDebugOutputWm0 => { #Structure Type: Reg; ArrayLength: 2; ArrayIndex: 0; ArrayLocationInName: 24;
    Name => "ResolutionDebugOutputWm[2]",
    RegMem => "Reg",
    Address => "131", # Excel Formula: =calc_reg_address(C154,A154,G154)
    Width => "8", # Excel Formula: =calc_reg_width(E158:E158,F158)
    Type => "ReadOnly",
    ArrayLength => "2",
    ArrayIndex => "0",
    Slice0OutputFifoWm => { #Structure Type: RegField; ArrayLength: 2; ArrayIndex: 0; ArrayLocationInName: 6;
      Name => "Slice[n]OutputFifoWm",
      RegMem => "RegField",
      Width => "8",
      Position => "7:0", # Excel Formula: =calc_position(F157,E158,TRUE)
      Type => "MaxWmk",
      UsedBy => "res",
      Comments => "counts number of valid members currently in cache",
    },
  },
  ResolutionDebugOutputWm1 => { #Structure Type: Reg; ArrayLength: 2; ArrayIndex: 1; ArrayLocationInName: 24;
    Name => "ResolutionDebugOutputWm[2]",
    RegMem => "Reg",
    Address => "132",
    Width => "8", # Excel Formula: =calc_reg_width(E158:E158,F158)
    Type => "ReadOnly",
    ArrayLength => "2",
    ArrayIndex => "1",
    Slice1OutputFifoWm => { #Structure Type: RegField; ArrayLength: 2; ArrayIndex: 1; ArrayLocationInName: 6;
      Name => "Slice[n]OutputFifoWm",
      RegMem => "RegField",
      Width => "8",
      Position => "7:0", # Excel Formula: =calc_position(F157,E158,TRUE)
      Type => "MaxWmk",
      UsedBy => "res",
      Comments => "counts number of valid members currently in cache",
    },
  },
  ResolutionDebugInputWm0 => { #Structure Type: Reg; ArrayLength: 2; ArrayIndex: 0; ArrayLocationInName: 23;
    Name => "ResolutionDebugInputWm[2]",
    RegMem => "Reg",
    Address => "133", # Excel Formula: =calc_reg_address(C157,A157,G157)
    Width => "14", # Excel Formula: =calc_reg_width(E160:E161,F161)
    Type => "ReadOnly",
    ArrayLength => "2",
    ArrayIndex => "0",
    Slice0MaxAmountOfLuInSliceWm => { #Structure Type: RegField; ArrayLength: 2; ArrayIndex: 0; ArrayLocationInName: 6;
      Name => "Slice[n]MaxAmountOfLuInSliceWm",
      RegMem => "RegField",
      Width => "8",
      Position => "7:0", # Excel Formula: =calc_position(F159,E160,TRUE)
      Type => "MaxWmk",
      UsedBy => "res",
      Comments => "counts number of valid members currently in cache",
    },
    Slice0InputCbrFullnessWm => { #Structure Type: RegField; ArrayLength: 2; ArrayIndex: 0; ArrayLocationInName: 6;
      Name => "Slice[n]InputCbrFullnessWm",
      RegMem => "RegField",
      Width => "6",
      Position => "13:8", # Excel Formula: =calc_position(F160,E161)
      Type => "MaxWmk",
      UsedBy => "res",
      Comments => "counts number of valid members currently in cache",
    },
  },
  ResolutionDebugInputWm1 => { #Structure Type: Reg; ArrayLength: 2; ArrayIndex: 1; ArrayLocationInName: 23;
    Name => "ResolutionDebugInputWm[2]",
    RegMem => "Reg",
    Address => "134",
    Width => "14", # Excel Formula: =calc_reg_width(E160:E161,F161)
    Type => "ReadOnly",
    ArrayLength => "2",
    ArrayIndex => "1",
    Slice1MaxAmountOfLuInSliceWm => { #Structure Type: RegField; ArrayLength: 2; ArrayIndex: 1; ArrayLocationInName: 6;
      Name => "Slice[n]MaxAmountOfLuInSliceWm",
      RegMem => "RegField",
      Width => "8",
      Position => "7:0", # Excel Formula: =calc_position(F159,E160,TRUE)
      Type => "MaxWmk",
      UsedBy => "res",
      Comments => "counts number of valid members currently in cache",
    },
    Slice1InputCbrFullnessWm => { #Structure Type: RegField; ArrayLength: 2; ArrayIndex: 1; ArrayLocationInName: 6;
      Name => "Slice[n]InputCbrFullnessWm",
      RegMem => "RegField",
      Width => "6",
      Position => "13:8", # Excel Formula: =calc_position(F160,E161)
      Type => "MaxWmk",
      UsedBy => "res",
      Comments => "counts number of valid members currently in cache",
    },
  },
  protection_table_slice0_stage0 => { #Structure Type: Mem; ArrayLength: 4; ArrayIndex: 0; ArrayLocationInName: 30;
    Name => "protection_table_slice0_stage[4]",
    RegMem => "Mem",
    Address => "100000",
    Description => "Protection table per stage",
    Width => "13", # Excel Formula: =calc_mem_width(E163:E163,M162,F163,-1)
    Type => "Config",
    UsedBy => "res",
    DocName => "ProtectionTable[4]",
    MemEntries => "1024",
    MemWrapper => "1P",
    MemProtect => "ECC",
    AdditionalInfo => "SampleReadBeforeProt=1,SampleReadAfterProt=1,PortErrPropagate=Enabled,CpuReadAccess=Enabled,CpuWriteAccess=Enabled,WriteActivityFactor=0,ReadActivityFactor=50",
    ArrayLength => "4",
    ArrayIndex => "0",
    MemLogicalWidth => "8",
    protection_table_field_stage0 => { #Structure Type: MemField; ArrayLength: 4; ArrayIndex: 0; ArrayLocationInName: 29;
      Name => "protection_table_field_stage[n]",
      RegMem => "MemField",
      Description => "Protection table logical depth is 8K, with 13b Key, and payload of 1b indicates 'path'
Physical implementation aspect ratio is 1K x 8, such that:
Addr = Key[12:3]
Selected-path = payload[Key[2:0]]",
      Width => "8",
      Position => "7:0", # Excel Formula: =calc_position(F162,E163,TRUE)
      DocName => "ProtectionTableField[n]",
    },
  },
  protection_table_slice0_stage1 => { #Structure Type: Mem; ArrayLength: 4; ArrayIndex: 1; ArrayLocationInName: 30;
    Name => "protection_table_slice0_stage[4]",
    RegMem => "Mem",
    Address => "200000",
    Description => "Protection table per stage",
    Width => "13", # Excel Formula: =calc_mem_width(E163:E163,M162,F163,-1)
    Type => "Config",
    UsedBy => "res",
    DocName => "ProtectionTable[4]",
    MemEntries => "1024",
    MemWrapper => "1P",
    MemProtect => "ECC",
    AdditionalInfo => "SampleReadBeforeProt=1,SampleReadAfterProt=1,PortErrPropagate=Enabled,CpuReadAccess=Enabled,CpuWriteAccess=Enabled,WriteActivityFactor=0,ReadActivityFactor=50",
    ArrayLength => "4",
    ArrayIndex => "1",
    MemLogicalWidth => "8",
    protection_table_field_stage1 => { #Structure Type: MemField; ArrayLength: 4; ArrayIndex: 1; ArrayLocationInName: 29;
      Name => "protection_table_field_stage[n]",
      RegMem => "MemField",
      Description => "Protection table logical depth is 8K, with 13b Key, and payload of 1b indicates 'path'
Physical implementation aspect ratio is 1K x 8, such that:
Addr = Key[12:3]
Selected-path = payload[Key[2:0]]",
      Width => "8",
      Position => "7:0", # Excel Formula: =calc_position(F162,E163,TRUE)
      DocName => "ProtectionTableField[n]",
    },
  },
  protection_table_slice0_stage2 => { #Structure Type: Mem; ArrayLength: 4; ArrayIndex: 2; ArrayLocationInName: 30;
    Name => "protection_table_slice0_stage[4]",
    RegMem => "Mem",
    Address => "300000",
    Description => "Protection table per stage",
    Width => "13", # Excel Formula: =calc_mem_width(E163:E163,M162,F163,-1)
    Type => "Config",
    UsedBy => "res",
    DocName => "ProtectionTable[4]",
    MemEntries => "1024",
    MemWrapper => "1P",
    MemProtect => "ECC",
    AdditionalInfo => "SampleReadBeforeProt=1,SampleReadAfterProt=1,PortErrPropagate=Enabled,CpuReadAccess=Enabled,CpuWriteAccess=Enabled,WriteActivityFactor=0,ReadActivityFactor=50",
    ArrayLength => "4",
    ArrayIndex => "2",
    MemLogicalWidth => "8",
    protection_table_field_stage2 => { #Structure Type: MemField; ArrayLength: 4; ArrayIndex: 2; ArrayLocationInName: 29;
      Name => "protection_table_field_stage[n]",
      RegMem => "MemField",
      Description => "Protection table logical depth is 8K, with 13b Key, and payload of 1b indicates 'path'
Physical implementation aspect ratio is 1K x 8, such that:
Addr = Key[12:3]
Selected-path = payload[Key[2:0]]",
      Width => "8",
      Position => "7:0", # Excel Formula: =calc_position(F162,E163,TRUE)
      DocName => "ProtectionTableField[n]",
    },
  },
  protection_table_slice0_stage3 => { #Structure Type: Mem; ArrayLength: 4; ArrayIndex: 3; ArrayLocationInName: 30;
    Name => "protection_table_slice0_stage[4]",
    RegMem => "Mem",
    Address => "400000",
    Description => "Protection table per stage",
    Width => "13", # Excel Formula: =calc_mem_width(E163:E163,M162,F163,-1)
    Type => "Config",
    UsedBy => "res",
    DocName => "ProtectionTable[4]",
    MemEntries => "1024",
    MemWrapper => "1P",
    MemProtect => "ECC",
    AdditionalInfo => "SampleReadBeforeProt=1,SampleReadAfterProt=1,PortErrPropagate=Enabled,CpuReadAccess=Enabled,CpuWriteAccess=Enabled,WriteActivityFactor=0,ReadActivityFactor=50",
    ArrayLength => "4",
    ArrayIndex => "3",
    MemLogicalWidth => "8",
    protection_table_field_stage3 => { #Structure Type: MemField; ArrayLength: 4; ArrayIndex: 3; ArrayLocationInName: 29;
      Name => "protection_table_field_stage[n]",
      RegMem => "MemField",
      Description => "Protection table logical depth is 8K, with 13b Key, and payload of 1b indicates 'path'
Physical implementation aspect ratio is 1K x 8, such that:
Addr = Key[12:3]
Selected-path = payload[Key[2:0]]",
      Width => "8",
      Position => "7:0", # Excel Formula: =calc_position(F162,E163,TRUE)
      DocName => "ProtectionTableField[n]",
    },
  },
  slice0_stage0_lb_consistence_cache_table => { #Structure Type: Mem; ArrayLength: 4; ArrayIndex: 0; ArrayLocationInName: 13;
    Name => "slice0_stage[4]_lb_consistence_cache_table",
    RegMem => "Mem",
    Address => "500000", # Excel Formula: =calc_mem_address(C162,A162,G164,L164)
    Description => "Lb consistance cache table",
    Width => "26", # Excel Formula: =calc_mem_width(E165:E167,M164,F167,-1)
    Type => "Dynamic",
    UsedBy => "res",
    DocName => "Slice[2]PortDspLbConsistenceCacheTable",
    MemEntries => "4096", # Excel Formula: =2^calc_field_width_define("RES_REDUCED_LB_KEY_WIDTH")
    MemWrapper => "1R1W",
    MemProtect => "ECC",
    AdditionalInfo => "SampleReadBeforeProt=1,SampleReadAfterProt=1,PortErrPropagate=Enabled,CpuReadAccess=Enabled,CpuWriteAccess=Enabled,DisableSameAddressErr=Enabled,WriteActivityFactor=100,ReadActivityFactor=100",
    ArrayLength => "4",
    ArrayIndex => "0",
    MemLogicalWidth => "20",
    valid_stage0 => { #Structure Type: MemField; ArrayLength: 4; ArrayIndex: 0; ArrayLocationInName: 12;
      Name => "valid_stage[n]",
      RegMem => "MemField",
      Description => "when set, the cache-member-id is valid",
      Width => "1",
      Position => "0", # Excel Formula: =calc_position(F164,E165,TRUE)
      DocName => "Valid[n]",
    },
    cache_member_id_stage0 => { #Structure Type: MemField; ArrayLength: 4; ArrayIndex: 0; ArrayLocationInName: 22;
      Name => "cache_member_id_stage[n]",
      RegMem => "MemField",
      Description => "cache member-id",
      Width => "9", # Excel Formula: =calc_field_width_define("RES_LB_GROUP_SIZE_WIDTH")
      Position => "9:1", # Excel Formula: =calc_position(F165,E166)
      DocName => "CacheMemberId[n]",
    },
    time_stamp_stage0 => { #Structure Type: MemField; ArrayLength: 4; ArrayIndex: 0; ArrayLocationInName: 17;
      Name => "time_stamp_stage[n]",
      RegMem => "MemField",
      Description => "stored-time-stamp - scale is according to cfg-consistence_cache_clock_offset",
      Width => "10", # Excel Formula: = calc_field_width_define("RES_LB_CONSISTENCE_CACHE_TS_WIDTH")
      Position => "19:10", # Excel Formula: =calc_position(F166,E167)
      DocName => "TimeStamp[n]",
    },
  },
  slice0_stage1_lb_consistence_cache_table => { #Structure Type: Mem; ArrayLength: 4; ArrayIndex: 1; ArrayLocationInName: 13;
    Name => "slice0_stage[4]_lb_consistence_cache_table",
    RegMem => "Mem",
    Address => "600000",
    Description => "Lb consistance cache table",
    Width => "26", # Excel Formula: =calc_mem_width(E165:E167,M164,F167,-1)
    Type => "Dynamic",
    UsedBy => "res",
    DocName => "Slice[2]PortDspLbConsistenceCacheTable",
    MemEntries => "4096", # Excel Formula: =2^calc_field_width_define("RES_REDUCED_LB_KEY_WIDTH")
    MemWrapper => "1R1W",
    MemProtect => "ECC",
    AdditionalInfo => "SampleReadBeforeProt=1,SampleReadAfterProt=1,PortErrPropagate=Enabled,CpuReadAccess=Enabled,CpuWriteAccess=Enabled,DisableSameAddressErr=Enabled,WriteActivityFactor=100,ReadActivityFactor=100",
    ArrayLength => "4",
    ArrayIndex => "1",
    MemLogicalWidth => "20",
    valid_stage1 => { #Structure Type: MemField; ArrayLength: 4; ArrayIndex: 1; ArrayLocationInName: 12;
      Name => "valid_stage[n]",
      RegMem => "MemField",
      Description => "when set, the cache-member-id is valid",
      Width => "1",
      Position => "0", # Excel Formula: =calc_position(F164,E165,TRUE)
      DocName => "Valid[n]",
    },
    cache_member_id_stage1 => { #Structure Type: MemField; ArrayLength: 4; ArrayIndex: 1; ArrayLocationInName: 22;
      Name => "cache_member_id_stage[n]",
      RegMem => "MemField",
      Description => "cache member-id",
      Width => "9", # Excel Formula: =calc_field_width_define("RES_LB_GROUP_SIZE_WIDTH")
      Position => "9:1", # Excel Formula: =calc_position(F165,E166)
      DocName => "CacheMemberId[n]",
    },
    time_stamp_stage1 => { #Structure Type: MemField; ArrayLength: 4; ArrayIndex: 1; ArrayLocationInName: 17;
      Name => "time_stamp_stage[n]",
      RegMem => "MemField",
      Description => "stored-time-stamp - scale is according to cfg-consistence_cache_clock_offset",
      Width => "10", # Excel Formula: = calc_field_width_define("RES_LB_CONSISTENCE_CACHE_TS_WIDTH")
      Position => "19:10", # Excel Formula: =calc_position(F166,E167)
      DocName => "TimeStamp[n]",
    },
  },
  slice0_stage2_lb_consistence_cache_table => { #Structure Type: Mem; ArrayLength: 4; ArrayIndex: 2; ArrayLocationInName: 13;
    Name => "slice0_stage[4]_lb_consistence_cache_table",
    RegMem => "Mem",
    Address => "700000",
    Description => "Lb consistance cache table",
    Width => "26", # Excel Formula: =calc_mem_width(E165:E167,M164,F167,-1)
    Type => "Dynamic",
    UsedBy => "res",
    DocName => "Slice[2]PortDspLbConsistenceCacheTable",
    MemEntries => "4096", # Excel Formula: =2^calc_field_width_define("RES_REDUCED_LB_KEY_WIDTH")
    MemWrapper => "1R1W",
    MemProtect => "ECC",
    AdditionalInfo => "SampleReadBeforeProt=1,SampleReadAfterProt=1,PortErrPropagate=Enabled,CpuReadAccess=Enabled,CpuWriteAccess=Enabled,DisableSameAddressErr=Enabled,WriteActivityFactor=100,ReadActivityFactor=100",
    ArrayLength => "4",
    ArrayIndex => "2",
    MemLogicalWidth => "20",
    valid_stage2 => { #Structure Type: MemField; ArrayLength: 4; ArrayIndex: 2; ArrayLocationInName: 12;
      Name => "valid_stage[n]",
      RegMem => "MemField",
      Description => "when set, the cache-member-id is valid",
      Width => "1",
      Position => "0", # Excel Formula: =calc_position(F164,E165,TRUE)
      DocName => "Valid[n]",
    },
    cache_member_id_stage2 => { #Structure Type: MemField; ArrayLength: 4; ArrayIndex: 2; ArrayLocationInName: 22;
      Name => "cache_member_id_stage[n]",
      RegMem => "MemField",
      Description => "cache member-id",
      Width => "9", # Excel Formula: =calc_field_width_define("RES_LB_GROUP_SIZE_WIDTH")
      Position => "9:1", # Excel Formula: =calc_position(F165,E166)
      DocName => "CacheMemberId[n]",
    },
    time_stamp_stage2 => { #Structure Type: MemField; ArrayLength: 4; ArrayIndex: 2; ArrayLocationInName: 17;
      Name => "time_stamp_stage[n]",
      RegMem => "MemField",
      Description => "stored-time-stamp - scale is according to cfg-consistence_cache_clock_offset",
      Width => "10", # Excel Formula: = calc_field_width_define("RES_LB_CONSISTENCE_CACHE_TS_WIDTH")
      Position => "19:10", # Excel Formula: =calc_position(F166,E167)
      DocName => "TimeStamp[n]",
    },
  },
  slice0_stage3_lb_consistence_cache_table => { #Structure Type: Mem; ArrayLength: 4; ArrayIndex: 3; ArrayLocationInName: 13;
    Name => "slice0_stage[4]_lb_consistence_cache_table",
    RegMem => "Mem",
    Address => "800000",
    Description => "Lb consistance cache table",
    Width => "26", # Excel Formula: =calc_mem_width(E165:E167,M164,F167,-1)
    Type => "Dynamic",
    UsedBy => "res",
    DocName => "Slice[2]PortDspLbConsistenceCacheTable",
    MemEntries => "4096", # Excel Formula: =2^calc_field_width_define("RES_REDUCED_LB_KEY_WIDTH")
    MemWrapper => "1R1W",
    MemProtect => "ECC",
    AdditionalInfo => "SampleReadBeforeProt=1,SampleReadAfterProt=1,PortErrPropagate=Enabled,CpuReadAccess=Enabled,CpuWriteAccess=Enabled,DisableSameAddressErr=Enabled,WriteActivityFactor=100,ReadActivityFactor=100",
    ArrayLength => "4",
    ArrayIndex => "3",
    MemLogicalWidth => "20",
    valid_stage3 => { #Structure Type: MemField; ArrayLength: 4; ArrayIndex: 3; ArrayLocationInName: 12;
      Name => "valid_stage[n]",
      RegMem => "MemField",
      Description => "when set, the cache-member-id is valid",
      Width => "1",
      Position => "0", # Excel Formula: =calc_position(F164,E165,TRUE)
      DocName => "Valid[n]",
    },
    cache_member_id_stage3 => { #Structure Type: MemField; ArrayLength: 4; ArrayIndex: 3; ArrayLocationInName: 22;
      Name => "cache_member_id_stage[n]",
      RegMem => "MemField",
      Description => "cache member-id",
      Width => "9", # Excel Formula: =calc_field_width_define("RES_LB_GROUP_SIZE_WIDTH")
      Position => "9:1", # Excel Formula: =calc_position(F165,E166)
      DocName => "CacheMemberId[n]",
    },
    time_stamp_stage3 => { #Structure Type: MemField; ArrayLength: 4; ArrayIndex: 3; ArrayLocationInName: 17;
      Name => "time_stamp_stage[n]",
      RegMem => "MemField",
      Description => "stored-time-stamp - scale is according to cfg-consistence_cache_clock_offset",
      Width => "10", # Excel Formula: = calc_field_width_define("RES_LB_CONSISTENCE_CACHE_TS_WIDTH")
      Position => "19:10", # Excel Formula: =calc_position(F166,E167)
      DocName => "TimeStamp[n]",
    },
  },
  ResolutionStage0Em => { #Structure Type: Mem;
    Name => "ResolutionStage0Em",
    RegMem => "Mem",
    Address => "500000", # Excel Formula: =calc_mem_address(C164,A164,G168,L168)
    Description => "Resolution stage exact match",
    Width => "38", # Excel Formula: =calc_mem_width(E169:E171,M168,F171,-1)
    Type => "DocOnly",
    UsedBy => "res",
    MemEntries => "196608",
    MemWrapper => "EM",
    MemProtect => "None",
    AdditionalInfo => "KeyWidth=24,SourceIdWidth=1,NumberOfBanks=12,NumberOfCamEntries=32,NumberOfParallelBanks=12,2PMemory=Enabled,VerifierSampleReadBeforeProt=2,VerifierSamplePhysicalMem=1,VerifierCpuReadAccess=Enabled,VerifierCpuWriteAccess=Enabled,VrfWriteActivityFactor=0,VrfReadActivityFactor=100,VrfDisableSameAddressErr=Enabled,VrfEnableNonCpuRdWrSameAddress=Enabled,VldWriteActivityFactor=0,VldReadActivityFactor=100",
    Comments => "Key is according to lb-emdb-key-type:
0: key = {zeros(7), member-id(9), Group-ID(14)}
1: key = {LB-key(16), Group-id(14)}",
    MemLogicalWidth => "38",
    ResolutionStage0MemberIndex => { #Structure Type: MemField;
      Name => "ResolutionStage0MemberIndex",
      RegMem => "MemField",
      Description => "index to the associated attributes table",
      Width => "16",
      Position => "15:0", # Excel Formula: =calc_position(F168,E169,TRUE)
    },
    ResolutionStage0MemberEntrySelector => { #Structure Type: MemField;
      Name => "ResolutionStage0MemberEntrySelector",
      RegMem => "MemField",
      Description => "Shift value applied on the associated data output",
      Width => "2",
      Position => "17:16", # Excel Formula: =calc_position(F169,E170)
    },
    ResolutionStage0AdditionalData => { #Structure Type: MemField;
      Name => "ResolutionStage0AdditionalData",
      RegMem => "MemField",
      Description => "Additional data for this record",
      Width => "20",
      Position => "37:18", # Excel Formula: =calc_position(F170,E171)
    },
  },
  ResolutionStage0AssociatedData => { #Structure Type: Mem;
    Name => "ResolutionStage0AssociatedData",
    RegMem => "Mem",
    Address => "900000", # Excel Formula: =calc_mem_address(C164,A164,G172,L172)
    Description => "Resolution stage associated data table",
    Width => "154", # Excel Formula: =calc_mem_width(E173:E173,M172,F173,-1)
    Type => "Config",
    UsedBy => "res",
    MemEntries => "49152",
    MemWrapper => "2R1W Slow Write",
    MemProtect => "ECC",
    AdditionalInfo => "SampleReadBeforeProt=3,SampleReadAfterProt=1,PortErrPropagate=Enabled,CpuReadAccess=Enabled,CpuWriteAccess=Enabled,WriteActivityFactor=0,ReadActivityFactor=100",
    MemLogicalWidth => "145",
    ResolutionStage0AssociatedRecord => { #Structure Type: MemField;
      Name => "ResolutionStage0AssociatedRecord",
      RegMem => "MemField",
      Width => "145",
      Position => "144:0", # Excel Formula: =calc_position(F172,E173,TRUE)
    },
  },
  EntryTypeDecodingTableSlice0Stage0 => { #Structure Type: Mem; ArrayLength: 4; ArrayIndex: 0; ArrayLocationInName: 34;
    Name => "EntryTypeDecodingTableSlice0Stage[4]",
    RegMem => "Mem",
    Address => "A00000", # Excel Formula: =calc_mem_address(C172,A172,G174,L174)
    Description => "Entry type decoding table",
    Width => "85", # Excel Formula: =calc_mem_width(E175:E191,M174,F191,-1)
    Type => "Config",
    UsedBy => "res",
    MemEntries => "64",
    MemWrapper => "RegArray",
    MemProtect => "None",
    AdditionalInfo => "CpuReadAccess=Enabled,CpuWriteAccess=Enabled,PortErrPropagate=Disabled",
    ArrayLength => "4",
    ArrayIndex => "0",
    MemLogicalWidth => "85",
    DestOffsetInBitsStage0 => { #Structure Type: MemField; ArrayLength: 4; ArrayIndex: 0; ArrayLocationInName: 22;
      Name => "DestOffsetInBitsStage[n]",
      RegMem => "MemField",
      Description => "Destination offset in nibbles ",
      Width => "7",
      Position => "6:0", # Excel Formula: =calc_position(F174,E175,TRUE)
    },
    DestSizeInBitsStage0 => { #Structure Type: MemField; ArrayLength: 4; ArrayIndex: 0; ArrayLocationInName: 20;
      Name => "DestSizeInBitsStage[n]",
      RegMem => "MemField",
      Description => "Destination width (according to Dest-encoding).  ",
      Width => "5",
      Position => "11:7", # Excel Formula: =calc_position(F175,E176)
    },
    DestTypeStage0 => { #Structure Type: MemField; ArrayLength: 4; ArrayIndex: 0; ArrayLocationInName: 14;
      Name => "DestTypeStage[n]",
      RegMem => "MemField",
      Width => "6",
      Position => "17:12", # Excel Formula: =calc_position(F176,E177)
    },
    StartEncapsulationStage0 => { #Structure Type: MemField; ArrayLength: 4; ArrayIndex: 0; ArrayLocationInName: 24;
      Name => "StartEncapsulationStage[n]",
      RegMem => "MemField",
      Description => "Encap-Index[1:0] flows in the resolution process. The initial value is 2'b00.
Every time Start-Encap is set increment this value by 1.
If Encap-Index is 2'b00 or 2'b01 then operate starting from msb
If Encap-Index is 2'b10 then operate 40b from msb
If Encap-Index is 2'b11 then operate 80b from msb",
      Width => "1",
      Position => "18", # Excel Formula: =calc_position(F177,E178)
    },
    EncTypeStage0 => { #Structure Type: MemField; ArrayLength: 4; ArrayIndex: 0; ArrayLocationInName: 13;
      Name => "EncTypeStage[n]",
      RegMem => "MemField",
      Description => "Encapsulation-type",
      Width => "4",
      Position => "22:19", # Excel Formula: =calc_position(F178,E179)
    },
    Field0SrcOffsetInBitsStage0 => { #Structure Type: MemField; ArrayLength: 4; ArrayIndex: 0; ArrayLocationInName: 27;
      Name => "Field0SrcOffsetInBitsStage[n]",
      RegMem => "MemField",
      Description => "Offset in bits from lsb from which to take field0",
      Width => "7",
      Position => "29:23", # Excel Formula: =calc_position(F179,E180)
    },
    Field0SizeInBitsStage0 => { #Structure Type: MemField; ArrayLength: 4; ArrayIndex: 0; ArrayLocationInName: 22;
      Name => "Field0SizeInBitsStage[n]",
      RegMem => "MemField",
      Description => "Size in bits of  field0",
      Width => "5",
      Position => "34:30", # Excel Formula: =calc_position(F180,E181)
    },
    Field0DestOffsetInNibblesStage0 => { #Structure Type: MemField; ArrayLength: 4; ArrayIndex: 0; ArrayLocationInName: 31;
      Name => "Field0DestOffsetInNibblesStage[n]",
      RegMem => "MemField",
      Description => "Offset in nibbles from lsb in which to stamp field0",
      Width => "5",
      Position => "39:35", # Excel Formula: =calc_position(F181,E182)
    },
    Field1SrcOffsetInBitsStage0 => { #Structure Type: MemField; ArrayLength: 4; ArrayIndex: 0; ArrayLocationInName: 27;
      Name => "Field1SrcOffsetInBitsStage[n]",
      RegMem => "MemField",
      Description => "Offset in bits from lsb from which to take field1",
      Width => "7",
      Position => "46:40", # Excel Formula: =calc_position(F182,E183)
    },
    Field1SizeInBitsStage0 => { #Structure Type: MemField; ArrayLength: 4; ArrayIndex: 0; ArrayLocationInName: 22;
      Name => "Field1SizeInBitsStage[n]",
      RegMem => "MemField",
      Description => "Size in bits of field1",
      Width => "5",
      Position => "51:47", # Excel Formula: =calc_position(F183,E184)
    },
    Field1DestOffsetInNibblesStage0 => { #Structure Type: MemField; ArrayLength: 4; ArrayIndex: 0; ArrayLocationInName: 31;
      Name => "Field1DestOffsetInNibblesStage[n]",
      RegMem => "MemField",
      Description => "Offset in nibbles from lsb in which to stamp  field1",
      Width => "5",
      Position => "56:52", # Excel Formula: =calc_position(F184,E185)
    },
    Field2SrcOffsetInBitsStage0 => { #Structure Type: MemField; ArrayLength: 4; ArrayIndex: 0; ArrayLocationInName: 27;
      Name => "Field2SrcOffsetInBitsStage[n]",
      RegMem => "MemField",
      Description => "Offset in bits from lsb from which to take field2",
      Width => "7",
      Position => "63:57", # Excel Formula: =calc_position(F185,E186)
    },
    Field2SizeInBitsStage0 => { #Structure Type: MemField; ArrayLength: 4; ArrayIndex: 0; ArrayLocationInName: 22;
      Name => "Field2SizeInBitsStage[n]",
      RegMem => "MemField",
      Description => "Size in bits of field2",
      Width => "5",
      Position => "68:64", # Excel Formula: =calc_position(F186,E187)
    },
    Field2DestOffsetInNibblesStage0 => { #Structure Type: MemField; ArrayLength: 4; ArrayIndex: 0; ArrayLocationInName: 31;
      Name => "Field2DestOffsetInNibblesStage[n]",
      RegMem => "MemField",
      Description => "Offset in nibbles from lsb in which to stamp  field2",
      Width => "5",
      Position => "73:69", # Excel Formula: =calc_position(F187,E188)
    },
    DestOffsetOnEncapDataInNibblesStage0 => { #Structure Type: MemField; ArrayLength: 4; ArrayIndex: 0; ArrayLocationInName: 36;
      Name => "DestOffsetOnEncapDataInNibblesStage[n]",
      RegMem => "MemField",
      Width => "5",
      Position => "78:74", # Excel Formula: =calc_position(F188,E189)
    },
    DestSizeOnEncapDataInBitsStage0 => { #Structure Type: MemField; ArrayLength: 4; ArrayIndex: 0; ArrayLocationInName: 31;
      Name => "DestSizeOnEncapDataInBitsStage[n]",
      RegMem => "MemField",
      Width => "5",
      Position => "83:79", # Excel Formula: =calc_position(F189,E190)
    },
    LpQueuingStage0 => { #Structure Type: MemField; ArrayLength: 4; ArrayIndex: 0; ArrayLocationInName: 15;
      Name => "LpQueuingStage[n]",
      RegMem => "MemField",
      Description => "Entry that should pass through the LP queuing stage in the resolution (it is Xor'ed into a sticky bit that indicated that this packet will finish its resolution processing only after going through the Resolution stage)",
      Width => "1",
      Position => "84", # Excel Formula: =calc_position(F190,E191)
    },
  },
  EntryTypeDecodingTableSlice0Stage1 => { #Structure Type: Mem; ArrayLength: 4; ArrayIndex: 1; ArrayLocationInName: 34;
    Name => "EntryTypeDecodingTableSlice0Stage[4]",
    RegMem => "Mem",
    Address => "B00000",
    Description => "Entry type decoding table",
    Width => "85", # Excel Formula: =calc_mem_width(E175:E191,M174,F191,-1)
    Type => "Config",
    UsedBy => "res",
    MemEntries => "64",
    MemWrapper => "RegArray",
    MemProtect => "None",
    AdditionalInfo => "CpuReadAccess=Enabled,CpuWriteAccess=Enabled,PortErrPropagate=Disabled",
    ArrayLength => "4",
    ArrayIndex => "1",
    MemLogicalWidth => "85",
    DestOffsetInBitsStage1 => { #Structure Type: MemField; ArrayLength: 4; ArrayIndex: 1; ArrayLocationInName: 22;
      Name => "DestOffsetInBitsStage[n]",
      RegMem => "MemField",
      Description => "Destination offset in nibbles ",
      Width => "7",
      Position => "6:0", # Excel Formula: =calc_position(F174,E175,TRUE)
    },
    DestSizeInBitsStage1 => { #Structure Type: MemField; ArrayLength: 4; ArrayIndex: 1; ArrayLocationInName: 20;
      Name => "DestSizeInBitsStage[n]",
      RegMem => "MemField",
      Description => "Destination width (according to Dest-encoding).  ",
      Width => "5",
      Position => "11:7", # Excel Formula: =calc_position(F175,E176)
    },
    DestTypeStage1 => { #Structure Type: MemField; ArrayLength: 4; ArrayIndex: 1; ArrayLocationInName: 14;
      Name => "DestTypeStage[n]",
      RegMem => "MemField",
      Width => "6",
      Position => "17:12", # Excel Formula: =calc_position(F176,E177)
    },
    StartEncapsulationStage1 => { #Structure Type: MemField; ArrayLength: 4; ArrayIndex: 1; ArrayLocationInName: 24;
      Name => "StartEncapsulationStage[n]",
      RegMem => "MemField",
      Description => "Encap-Index[1:0] flows in the resolution process. The initial value is 2'b00.
Every time Start-Encap is set increment this value by 1.
If Encap-Index is 2'b00 or 2'b01 then operate starting from msb
If Encap-Index is 2'b10 then operate 40b from msb
If Encap-Index is 2'b11 then operate 80b from msb",
      Width => "1",
      Position => "18", # Excel Formula: =calc_position(F177,E178)
    },
    EncTypeStage1 => { #Structure Type: MemField; ArrayLength: 4; ArrayIndex: 1; ArrayLocationInName: 13;
      Name => "EncTypeStage[n]",
      RegMem => "MemField",
      Description => "Encapsulation-type",
      Width => "4",
      Position => "22:19", # Excel Formula: =calc_position(F178,E179)
    },
    Field0SrcOffsetInBitsStage1 => { #Structure Type: MemField; ArrayLength: 4; ArrayIndex: 1; ArrayLocationInName: 27;
      Name => "Field0SrcOffsetInBitsStage[n]",
      RegMem => "MemField",
      Description => "Offset in bits from lsb from which to take field0",
      Width => "7",
      Position => "29:23", # Excel Formula: =calc_position(F179,E180)
    },
    Field0SizeInBitsStage1 => { #Structure Type: MemField; ArrayLength: 4; ArrayIndex: 1; ArrayLocationInName: 22;
      Name => "Field0SizeInBitsStage[n]",
      RegMem => "MemField",
      Description => "Size in bits of  field0",
      Width => "5",
      Position => "34:30", # Excel Formula: =calc_position(F180,E181)
    },
    Field0DestOffsetInNibblesStage1 => { #Structure Type: MemField; ArrayLength: 4; ArrayIndex: 1; ArrayLocationInName: 31;
      Name => "Field0DestOffsetInNibblesStage[n]",
      RegMem => "MemField",
      Description => "Offset in nibbles from lsb in which to stamp field0",
      Width => "5",
      Position => "39:35", # Excel Formula: =calc_position(F181,E182)
    },
    Field1SrcOffsetInBitsStage1 => { #Structure Type: MemField; ArrayLength: 4; ArrayIndex: 1; ArrayLocationInName: 27;
      Name => "Field1SrcOffsetInBitsStage[n]",
      RegMem => "MemField",
      Description => "Offset in bits from lsb from which to take field1",
      Width => "7",
      Position => "46:40", # Excel Formula: =calc_position(F182,E183)
    },
    Field1SizeInBitsStage1 => { #Structure Type: MemField; ArrayLength: 4; ArrayIndex: 1; ArrayLocationInName: 22;
      Name => "Field1SizeInBitsStage[n]",
      RegMem => "MemField",
      Description => "Size in bits of field1",
      Width => "5",
      Position => "51:47", # Excel Formula: =calc_position(F183,E184)
    },
    Field1DestOffsetInNibblesStage1 => { #Structure Type: MemField; ArrayLength: 4; ArrayIndex: 1; ArrayLocationInName: 31;
      Name => "Field1DestOffsetInNibblesStage[n]",
      RegMem => "MemField",
      Description => "Offset in nibbles from lsb in which to stamp  field1",
      Width => "5",
      Position => "56:52", # Excel Formula: =calc_position(F184,E185)
    },
    Field2SrcOffsetInBitsStage1 => { #Structure Type: MemField; ArrayLength: 4; ArrayIndex: 1; ArrayLocationInName: 27;
      Name => "Field2SrcOffsetInBitsStage[n]",
      RegMem => "MemField",
      Description => "Offset in bits from lsb from which to take field2",
      Width => "7",
      Position => "63:57", # Excel Formula: =calc_position(F185,E186)
    },
    Field2SizeInBitsStage1 => { #Structure Type: MemField; ArrayLength: 4; ArrayIndex: 1; ArrayLocationInName: 22;
      Name => "Field2SizeInBitsStage[n]",
      RegMem => "MemField",
      Description => "Size in bits of field2",
      Width => "5",
      Position => "68:64", # Excel Formula: =calc_position(F186,E187)
    },
    Field2DestOffsetInNibblesStage1 => { #Structure Type: MemField; ArrayLength: 4; ArrayIndex: 1; ArrayLocationInName: 31;
      Name => "Field2DestOffsetInNibblesStage[n]",
      RegMem => "MemField",
      Description => "Offset in nibbles from lsb in which to stamp  field2",
      Width => "5",
      Position => "73:69", # Excel Formula: =calc_position(F187,E188)
    },
    DestOffsetOnEncapDataInNibblesStage1 => { #Structure Type: MemField; ArrayLength: 4; ArrayIndex: 1; ArrayLocationInName: 36;
      Name => "DestOffsetOnEncapDataInNibblesStage[n]",
      RegMem => "MemField",
      Width => "5",
      Position => "78:74", # Excel Formula: =calc_position(F188,E189)
    },
    DestSizeOnEncapDataInBitsStage1 => { #Structure Type: MemField; ArrayLength: 4; ArrayIndex: 1; ArrayLocationInName: 31;
      Name => "DestSizeOnEncapDataInBitsStage[n]",
      RegMem => "MemField",
      Width => "5",
      Position => "83:79", # Excel Formula: =calc_position(F189,E190)
    },
    LpQueuingStage1 => { #Structure Type: MemField; ArrayLength: 4; ArrayIndex: 1; ArrayLocationInName: 15;
      Name => "LpQueuingStage[n]",
      RegMem => "MemField",
      Description => "Entry that should pass through the LP queuing stage in the resolution (it is Xor'ed into a sticky bit that indicated that this packet will finish its resolution processing only after going through the Resolution stage)",
      Width => "1",
      Position => "84", # Excel Formula: =calc_position(F190,E191)
    },
  },
  EntryTypeDecodingTableSlice0Stage2 => { #Structure Type: Mem; ArrayLength: 4; ArrayIndex: 2; ArrayLocationInName: 34;
    Name => "EntryTypeDecodingTableSlice0Stage[4]",
    RegMem => "Mem",
    Address => "C00000",
    Description => "Entry type decoding table",
    Width => "85", # Excel Formula: =calc_mem_width(E175:E191,M174,F191,-1)
    Type => "Config",
    UsedBy => "res",
    MemEntries => "64",
    MemWrapper => "RegArray",
    MemProtect => "None",
    AdditionalInfo => "CpuReadAccess=Enabled,CpuWriteAccess=Enabled,PortErrPropagate=Disabled",
    ArrayLength => "4",
    ArrayIndex => "2",
    MemLogicalWidth => "85",
    DestOffsetInBitsStage2 => { #Structure Type: MemField; ArrayLength: 4; ArrayIndex: 2; ArrayLocationInName: 22;
      Name => "DestOffsetInBitsStage[n]",
      RegMem => "MemField",
      Description => "Destination offset in nibbles ",
      Width => "7",
      Position => "6:0", # Excel Formula: =calc_position(F174,E175,TRUE)
    },
    DestSizeInBitsStage2 => { #Structure Type: MemField; ArrayLength: 4; ArrayIndex: 2; ArrayLocationInName: 20;
      Name => "DestSizeInBitsStage[n]",
      RegMem => "MemField",
      Description => "Destination width (according to Dest-encoding).  ",
      Width => "5",
      Position => "11:7", # Excel Formula: =calc_position(F175,E176)
    },
    DestTypeStage2 => { #Structure Type: MemField; ArrayLength: 4; ArrayIndex: 2; ArrayLocationInName: 14;
      Name => "DestTypeStage[n]",
      RegMem => "MemField",
      Width => "6",
      Position => "17:12", # Excel Formula: =calc_position(F176,E177)
    },
    StartEncapsulationStage2 => { #Structure Type: MemField; ArrayLength: 4; ArrayIndex: 2; ArrayLocationInName: 24;
      Name => "StartEncapsulationStage[n]",
      RegMem => "MemField",
      Description => "Encap-Index[1:0] flows in the resolution process. The initial value is 2'b00.
Every time Start-Encap is set increment this value by 1.
If Encap-Index is 2'b00 or 2'b01 then operate starting from msb
If Encap-Index is 2'b10 then operate 40b from msb
If Encap-Index is 2'b11 then operate 80b from msb",
      Width => "1",
      Position => "18", # Excel Formula: =calc_position(F177,E178)
    },
    EncTypeStage2 => { #Structure Type: MemField; ArrayLength: 4; ArrayIndex: 2; ArrayLocationInName: 13;
      Name => "EncTypeStage[n]",
      RegMem => "MemField",
      Description => "Encapsulation-type",
      Width => "4",
      Position => "22:19", # Excel Formula: =calc_position(F178,E179)
    },
    Field0SrcOffsetInBitsStage2 => { #Structure Type: MemField; ArrayLength: 4; ArrayIndex: 2; ArrayLocationInName: 27;
      Name => "Field0SrcOffsetInBitsStage[n]",
      RegMem => "MemField",
      Description => "Offset in bits from lsb from which to take field0",
      Width => "7",
      Position => "29:23", # Excel Formula: =calc_position(F179,E180)
    },
    Field0SizeInBitsStage2 => { #Structure Type: MemField; ArrayLength: 4; ArrayIndex: 2; ArrayLocationInName: 22;
      Name => "Field0SizeInBitsStage[n]",
      RegMem => "MemField",
      Description => "Size in bits of  field0",
      Width => "5",
      Position => "34:30", # Excel Formula: =calc_position(F180,E181)
    },
    Field0DestOffsetInNibblesStage2 => { #Structure Type: MemField; ArrayLength: 4; ArrayIndex: 2; ArrayLocationInName: 31;
      Name => "Field0DestOffsetInNibblesStage[n]",
      RegMem => "MemField",
      Description => "Offset in nibbles from lsb in which to stamp field0",
      Width => "5",
      Position => "39:35", # Excel Formula: =calc_position(F181,E182)
    },
    Field1SrcOffsetInBitsStage2 => { #Structure Type: MemField; ArrayLength: 4; ArrayIndex: 2; ArrayLocationInName: 27;
      Name => "Field1SrcOffsetInBitsStage[n]",
      RegMem => "MemField",
      Description => "Offset in bits from lsb from which to take field1",
      Width => "7",
      Position => "46:40", # Excel Formula: =calc_position(F182,E183)
    },
    Field1SizeInBitsStage2 => { #Structure Type: MemField; ArrayLength: 4; ArrayIndex: 2; ArrayLocationInName: 22;
      Name => "Field1SizeInBitsStage[n]",
      RegMem => "MemField",
      Description => "Size in bits of field1",
      Width => "5",
      Position => "51:47", # Excel Formula: =calc_position(F183,E184)
    },
    Field1DestOffsetInNibblesStage2 => { #Structure Type: MemField; ArrayLength: 4; ArrayIndex: 2; ArrayLocationInName: 31;
      Name => "Field1DestOffsetInNibblesStage[n]",
      RegMem => "MemField",
      Description => "Offset in nibbles from lsb in which to stamp  field1",
      Width => "5",
      Position => "56:52", # Excel Formula: =calc_position(F184,E185)
    },
    Field2SrcOffsetInBitsStage2 => { #Structure Type: MemField; ArrayLength: 4; ArrayIndex: 2; ArrayLocationInName: 27;
      Name => "Field2SrcOffsetInBitsStage[n]",
      RegMem => "MemField",
      Description => "Offset in bits from lsb from which to take field2",
      Width => "7",
      Position => "63:57", # Excel Formula: =calc_position(F185,E186)
    },
    Field2SizeInBitsStage2 => { #Structure Type: MemField; ArrayLength: 4; ArrayIndex: 2; ArrayLocationInName: 22;
      Name => "Field2SizeInBitsStage[n]",
      RegMem => "MemField",
      Description => "Size in bits of field2",
      Width => "5",
      Position => "68:64", # Excel Formula: =calc_position(F186,E187)
    },
    Field2DestOffsetInNibblesStage2 => { #Structure Type: MemField; ArrayLength: 4; ArrayIndex: 2; ArrayLocationInName: 31;
      Name => "Field2DestOffsetInNibblesStage[n]",
      RegMem => "MemField",
      Description => "Offset in nibbles from lsb in which to stamp  field2",
      Width => "5",
      Position => "73:69", # Excel Formula: =calc_position(F187,E188)
    },
    DestOffsetOnEncapDataInNibblesStage2 => { #Structure Type: MemField; ArrayLength: 4; ArrayIndex: 2; ArrayLocationInName: 36;
      Name => "DestOffsetOnEncapDataInNibblesStage[n]",
      RegMem => "MemField",
      Width => "5",
      Position => "78:74", # Excel Formula: =calc_position(F188,E189)
    },
    DestSizeOnEncapDataInBitsStage2 => { #Structure Type: MemField; ArrayLength: 4; ArrayIndex: 2; ArrayLocationInName: 31;
      Name => "DestSizeOnEncapDataInBitsStage[n]",
      RegMem => "MemField",
      Width => "5",
      Position => "83:79", # Excel Formula: =calc_position(F189,E190)
    },
    LpQueuingStage2 => { #Structure Type: MemField; ArrayLength: 4; ArrayIndex: 2; ArrayLocationInName: 15;
      Name => "LpQueuingStage[n]",
      RegMem => "MemField",
      Description => "Entry that should pass through the LP queuing stage in the resolution (it is Xor'ed into a sticky bit that indicated that this packet will finish its resolution processing only after going through the Resolution stage)",
      Width => "1",
      Position => "84", # Excel Formula: =calc_position(F190,E191)
    },
  },
  EntryTypeDecodingTableSlice0Stage3 => { #Structure Type: Mem; ArrayLength: 4; ArrayIndex: 3; ArrayLocationInName: 34;
    Name => "EntryTypeDecodingTableSlice0Stage[4]",
    RegMem => "Mem",
    Address => "D00000",
    Description => "Entry type decoding table",
    Width => "85", # Excel Formula: =calc_mem_width(E175:E191,M174,F191,-1)
    Type => "Config",
    UsedBy => "res",
    MemEntries => "64",
    MemWrapper => "RegArray",
    MemProtect => "None",
    AdditionalInfo => "CpuReadAccess=Enabled,CpuWriteAccess=Enabled,PortErrPropagate=Disabled",
    ArrayLength => "4",
    ArrayIndex => "3",
    MemLogicalWidth => "85",
    DestOffsetInBitsStage3 => { #Structure Type: MemField; ArrayLength: 4; ArrayIndex: 3; ArrayLocationInName: 22;
      Name => "DestOffsetInBitsStage[n]",
      RegMem => "MemField",
      Description => "Destination offset in nibbles ",
      Width => "7",
      Position => "6:0", # Excel Formula: =calc_position(F174,E175,TRUE)
    },
    DestSizeInBitsStage3 => { #Structure Type: MemField; ArrayLength: 4; ArrayIndex: 3; ArrayLocationInName: 20;
      Name => "DestSizeInBitsStage[n]",
      RegMem => "MemField",
      Description => "Destination width (according to Dest-encoding).  ",
      Width => "5",
      Position => "11:7", # Excel Formula: =calc_position(F175,E176)
    },
    DestTypeStage3 => { #Structure Type: MemField; ArrayLength: 4; ArrayIndex: 3; ArrayLocationInName: 14;
      Name => "DestTypeStage[n]",
      RegMem => "MemField",
      Width => "6",
      Position => "17:12", # Excel Formula: =calc_position(F176,E177)
    },
    StartEncapsulationStage3 => { #Structure Type: MemField; ArrayLength: 4; ArrayIndex: 3; ArrayLocationInName: 24;
      Name => "StartEncapsulationStage[n]",
      RegMem => "MemField",
      Description => "Encap-Index[1:0] flows in the resolution process. The initial value is 2'b00.
Every time Start-Encap is set increment this value by 1.
If Encap-Index is 2'b00 or 2'b01 then operate starting from msb
If Encap-Index is 2'b10 then operate 40b from msb
If Encap-Index is 2'b11 then operate 80b from msb",
      Width => "1",
      Position => "18", # Excel Formula: =calc_position(F177,E178)
    },
    EncTypeStage3 => { #Structure Type: MemField; ArrayLength: 4; ArrayIndex: 3; ArrayLocationInName: 13;
      Name => "EncTypeStage[n]",
      RegMem => "MemField",
      Description => "Encapsulation-type",
      Width => "4",
      Position => "22:19", # Excel Formula: =calc_position(F178,E179)
    },
    Field0SrcOffsetInBitsStage3 => { #Structure Type: MemField; ArrayLength: 4; ArrayIndex: 3; ArrayLocationInName: 27;
      Name => "Field0SrcOffsetInBitsStage[n]",
      RegMem => "MemField",
      Description => "Offset in bits from lsb from which to take field0",
      Width => "7",
      Position => "29:23", # Excel Formula: =calc_position(F179,E180)
    },
    Field0SizeInBitsStage3 => { #Structure Type: MemField; ArrayLength: 4; ArrayIndex: 3; ArrayLocationInName: 22;
      Name => "Field0SizeInBitsStage[n]",
      RegMem => "MemField",
      Description => "Size in bits of  field0",
      Width => "5",
      Position => "34:30", # Excel Formula: =calc_position(F180,E181)
    },
    Field0DestOffsetInNibblesStage3 => { #Structure Type: MemField; ArrayLength: 4; ArrayIndex: 3; ArrayLocationInName: 31;
      Name => "Field0DestOffsetInNibblesStage[n]",
      RegMem => "MemField",
      Description => "Offset in nibbles from lsb in which to stamp field0",
      Width => "5",
      Position => "39:35", # Excel Formula: =calc_position(F181,E182)
    },
    Field1SrcOffsetInBitsStage3 => { #Structure Type: MemField; ArrayLength: 4; ArrayIndex: 3; ArrayLocationInName: 27;
      Name => "Field1SrcOffsetInBitsStage[n]",
      RegMem => "MemField",
      Description => "Offset in bits from lsb from which to take field1",
      Width => "7",
      Position => "46:40", # Excel Formula: =calc_position(F182,E183)
    },
    Field1SizeInBitsStage3 => { #Structure Type: MemField; ArrayLength: 4; ArrayIndex: 3; ArrayLocationInName: 22;
      Name => "Field1SizeInBitsStage[n]",
      RegMem => "MemField",
      Description => "Size in bits of field1",
      Width => "5",
      Position => "51:47", # Excel Formula: =calc_position(F183,E184)
    },
    Field1DestOffsetInNibblesStage3 => { #Structure Type: MemField; ArrayLength: 4; ArrayIndex: 3; ArrayLocationInName: 31;
      Name => "Field1DestOffsetInNibblesStage[n]",
      RegMem => "MemField",
      Description => "Offset in nibbles from lsb in which to stamp  field1",
      Width => "5",
      Position => "56:52", # Excel Formula: =calc_position(F184,E185)
    },
    Field2SrcOffsetInBitsStage3 => { #Structure Type: MemField; ArrayLength: 4; ArrayIndex: 3; ArrayLocationInName: 27;
      Name => "Field2SrcOffsetInBitsStage[n]",
      RegMem => "MemField",
      Description => "Offset in bits from lsb from which to take field2",
      Width => "7",
      Position => "63:57", # Excel Formula: =calc_position(F185,E186)
    },
    Field2SizeInBitsStage3 => { #Structure Type: MemField; ArrayLength: 4; ArrayIndex: 3; ArrayLocationInName: 22;
      Name => "Field2SizeInBitsStage[n]",
      RegMem => "MemField",
      Description => "Size in bits of field2",
      Width => "5",
      Position => "68:64", # Excel Formula: =calc_position(F186,E187)
    },
    Field2DestOffsetInNibblesStage3 => { #Structure Type: MemField; ArrayLength: 4; ArrayIndex: 3; ArrayLocationInName: 31;
      Name => "Field2DestOffsetInNibblesStage[n]",
      RegMem => "MemField",
      Description => "Offset in nibbles from lsb in which to stamp  field2",
      Width => "5",
      Position => "73:69", # Excel Formula: =calc_position(F187,E188)
    },
    DestOffsetOnEncapDataInNibblesStage3 => { #Structure Type: MemField; ArrayLength: 4; ArrayIndex: 3; ArrayLocationInName: 36;
      Name => "DestOffsetOnEncapDataInNibblesStage[n]",
      RegMem => "MemField",
      Width => "5",
      Position => "78:74", # Excel Formula: =calc_position(F188,E189)
    },
    DestSizeOnEncapDataInBitsStage3 => { #Structure Type: MemField; ArrayLength: 4; ArrayIndex: 3; ArrayLocationInName: 31;
      Name => "DestSizeOnEncapDataInBitsStage[n]",
      RegMem => "MemField",
      Width => "5",
      Position => "83:79", # Excel Formula: =calc_position(F189,E190)
    },
    LpQueuingStage3 => { #Structure Type: MemField; ArrayLength: 4; ArrayIndex: 3; ArrayLocationInName: 15;
      Name => "LpQueuingStage[n]",
      RegMem => "MemField",
      Description => "Entry that should pass through the LP queuing stage in the resolution (it is Xor'ed into a sticky bit that indicated that this packet will finish its resolution processing only after going through the Resolution stage)",
      Width => "1",
      Position => "84", # Excel Formula: =calc_position(F190,E191)
    },
  },
  QosBvnMappingTableSlice0Stage0 => { #Structure Type: Mem; ArrayLength: 4; ArrayIndex: 0; ArrayLocationInName: 30;
    Name => "QosBvnMappingTableSlice0Stage[4]",
    RegMem => "Mem",
    Address => "E00000", # Excel Formula: =calc_mem_address(C174,A174,G192,L192)
    Description => "Qos and Bvn mapping table",
    Width => "6", # Excel Formula: =calc_mem_width(E193:E193,M192,F193,-1)
    Type => "Config",
    UsedBy => "res",
    MemEntries => "64",
    MemWrapper => "RegArray",
    MemProtect => "None",
    AdditionalInfo => "CpuReadAccess=Enabled,CpuWriteAccess=Enabled,PortErrPropagate=Disabled",
    ArrayLength => "4",
    ArrayIndex => "0",
    MemLogicalWidth => "6",
    DestAdditionStage0 => { #Structure Type: MemField; ArrayLength: 4; ArrayIndex: 0; ArrayLocationInName: 18;
      Name => "DestAdditionStage[n]",
      RegMem => "MemField",
      Description => "Value to be added to the destination for the above QoS/BVN combination",
      Width => "6",
      Position => "5:0", # Excel Formula: =calc_position(F192,E193,TRUE)
    },
  },
  QosBvnMappingTableSlice0Stage1 => { #Structure Type: Mem; ArrayLength: 4; ArrayIndex: 1; ArrayLocationInName: 30;
    Name => "QosBvnMappingTableSlice0Stage[4]",
    RegMem => "Mem",
    Address => "F00000",
    Description => "Qos and Bvn mapping table",
    Width => "6", # Excel Formula: =calc_mem_width(E193:E193,M192,F193,-1)
    Type => "Config",
    UsedBy => "res",
    MemEntries => "64",
    MemWrapper => "RegArray",
    MemProtect => "None",
    AdditionalInfo => "CpuReadAccess=Enabled,CpuWriteAccess=Enabled,PortErrPropagate=Disabled",
    ArrayLength => "4",
    ArrayIndex => "1",
    MemLogicalWidth => "6",
    DestAdditionStage1 => { #Structure Type: MemField; ArrayLength: 4; ArrayIndex: 1; ArrayLocationInName: 18;
      Name => "DestAdditionStage[n]",
      RegMem => "MemField",
      Description => "Value to be added to the destination for the above QoS/BVN combination",
      Width => "6",
      Position => "5:0", # Excel Formula: =calc_position(F192,E193,TRUE)
    },
  },
  QosBvnMappingTableSlice0Stage2 => { #Structure Type: Mem; ArrayLength: 4; ArrayIndex: 2; ArrayLocationInName: 30;
    Name => "QosBvnMappingTableSlice0Stage[4]",
    RegMem => "Mem",
    Address => "1000000",
    Description => "Qos and Bvn mapping table",
    Width => "6", # Excel Formula: =calc_mem_width(E193:E193,M192,F193,-1)
    Type => "Config",
    UsedBy => "res",
    MemEntries => "64",
    MemWrapper => "RegArray",
    MemProtect => "None",
    AdditionalInfo => "CpuReadAccess=Enabled,CpuWriteAccess=Enabled,PortErrPropagate=Disabled",
    ArrayLength => "4",
    ArrayIndex => "2",
    MemLogicalWidth => "6",
    DestAdditionStage2 => { #Structure Type: MemField; ArrayLength: 4; ArrayIndex: 2; ArrayLocationInName: 18;
      Name => "DestAdditionStage[n]",
      RegMem => "MemField",
      Description => "Value to be added to the destination for the above QoS/BVN combination",
      Width => "6",
      Position => "5:0", # Excel Formula: =calc_position(F192,E193,TRUE)
    },
  },
  QosBvnMappingTableSlice0Stage3 => { #Structure Type: Mem; ArrayLength: 4; ArrayIndex: 3; ArrayLocationInName: 30;
    Name => "QosBvnMappingTableSlice0Stage[4]",
    RegMem => "Mem",
    Address => "1100000",
    Description => "Qos and Bvn mapping table",
    Width => "6", # Excel Formula: =calc_mem_width(E193:E193,M192,F193,-1)
    Type => "Config",
    UsedBy => "res",
    MemEntries => "64",
    MemWrapper => "RegArray",
    MemProtect => "None",
    AdditionalInfo => "CpuReadAccess=Enabled,CpuWriteAccess=Enabled,PortErrPropagate=Disabled",
    ArrayLength => "4",
    ArrayIndex => "3",
    MemLogicalWidth => "6",
    DestAdditionStage3 => { #Structure Type: MemField; ArrayLength: 4; ArrayIndex: 3; ArrayLocationInName: 18;
      Name => "DestAdditionStage[n]",
      RegMem => "MemField",
      Description => "Value to be added to the destination for the above QoS/BVN combination",
      Width => "6",
      Position => "5:0", # Excel Formula: =calc_position(F192,E193,TRUE)
    },
  },
  DestDecodingTable => { #Structure Type: Mem;
    Name => "DestDecodingTable",
    RegMem => "Mem",
    Address => "1200000", # Excel Formula: =calc_mem_address(C192,A192,G194,L194)
    Description => "destination decoding table",
    Width => "7", # Excel Formula: =calc_mem_width(E195:E199,M194,F199,-1)
    Type => "Config",
    UsedBy => "res",
    MemEntries => "64",
    MemWrapper => "RegArray",
    MemProtect => "None",
    AdditionalInfo => "CpuReadAccess=Enabled,CpuWriteAccess=Enabled,PortErrPropagate=Disabled",
    MemLogicalWidth => "7",
    TableId => { #Structure Type: MemField;
      Name => "TableId",
      RegMem => "MemField",
      Description => "The table that can process this destination. May be one of the following values:
0 - FEC
1 - Stage 0
2 - Stage 1
3 - Stage 2
4 - Stage 3 
5 - LP Queuing
7 - Exit (go back to the NPE)",
      Width => "3",
      Position => "2:0", # Excel Formula: =calc_position(F194,E195,TRUE)
    },
    DestType => { #Structure Type: MemField;
      Name => "DestType",
      RegMem => "MemField",
      Description => "When accessing an EM table this field indicates the key to use. May be one of the following:
0  Load Balancing. In this case the table is used for load balancing
1  Destination mapping. In this case the destination is mapped.",
      Width => "1",
      Position => "3", # Excel Formula: =calc_position(F195,E196)
    },
    AddQosMapping => { #Structure Type: MemField;
      Name => "AddQosMapping",
      RegMem => "MemField",
      Description => "If set then the mapped value of {QoS, BVN-Profile} is added to the destination (after entry processing).",
      Width => "1",
      Position => "4", # Excel Formula: =calc_position(F196,E197)
    },
    IsPbts => { #Structure Type: MemField;
      Name => "IsPbts",
      RegMem => "MemField",
      Description => "If set then the destination should undergo PBTS processing",
      Width => "1",
      Position => "5", # Excel Formula: =calc_position(F197,E198)
    },
    DestinationSourceForEncapData => { #Structure Type: MemField;
      Name => "DestinationSourceForEncapData",
      RegMem => "MemField",
      Description => "When the destination is placed on the encapsulation data this configuration determines if the value to use is before or after PBTS calculation.
1b0  Use destination before PBTS calculation
1b1  User destination after PBTS calculation
",
      Width => "1",
      Position => "6", # Excel Formula: =calc_position(F198,E199)
    },
  },
  PbtsMapTableSlice0Stage0 => { #Structure Type: Mem; ArrayLength: 4; ArrayIndex: 0; ArrayLocationInName: 24;
    Name => "PbtsMapTableSlice0Stage[4]",
    RegMem => "Mem",
    Address => "1300000", # Excel Formula: =calc_mem_address(C194,A194,G200,L200)
    Description => "Pbts map table",
    Width => "23", # Excel Formula: =calc_mem_width(E201:E203,M200,F203,-1)
    Type => "Config",
    UsedBy => "res",
    MemEntries => "32",
    MemWrapper => "RegArray",
    MemProtect => "None",
    AdditionalInfo => "CpuReadAccess=Enabled,CpuWriteAccess=Enabled,PortErrPropagate=Disabled",
    ArrayLength => "4",
    ArrayIndex => "0",
    MemLogicalWidth => "23",
    AndMaskStage0 => { #Structure Type: MemField; ArrayLength: 4; ArrayIndex: 0; ArrayLocationInName: 13;
      Name => "AndMaskStage[n]",
      RegMem => "MemField",
      Description => "Indicates the destination base bits in the destination",
      Width => "18",
      Position => "17:0", # Excel Formula: =calc_position(F200,E201,TRUE)
    },
    DestinationShiftStage0 => { #Structure Type: MemField; ArrayLength: 4; ArrayIndex: 0; ArrayLocationInName: 22;
      Name => "DestinationShiftStage[n]",
      RegMem => "MemField",
      Description => "The masked destination is shifted by these value to provide the new destination base.",
      Width => "2",
      Position => "19:18", # Excel Formula: =calc_position(F201,E202)
    },
    PbtsOffsetStage0 => { #Structure Type: MemField; ArrayLength: 4; ArrayIndex: 0; ArrayLocationInName: 16;
      Name => "PbtsOffsetStage[n]",
      RegMem => "MemField",
      Description => "This value is added to the destination.",
      Width => "3",
      Position => "22:20", # Excel Formula: =calc_position(F202,E203)
    },
  },
  PbtsMapTableSlice0Stage1 => { #Structure Type: Mem; ArrayLength: 4; ArrayIndex: 1; ArrayLocationInName: 24;
    Name => "PbtsMapTableSlice0Stage[4]",
    RegMem => "Mem",
    Address => "1400000",
    Description => "Pbts map table",
    Width => "23", # Excel Formula: =calc_mem_width(E201:E203,M200,F203,-1)
    Type => "Config",
    UsedBy => "res",
    MemEntries => "32",
    MemWrapper => "RegArray",
    MemProtect => "None",
    AdditionalInfo => "CpuReadAccess=Enabled,CpuWriteAccess=Enabled,PortErrPropagate=Disabled",
    ArrayLength => "4",
    ArrayIndex => "1",
    MemLogicalWidth => "23",
    AndMaskStage1 => { #Structure Type: MemField; ArrayLength: 4; ArrayIndex: 1; ArrayLocationInName: 13;
      Name => "AndMaskStage[n]",
      RegMem => "MemField",
      Description => "Indicates the destination base bits in the destination",
      Width => "18",
      Position => "17:0", # Excel Formula: =calc_position(F200,E201,TRUE)
    },
    DestinationShiftStage1 => { #Structure Type: MemField; ArrayLength: 4; ArrayIndex: 1; ArrayLocationInName: 22;
      Name => "DestinationShiftStage[n]",
      RegMem => "MemField",
      Description => "The masked destination is shifted by these value to provide the new destination base.",
      Width => "2",
      Position => "19:18", # Excel Formula: =calc_position(F201,E202)
    },
    PbtsOffsetStage1 => { #Structure Type: MemField; ArrayLength: 4; ArrayIndex: 1; ArrayLocationInName: 16;
      Name => "PbtsOffsetStage[n]",
      RegMem => "MemField",
      Description => "This value is added to the destination.",
      Width => "3",
      Position => "22:20", # Excel Formula: =calc_position(F202,E203)
    },
  },
  PbtsMapTableSlice0Stage2 => { #Structure Type: Mem; ArrayLength: 4; ArrayIndex: 2; ArrayLocationInName: 24;
    Name => "PbtsMapTableSlice0Stage[4]",
    RegMem => "Mem",
    Address => "1500000",
    Description => "Pbts map table",
    Width => "23", # Excel Formula: =calc_mem_width(E201:E203,M200,F203,-1)
    Type => "Config",
    UsedBy => "res",
    MemEntries => "32",
    MemWrapper => "RegArray",
    MemProtect => "None",
    AdditionalInfo => "CpuReadAccess=Enabled,CpuWriteAccess=Enabled,PortErrPropagate=Disabled",
    ArrayLength => "4",
    ArrayIndex => "2",
    MemLogicalWidth => "23",
    AndMaskStage2 => { #Structure Type: MemField; ArrayLength: 4; ArrayIndex: 2; ArrayLocationInName: 13;
      Name => "AndMaskStage[n]",
      RegMem => "MemField",
      Description => "Indicates the destination base bits in the destination",
      Width => "18",
      Position => "17:0", # Excel Formula: =calc_position(F200,E201,TRUE)
    },
    DestinationShiftStage2 => { #Structure Type: MemField; ArrayLength: 4; ArrayIndex: 2; ArrayLocationInName: 22;
      Name => "DestinationShiftStage[n]",
      RegMem => "MemField",
      Description => "The masked destination is shifted by these value to provide the new destination base.",
      Width => "2",
      Position => "19:18", # Excel Formula: =calc_position(F201,E202)
    },
    PbtsOffsetStage2 => { #Structure Type: MemField; ArrayLength: 4; ArrayIndex: 2; ArrayLocationInName: 16;
      Name => "PbtsOffsetStage[n]",
      RegMem => "MemField",
      Description => "This value is added to the destination.",
      Width => "3",
      Position => "22:20", # Excel Formula: =calc_position(F202,E203)
    },
  },
  PbtsMapTableSlice0Stage3 => { #Structure Type: Mem; ArrayLength: 4; ArrayIndex: 3; ArrayLocationInName: 24;
    Name => "PbtsMapTableSlice0Stage[4]",
    RegMem => "Mem",
    Address => "1600000",
    Description => "Pbts map table",
    Width => "23", # Excel Formula: =calc_mem_width(E201:E203,M200,F203,-1)
    Type => "Config",
    UsedBy => "res",
    MemEntries => "32",
    MemWrapper => "RegArray",
    MemProtect => "None",
    AdditionalInfo => "CpuReadAccess=Enabled,CpuWriteAccess=Enabled,PortErrPropagate=Disabled",
    ArrayLength => "4",
    ArrayIndex => "3",
    MemLogicalWidth => "23",
    AndMaskStage3 => { #Structure Type: MemField; ArrayLength: 4; ArrayIndex: 3; ArrayLocationInName: 13;
      Name => "AndMaskStage[n]",
      RegMem => "MemField",
      Description => "Indicates the destination base bits in the destination",
      Width => "18",
      Position => "17:0", # Excel Formula: =calc_position(F200,E201,TRUE)
    },
    DestinationShiftStage3 => { #Structure Type: MemField; ArrayLength: 4; ArrayIndex: 3; ArrayLocationInName: 22;
      Name => "DestinationShiftStage[n]",
      RegMem => "MemField",
      Description => "The masked destination is shifted by these value to provide the new destination base.",
      Width => "2",
      Position => "19:18", # Excel Formula: =calc_position(F201,E202)
    },
    PbtsOffsetStage3 => { #Structure Type: MemField; ArrayLength: 4; ArrayIndex: 3; ArrayLocationInName: 16;
      Name => "PbtsOffsetStage[n]",
      RegMem => "MemField",
      Description => "This value is added to the destination.",
      Width => "3",
      Position => "22:20", # Excel Formula: =calc_position(F202,E203)
    },
  },
  Slice0LpQueuingFlowEncapTypeMapping => { #Structure Type: Mem; ArrayLength: 2; ArrayIndex: 0; ArrayLocationInName: 6;
    Name => "Slice[2]LpQueuingFlowEncapTypeMapping",
    RegMem => "Mem",
    Address => "1700000", # Excel Formula: =calc_mem_address(C200,A200,G204,L204)
    Width => "20", # Excel Formula: =calc_mem_width(E205:E208,M204,F208,-1)
    Type => "Config",
    UsedBy => "res",
    MemEntries => "64",
    MemWrapper => "RegArray",
    MemProtect => "None",
    AdditionalInfo => "CpuReadAccess=Enabled,CpuWriteAccess=Enabled,PortErrPropagate=Disabled",
    ArrayLength => "2",
    ArrayIndex => "0",
    MemLogicalWidth => "20",
    Field0OffsetInNibbles0 => { #Structure Type: MemField; ArrayLength: 2; ArrayIndex: 0; ArrayLocationInName: 22;
      Name => "Field0OffsetInNibbles[n]",
      RegMem => "MemField",
      Width => "5",
      Position => "4:0", # Excel Formula: =calc_position(F204,E205,TRUE)
    },
    Field1OffsetInNibbles0 => { #Structure Type: MemField; ArrayLength: 2; ArrayIndex: 0; ArrayLocationInName: 22;
      Name => "Field1OffsetInNibbles[n]",
      RegMem => "MemField",
      Width => "5",
      Position => "9:5", # Excel Formula: =calc_position(F205,E206)
    },
    Field0SizeInBits0 => { #Structure Type: MemField; ArrayLength: 2; ArrayIndex: 0; ArrayLocationInName: 17;
      Name => "Field0SizeInBits[n]",
      RegMem => "MemField",
      Width => "5",
      Position => "14:10", # Excel Formula: =calc_position(F206,E207)
    },
    Field1SizeInBits0 => { #Structure Type: MemField; ArrayLength: 2; ArrayIndex: 0; ArrayLocationInName: 17;
      Name => "Field1SizeInBits[n]",
      RegMem => "MemField",
      Width => "5",
      Position => "19:15", # Excel Formula: =calc_position(F207,E208)
    },
  },
  Slice1LpQueuingFlowEncapTypeMapping => { #Structure Type: Mem; ArrayLength: 2; ArrayIndex: 1; ArrayLocationInName: 6;
    Name => "Slice[2]LpQueuingFlowEncapTypeMapping",
    RegMem => "Mem",
    Address => "1800000",
    Width => "20", # Excel Formula: =calc_mem_width(E205:E208,M204,F208,-1)
    Type => "Config",
    UsedBy => "res",
    MemEntries => "64",
    MemWrapper => "RegArray",
    MemProtect => "None",
    AdditionalInfo => "CpuReadAccess=Enabled,CpuWriteAccess=Enabled,PortErrPropagate=Disabled",
    ArrayLength => "2",
    ArrayIndex => "1",
    MemLogicalWidth => "20",
    Field0OffsetInNibbles1 => { #Structure Type: MemField; ArrayLength: 2; ArrayIndex: 1; ArrayLocationInName: 22;
      Name => "Field0OffsetInNibbles[n]",
      RegMem => "MemField",
      Width => "5",
      Position => "4:0", # Excel Formula: =calc_position(F204,E205,TRUE)
    },
    Field1OffsetInNibbles1 => { #Structure Type: MemField; ArrayLength: 2; ArrayIndex: 1; ArrayLocationInName: 22;
      Name => "Field1OffsetInNibbles[n]",
      RegMem => "MemField",
      Width => "5",
      Position => "9:5", # Excel Formula: =calc_position(F205,E206)
    },
    Field0SizeInBits1 => { #Structure Type: MemField; ArrayLength: 2; ArrayIndex: 1; ArrayLocationInName: 17;
      Name => "Field0SizeInBits[n]",
      RegMem => "MemField",
      Width => "5",
      Position => "14:10", # Excel Formula: =calc_position(F206,E207)
    },
    Field1SizeInBits1 => { #Structure Type: MemField; ArrayLength: 2; ArrayIndex: 1; ArrayLocationInName: 17;
      Name => "Field1SizeInBits[n]",
      RegMem => "MemField",
      Width => "5",
      Position => "19:15", # Excel Formula: =calc_position(F207,E208)
    },
  },
  Slice0LpQueuingQosMapping => { #Structure Type: Mem; ArrayLength: 2; ArrayIndex: 0; ArrayLocationInName: 6;
    Name => "Slice[2]LpQueuingQosMapping",
    RegMem => "Mem",
    Address => "1900000", # Excel Formula: =calc_mem_address(C204,A204,G209,L209)
    Width => "3", # Excel Formula: =calc_mem_width(E210:E210,M209,F210,-1)
    Type => "Config",
    UsedBy => "res",
    MemEntries => "64",
    MemWrapper => "RegArray",
    MemProtect => "None",
    AdditionalInfo => "CpuReadAccess=Enabled,CpuWriteAccess=Enabled,PortErrPropagate=Disabled",
    ArrayLength => "2",
    ArrayIndex => "0",
    MemLogicalWidth => "3",
    QosMapBvnAddition0 => { #Structure Type: MemField; ArrayLength: 2; ArrayIndex: 0; ArrayLocationInName: 18;
      Name => "QosMapBvnAddition[n]",
      RegMem => "MemField",
      Width => "3",
      Position => "2:0", # Excel Formula: =calc_position(F209,E210,TRUE)
    },
  },
  Slice1LpQueuingQosMapping => { #Structure Type: Mem; ArrayLength: 2; ArrayIndex: 1; ArrayLocationInName: 6;
    Name => "Slice[2]LpQueuingQosMapping",
    RegMem => "Mem",
    Address => "1A00000",
    Width => "3", # Excel Formula: =calc_mem_width(E210:E210,M209,F210,-1)
    Type => "Config",
    UsedBy => "res",
    MemEntries => "64",
    MemWrapper => "RegArray",
    MemProtect => "None",
    AdditionalInfo => "CpuReadAccess=Enabled,CpuWriteAccess=Enabled,PortErrPropagate=Disabled",
    ArrayLength => "2",
    ArrayIndex => "1",
    MemLogicalWidth => "3",
    QosMapBvnAddition1 => { #Structure Type: MemField; ArrayLength: 2; ArrayIndex: 1; ArrayLocationInName: 18;
      Name => "QosMapBvnAddition[n]",
      RegMem => "MemField",
      Width => "3",
      Position => "2:0", # Excel Formula: =calc_position(F209,E210,TRUE)
    },
  },
  LpQueuingEm => { #Structure Type: Mem;
    Name => "LpQueuingEm",
    RegMem => "Mem",
    Address => "1900000", # Excel Formula: =calc_mem_address(C209,A209,G211,L211)
    Description => "Lp Queuing Exact Match",
    Width => "19", # Excel Formula: =calc_mem_width(E212:E213,M211,F213,-1)
    Type => "DocOnly",
    UsedBy => "res",
    MemEntries => "20480",
    MemWrapper => "EM",
    MemProtect => "None",
    AdditionalInfo => "KeyWidth=56,SourceIdWidth=1,NumberOfBanks=5,NumberOfCamEntries=32,NumberOfParallelBanks=5,2PMemory=Enabled,VerifierSampleReadBeforeProt=2,VerifierSamplePhysicalMem=1,VerifierCpuReadAccess=Enabled,VerifierCpuWriteAccess=Enabled,VrfWriteActivityFactor=0,VrfReadActivityFactor=100,VrfDisableSameAddressErr=Enabled,VrfEnableNonCpuRdWrSameAddress=Enabled,VldWriteActivityFactor=0,VldReadActivityFactor=100",
    Comments => "Key is according to lb-emdb-key-type:
0: key = {zeros(7), member-id(9), Group-ID(14)}
1: key = {LB-key(16), Group-id(14)}",
    MemLogicalWidth => "19",
    LpQueuingBvn => { #Structure Type: MemField;
      Name => "LpQueuingBvn",
      RegMem => "MemField",
      Width => "16",
      Position => "15:0", # Excel Formula: =calc_position(F211,E212,TRUE)
    },
    LpQueuingBvnProfile => { #Structure Type: MemField;
      Name => "LpQueuingBvnProfile",
      RegMem => "MemField",
      Width => "3",
      Position => "18:16", # Excel Formula: =calc_position(F212,E213)
    },
  },
  FecTable => { #Structure Type: Mem;
    Name => "FecTable",
    RegMem => "Mem",
    Address => "1B00000", # Excel Formula: =calc_mem_address(C209,A209,G214,L214)
    Description => "Resolution FEC table",
    Width => "88", # Excel Formula: =calc_mem_width(E215:E215,M214,F215,-1)
    Type => "Config",
    UsedBy => "res",
    MemEntries => "8192",
    MemWrapper => "2R1W Slow Write",
    MemProtect => "ECC",
    AdditionalInfo => "SampleReadBeforeProt=2,SampleReadAfterProt=1,PortErrPropagate=Enabled,CpuReadAccess=Enabled,CpuWriteAccess=Enabled,WriteActivityFactor=0,ReadActivityFactor=100",
    MemLogicalWidth => "80",
    FecTableRecord => { #Structure Type: MemField;
      Name => "FecTableRecord",
      RegMem => "MemField",
      Width => "80",
      Position => "79:0", # Excel Formula: =calc_position(F214,E215,TRUE)
    },
  },
  Slice0FecEntryTypeDecodingTable => { #Structure Type: Mem; ArrayLength: 2; ArrayIndex: 0; ArrayLocationInName: 6;
    Name => "Slice[2]FecEntryTypeDecodingTable",
    RegMem => "Mem",
    Address => "1C00000", # Excel Formula: =calc_mem_address(C214,A214,G216,L216)
    Description => "Entry type decoding table",
    Width => "85", # Excel Formula: =calc_mem_width(E217:E233,M216,F233,-1)
    Type => "Config",
    UsedBy => "res",
    MemEntries => "64",
    MemWrapper => "RegArray",
    MemProtect => "None",
    AdditionalInfo => "CpuReadAccess=Enabled,CpuWriteAccess=Enabled,PortErrPropagate=Disabled",
    ArrayLength => "2",
    ArrayIndex => "0",
    MemLogicalWidth => "85",
    DestOffsetInBits0 => { #Structure Type: MemField; ArrayLength: 2; ArrayIndex: 0; ArrayLocationInName: 17;
      Name => "DestOffsetInBits[n]",
      RegMem => "MemField",
      Description => "Destination offset in nibbles ",
      Width => "7",
      Position => "6:0", # Excel Formula: =calc_position(F216,E217,TRUE)
    },
    DestSizeInBits0 => { #Structure Type: MemField; ArrayLength: 2; ArrayIndex: 0; ArrayLocationInName: 15;
      Name => "DestSizeInBits[n]",
      RegMem => "MemField",
      Description => "Destination width (according to Dest-encoding).  ",
      Width => "5",
      Position => "11:7", # Excel Formula: =calc_position(F217,E218)
    },
    DestTypeSlice0 => { #Structure Type: MemField; ArrayLength: 2; ArrayIndex: 0; ArrayLocationInName: 14;
      Name => "DestTypeSlice[n]",
      RegMem => "MemField",
      Width => "6",
      Position => "17:12", # Excel Formula: =calc_position(F218,E219)
    },
    StartEncapsulation0 => { #Structure Type: MemField; ArrayLength: 2; ArrayIndex: 0; ArrayLocationInName: 19;
      Name => "StartEncapsulation[n]",
      RegMem => "MemField",
      Description => "Encap-Index[1:0] flows in the resolution process. The initial value is 2'b00.
Every time Start-Encap is set increment this value by 1.
If Encap-Index is 2'b00 or 2'b01 then operate starting from msb
If Encap-Index is 2'b10 then operate 40b from msb
If Encap-Index is 2'b11 then operate 80b from msb",
      Width => "1",
      Position => "18", # Excel Formula: =calc_position(F219,E220)
    },
    EncType0 => { #Structure Type: MemField; ArrayLength: 2; ArrayIndex: 0; ArrayLocationInName: 8;
      Name => "EncType[n]",
      RegMem => "MemField",
      Description => "Encapsulation-type",
      Width => "4",
      Position => "22:19", # Excel Formula: =calc_position(F220,E221)
    },
    Field0SrcOffsetInBits0 => { #Structure Type: MemField; ArrayLength: 2; ArrayIndex: 0; ArrayLocationInName: 22;
      Name => "Field0SrcOffsetInBits[n]",
      RegMem => "MemField",
      Description => "Offset in bits from lsb from which to take field0",
      Width => "7",
      Position => "29:23", # Excel Formula: =calc_position(F221,E222)
    },
    Field0SizeInBits0 => { #Structure Type: MemField; ArrayLength: 2; ArrayIndex: 0; ArrayLocationInName: 17;
      Name => "Field0SizeInBits[n]",
      RegMem => "MemField",
      Description => "Size in bits of  field0",
      Width => "5",
      Position => "34:30", # Excel Formula: =calc_position(F222,E223)
    },
    Field0DestOffsetInNibbles0 => { #Structure Type: MemField; ArrayLength: 2; ArrayIndex: 0; ArrayLocationInName: 26;
      Name => "Field0DestOffsetInNibbles[n]",
      RegMem => "MemField",
      Description => "Offset in nibbles from lsb in which to stamp field0",
      Width => "5",
      Position => "39:35", # Excel Formula: =calc_position(F223,E224)
    },
    Field1SrcOffsetInBits0 => { #Structure Type: MemField; ArrayLength: 2; ArrayIndex: 0; ArrayLocationInName: 22;
      Name => "Field1SrcOffsetInBits[n]",
      RegMem => "MemField",
      Description => "Offset in bits from lsb from which to take field1",
      Width => "7",
      Position => "46:40", # Excel Formula: =calc_position(F224,E225)
    },
    Field1SizeInBits0 => { #Structure Type: MemField; ArrayLength: 2; ArrayIndex: 0; ArrayLocationInName: 17;
      Name => "Field1SizeInBits[n]",
      RegMem => "MemField",
      Description => "Size in bits of field1",
      Width => "5",
      Position => "51:47", # Excel Formula: =calc_position(F225,E226)
    },
    Field1DestOffsetInNibbles0 => { #Structure Type: MemField; ArrayLength: 2; ArrayIndex: 0; ArrayLocationInName: 26;
      Name => "Field1DestOffsetInNibbles[n]",
      RegMem => "MemField",
      Description => "Offset in nibbles from lsb in which to stamp  field1",
      Width => "5",
      Position => "56:52", # Excel Formula: =calc_position(F226,E227)
    },
    Field2SrcOffsetInBits0 => { #Structure Type: MemField; ArrayLength: 2; ArrayIndex: 0; ArrayLocationInName: 22;
      Name => "Field2SrcOffsetInBits[n]",
      RegMem => "MemField",
      Description => "Offset in bits from lsb from which to take field2",
      Width => "7",
      Position => "63:57", # Excel Formula: =calc_position(F227,E228)
    },
    Field2SizeInBits0 => { #Structure Type: MemField; ArrayLength: 2; ArrayIndex: 0; ArrayLocationInName: 17;
      Name => "Field2SizeInBits[n]",
      RegMem => "MemField",
      Description => "Size in bits of field2",
      Width => "5",
      Position => "68:64", # Excel Formula: =calc_position(F228,E229)
    },
    Field2DestOffsetInNibbles0 => { #Structure Type: MemField; ArrayLength: 2; ArrayIndex: 0; ArrayLocationInName: 26;
      Name => "Field2DestOffsetInNibbles[n]",
      RegMem => "MemField",
      Description => "Offset in nibbles from lsb in which to stamp  field2",
      Width => "5",
      Position => "73:69", # Excel Formula: =calc_position(F229,E230)
    },
    DestOffsetOnEncapDataInNibbles0 => { #Structure Type: MemField; ArrayLength: 2; ArrayIndex: 0; ArrayLocationInName: 31;
      Name => "DestOffsetOnEncapDataInNibbles[n]",
      RegMem => "MemField",
      Width => "5",
      Position => "78:74", # Excel Formula: =calc_position(F230,E231)
    },
    DestSizeOnEncapDataInBits0 => { #Structure Type: MemField; ArrayLength: 2; ArrayIndex: 0; ArrayLocationInName: 26;
      Name => "DestSizeOnEncapDataInBits[n]",
      RegMem => "MemField",
      Width => "5",
      Position => "83:79", # Excel Formula: =calc_position(F231,E232)
    },
    LpQueuingStage0 => { #Structure Type: MemField; ArrayLength: 2; ArrayIndex: 0; ArrayLocationInName: 15;
      Name => "LpQueuingStage[n]",
      RegMem => "MemField",
      Description => "Entry that should pass through the LP queuing stage in the resolution (it is Xor'ed into a sticky bit that indicated that this packet will finish its resolution processing only after going through the Resolution stage)",
      Width => "1",
      Position => "84", # Excel Formula: =calc_position(F232,E233)
    },
  },
  Slice1FecEntryTypeDecodingTable => { #Structure Type: Mem; ArrayLength: 2; ArrayIndex: 1; ArrayLocationInName: 6;
    Name => "Slice[2]FecEntryTypeDecodingTable",
    RegMem => "Mem",
    Address => "1D00000",
    Description => "Entry type decoding table",
    Width => "85", # Excel Formula: =calc_mem_width(E217:E233,M216,F233,-1)
    Type => "Config",
    UsedBy => "res",
    MemEntries => "64",
    MemWrapper => "RegArray",
    MemProtect => "None",
    AdditionalInfo => "CpuReadAccess=Enabled,CpuWriteAccess=Enabled,PortErrPropagate=Disabled",
    ArrayLength => "2",
    ArrayIndex => "1",
    MemLogicalWidth => "85",
    DestOffsetInBits1 => { #Structure Type: MemField; ArrayLength: 2; ArrayIndex: 1; ArrayLocationInName: 17;
      Name => "DestOffsetInBits[n]",
      RegMem => "MemField",
      Description => "Destination offset in nibbles ",
      Width => "7",
      Position => "6:0", # Excel Formula: =calc_position(F216,E217,TRUE)
    },
    DestSizeInBits1 => { #Structure Type: MemField; ArrayLength: 2; ArrayIndex: 1; ArrayLocationInName: 15;
      Name => "DestSizeInBits[n]",
      RegMem => "MemField",
      Description => "Destination width (according to Dest-encoding).  ",
      Width => "5",
      Position => "11:7", # Excel Formula: =calc_position(F217,E218)
    },
    DestTypeSlice1 => { #Structure Type: MemField; ArrayLength: 2; ArrayIndex: 1; ArrayLocationInName: 14;
      Name => "DestTypeSlice[n]",
      RegMem => "MemField",
      Width => "6",
      Position => "17:12", # Excel Formula: =calc_position(F218,E219)
    },
    StartEncapsulation1 => { #Structure Type: MemField; ArrayLength: 2; ArrayIndex: 1; ArrayLocationInName: 19;
      Name => "StartEncapsulation[n]",
      RegMem => "MemField",
      Description => "Encap-Index[1:0] flows in the resolution process. The initial value is 2'b00.
Every time Start-Encap is set increment this value by 1.
If Encap-Index is 2'b00 or 2'b01 then operate starting from msb
If Encap-Index is 2'b10 then operate 40b from msb
If Encap-Index is 2'b11 then operate 80b from msb",
      Width => "1",
      Position => "18", # Excel Formula: =calc_position(F219,E220)
    },
    EncType1 => { #Structure Type: MemField; ArrayLength: 2; ArrayIndex: 1; ArrayLocationInName: 8;
      Name => "EncType[n]",
      RegMem => "MemField",
      Description => "Encapsulation-type",
      Width => "4",
      Position => "22:19", # Excel Formula: =calc_position(F220,E221)
    },
    Field0SrcOffsetInBits1 => { #Structure Type: MemField; ArrayLength: 2; ArrayIndex: 1; ArrayLocationInName: 22;
      Name => "Field0SrcOffsetInBits[n]",
      RegMem => "MemField",
      Description => "Offset in bits from lsb from which to take field0",
      Width => "7",
      Position => "29:23", # Excel Formula: =calc_position(F221,E222)
    },
    Field0SizeInBits1 => { #Structure Type: MemField; ArrayLength: 2; ArrayIndex: 1; ArrayLocationInName: 17;
      Name => "Field0SizeInBits[n]",
      RegMem => "MemField",
      Description => "Size in bits of  field0",
      Width => "5",
      Position => "34:30", # Excel Formula: =calc_position(F222,E223)
    },
    Field0DestOffsetInNibbles1 => { #Structure Type: MemField; ArrayLength: 2; ArrayIndex: 1; ArrayLocationInName: 26;
      Name => "Field0DestOffsetInNibbles[n]",
      RegMem => "MemField",
      Description => "Offset in nibbles from lsb in which to stamp field0",
      Width => "5",
      Position => "39:35", # Excel Formula: =calc_position(F223,E224)
    },
    Field1SrcOffsetInBits1 => { #Structure Type: MemField; ArrayLength: 2; ArrayIndex: 1; ArrayLocationInName: 22;
      Name => "Field1SrcOffsetInBits[n]",
      RegMem => "MemField",
      Description => "Offset in bits from lsb from which to take field1",
      Width => "7",
      Position => "46:40", # Excel Formula: =calc_position(F224,E225)
    },
    Field1SizeInBits1 => { #Structure Type: MemField; ArrayLength: 2; ArrayIndex: 1; ArrayLocationInName: 17;
      Name => "Field1SizeInBits[n]",
      RegMem => "MemField",
      Description => "Size in bits of field1",
      Width => "5",
      Position => "51:47", # Excel Formula: =calc_position(F225,E226)
    },
    Field1DestOffsetInNibbles1 => { #Structure Type: MemField; ArrayLength: 2; ArrayIndex: 1; ArrayLocationInName: 26;
      Name => "Field1DestOffsetInNibbles[n]",
      RegMem => "MemField",
      Description => "Offset in nibbles from lsb in which to stamp  field1",
      Width => "5",
      Position => "56:52", # Excel Formula: =calc_position(F226,E227)
    },
    Field2SrcOffsetInBits1 => { #Structure Type: MemField; ArrayLength: 2; ArrayIndex: 1; ArrayLocationInName: 22;
      Name => "Field2SrcOffsetInBits[n]",
      RegMem => "MemField",
      Description => "Offset in bits from lsb from which to take field2",
      Width => "7",
      Position => "63:57", # Excel Formula: =calc_position(F227,E228)
    },
    Field2SizeInBits1 => { #Structure Type: MemField; ArrayLength: 2; ArrayIndex: 1; ArrayLocationInName: 17;
      Name => "Field2SizeInBits[n]",
      RegMem => "MemField",
      Description => "Size in bits of field2",
      Width => "5",
      Position => "68:64", # Excel Formula: =calc_position(F228,E229)
    },
    Field2DestOffsetInNibbles1 => { #Structure Type: MemField; ArrayLength: 2; ArrayIndex: 1; ArrayLocationInName: 26;
      Name => "Field2DestOffsetInNibbles[n]",
      RegMem => "MemField",
      Description => "Offset in nibbles from lsb in which to stamp  field2",
      Width => "5",
      Position => "73:69", # Excel Formula: =calc_position(F229,E230)
    },
    DestOffsetOnEncapDataInNibbles1 => { #Structure Type: MemField; ArrayLength: 2; ArrayIndex: 1; ArrayLocationInName: 31;
      Name => "DestOffsetOnEncapDataInNibbles[n]",
      RegMem => "MemField",
      Width => "5",
      Position => "78:74", # Excel Formula: =calc_position(F230,E231)
    },
    DestSizeOnEncapDataInBits1 => { #Structure Type: MemField; ArrayLength: 2; ArrayIndex: 1; ArrayLocationInName: 26;
      Name => "DestSizeOnEncapDataInBits[n]",
      RegMem => "MemField",
      Width => "5",
      Position => "83:79", # Excel Formula: =calc_position(F231,E232)
    },
    LpQueuingStage1 => { #Structure Type: MemField; ArrayLength: 2; ArrayIndex: 1; ArrayLocationInName: 15;
      Name => "LpQueuingStage[n]",
      RegMem => "MemField",
      Description => "Entry that should pass through the LP queuing stage in the resolution (it is Xor'ed into a sticky bit that indicated that this packet will finish its resolution processing only after going through the Resolution stage)",
      Width => "1",
      Position => "84", # Excel Formula: =calc_position(F232,E233)
    },
  },
  Slice0FecQosBvnMappingTable => { #Structure Type: Mem; ArrayLength: 2; ArrayIndex: 0; ArrayLocationInName: 6;
    Name => "Slice[2]FecQosBvnMappingTable",
    RegMem => "Mem",
    Address => "1E00000", # Excel Formula: =calc_mem_address(C216,A216,G234,L234)
    Description => "Qos and Bvn mapping table",
    Width => "6", # Excel Formula: =calc_mem_width(E235:E235,M234,F235,-1)
    Type => "Config",
    UsedBy => "res",
    MemEntries => "64",
    MemWrapper => "RegArray",
    MemProtect => "None",
    AdditionalInfo => "CpuReadAccess=Enabled,CpuWriteAccess=Enabled,PortErrPropagate=Disabled",
    ArrayLength => "2",
    ArrayIndex => "0",
    MemLogicalWidth => "6",
    DestAddition0 => { #Structure Type: MemField; ArrayLength: 2; ArrayIndex: 0; ArrayLocationInName: 13;
      Name => "DestAddition[n]",
      RegMem => "MemField",
      Description => "Value to be added to the destination for the above QoS/BVN combination",
      Width => "6",
      Position => "5:0", # Excel Formula: =calc_position(F234,E235,TRUE)
    },
  },
  Slice1FecQosBvnMappingTable => { #Structure Type: Mem; ArrayLength: 2; ArrayIndex: 1; ArrayLocationInName: 6;
    Name => "Slice[2]FecQosBvnMappingTable",
    RegMem => "Mem",
    Address => "1F00000",
    Description => "Qos and Bvn mapping table",
    Width => "6", # Excel Formula: =calc_mem_width(E235:E235,M234,F235,-1)
    Type => "Config",
    UsedBy => "res",
    MemEntries => "64",
    MemWrapper => "RegArray",
    MemProtect => "None",
    AdditionalInfo => "CpuReadAccess=Enabled,CpuWriteAccess=Enabled,PortErrPropagate=Disabled",
    ArrayLength => "2",
    ArrayIndex => "1",
    MemLogicalWidth => "6",
    DestAddition1 => { #Structure Type: MemField; ArrayLength: 2; ArrayIndex: 1; ArrayLocationInName: 13;
      Name => "DestAddition[n]",
      RegMem => "MemField",
      Description => "Value to be added to the destination for the above QoS/BVN combination",
      Width => "6",
      Position => "5:0", # Excel Formula: =calc_position(F234,E235,TRUE)
    },
  },
  ResolutionStage1Em => { #Structure Type: Mem;
    Name => "ResolutionStage1Em",
    RegMem => "Mem",
    Address => "1E00000", # Excel Formula: =calc_mem_address(C234,A234,G236,L236)
    Description => "Resolution stage exact match",
    Width => "35", # Excel Formula: =calc_mem_width(E237:E239,M236,F239,-1)
    Type => "DocOnly",
    UsedBy => "res",
    MemEntries => "32768",
    MemWrapper => "EM",
    MemProtect => "None",
    AdditionalInfo => "KeyWidth=24,SourceIdWidth=1,NumberOfBanks=4,NumberOfCamEntries=32,NumberOfParallelBanks=4,2PMemory=Enabled,VerifierSampleReadBeforeProt=2,VerifierSamplePhysicalMem=1,VerifierCpuReadAccess=Enabled,VerifierCpuWriteAccess=Enabled,VrfWriteActivityFactor=0,VrfReadActivityFactor=100,VrfDisableSameAddressErr=Enabled,VrfEnableNonCpuRdWrSameAddress=Enabled,VldWriteActivityFactor=0,VldReadActivityFactor=100",
    Comments => "Key is according to lb-emdb-key-type:
0: key = {zeros(7), member-id(9), Group-ID(14)}
1: key = {LB-key(16), Group-id(14)}",
    MemLogicalWidth => "35",
    ResolutionStage1MemberIndex => { #Structure Type: MemField;
      Name => "ResolutionStage1MemberIndex",
      RegMem => "MemField",
      Description => "index to the associated attributes table",
      Width => "13",
      Position => "12:0", # Excel Formula: =calc_position(F236,E237,TRUE)
    },
    ResolutionStage1MemberEntrySelector => { #Structure Type: MemField;
      Name => "ResolutionStage1MemberEntrySelector",
      RegMem => "MemField",
      Description => "Shift value applied on the associated data output",
      Width => "2",
      Position => "14:13", # Excel Formula: =calc_position(F237,E238)
    },
    ResolutionStage1AdditionalData => { #Structure Type: MemField;
      Name => "ResolutionStage1AdditionalData",
      RegMem => "MemField",
      Description => "Additional data for this record",
      Width => "20",
      Position => "34:15", # Excel Formula: =calc_position(F238,E239)
    },
  },
  ResolutionStage1AssociatedData => { #Structure Type: Mem;
    Name => "ResolutionStage1AssociatedData",
    RegMem => "Mem",
    Address => "2000000", # Excel Formula: =calc_mem_address(C234,A234,G240,L240)
    Description => "Resolution stage associated data table",
    Width => "154", # Excel Formula: =calc_mem_width(E241:E241,M240,F241,-1)
    Type => "Config",
    UsedBy => "res",
    MemEntries => "8192",
    MemWrapper => "2R1W Slow Write",
    MemProtect => "ECC",
    AdditionalInfo => "SampleReadBeforeProt=3,SampleReadAfterProt=1,PortErrPropagate=Enabled,CpuReadAccess=Enabled,CpuWriteAccess=Enabled,WriteActivityFactor=0,ReadActivityFactor=100",
    MemLogicalWidth => "145",
    ResolutionStage1AssociatedRecord => { #Structure Type: MemField;
      Name => "ResolutionStage1AssociatedRecord",
      RegMem => "MemField",
      Width => "145",
      Position => "144:0", # Excel Formula: =calc_position(F240,E241,TRUE)
    },
  },
  ResolutionStage2Em => { #Structure Type: Mem;
    Name => "ResolutionStage2Em",
    RegMem => "Mem",
    Address => "2000000", # Excel Formula: =calc_mem_address(C240,A240,G242,L242)
    Description => "Resolution stage exact match",
    Width => "35", # Excel Formula: =calc_mem_width(E243:E245,M242,F245,-1)
    Type => "DocOnly",
    UsedBy => "res",
    MemEntries => "32768",
    MemWrapper => "EM",
    MemProtect => "None",
    AdditionalInfo => "KeyWidth=24,SourceIdWidth=1,NumberOfBanks=4,NumberOfCamEntries=32,NumberOfParallelBanks=4,2PMemory=Enabled,VerifierSampleReadBeforeProt=2,VerifierSamplePhysicalMem=1,VerifierCpuReadAccess=Enabled,VerifierCpuWriteAccess=Enabled,VrfWriteActivityFactor=0,VrfReadActivityFactor=100,VrfDisableSameAddressErr=Enabled,VrfEnableNonCpuRdWrSameAddress=Enabled,VldWriteActivityFactor=0,VldReadActivityFactor=100",
    Comments => "Key is according to lb-emdb-key-type:
0: key = {zeros(7), member-id(9), Group-ID(14)}
1: key = {LB-key(16), Group-id(14)}",
    MemLogicalWidth => "35",
    ResolutionStage2MemberIndex => { #Structure Type: MemField;
      Name => "ResolutionStage2MemberIndex",
      RegMem => "MemField",
      Description => "index to the associated attributes table",
      Width => "13",
      Position => "12:0", # Excel Formula: =calc_position(F242,E243,TRUE)
    },
    ResolutionStage2MemberEntrySelector => { #Structure Type: MemField;
      Name => "ResolutionStage2MemberEntrySelector",
      RegMem => "MemField",
      Description => "Shift value applied on the associated data output",
      Width => "2",
      Position => "14:13", # Excel Formula: =calc_position(F243,E244)
    },
    ResolutionStage2AdditionalData => { #Structure Type: MemField;
      Name => "ResolutionStage2AdditionalData",
      RegMem => "MemField",
      Description => "Additional data for this record",
      Width => "20",
      Position => "34:15", # Excel Formula: =calc_position(F244,E245)
    },
  },
  ResolutionStage2AssociatedData => { #Structure Type: Mem;
    Name => "ResolutionStage2AssociatedData",
    RegMem => "Mem",
    Address => "2100000", # Excel Formula: =calc_mem_address(C240,A240,G246,L246)
    Description => "Resolution stage associated data table",
    Width => "154", # Excel Formula: =calc_mem_width(E247:E247,M246,F247,-1)
    Type => "Config",
    UsedBy => "res",
    MemEntries => "8192",
    MemWrapper => "2R1W Slow Write",
    MemProtect => "ECC",
    AdditionalInfo => "SampleReadBeforeProt=3,SampleReadAfterProt=1,PortErrPropagate=Enabled,CpuReadAccess=Enabled,CpuWriteAccess=Enabled,WriteActivityFactor=0,ReadActivityFactor=100",
    MemLogicalWidth => "145",
    ResolutionStage2AssociatedRecord => { #Structure Type: MemField;
      Name => "ResolutionStage2AssociatedRecord",
      RegMem => "MemField",
      Width => "145",
      Position => "144:0", # Excel Formula: =calc_position(F246,E247,TRUE)
    },
  },
  ResolutionStage3Em => { #Structure Type: Mem;
    Name => "ResolutionStage3Em",
    RegMem => "Mem",
    Address => "2100000", # Excel Formula: =calc_mem_address(C246,A246,G248,L248)
    Description => "Resolution stage exact match",
    Width => "34", # Excel Formula: =calc_mem_width(E249:E251,M248,F251,-1)
    Type => "DocOnly",
    UsedBy => "res",
    MemEntries => "12288",
    MemWrapper => "EM",
    MemProtect => "None",
    AdditionalInfo => "KeyWidth=24,SourceIdWidth=1,NumberOfBanks=6,NumberOfCamEntries=32,NumberOfParallelBanks=6,2PMemory=Enabled,VerifierSampleReadBeforeProt=2,VerifierSamplePhysicalMem=1,VerifierCpuReadAccess=Enabled,VerifierCpuWriteAccess=Enabled,VrfWriteActivityFactor=0,VrfReadActivityFactor=100,VrfDisableSameAddressErr=Enabled,VrfEnableNonCpuRdWrSameAddress=Enabled,VldWriteActivityFactor=0,VldReadActivityFactor=100",
    Comments => "Key is according to lb-emdb-key-type:
0: key = {zeros(7), member-id(9), Group-ID(14)}
1: key = {LB-key(16), Group-id(14)}",
    MemLogicalWidth => "34",
    ResolutionStage3MemberIndex => { #Structure Type: MemField;
      Name => "ResolutionStage3MemberIndex",
      RegMem => "MemField",
      Description => "index to the associated attributes table",
      Width => "12",
      Position => "11:0", # Excel Formula: =calc_position(F248,E249,TRUE)
    },
    ResolutionStage3MemberEntrySelector => { #Structure Type: MemField;
      Name => "ResolutionStage3MemberEntrySelector",
      RegMem => "MemField",
      Description => "Shift value applied on the associated data output",
      Width => "2",
      Position => "13:12", # Excel Formula: =calc_position(F249,E250)
    },
    ResolutionStage3AdditionalData => { #Structure Type: MemField;
      Name => "ResolutionStage3AdditionalData",
      RegMem => "MemField",
      Description => "Additional data for this record",
      Width => "20",
      Position => "33:14", # Excel Formula: =calc_position(F250,E251)
    },
  },
  ResolutionStage3AssociatedData => { #Structure Type: Mem;
    Name => "ResolutionStage3AssociatedData",
    RegMem => "Mem",
    Address => "2200000", # Excel Formula: =calc_mem_address(C246,A246,G252,L252)
    Description => "Resolution stage associated data table",
    Width => "154", # Excel Formula: =calc_mem_width(E253:E253,M252,F253,-1)
    Type => "Config",
    UsedBy => "res",
    MemEntries => "3072",
    MemWrapper => "2R1W Slow Write",
    MemProtect => "ECC",
    AdditionalInfo => "SampleReadBeforeProt=3,SampleReadAfterProt=1,PortErrPropagate=Enabled,CpuReadAccess=Enabled,CpuWriteAccess=Enabled,WriteActivityFactor=0,ReadActivityFactor=100",
    MemLogicalWidth => "145",
    ResolutionStage3AssociatedRecord => { #Structure Type: MemField;
      Name => "ResolutionStage3AssociatedRecord",
      RegMem => "MemField",
      Width => "145",
      Position => "144:0", # Excel Formula: =calc_position(F252,E253,TRUE)
    },
  },
  protection_table_slice1_stage0 => { #Structure Type: Mem; ArrayLength: 4; ArrayIndex: 0; ArrayLocationInName: 30;
    Name => "protection_table_slice1_stage[4]",
    RegMem => "Mem",
    Address => "2300000", # Excel Formula: =calc_mem_address(C252,A252,G254,L254)
    Description => "Protection table per stage",
    Width => "13", # Excel Formula: =calc_mem_width(E255:E255,M254,F255,-1)
    Type => "Config",
    UsedBy => "res",
    DocName => "ProtectionTable[4]",
    MemEntries => "1024",
    MemWrapper => "1P",
    MemProtect => "ECC",
    AdditionalInfo => "SampleReadBeforeProt=1,SampleReadAfterProt=1,PortErrPropagate=Enabled,CpuReadAccess=Enabled,CpuWriteAccess=Enabled,WriteActivityFactor=0,ReadActivityFactor=50",
    ArrayLength => "4",
    ArrayIndex => "0",
    MemLogicalWidth => "8",
    protection_table_field_stage0 => { #Structure Type: MemField; ArrayLength: 4; ArrayIndex: 0; ArrayLocationInName: 29;
      Name => "protection_table_field_stage[n]",
      RegMem => "MemField",
      Description => "Protection table logical depth is 8K, with 13b Key, and payload of 1b indicates 'path'
Physical implementation aspect ratio is 1K x 8, such that:
Addr = Key[12:3]
Selected-path = payload[Key[2:0]]",
      Width => "8",
      Position => "7:0", # Excel Formula: =calc_position(F254,E255,TRUE)
      DocName => "ProtectionTableField[n]",
    },
  },
  protection_table_slice1_stage1 => { #Structure Type: Mem; ArrayLength: 4; ArrayIndex: 1; ArrayLocationInName: 30;
    Name => "protection_table_slice1_stage[4]",
    RegMem => "Mem",
    Address => "2400000",
    Description => "Protection table per stage",
    Width => "13", # Excel Formula: =calc_mem_width(E255:E255,M254,F255,-1)
    Type => "Config",
    UsedBy => "res",
    DocName => "ProtectionTable[4]",
    MemEntries => "1024",
    MemWrapper => "1P",
    MemProtect => "ECC",
    AdditionalInfo => "SampleReadBeforeProt=1,SampleReadAfterProt=1,PortErrPropagate=Enabled,CpuReadAccess=Enabled,CpuWriteAccess=Enabled,WriteActivityFactor=0,ReadActivityFactor=50",
    ArrayLength => "4",
    ArrayIndex => "1",
    MemLogicalWidth => "8",
    protection_table_field_stage1 => { #Structure Type: MemField; ArrayLength: 4; ArrayIndex: 1; ArrayLocationInName: 29;
      Name => "protection_table_field_stage[n]",
      RegMem => "MemField",
      Description => "Protection table logical depth is 8K, with 13b Key, and payload of 1b indicates 'path'
Physical implementation aspect ratio is 1K x 8, such that:
Addr = Key[12:3]
Selected-path = payload[Key[2:0]]",
      Width => "8",
      Position => "7:0", # Excel Formula: =calc_position(F254,E255,TRUE)
      DocName => "ProtectionTableField[n]",
    },
  },
  protection_table_slice1_stage2 => { #Structure Type: Mem; ArrayLength: 4; ArrayIndex: 2; ArrayLocationInName: 30;
    Name => "protection_table_slice1_stage[4]",
    RegMem => "Mem",
    Address => "2500000",
    Description => "Protection table per stage",
    Width => "13", # Excel Formula: =calc_mem_width(E255:E255,M254,F255,-1)
    Type => "Config",
    UsedBy => "res",
    DocName => "ProtectionTable[4]",
    MemEntries => "1024",
    MemWrapper => "1P",
    MemProtect => "ECC",
    AdditionalInfo => "SampleReadBeforeProt=1,SampleReadAfterProt=1,PortErrPropagate=Enabled,CpuReadAccess=Enabled,CpuWriteAccess=Enabled,WriteActivityFactor=0,ReadActivityFactor=50",
    ArrayLength => "4",
    ArrayIndex => "2",
    MemLogicalWidth => "8",
    protection_table_field_stage2 => { #Structure Type: MemField; ArrayLength: 4; ArrayIndex: 2; ArrayLocationInName: 29;
      Name => "protection_table_field_stage[n]",
      RegMem => "MemField",
      Description => "Protection table logical depth is 8K, with 13b Key, and payload of 1b indicates 'path'
Physical implementation aspect ratio is 1K x 8, such that:
Addr = Key[12:3]
Selected-path = payload[Key[2:0]]",
      Width => "8",
      Position => "7:0", # Excel Formula: =calc_position(F254,E255,TRUE)
      DocName => "ProtectionTableField[n]",
    },
  },
  protection_table_slice1_stage3 => { #Structure Type: Mem; ArrayLength: 4; ArrayIndex: 3; ArrayLocationInName: 30;
    Name => "protection_table_slice1_stage[4]",
    RegMem => "Mem",
    Address => "2600000",
    Description => "Protection table per stage",
    Width => "13", # Excel Formula: =calc_mem_width(E255:E255,M254,F255,-1)
    Type => "Config",
    UsedBy => "res",
    DocName => "ProtectionTable[4]",
    MemEntries => "1024",
    MemWrapper => "1P",
    MemProtect => "ECC",
    AdditionalInfo => "SampleReadBeforeProt=1,SampleReadAfterProt=1,PortErrPropagate=Enabled,CpuReadAccess=Enabled,CpuWriteAccess=Enabled,WriteActivityFactor=0,ReadActivityFactor=50",
    ArrayLength => "4",
    ArrayIndex => "3",
    MemLogicalWidth => "8",
    protection_table_field_stage3 => { #Structure Type: MemField; ArrayLength: 4; ArrayIndex: 3; ArrayLocationInName: 29;
      Name => "protection_table_field_stage[n]",
      RegMem => "MemField",
      Description => "Protection table logical depth is 8K, with 13b Key, and payload of 1b indicates 'path'
Physical implementation aspect ratio is 1K x 8, such that:
Addr = Key[12:3]
Selected-path = payload[Key[2:0]]",
      Width => "8",
      Position => "7:0", # Excel Formula: =calc_position(F254,E255,TRUE)
      DocName => "ProtectionTableField[n]",
    },
  },
  Slice0Stage0LbGroupSizeTable => { #Structure Type: Mem;
    Name => "Slice0Stage0LbGroupSizeTable",
    RegMem => "Mem",
    Address => "2700000", # Excel Formula: =calc_mem_address(C254,A254,G256,L256)
    Description => "Port-DSP-LB-Group-Size-Table:
If:
  payload.enable-consistence == 1'b1 && 
  (consistence-regs.valid == 1'b1) && 
  (consistence-regs.group-id == in-group-id) than
Consistence logic is done for the member-id-calculation
Else:
Regular member-id-calculation (according to payload.group-size and in-lb-key)",
    Width => "15", # Excel Formula: =calc_mem_width(E257:E258,M256,F258,-1)
    Type => "Config",
    UsedBy => "res",
    MemEntries => "32768", # Excel Formula: =2^15
    MemWrapper => "1P",
    MemProtect => "ECC",
    AdditionalInfo => "SampleReadBeforeProt=1,SampleReadAfterProt=1,PortErrPropagate=Enabled,CpuReadAccess=Enabled,CpuWriteAccess=Enabled,WriteActivityFactor=0,ReadActivityFactor=100",
    MemLogicalWidth => "10",
    EnableConsistenceStage0 => { #Structure Type: MemField;
      Name => "EnableConsistenceStage0",
      RegMem => "MemField",
      Description => "payload.enable_consistence",
      Width => "1",
      Position => "0", # Excel Formula: =calc_position(F256,E257,TRUE)
    },
    GroupSizeStage0 => { #Structure Type: MemField;
      Name => "GroupSizeStage0",
      RegMem => "MemField",
      Description => "payload.group-size",
      Width => "9", # Excel Formula: =calc_field_width_define("RES_LB_GROUP_SIZE_WIDTH")
      Position => "9:1", # Excel Formula: =calc_position(F257,E258)
    },
  },
  Slice0Stage1LbGroupSizeTable => { #Structure Type: Mem;
    Name => "Slice0Stage1LbGroupSizeTable",
    RegMem => "Mem",
    Address => "2800000", # Excel Formula: =calc_mem_address(C256,A256,G259,L259)
    Description => "Port-DSP-LB-Group-Size-Table:
If:
  payload.enable-consistence == 1'b1 && 
  (consistence-regs.valid == 1'b1) && 
  (consistence-regs.group-id == in-group-id) than
Consistence logic is done for the member-id-calculation
Else:
Regular member-id-calculation (according to payload.group-size and in-lb-key)",
    Width => "15", # Excel Formula: =calc_mem_width(E260:E261,M259,F261,-1)
    Type => "Config",
    UsedBy => "res",
    MemEntries => "16384", # Excel Formula: =2^14
    MemWrapper => "1P",
    MemProtect => "ECC",
    AdditionalInfo => "SampleReadBeforeProt=1,SampleReadAfterProt=1,PortErrPropagate=Enabled,CpuReadAccess=Enabled,CpuWriteAccess=Enabled,WriteActivityFactor=0,ReadActivityFactor=100",
    MemLogicalWidth => "10",
    EnableConsistenceStage1 => { #Structure Type: MemField;
      Name => "EnableConsistenceStage1",
      RegMem => "MemField",
      Description => "payload.enable_consistence",
      Width => "1",
      Position => "0", # Excel Formula: =calc_position(F259,E260,TRUE)
    },
    GroupSizeStage1 => { #Structure Type: MemField;
      Name => "GroupSizeStage1",
      RegMem => "MemField",
      Description => "payload.group-size",
      Width => "9", # Excel Formula: =calc_field_width_define("RES_LB_GROUP_SIZE_WIDTH")
      Position => "9:1", # Excel Formula: =calc_position(F260,E261)
    },
  },
  Slice0Stage2LbGroupSizeTable => { #Structure Type: Mem;
    Name => "Slice0Stage2LbGroupSizeTable",
    RegMem => "Mem",
    Address => "2900000", # Excel Formula: =calc_mem_address(C259,A259,G262,L262)
    Description => "Port-DSP-LB-Group-Size-Table:
If:
  payload.enable-consistence == 1'b1 && 
  (consistence-regs.valid == 1'b1) && 
  (consistence-regs.group-id == in-group-id) than
Consistence logic is done for the member-id-calculation
Else:
Regular member-id-calculation (according to payload.group-size and in-lb-key)",
    Width => "15", # Excel Formula: =calc_mem_width(E263:E264,M262,F264,-1)
    Type => "Config",
    UsedBy => "res",
    MemEntries => "16384", # Excel Formula: =2^14
    MemWrapper => "1P",
    MemProtect => "ECC",
    AdditionalInfo => "SampleReadBeforeProt=1,SampleReadAfterProt=1,PortErrPropagate=Enabled,CpuReadAccess=Enabled,CpuWriteAccess=Enabled,WriteActivityFactor=0,ReadActivityFactor=100",
    MemLogicalWidth => "10",
    EnableConsistenceStage2 => { #Structure Type: MemField;
      Name => "EnableConsistenceStage2",
      RegMem => "MemField",
      Description => "payload.enable_consistence",
      Width => "1",
      Position => "0", # Excel Formula: =calc_position(F262,E263,TRUE)
    },
    GroupSizeStage2 => { #Structure Type: MemField;
      Name => "GroupSizeStage2",
      RegMem => "MemField",
      Description => "payload.group-size",
      Width => "9", # Excel Formula: =calc_field_width_define("RES_LB_GROUP_SIZE_WIDTH")
      Position => "9:1", # Excel Formula: =calc_position(F263,E264)
    },
  },
  Slice0Stage3LbGroupSizeTable => { #Structure Type: Mem;
    Name => "Slice0Stage3LbGroupSizeTable",
    RegMem => "Mem",
    Address => "2A00000", # Excel Formula: =calc_mem_address(C262,A262,G265,L265)
    Description => "Port-DSP-LB-Group-Size-Table:
If:
  payload.enable-consistence == 1'b1 && 
  (consistence-regs.valid == 1'b1) && 
  (consistence-regs.group-id == in-group-id) than
Consistence logic is done for the member-id-calculation
Else:
Regular member-id-calculation (according to payload.group-size and in-lb-key)",
    Width => "15", # Excel Formula: =calc_mem_width(E266:E267,M265,F267,-1)
    Type => "Config",
    UsedBy => "res",
    MemEntries => "16384", # Excel Formula: =2^14
    MemWrapper => "1P",
    MemProtect => "ECC",
    AdditionalInfo => "SampleReadBeforeProt=1,SampleReadAfterProt=1,PortErrPropagate=Enabled,CpuReadAccess=Enabled,CpuWriteAccess=Enabled,WriteActivityFactor=0,ReadActivityFactor=100",
    MemLogicalWidth => "10",
    EnableConsistenceStage3 => { #Structure Type: MemField;
      Name => "EnableConsistenceStage3",
      RegMem => "MemField",
      Description => "payload.enable_consistence",
      Width => "1",
      Position => "0", # Excel Formula: =calc_position(F265,E266,TRUE)
    },
    GroupSizeStage3 => { #Structure Type: MemField;
      Name => "GroupSizeStage3",
      RegMem => "MemField",
      Description => "payload.group-size",
      Width => "9", # Excel Formula: =calc_field_width_define("RES_LB_GROUP_SIZE_WIDTH")
      Position => "9:1", # Excel Formula: =calc_position(F266,E267)
    },
  },
  Slice1Stage0LbGroupSizeTable => { #Structure Type: Mem;
    Name => "Slice1Stage0LbGroupSizeTable",
    RegMem => "Mem",
    Address => "2B00000", # Excel Formula: =calc_mem_address(C265,A265,G268,L268)
    Description => "Port-DSP-LB-Group-Size-Table:
If:
  payload.enable-consistence == 1'b1 && 
  (consistence-regs.valid == 1'b1) && 
  (consistence-regs.group-id == in-group-id) than
Consistence logic is done for the member-id-calculation
Else:
Regular member-id-calculation (according to payload.group-size and in-lb-key)",
    Width => "15", # Excel Formula: =calc_mem_width(E269:E270,M268,F270,-1)
    Type => "Config",
    UsedBy => "res",
    MemEntries => "32768", # Excel Formula: =2^15
    MemWrapper => "1P",
    MemProtect => "ECC",
    AdditionalInfo => "SampleReadBeforeProt=1,SampleReadAfterProt=1,PortErrPropagate=Enabled,CpuReadAccess=Enabled,CpuWriteAccess=Enabled,WriteActivityFactor=0,ReadActivityFactor=100",
    MemLogicalWidth => "10",
    EnableConsistenceStage0 => { #Structure Type: MemField;
      Name => "EnableConsistenceStage0",
      RegMem => "MemField",
      Description => "payload.enable_consistence",
      Width => "1",
      Position => "0", # Excel Formula: =calc_position(F268,E269,TRUE)
    },
    GroupSizeStage0 => { #Structure Type: MemField;
      Name => "GroupSizeStage0",
      RegMem => "MemField",
      Description => "payload.group-size",
      Width => "9", # Excel Formula: =calc_field_width_define("RES_LB_GROUP_SIZE_WIDTH")
      Position => "9:1", # Excel Formula: =calc_position(F269,E270)
    },
  },
  Slice1Stage1LbGroupSizeTable => { #Structure Type: Mem;
    Name => "Slice1Stage1LbGroupSizeTable",
    RegMem => "Mem",
    Address => "2C00000", # Excel Formula: =calc_mem_address(C268,A268,G271,L271)
    Description => "Port-DSP-LB-Group-Size-Table:
If:
  payload.enable-consistence == 1'b1 && 
  (consistence-regs.valid == 1'b1) && 
  (consistence-regs.group-id == in-group-id) than
Consistence logic is done for the member-id-calculation
Else:
Regular member-id-calculation (according to payload.group-size and in-lb-key)",
    Width => "15", # Excel Formula: =calc_mem_width(E272:E273,M271,F273,-1)
    Type => "Config",
    UsedBy => "res",
    MemEntries => "16384", # Excel Formula: =2^14
    MemWrapper => "1P",
    MemProtect => "ECC",
    AdditionalInfo => "SampleReadBeforeProt=1,SampleReadAfterProt=1,PortErrPropagate=Enabled,CpuReadAccess=Enabled,CpuWriteAccess=Enabled,WriteActivityFactor=0,ReadActivityFactor=100",
    MemLogicalWidth => "10",
    EnableConsistenceStage1 => { #Structure Type: MemField;
      Name => "EnableConsistenceStage1",
      RegMem => "MemField",
      Description => "payload.enable_consistence",
      Width => "1",
      Position => "0", # Excel Formula: =calc_position(F271,E272,TRUE)
    },
    GroupSizeStage1 => { #Structure Type: MemField;
      Name => "GroupSizeStage1",
      RegMem => "MemField",
      Description => "payload.group-size",
      Width => "9", # Excel Formula: =calc_field_width_define("RES_LB_GROUP_SIZE_WIDTH")
      Position => "9:1", # Excel Formula: =calc_position(F272,E273)
    },
  },
  Slice1Stage2LbGroupSizeTable => { #Structure Type: Mem;
    Name => "Slice1Stage2LbGroupSizeTable",
    RegMem => "Mem",
    Address => "2D00000", # Excel Formula: =calc_mem_address(C271,A271,G274,L274)
    Description => "Port-DSP-LB-Group-Size-Table:
If:
  payload.enable-consistence == 1'b1 && 
  (consistence-regs.valid == 1'b1) && 
  (consistence-regs.group-id == in-group-id) than
Consistence logic is done for the member-id-calculation
Else:
Regular member-id-calculation (according to payload.group-size and in-lb-key)",
    Width => "15", # Excel Formula: =calc_mem_width(E275:E276,M274,F276,-1)
    Type => "Config",
    UsedBy => "res",
    MemEntries => "16384", # Excel Formula: =2^14
    MemWrapper => "1P",
    MemProtect => "ECC",
    AdditionalInfo => "SampleReadBeforeProt=1,SampleReadAfterProt=1,PortErrPropagate=Enabled,CpuReadAccess=Enabled,CpuWriteAccess=Enabled,WriteActivityFactor=0,ReadActivityFactor=100",
    MemLogicalWidth => "10",
    EnableConsistenceStage2 => { #Structure Type: MemField;
      Name => "EnableConsistenceStage2",
      RegMem => "MemField",
      Description => "payload.enable_consistence",
      Width => "1",
      Position => "0", # Excel Formula: =calc_position(F274,E275,TRUE)
    },
    GroupSizeStage2 => { #Structure Type: MemField;
      Name => "GroupSizeStage2",
      RegMem => "MemField",
      Description => "payload.group-size",
      Width => "9", # Excel Formula: =calc_field_width_define("RES_LB_GROUP_SIZE_WIDTH")
      Position => "9:1", # Excel Formula: =calc_position(F275,E276)
    },
  },
  Slice1Stage3LbGroupSizeTable => { #Structure Type: Mem;
    Name => "Slice1Stage3LbGroupSizeTable",
    RegMem => "Mem",
    Address => "2E00000", # Excel Formula: =calc_mem_address(C274,A274,G277,L277)
    Description => "Port-DSP-LB-Group-Size-Table:
If:
  payload.enable-consistence == 1'b1 && 
  (consistence-regs.valid == 1'b1) && 
  (consistence-regs.group-id == in-group-id) than
Consistence logic is done for the member-id-calculation
Else:
Regular member-id-calculation (according to payload.group-size and in-lb-key)",
    Width => "15", # Excel Formula: =calc_mem_width(E278:E279,M277,F279,-1)
    Type => "Config",
    UsedBy => "res",
    MemEntries => "16384", # Excel Formula: =2^14
    MemWrapper => "1P",
    MemProtect => "ECC",
    AdditionalInfo => "SampleReadBeforeProt=1,SampleReadAfterProt=1,PortErrPropagate=Enabled,CpuReadAccess=Enabled,CpuWriteAccess=Enabled,WriteActivityFactor=0,ReadActivityFactor=100",
    MemLogicalWidth => "10",
    EnableConsistenceStage3 => { #Structure Type: MemField;
      Name => "EnableConsistenceStage3",
      RegMem => "MemField",
      Description => "payload.enable_consistence",
      Width => "1",
      Position => "0", # Excel Formula: =calc_position(F277,E278,TRUE)
    },
    GroupSizeStage3 => { #Structure Type: MemField;
      Name => "GroupSizeStage3",
      RegMem => "MemField",
      Description => "payload.group-size",
      Width => "9", # Excel Formula: =calc_field_width_define("RES_LB_GROUP_SIZE_WIDTH")
      Position => "9:1", # Excel Formula: =calc_position(F278,E279)
    },
  },
  QosBvnMappingTableSlice1Stage0 => { #Structure Type: Mem; ArrayLength: 4; ArrayIndex: 0; ArrayLocationInName: 30;
    Name => "QosBvnMappingTableSlice1Stage[4]",
    RegMem => "Mem",
    Address => "2F00000", # Excel Formula: =calc_mem_address(C277,A277,G280,L280)
    Description => "Qos and Bvn mapping table",
    Width => "6", # Excel Formula: =calc_mem_width(E281:E281,M280,F281,-1)
    Type => "Config",
    UsedBy => "res",
    MemEntries => "64",
    MemWrapper => "RegArray",
    MemProtect => "None",
    AdditionalInfo => "CpuReadAccess=Enabled,CpuWriteAccess=Enabled,PortErrPropagate=Disabled",
    ArrayLength => "4",
    ArrayIndex => "0",
    MemLogicalWidth => "6",
    DestAdditionStage0 => { #Structure Type: MemField; ArrayLength: 4; ArrayIndex: 0; ArrayLocationInName: 18;
      Name => "DestAdditionStage[n]",
      RegMem => "MemField",
      Description => "Value to be added to the destination for the above QoS/BVN combination",
      Width => "6",
      Position => "5:0", # Excel Formula: =calc_position(F280,E281,TRUE)
    },
  },
  QosBvnMappingTableSlice1Stage1 => { #Structure Type: Mem; ArrayLength: 4; ArrayIndex: 1; ArrayLocationInName: 30;
    Name => "QosBvnMappingTableSlice1Stage[4]",
    RegMem => "Mem",
    Address => "3000000",
    Description => "Qos and Bvn mapping table",
    Width => "6", # Excel Formula: =calc_mem_width(E281:E281,M280,F281,-1)
    Type => "Config",
    UsedBy => "res",
    MemEntries => "64",
    MemWrapper => "RegArray",
    MemProtect => "None",
    AdditionalInfo => "CpuReadAccess=Enabled,CpuWriteAccess=Enabled,PortErrPropagate=Disabled",
    ArrayLength => "4",
    ArrayIndex => "1",
    MemLogicalWidth => "6",
    DestAdditionStage1 => { #Structure Type: MemField; ArrayLength: 4; ArrayIndex: 1; ArrayLocationInName: 18;
      Name => "DestAdditionStage[n]",
      RegMem => "MemField",
      Description => "Value to be added to the destination for the above QoS/BVN combination",
      Width => "6",
      Position => "5:0", # Excel Formula: =calc_position(F280,E281,TRUE)
    },
  },
  QosBvnMappingTableSlice1Stage2 => { #Structure Type: Mem; ArrayLength: 4; ArrayIndex: 2; ArrayLocationInName: 30;
    Name => "QosBvnMappingTableSlice1Stage[4]",
    RegMem => "Mem",
    Address => "3100000",
    Description => "Qos and Bvn mapping table",
    Width => "6", # Excel Formula: =calc_mem_width(E281:E281,M280,F281,-1)
    Type => "Config",
    UsedBy => "res",
    MemEntries => "64",
    MemWrapper => "RegArray",
    MemProtect => "None",
    AdditionalInfo => "CpuReadAccess=Enabled,CpuWriteAccess=Enabled,PortErrPropagate=Disabled",
    ArrayLength => "4",
    ArrayIndex => "2",
    MemLogicalWidth => "6",
    DestAdditionStage2 => { #Structure Type: MemField; ArrayLength: 4; ArrayIndex: 2; ArrayLocationInName: 18;
      Name => "DestAdditionStage[n]",
      RegMem => "MemField",
      Description => "Value to be added to the destination for the above QoS/BVN combination",
      Width => "6",
      Position => "5:0", # Excel Formula: =calc_position(F280,E281,TRUE)
    },
  },
  QosBvnMappingTableSlice1Stage3 => { #Structure Type: Mem; ArrayLength: 4; ArrayIndex: 3; ArrayLocationInName: 30;
    Name => "QosBvnMappingTableSlice1Stage[4]",
    RegMem => "Mem",
    Address => "3200000",
    Description => "Qos and Bvn mapping table",
    Width => "6", # Excel Formula: =calc_mem_width(E281:E281,M280,F281,-1)
    Type => "Config",
    UsedBy => "res",
    MemEntries => "64",
    MemWrapper => "RegArray",
    MemProtect => "None",
    AdditionalInfo => "CpuReadAccess=Enabled,CpuWriteAccess=Enabled,PortErrPropagate=Disabled",
    ArrayLength => "4",
    ArrayIndex => "3",
    MemLogicalWidth => "6",
    DestAdditionStage3 => { #Structure Type: MemField; ArrayLength: 4; ArrayIndex: 3; ArrayLocationInName: 18;
      Name => "DestAdditionStage[n]",
      RegMem => "MemField",
      Description => "Value to be added to the destination for the above QoS/BVN combination",
      Width => "6",
      Position => "5:0", # Excel Formula: =calc_position(F280,E281,TRUE)
    },
  },
  EntryTypeDecodingTableSlice1Stage0 => { #Structure Type: Mem; ArrayLength: 4; ArrayIndex: 0; ArrayLocationInName: 34;
    Name => "EntryTypeDecodingTableSlice1Stage[4]",
    RegMem => "Mem",
    Address => "3300000", # Excel Formula: =calc_mem_address(C280,A280,G282,L282)
    Description => "Entry type decoding table",
    Width => "85", # Excel Formula: =calc_mem_width(E283:E299,M282,F299,-1)
    Type => "Config",
    UsedBy => "res",
    MemEntries => "64",
    MemWrapper => "RegArray",
    MemProtect => "None",
    AdditionalInfo => "CpuReadAccess=Enabled,CpuWriteAccess=Enabled,PortErrPropagate=Disabled",
    ArrayLength => "4",
    ArrayIndex => "0",
    MemLogicalWidth => "85",
    DestOffsetInBitsStage0 => { #Structure Type: MemField; ArrayLength: 4; ArrayIndex: 0; ArrayLocationInName: 22;
      Name => "DestOffsetInBitsStage[n]",
      RegMem => "MemField",
      Description => "Destination offset in nibbles ",
      Width => "7",
      Position => "6:0", # Excel Formula: =calc_position(F282,E283,TRUE)
    },
    DestSizeInBitsStage0 => { #Structure Type: MemField; ArrayLength: 4; ArrayIndex: 0; ArrayLocationInName: 20;
      Name => "DestSizeInBitsStage[n]",
      RegMem => "MemField",
      Description => "Destination width (according to Dest-encoding).  ",
      Width => "5",
      Position => "11:7", # Excel Formula: =calc_position(F283,E284)
    },
    DestTypeStage0 => { #Structure Type: MemField; ArrayLength: 4; ArrayIndex: 0; ArrayLocationInName: 14;
      Name => "DestTypeStage[n]",
      RegMem => "MemField",
      Width => "6",
      Position => "17:12", # Excel Formula: =calc_position(F284,E285)
    },
    StartEncapsulationStage0 => { #Structure Type: MemField; ArrayLength: 4; ArrayIndex: 0; ArrayLocationInName: 24;
      Name => "StartEncapsulationStage[n]",
      RegMem => "MemField",
      Description => "Encap-Index[1:0] flows in the resolution process. The initial value is 2'b00.
Every time Start-Encap is set increment this value by 1.
If Encap-Index is 2'b00 or 2'b01 then operate starting from msb
If Encap-Index is 2'b10 then operate 40b from msb
If Encap-Index is 2'b11 then operate 80b from msb",
      Width => "1",
      Position => "18", # Excel Formula: =calc_position(F285,E286)
    },
    EncTypeStage0 => { #Structure Type: MemField; ArrayLength: 4; ArrayIndex: 0; ArrayLocationInName: 13;
      Name => "EncTypeStage[n]",
      RegMem => "MemField",
      Description => "Encapsulation-type",
      Width => "4",
      Position => "22:19", # Excel Formula: =calc_position(F286,E287)
    },
    Field0SrcOffsetInBitsStage0 => { #Structure Type: MemField; ArrayLength: 4; ArrayIndex: 0; ArrayLocationInName: 27;
      Name => "Field0SrcOffsetInBitsStage[n]",
      RegMem => "MemField",
      Description => "Offset in bits from lsb from which to take field0",
      Width => "7",
      Position => "29:23", # Excel Formula: =calc_position(F287,E288)
    },
    Field0SizeInBitsStage0 => { #Structure Type: MemField; ArrayLength: 4; ArrayIndex: 0; ArrayLocationInName: 22;
      Name => "Field0SizeInBitsStage[n]",
      RegMem => "MemField",
      Description => "Size in bits of  field0",
      Width => "5",
      Position => "34:30", # Excel Formula: =calc_position(F288,E289)
    },
    Field0DestOffsetInNibblesStage0 => { #Structure Type: MemField; ArrayLength: 4; ArrayIndex: 0; ArrayLocationInName: 31;
      Name => "Field0DestOffsetInNibblesStage[n]",
      RegMem => "MemField",
      Description => "Offset in nibbles from lsb in which to stamp field0",
      Width => "5",
      Position => "39:35", # Excel Formula: =calc_position(F289,E290)
    },
    Field1SrcOffsetInBitsStage0 => { #Structure Type: MemField; ArrayLength: 4; ArrayIndex: 0; ArrayLocationInName: 27;
      Name => "Field1SrcOffsetInBitsStage[n]",
      RegMem => "MemField",
      Description => "Offset in bits from lsb from which to take field1",
      Width => "7",
      Position => "46:40", # Excel Formula: =calc_position(F290,E291)
    },
    Field1SizeInBitsStage0 => { #Structure Type: MemField; ArrayLength: 4; ArrayIndex: 0; ArrayLocationInName: 22;
      Name => "Field1SizeInBitsStage[n]",
      RegMem => "MemField",
      Description => "Size in bits of field1",
      Width => "5",
      Position => "51:47", # Excel Formula: =calc_position(F291,E292)
    },
    Field1DestOffsetInNibblesStage0 => { #Structure Type: MemField; ArrayLength: 4; ArrayIndex: 0; ArrayLocationInName: 31;
      Name => "Field1DestOffsetInNibblesStage[n]",
      RegMem => "MemField",
      Description => "Offset in nibbles from lsb in which to stamp  field1",
      Width => "5",
      Position => "56:52", # Excel Formula: =calc_position(F292,E293)
    },
    Field2SrcOffsetInBitsStage0 => { #Structure Type: MemField; ArrayLength: 4; ArrayIndex: 0; ArrayLocationInName: 27;
      Name => "Field2SrcOffsetInBitsStage[n]",
      RegMem => "MemField",
      Description => "Offset in bits from lsb from which to take field2",
      Width => "7",
      Position => "63:57", # Excel Formula: =calc_position(F293,E294)
    },
    Field2SizeInBitsStage0 => { #Structure Type: MemField; ArrayLength: 4; ArrayIndex: 0; ArrayLocationInName: 22;
      Name => "Field2SizeInBitsStage[n]",
      RegMem => "MemField",
      Description => "Size in bits of field2",
      Width => "5",
      Position => "68:64", # Excel Formula: =calc_position(F294,E295)
    },
    Field2DestOffsetInNibblesStage0 => { #Structure Type: MemField; ArrayLength: 4; ArrayIndex: 0; ArrayLocationInName: 31;
      Name => "Field2DestOffsetInNibblesStage[n]",
      RegMem => "MemField",
      Description => "Offset in nibbles from lsb in which to stamp  field2",
      Width => "5",
      Position => "73:69", # Excel Formula: =calc_position(F295,E296)
    },
    DestOffsetOnEncapDataInNibblesStage0 => { #Structure Type: MemField; ArrayLength: 4; ArrayIndex: 0; ArrayLocationInName: 36;
      Name => "DestOffsetOnEncapDataInNibblesStage[n]",
      RegMem => "MemField",
      Width => "5",
      Position => "78:74", # Excel Formula: =calc_position(F296,E297)
    },
    DestSizeOnEncapDataInBitsStage0 => { #Structure Type: MemField; ArrayLength: 4; ArrayIndex: 0; ArrayLocationInName: 31;
      Name => "DestSizeOnEncapDataInBitsStage[n]",
      RegMem => "MemField",
      Width => "5",
      Position => "83:79", # Excel Formula: =calc_position(F297,E298)
    },
    LpQueuingStage0 => { #Structure Type: MemField; ArrayLength: 4; ArrayIndex: 0; ArrayLocationInName: 15;
      Name => "LpQueuingStage[n]",
      RegMem => "MemField",
      Description => "Entry that should pass through the LP queuing stage in the resolution (it is Xor'ed into a sticky bit that indicated that this packet will finish its resolution processing only after going through the Resolution stage)",
      Width => "1",
      Position => "84", # Excel Formula: =calc_position(F298,E299)
    },
  },
  EntryTypeDecodingTableSlice1Stage1 => { #Structure Type: Mem; ArrayLength: 4; ArrayIndex: 1; ArrayLocationInName: 34;
    Name => "EntryTypeDecodingTableSlice1Stage[4]",
    RegMem => "Mem",
    Address => "3400000",
    Description => "Entry type decoding table",
    Width => "85", # Excel Formula: =calc_mem_width(E283:E299,M282,F299,-1)
    Type => "Config",
    UsedBy => "res",
    MemEntries => "64",
    MemWrapper => "RegArray",
    MemProtect => "None",
    AdditionalInfo => "CpuReadAccess=Enabled,CpuWriteAccess=Enabled,PortErrPropagate=Disabled",
    ArrayLength => "4",
    ArrayIndex => "1",
    MemLogicalWidth => "85",
    DestOffsetInBitsStage1 => { #Structure Type: MemField; ArrayLength: 4; ArrayIndex: 1; ArrayLocationInName: 22;
      Name => "DestOffsetInBitsStage[n]",
      RegMem => "MemField",
      Description => "Destination offset in nibbles ",
      Width => "7",
      Position => "6:0", # Excel Formula: =calc_position(F282,E283,TRUE)
    },
    DestSizeInBitsStage1 => { #Structure Type: MemField; ArrayLength: 4; ArrayIndex: 1; ArrayLocationInName: 20;
      Name => "DestSizeInBitsStage[n]",
      RegMem => "MemField",
      Description => "Destination width (according to Dest-encoding).  ",
      Width => "5",
      Position => "11:7", # Excel Formula: =calc_position(F283,E284)
    },
    DestTypeStage1 => { #Structure Type: MemField; ArrayLength: 4; ArrayIndex: 1; ArrayLocationInName: 14;
      Name => "DestTypeStage[n]",
      RegMem => "MemField",
      Width => "6",
      Position => "17:12", # Excel Formula: =calc_position(F284,E285)
    },
    StartEncapsulationStage1 => { #Structure Type: MemField; ArrayLength: 4; ArrayIndex: 1; ArrayLocationInName: 24;
      Name => "StartEncapsulationStage[n]",
      RegMem => "MemField",
      Description => "Encap-Index[1:0] flows in the resolution process. The initial value is 2'b00.
Every time Start-Encap is set increment this value by 1.
If Encap-Index is 2'b00 or 2'b01 then operate starting from msb
If Encap-Index is 2'b10 then operate 40b from msb
If Encap-Index is 2'b11 then operate 80b from msb",
      Width => "1",
      Position => "18", # Excel Formula: =calc_position(F285,E286)
    },
    EncTypeStage1 => { #Structure Type: MemField; ArrayLength: 4; ArrayIndex: 1; ArrayLocationInName: 13;
      Name => "EncTypeStage[n]",
      RegMem => "MemField",
      Description => "Encapsulation-type",
      Width => "4",
      Position => "22:19", # Excel Formula: =calc_position(F286,E287)
    },
    Field0SrcOffsetInBitsStage1 => { #Structure Type: MemField; ArrayLength: 4; ArrayIndex: 1; ArrayLocationInName: 27;
      Name => "Field0SrcOffsetInBitsStage[n]",
      RegMem => "MemField",
      Description => "Offset in bits from lsb from which to take field0",
      Width => "7",
      Position => "29:23", # Excel Formula: =calc_position(F287,E288)
    },
    Field0SizeInBitsStage1 => { #Structure Type: MemField; ArrayLength: 4; ArrayIndex: 1; ArrayLocationInName: 22;
      Name => "Field0SizeInBitsStage[n]",
      RegMem => "MemField",
      Description => "Size in bits of  field0",
      Width => "5",
      Position => "34:30", # Excel Formula: =calc_position(F288,E289)
    },
    Field0DestOffsetInNibblesStage1 => { #Structure Type: MemField; ArrayLength: 4; ArrayIndex: 1; ArrayLocationInName: 31;
      Name => "Field0DestOffsetInNibblesStage[n]",
      RegMem => "MemField",
      Description => "Offset in nibbles from lsb in which to stamp field0",
      Width => "5",
      Position => "39:35", # Excel Formula: =calc_position(F289,E290)
    },
    Field1SrcOffsetInBitsStage1 => { #Structure Type: MemField; ArrayLength: 4; ArrayIndex: 1; ArrayLocationInName: 27;
      Name => "Field1SrcOffsetInBitsStage[n]",
      RegMem => "MemField",
      Description => "Offset in bits from lsb from which to take field1",
      Width => "7",
      Position => "46:40", # Excel Formula: =calc_position(F290,E291)
    },
    Field1SizeInBitsStage1 => { #Structure Type: MemField; ArrayLength: 4; ArrayIndex: 1; ArrayLocationInName: 22;
      Name => "Field1SizeInBitsStage[n]",
      RegMem => "MemField",
      Description => "Size in bits of field1",
      Width => "5",
      Position => "51:47", # Excel Formula: =calc_position(F291,E292)
    },
    Field1DestOffsetInNibblesStage1 => { #Structure Type: MemField; ArrayLength: 4; ArrayIndex: 1; ArrayLocationInName: 31;
      Name => "Field1DestOffsetInNibblesStage[n]",
      RegMem => "MemField",
      Description => "Offset in nibbles from lsb in which to stamp  field1",
      Width => "5",
      Position => "56:52", # Excel Formula: =calc_position(F292,E293)
    },
    Field2SrcOffsetInBitsStage1 => { #Structure Type: MemField; ArrayLength: 4; ArrayIndex: 1; ArrayLocationInName: 27;
      Name => "Field2SrcOffsetInBitsStage[n]",
      RegMem => "MemField",
      Description => "Offset in bits from lsb from which to take field2",
      Width => "7",
      Position => "63:57", # Excel Formula: =calc_position(F293,E294)
    },
    Field2SizeInBitsStage1 => { #Structure Type: MemField; ArrayLength: 4; ArrayIndex: 1; ArrayLocationInName: 22;
      Name => "Field2SizeInBitsStage[n]",
      RegMem => "MemField",
      Description => "Size in bits of field2",
      Width => "5",
      Position => "68:64", # Excel Formula: =calc_position(F294,E295)
    },
    Field2DestOffsetInNibblesStage1 => { #Structure Type: MemField; ArrayLength: 4; ArrayIndex: 1; ArrayLocationInName: 31;
      Name => "Field2DestOffsetInNibblesStage[n]",
      RegMem => "MemField",
      Description => "Offset in nibbles from lsb in which to stamp  field2",
      Width => "5",
      Position => "73:69", # Excel Formula: =calc_position(F295,E296)
    },
    DestOffsetOnEncapDataInNibblesStage1 => { #Structure Type: MemField; ArrayLength: 4; ArrayIndex: 1; ArrayLocationInName: 36;
      Name => "DestOffsetOnEncapDataInNibblesStage[n]",
      RegMem => "MemField",
      Width => "5",
      Position => "78:74", # Excel Formula: =calc_position(F296,E297)
    },
    DestSizeOnEncapDataInBitsStage1 => { #Structure Type: MemField; ArrayLength: 4; ArrayIndex: 1; ArrayLocationInName: 31;
      Name => "DestSizeOnEncapDataInBitsStage[n]",
      RegMem => "MemField",
      Width => "5",
      Position => "83:79", # Excel Formula: =calc_position(F297,E298)
    },
    LpQueuingStage1 => { #Structure Type: MemField; ArrayLength: 4; ArrayIndex: 1; ArrayLocationInName: 15;
      Name => "LpQueuingStage[n]",
      RegMem => "MemField",
      Description => "Entry that should pass through the LP queuing stage in the resolution (it is Xor'ed into a sticky bit that indicated that this packet will finish its resolution processing only after going through the Resolution stage)",
      Width => "1",
      Position => "84", # Excel Formula: =calc_position(F298,E299)
    },
  },
  EntryTypeDecodingTableSlice1Stage2 => { #Structure Type: Mem; ArrayLength: 4; ArrayIndex: 2; ArrayLocationInName: 34;
    Name => "EntryTypeDecodingTableSlice1Stage[4]",
    RegMem => "Mem",
    Address => "3500000",
    Description => "Entry type decoding table",
    Width => "85", # Excel Formula: =calc_mem_width(E283:E299,M282,F299,-1)
    Type => "Config",
    UsedBy => "res",
    MemEntries => "64",
    MemWrapper => "RegArray",
    MemProtect => "None",
    AdditionalInfo => "CpuReadAccess=Enabled,CpuWriteAccess=Enabled,PortErrPropagate=Disabled",
    ArrayLength => "4",
    ArrayIndex => "2",
    MemLogicalWidth => "85",
    DestOffsetInBitsStage2 => { #Structure Type: MemField; ArrayLength: 4; ArrayIndex: 2; ArrayLocationInName: 22;
      Name => "DestOffsetInBitsStage[n]",
      RegMem => "MemField",
      Description => "Destination offset in nibbles ",
      Width => "7",
      Position => "6:0", # Excel Formula: =calc_position(F282,E283,TRUE)
    },
    DestSizeInBitsStage2 => { #Structure Type: MemField; ArrayLength: 4; ArrayIndex: 2; ArrayLocationInName: 20;
      Name => "DestSizeInBitsStage[n]",
      RegMem => "MemField",
      Description => "Destination width (according to Dest-encoding).  ",
      Width => "5",
      Position => "11:7", # Excel Formula: =calc_position(F283,E284)
    },
    DestTypeStage2 => { #Structure Type: MemField; ArrayLength: 4; ArrayIndex: 2; ArrayLocationInName: 14;
      Name => "DestTypeStage[n]",
      RegMem => "MemField",
      Width => "6",
      Position => "17:12", # Excel Formula: =calc_position(F284,E285)
    },
    StartEncapsulationStage2 => { #Structure Type: MemField; ArrayLength: 4; ArrayIndex: 2; ArrayLocationInName: 24;
      Name => "StartEncapsulationStage[n]",
      RegMem => "MemField",
      Description => "Encap-Index[1:0] flows in the resolution process. The initial value is 2'b00.
Every time Start-Encap is set increment this value by 1.
If Encap-Index is 2'b00 or 2'b01 then operate starting from msb
If Encap-Index is 2'b10 then operate 40b from msb
If Encap-Index is 2'b11 then operate 80b from msb",
      Width => "1",
      Position => "18", # Excel Formula: =calc_position(F285,E286)
    },
    EncTypeStage2 => { #Structure Type: MemField; ArrayLength: 4; ArrayIndex: 2; ArrayLocationInName: 13;
      Name => "EncTypeStage[n]",
      RegMem => "MemField",
      Description => "Encapsulation-type",
      Width => "4",
      Position => "22:19", # Excel Formula: =calc_position(F286,E287)
    },
    Field0SrcOffsetInBitsStage2 => { #Structure Type: MemField; ArrayLength: 4; ArrayIndex: 2; ArrayLocationInName: 27;
      Name => "Field0SrcOffsetInBitsStage[n]",
      RegMem => "MemField",
      Description => "Offset in bits from lsb from which to take field0",
      Width => "7",
      Position => "29:23", # Excel Formula: =calc_position(F287,E288)
    },
    Field0SizeInBitsStage2 => { #Structure Type: MemField; ArrayLength: 4; ArrayIndex: 2; ArrayLocationInName: 22;
      Name => "Field0SizeInBitsStage[n]",
      RegMem => "MemField",
      Description => "Size in bits of  field0",
      Width => "5",
      Position => "34:30", # Excel Formula: =calc_position(F288,E289)
    },
    Field0DestOffsetInNibblesStage2 => { #Structure Type: MemField; ArrayLength: 4; ArrayIndex: 2; ArrayLocationInName: 31;
      Name => "Field0DestOffsetInNibblesStage[n]",
      RegMem => "MemField",
      Description => "Offset in nibbles from lsb in which to stamp field0",
      Width => "5",
      Position => "39:35", # Excel Formula: =calc_position(F289,E290)
    },
    Field1SrcOffsetInBitsStage2 => { #Structure Type: MemField; ArrayLength: 4; ArrayIndex: 2; ArrayLocationInName: 27;
      Name => "Field1SrcOffsetInBitsStage[n]",
      RegMem => "MemField",
      Description => "Offset in bits from lsb from which to take field1",
      Width => "7",
      Position => "46:40", # Excel Formula: =calc_position(F290,E291)
    },
    Field1SizeInBitsStage2 => { #Structure Type: MemField; ArrayLength: 4; ArrayIndex: 2; ArrayLocationInName: 22;
      Name => "Field1SizeInBitsStage[n]",
      RegMem => "MemField",
      Description => "Size in bits of field1",
      Width => "5",
      Position => "51:47", # Excel Formula: =calc_position(F291,E292)
    },
    Field1DestOffsetInNibblesStage2 => { #Structure Type: MemField; ArrayLength: 4; ArrayIndex: 2; ArrayLocationInName: 31;
      Name => "Field1DestOffsetInNibblesStage[n]",
      RegMem => "MemField",
      Description => "Offset in nibbles from lsb in which to stamp  field1",
      Width => "5",
      Position => "56:52", # Excel Formula: =calc_position(F292,E293)
    },
    Field2SrcOffsetInBitsStage2 => { #Structure Type: MemField; ArrayLength: 4; ArrayIndex: 2; ArrayLocationInName: 27;
      Name => "Field2SrcOffsetInBitsStage[n]",
      RegMem => "MemField",
      Description => "Offset in bits from lsb from which to take field2",
      Width => "7",
      Position => "63:57", # Excel Formula: =calc_position(F293,E294)
    },
    Field2SizeInBitsStage2 => { #Structure Type: MemField; ArrayLength: 4; ArrayIndex: 2; ArrayLocationInName: 22;
      Name => "Field2SizeInBitsStage[n]",
      RegMem => "MemField",
      Description => "Size in bits of field2",
      Width => "5",
      Position => "68:64", # Excel Formula: =calc_position(F294,E295)
    },
    Field2DestOffsetInNibblesStage2 => { #Structure Type: MemField; ArrayLength: 4; ArrayIndex: 2; ArrayLocationInName: 31;
      Name => "Field2DestOffsetInNibblesStage[n]",
      RegMem => "MemField",
      Description => "Offset in nibbles from lsb in which to stamp  field2",
      Width => "5",
      Position => "73:69", # Excel Formula: =calc_position(F295,E296)
    },
    DestOffsetOnEncapDataInNibblesStage2 => { #Structure Type: MemField; ArrayLength: 4; ArrayIndex: 2; ArrayLocationInName: 36;
      Name => "DestOffsetOnEncapDataInNibblesStage[n]",
      RegMem => "MemField",
      Width => "5",
      Position => "78:74", # Excel Formula: =calc_position(F296,E297)
    },
    DestSizeOnEncapDataInBitsStage2 => { #Structure Type: MemField; ArrayLength: 4; ArrayIndex: 2; ArrayLocationInName: 31;
      Name => "DestSizeOnEncapDataInBitsStage[n]",
      RegMem => "MemField",
      Width => "5",
      Position => "83:79", # Excel Formula: =calc_position(F297,E298)
    },
    LpQueuingStage2 => { #Structure Type: MemField; ArrayLength: 4; ArrayIndex: 2; ArrayLocationInName: 15;
      Name => "LpQueuingStage[n]",
      RegMem => "MemField",
      Description => "Entry that should pass through the LP queuing stage in the resolution (it is Xor'ed into a sticky bit that indicated that this packet will finish its resolution processing only after going through the Resolution stage)",
      Width => "1",
      Position => "84", # Excel Formula: =calc_position(F298,E299)
    },
  },
  EntryTypeDecodingTableSlice1Stage3 => { #Structure Type: Mem; ArrayLength: 4; ArrayIndex: 3; ArrayLocationInName: 34;
    Name => "EntryTypeDecodingTableSlice1Stage[4]",
    RegMem => "Mem",
    Address => "3600000",
    Description => "Entry type decoding table",
    Width => "85", # Excel Formula: =calc_mem_width(E283:E299,M282,F299,-1)
    Type => "Config",
    UsedBy => "res",
    MemEntries => "64",
    MemWrapper => "RegArray",
    MemProtect => "None",
    AdditionalInfo => "CpuReadAccess=Enabled,CpuWriteAccess=Enabled,PortErrPropagate=Disabled",
    ArrayLength => "4",
    ArrayIndex => "3",
    MemLogicalWidth => "85",
    DestOffsetInBitsStage3 => { #Structure Type: MemField; ArrayLength: 4; ArrayIndex: 3; ArrayLocationInName: 22;
      Name => "DestOffsetInBitsStage[n]",
      RegMem => "MemField",
      Description => "Destination offset in nibbles ",
      Width => "7",
      Position => "6:0", # Excel Formula: =calc_position(F282,E283,TRUE)
    },
    DestSizeInBitsStage3 => { #Structure Type: MemField; ArrayLength: 4; ArrayIndex: 3; ArrayLocationInName: 20;
      Name => "DestSizeInBitsStage[n]",
      RegMem => "MemField",
      Description => "Destination width (according to Dest-encoding).  ",
      Width => "5",
      Position => "11:7", # Excel Formula: =calc_position(F283,E284)
    },
    DestTypeStage3 => { #Structure Type: MemField; ArrayLength: 4; ArrayIndex: 3; ArrayLocationInName: 14;
      Name => "DestTypeStage[n]",
      RegMem => "MemField",
      Width => "6",
      Position => "17:12", # Excel Formula: =calc_position(F284,E285)
    },
    StartEncapsulationStage3 => { #Structure Type: MemField; ArrayLength: 4; ArrayIndex: 3; ArrayLocationInName: 24;
      Name => "StartEncapsulationStage[n]",
      RegMem => "MemField",
      Description => "Encap-Index[1:0] flows in the resolution process. The initial value is 2'b00.
Every time Start-Encap is set increment this value by 1.
If Encap-Index is 2'b00 or 2'b01 then operate starting from msb
If Encap-Index is 2'b10 then operate 40b from msb
If Encap-Index is 2'b11 then operate 80b from msb",
      Width => "1",
      Position => "18", # Excel Formula: =calc_position(F285,E286)
    },
    EncTypeStage3 => { #Structure Type: MemField; ArrayLength: 4; ArrayIndex: 3; ArrayLocationInName: 13;
      Name => "EncTypeStage[n]",
      RegMem => "MemField",
      Description => "Encapsulation-type",
      Width => "4",
      Position => "22:19", # Excel Formula: =calc_position(F286,E287)
    },
    Field0SrcOffsetInBitsStage3 => { #Structure Type: MemField; ArrayLength: 4; ArrayIndex: 3; ArrayLocationInName: 27;
      Name => "Field0SrcOffsetInBitsStage[n]",
      RegMem => "MemField",
      Description => "Offset in bits from lsb from which to take field0",
      Width => "7",
      Position => "29:23", # Excel Formula: =calc_position(F287,E288)
    },
    Field0SizeInBitsStage3 => { #Structure Type: MemField; ArrayLength: 4; ArrayIndex: 3; ArrayLocationInName: 22;
      Name => "Field0SizeInBitsStage[n]",
      RegMem => "MemField",
      Description => "Size in bits of  field0",
      Width => "5",
      Position => "34:30", # Excel Formula: =calc_position(F288,E289)
    },
    Field0DestOffsetInNibblesStage3 => { #Structure Type: MemField; ArrayLength: 4; ArrayIndex: 3; ArrayLocationInName: 31;
      Name => "Field0DestOffsetInNibblesStage[n]",
      RegMem => "MemField",
      Description => "Offset in nibbles from lsb in which to stamp field0",
      Width => "5",
      Position => "39:35", # Excel Formula: =calc_position(F289,E290)
    },
    Field1SrcOffsetInBitsStage3 => { #Structure Type: MemField; ArrayLength: 4; ArrayIndex: 3; ArrayLocationInName: 27;
      Name => "Field1SrcOffsetInBitsStage[n]",
      RegMem => "MemField",
      Description => "Offset in bits from lsb from which to take field1",
      Width => "7",
      Position => "46:40", # Excel Formula: =calc_position(F290,E291)
    },
    Field1SizeInBitsStage3 => { #Structure Type: MemField; ArrayLength: 4; ArrayIndex: 3; ArrayLocationInName: 22;
      Name => "Field1SizeInBitsStage[n]",
      RegMem => "MemField",
      Description => "Size in bits of field1",
      Width => "5",
      Position => "51:47", # Excel Formula: =calc_position(F291,E292)
    },
    Field1DestOffsetInNibblesStage3 => { #Structure Type: MemField; ArrayLength: 4; ArrayIndex: 3; ArrayLocationInName: 31;
      Name => "Field1DestOffsetInNibblesStage[n]",
      RegMem => "MemField",
      Description => "Offset in nibbles from lsb in which to stamp  field1",
      Width => "5",
      Position => "56:52", # Excel Formula: =calc_position(F292,E293)
    },
    Field2SrcOffsetInBitsStage3 => { #Structure Type: MemField; ArrayLength: 4; ArrayIndex: 3; ArrayLocationInName: 27;
      Name => "Field2SrcOffsetInBitsStage[n]",
      RegMem => "MemField",
      Description => "Offset in bits from lsb from which to take field2",
      Width => "7",
      Position => "63:57", # Excel Formula: =calc_position(F293,E294)
    },
    Field2SizeInBitsStage3 => { #Structure Type: MemField; ArrayLength: 4; ArrayIndex: 3; ArrayLocationInName: 22;
      Name => "Field2SizeInBitsStage[n]",
      RegMem => "MemField",
      Description => "Size in bits of field2",
      Width => "5",
      Position => "68:64", # Excel Formula: =calc_position(F294,E295)
    },
    Field2DestOffsetInNibblesStage3 => { #Structure Type: MemField; ArrayLength: 4; ArrayIndex: 3; ArrayLocationInName: 31;
      Name => "Field2DestOffsetInNibblesStage[n]",
      RegMem => "MemField",
      Description => "Offset in nibbles from lsb in which to stamp  field2",
      Width => "5",
      Position => "73:69", # Excel Formula: =calc_position(F295,E296)
    },
    DestOffsetOnEncapDataInNibblesStage3 => { #Structure Type: MemField; ArrayLength: 4; ArrayIndex: 3; ArrayLocationInName: 36;
      Name => "DestOffsetOnEncapDataInNibblesStage[n]",
      RegMem => "MemField",
      Width => "5",
      Position => "78:74", # Excel Formula: =calc_position(F296,E297)
    },
    DestSizeOnEncapDataInBitsStage3 => { #Structure Type: MemField; ArrayLength: 4; ArrayIndex: 3; ArrayLocationInName: 31;
      Name => "DestSizeOnEncapDataInBitsStage[n]",
      RegMem => "MemField",
      Width => "5",
      Position => "83:79", # Excel Formula: =calc_position(F297,E298)
    },
    LpQueuingStage3 => { #Structure Type: MemField; ArrayLength: 4; ArrayIndex: 3; ArrayLocationInName: 15;
      Name => "LpQueuingStage[n]",
      RegMem => "MemField",
      Description => "Entry that should pass through the LP queuing stage in the resolution (it is Xor'ed into a sticky bit that indicated that this packet will finish its resolution processing only after going through the Resolution stage)",
      Width => "1",
      Position => "84", # Excel Formula: =calc_position(F298,E299)
    },
  },
  slice1_stage0_lb_consistence_cache_table => { #Structure Type: Mem; ArrayLength: 4; ArrayIndex: 0; ArrayLocationInName: 13;
    Name => "slice1_stage[4]_lb_consistence_cache_table",
    RegMem => "Mem",
    Address => "3700000", # Excel Formula: =calc_mem_address(C282,A282,G300,L300)
    Description => "Lb consistance cache table",
    Width => "26", # Excel Formula: =calc_mem_width(E301:E303,M300,F303,-1)
    Type => "Dynamic",
    UsedBy => "res",
    DocName => "Slice[2]PortDspLbConsistenceCacheTable",
    MemEntries => "4096", # Excel Formula: =2^calc_field_width_define("RES_REDUCED_LB_KEY_WIDTH")
    MemWrapper => "1R1W",
    MemProtect => "ECC",
    AdditionalInfo => "SampleReadBeforeProt=1,SampleReadAfterProt=1,PortErrPropagate=Enabled,CpuReadAccess=Enabled,CpuWriteAccess=Enabled,DisableSameAddressErr=Enabled,WriteActivityFactor=100,ReadActivityFactor=100",
    ArrayLength => "4",
    ArrayIndex => "0",
    MemLogicalWidth => "20",
    valid_stage0 => { #Structure Type: MemField; ArrayLength: 4; ArrayIndex: 0; ArrayLocationInName: 12;
      Name => "valid_stage[n]",
      RegMem => "MemField",
      Description => "when set, the cache-member-id is valid",
      Width => "1",
      Position => "0", # Excel Formula: =calc_position(F300,E301,TRUE)
      DocName => "Valid[n]",
    },
    cache_member_id_stage0 => { #Structure Type: MemField; ArrayLength: 4; ArrayIndex: 0; ArrayLocationInName: 22;
      Name => "cache_member_id_stage[n]",
      RegMem => "MemField",
      Description => "cache member-id",
      Width => "9", # Excel Formula: =calc_field_width_define("RES_LB_GROUP_SIZE_WIDTH")
      Position => "9:1", # Excel Formula: =calc_position(F301,E302)
      DocName => "CacheMemberId[n]",
    },
    time_stamp_stage0 => { #Structure Type: MemField; ArrayLength: 4; ArrayIndex: 0; ArrayLocationInName: 17;
      Name => "time_stamp_stage[n]",
      RegMem => "MemField",
      Description => "stored-time-stamp - scale is according to cfg-consistence_cache_clock_offset",
      Width => "10", # Excel Formula: = calc_field_width_define("RES_LB_CONSISTENCE_CACHE_TS_WIDTH")
      Position => "19:10", # Excel Formula: =calc_position(F302,E303)
      DocName => "TimeStamp[n]",
    },
  },
  slice1_stage1_lb_consistence_cache_table => { #Structure Type: Mem; ArrayLength: 4; ArrayIndex: 1; ArrayLocationInName: 13;
    Name => "slice1_stage[4]_lb_consistence_cache_table",
    RegMem => "Mem",
    Address => "3800000",
    Description => "Lb consistance cache table",
    Width => "26", # Excel Formula: =calc_mem_width(E301:E303,M300,F303,-1)
    Type => "Dynamic",
    UsedBy => "res",
    DocName => "Slice[2]PortDspLbConsistenceCacheTable",
    MemEntries => "4096", # Excel Formula: =2^calc_field_width_define("RES_REDUCED_LB_KEY_WIDTH")
    MemWrapper => "1R1W",
    MemProtect => "ECC",
    AdditionalInfo => "SampleReadBeforeProt=1,SampleReadAfterProt=1,PortErrPropagate=Enabled,CpuReadAccess=Enabled,CpuWriteAccess=Enabled,DisableSameAddressErr=Enabled,WriteActivityFactor=100,ReadActivityFactor=100",
    ArrayLength => "4",
    ArrayIndex => "1",
    MemLogicalWidth => "20",
    valid_stage1 => { #Structure Type: MemField; ArrayLength: 4; ArrayIndex: 1; ArrayLocationInName: 12;
      Name => "valid_stage[n]",
      RegMem => "MemField",
      Description => "when set, the cache-member-id is valid",
      Width => "1",
      Position => "0", # Excel Formula: =calc_position(F300,E301,TRUE)
      DocName => "Valid[n]",
    },
    cache_member_id_stage1 => { #Structure Type: MemField; ArrayLength: 4; ArrayIndex: 1; ArrayLocationInName: 22;
      Name => "cache_member_id_stage[n]",
      RegMem => "MemField",
      Description => "cache member-id",
      Width => "9", # Excel Formula: =calc_field_width_define("RES_LB_GROUP_SIZE_WIDTH")
      Position => "9:1", # Excel Formula: =calc_position(F301,E302)
      DocName => "CacheMemberId[n]",
    },
    time_stamp_stage1 => { #Structure Type: MemField; ArrayLength: 4; ArrayIndex: 1; ArrayLocationInName: 17;
      Name => "time_stamp_stage[n]",
      RegMem => "MemField",
      Description => "stored-time-stamp - scale is according to cfg-consistence_cache_clock_offset",
      Width => "10", # Excel Formula: = calc_field_width_define("RES_LB_CONSISTENCE_CACHE_TS_WIDTH")
      Position => "19:10", # Excel Formula: =calc_position(F302,E303)
      DocName => "TimeStamp[n]",
    },
  },
  slice1_stage2_lb_consistence_cache_table => { #Structure Type: Mem; ArrayLength: 4; ArrayIndex: 2; ArrayLocationInName: 13;
    Name => "slice1_stage[4]_lb_consistence_cache_table",
    RegMem => "Mem",
    Address => "3900000",
    Description => "Lb consistance cache table",
    Width => "26", # Excel Formula: =calc_mem_width(E301:E303,M300,F303,-1)
    Type => "Dynamic",
    UsedBy => "res",
    DocName => "Slice[2]PortDspLbConsistenceCacheTable",
    MemEntries => "4096", # Excel Formula: =2^calc_field_width_define("RES_REDUCED_LB_KEY_WIDTH")
    MemWrapper => "1R1W",
    MemProtect => "ECC",
    AdditionalInfo => "SampleReadBeforeProt=1,SampleReadAfterProt=1,PortErrPropagate=Enabled,CpuReadAccess=Enabled,CpuWriteAccess=Enabled,DisableSameAddressErr=Enabled,WriteActivityFactor=100,ReadActivityFactor=100",
    ArrayLength => "4",
    ArrayIndex => "2",
    MemLogicalWidth => "20",
    valid_stage2 => { #Structure Type: MemField; ArrayLength: 4; ArrayIndex: 2; ArrayLocationInName: 12;
      Name => "valid_stage[n]",
      RegMem => "MemField",
      Description => "when set, the cache-member-id is valid",
      Width => "1",
      Position => "0", # Excel Formula: =calc_position(F300,E301,TRUE)
      DocName => "Valid[n]",
    },
    cache_member_id_stage2 => { #Structure Type: MemField; ArrayLength: 4; ArrayIndex: 2; ArrayLocationInName: 22;
      Name => "cache_member_id_stage[n]",
      RegMem => "MemField",
      Description => "cache member-id",
      Width => "9", # Excel Formula: =calc_field_width_define("RES_LB_GROUP_SIZE_WIDTH")
      Position => "9:1", # Excel Formula: =calc_position(F301,E302)
      DocName => "CacheMemberId[n]",
    },
    time_stamp_stage2 => { #Structure Type: MemField; ArrayLength: 4; ArrayIndex: 2; ArrayLocationInName: 17;
      Name => "time_stamp_stage[n]",
      RegMem => "MemField",
      Description => "stored-time-stamp - scale is according to cfg-consistence_cache_clock_offset",
      Width => "10", # Excel Formula: = calc_field_width_define("RES_LB_CONSISTENCE_CACHE_TS_WIDTH")
      Position => "19:10", # Excel Formula: =calc_position(F302,E303)
      DocName => "TimeStamp[n]",
    },
  },
  slice1_stage3_lb_consistence_cache_table => { #Structure Type: Mem; ArrayLength: 4; ArrayIndex: 3; ArrayLocationInName: 13;
    Name => "slice1_stage[4]_lb_consistence_cache_table",
    RegMem => "Mem",
    Address => "3A00000",
    Description => "Lb consistance cache table",
    Width => "26", # Excel Formula: =calc_mem_width(E301:E303,M300,F303,-1)
    Type => "Dynamic",
    UsedBy => "res",
    DocName => "Slice[2]PortDspLbConsistenceCacheTable",
    MemEntries => "4096", # Excel Formula: =2^calc_field_width_define("RES_REDUCED_LB_KEY_WIDTH")
    MemWrapper => "1R1W",
    MemProtect => "ECC",
    AdditionalInfo => "SampleReadBeforeProt=1,SampleReadAfterProt=1,PortErrPropagate=Enabled,CpuReadAccess=Enabled,CpuWriteAccess=Enabled,DisableSameAddressErr=Enabled,WriteActivityFactor=100,ReadActivityFactor=100",
    ArrayLength => "4",
    ArrayIndex => "3",
    MemLogicalWidth => "20",
    valid_stage3 => { #Structure Type: MemField; ArrayLength: 4; ArrayIndex: 3; ArrayLocationInName: 12;
      Name => "valid_stage[n]",
      RegMem => "MemField",
      Description => "when set, the cache-member-id is valid",
      Width => "1",
      Position => "0", # Excel Formula: =calc_position(F300,E301,TRUE)
      DocName => "Valid[n]",
    },
    cache_member_id_stage3 => { #Structure Type: MemField; ArrayLength: 4; ArrayIndex: 3; ArrayLocationInName: 22;
      Name => "cache_member_id_stage[n]",
      RegMem => "MemField",
      Description => "cache member-id",
      Width => "9", # Excel Formula: =calc_field_width_define("RES_LB_GROUP_SIZE_WIDTH")
      Position => "9:1", # Excel Formula: =calc_position(F301,E302)
      DocName => "CacheMemberId[n]",
    },
    time_stamp_stage3 => { #Structure Type: MemField; ArrayLength: 4; ArrayIndex: 3; ArrayLocationInName: 17;
      Name => "time_stamp_stage[n]",
      RegMem => "MemField",
      Description => "stored-time-stamp - scale is according to cfg-consistence_cache_clock_offset",
      Width => "10", # Excel Formula: = calc_field_width_define("RES_LB_CONSISTENCE_CACHE_TS_WIDTH")
      Position => "19:10", # Excel Formula: =calc_position(F302,E303)
      DocName => "TimeStamp[n]",
    },
  },
  PbtsMapTableSlice1Stage0 => { #Structure Type: Mem; ArrayLength: 4; ArrayIndex: 0; ArrayLocationInName: 24;
    Name => "PbtsMapTableSlice1Stage[4]",
    RegMem => "Mem",
    Address => "3B00000", # Excel Formula: =calc_mem_address(C300,A300,G304,L304)
    Description => "Pbts map table",
    Width => "23", # Excel Formula: =calc_mem_width(E305:E307,M304,F307,-1)
    Type => "Config",
    UsedBy => "res",
    MemEntries => "32",
    MemWrapper => "RegArray",
    MemProtect => "None",
    AdditionalInfo => "CpuReadAccess=Enabled,CpuWriteAccess=Enabled,PortErrPropagate=Disabled",
    ArrayLength => "4",
    ArrayIndex => "0",
    MemLogicalWidth => "23",
    AndMaskStage0 => { #Structure Type: MemField; ArrayLength: 4; ArrayIndex: 0; ArrayLocationInName: 13;
      Name => "AndMaskStage[n]",
      RegMem => "MemField",
      Description => "Indicates the destination base bits in the destination",
      Width => "18",
      Position => "17:0", # Excel Formula: =calc_position(F304,E305,TRUE)
    },
    DestinationShiftStage0 => { #Structure Type: MemField; ArrayLength: 4; ArrayIndex: 0; ArrayLocationInName: 22;
      Name => "DestinationShiftStage[n]",
      RegMem => "MemField",
      Description => "The masked destination is shifted by these value to provide the new destination base.",
      Width => "2",
      Position => "19:18", # Excel Formula: =calc_position(F305,E306)
    },
    PbtsOffsetStage0 => { #Structure Type: MemField; ArrayLength: 4; ArrayIndex: 0; ArrayLocationInName: 16;
      Name => "PbtsOffsetStage[n]",
      RegMem => "MemField",
      Description => "This value is added to the destination.",
      Width => "3",
      Position => "22:20", # Excel Formula: =calc_position(F306,E307)
    },
  },
  PbtsMapTableSlice1Stage1 => { #Structure Type: Mem; ArrayLength: 4; ArrayIndex: 1; ArrayLocationInName: 24;
    Name => "PbtsMapTableSlice1Stage[4]",
    RegMem => "Mem",
    Address => "3C00000",
    Description => "Pbts map table",
    Width => "23", # Excel Formula: =calc_mem_width(E305:E307,M304,F307,-1)
    Type => "Config",
    UsedBy => "res",
    MemEntries => "32",
    MemWrapper => "RegArray",
    MemProtect => "None",
    AdditionalInfo => "CpuReadAccess=Enabled,CpuWriteAccess=Enabled,PortErrPropagate=Disabled",
    ArrayLength => "4",
    ArrayIndex => "1",
    MemLogicalWidth => "23",
    AndMaskStage1 => { #Structure Type: MemField; ArrayLength: 4; ArrayIndex: 1; ArrayLocationInName: 13;
      Name => "AndMaskStage[n]",
      RegMem => "MemField",
      Description => "Indicates the destination base bits in the destination",
      Width => "18",
      Position => "17:0", # Excel Formula: =calc_position(F304,E305,TRUE)
    },
    DestinationShiftStage1 => { #Structure Type: MemField; ArrayLength: 4; ArrayIndex: 1; ArrayLocationInName: 22;
      Name => "DestinationShiftStage[n]",
      RegMem => "MemField",
      Description => "The masked destination is shifted by these value to provide the new destination base.",
      Width => "2",
      Position => "19:18", # Excel Formula: =calc_position(F305,E306)
    },
    PbtsOffsetStage1 => { #Structure Type: MemField; ArrayLength: 4; ArrayIndex: 1; ArrayLocationInName: 16;
      Name => "PbtsOffsetStage[n]",
      RegMem => "MemField",
      Description => "This value is added to the destination.",
      Width => "3",
      Position => "22:20", # Excel Formula: =calc_position(F306,E307)
    },
  },
  PbtsMapTableSlice1Stage2 => { #Structure Type: Mem; ArrayLength: 4; ArrayIndex: 2; ArrayLocationInName: 24;
    Name => "PbtsMapTableSlice1Stage[4]",
    RegMem => "Mem",
    Address => "3D00000",
    Description => "Pbts map table",
    Width => "23", # Excel Formula: =calc_mem_width(E305:E307,M304,F307,-1)
    Type => "Config",
    UsedBy => "res",
    MemEntries => "32",
    MemWrapper => "RegArray",
    MemProtect => "None",
    AdditionalInfo => "CpuReadAccess=Enabled,CpuWriteAccess=Enabled,PortErrPropagate=Disabled",
    ArrayLength => "4",
    ArrayIndex => "2",
    MemLogicalWidth => "23",
    AndMaskStage2 => { #Structure Type: MemField; ArrayLength: 4; ArrayIndex: 2; ArrayLocationInName: 13;
      Name => "AndMaskStage[n]",
      RegMem => "MemField",
      Description => "Indicates the destination base bits in the destination",
      Width => "18",
      Position => "17:0", # Excel Formula: =calc_position(F304,E305,TRUE)
    },
    DestinationShiftStage2 => { #Structure Type: MemField; ArrayLength: 4; ArrayIndex: 2; ArrayLocationInName: 22;
      Name => "DestinationShiftStage[n]",
      RegMem => "MemField",
      Description => "The masked destination is shifted by these value to provide the new destination base.",
      Width => "2",
      Position => "19:18", # Excel Formula: =calc_position(F305,E306)
    },
    PbtsOffsetStage2 => { #Structure Type: MemField; ArrayLength: 4; ArrayIndex: 2; ArrayLocationInName: 16;
      Name => "PbtsOffsetStage[n]",
      RegMem => "MemField",
      Description => "This value is added to the destination.",
      Width => "3",
      Position => "22:20", # Excel Formula: =calc_position(F306,E307)
    },
  },
  PbtsMapTableSlice1Stage3 => { #Structure Type: Mem; ArrayLength: 4; ArrayIndex: 3; ArrayLocationInName: 24;
    Name => "PbtsMapTableSlice1Stage[4]",
    RegMem => "Mem",
    Address => "3E00000",
    Description => "Pbts map table",
    Width => "23", # Excel Formula: =calc_mem_width(E305:E307,M304,F307,-1)
    Type => "Config",
    UsedBy => "res",
    MemEntries => "32",
    MemWrapper => "RegArray",
    MemProtect => "None",
    AdditionalInfo => "CpuReadAccess=Enabled,CpuWriteAccess=Enabled,PortErrPropagate=Disabled",
    ArrayLength => "4",
    ArrayIndex => "3",
    MemLogicalWidth => "23",
    AndMaskStage3 => { #Structure Type: MemField; ArrayLength: 4; ArrayIndex: 3; ArrayLocationInName: 13;
      Name => "AndMaskStage[n]",
      RegMem => "MemField",
      Description => "Indicates the destination base bits in the destination",
      Width => "18",
      Position => "17:0", # Excel Formula: =calc_position(F304,E305,TRUE)
    },
    DestinationShiftStage3 => { #Structure Type: MemField; ArrayLength: 4; ArrayIndex: 3; ArrayLocationInName: 22;
      Name => "DestinationShiftStage[n]",
      RegMem => "MemField",
      Description => "The masked destination is shifted by these value to provide the new destination base.",
      Width => "2",
      Position => "19:18", # Excel Formula: =calc_position(F305,E306)
    },
    PbtsOffsetStage3 => { #Structure Type: MemField; ArrayLength: 4; ArrayIndex: 3; ArrayLocationInName: 16;
      Name => "PbtsOffsetStage[n]",
      RegMem => "MemField",
      Description => "This value is added to the destination.",
      Width => "3",
      Position => "22:20", # Excel Formula: =calc_position(F306,E307)
    },
  },
  ResolutionStage0EmVerifier0 => { #Structure Type: Mem; ArrayLength: 12; ArrayIndex: 0; ArrayLocationInName: 27; Skip Register;
    Name => "ResolutionStage0EmVerifier[12]",
    RegMem => "Mem",
    Address => "3F00000", # Excel Formula: =calc_mem_address(C304,A304,G308,L308)
    Description => "Holds the verifier and the payload of the EM entry",
    Width => "56", # Excel Formula: =calc_mem_width(E309:E309,M308,F309,-1)
    Type => "Dynamic",
    UsedBy => "ResolutionStage0Em",
    MemEntries => "16384",
    MemWrapper => "2R1W Slow Write",
    MemProtect => "ExtECC",
    AdditionalInfo => "PackArrayToBus=Enabled,UseHardReset=1,SampleReadBeforeProt=2,SamplePhysicalMem=1,CpuReadAccess=Enabled,CpuWriteAccess=Enabled,WriteActivityFactor=0,ReadActivityFactor=100,DisableSameAddressErr=Enabled,EnableNonCpuRdWrSameAddress=Enabled,PortErrPropagate=Disabled",
    Comments => "EM Skip Reg",
    ArrayLength => "12",
    ArrayIndex => "0",
    MemLogicalWidth => "56",
    ResolutionStage0EmVerifier0Data => { #Structure Type: MemField; ArrayLength: 12; ArrayIndex: 0; ArrayLocationInName: 27;
      Name => "ResolutionStage0EmVerifier[n]Data",
      RegMem => "MemField",
      Description => "Verifier and payload data",
      Width => "56",
      Position => "55:0", # Excel Formula: =calc_position(F308,E309,TRUE)
    },
  },
  ResolutionStage0EmVerifier1 => { #Structure Type: Mem; ArrayLength: 12; ArrayIndex: 1; ArrayLocationInName: 27; Skip Register;
    Name => "ResolutionStage0EmVerifier[12]",
    RegMem => "Mem",
    Address => "4000000",
    Description => "Holds the verifier and the payload of the EM entry",
    Width => "56", # Excel Formula: =calc_mem_width(E309:E309,M308,F309,-1)
    Type => "Dynamic",
    UsedBy => "ResolutionStage0Em",
    MemEntries => "16384",
    MemWrapper => "2R1W Slow Write",
    MemProtect => "ExtECC",
    AdditionalInfo => "PackArrayToBus=Enabled,UseHardReset=1,SampleReadBeforeProt=2,SamplePhysicalMem=1,CpuReadAccess=Enabled,CpuWriteAccess=Enabled,WriteActivityFactor=0,ReadActivityFactor=100,DisableSameAddressErr=Enabled,EnableNonCpuRdWrSameAddress=Enabled,PortErrPropagate=Disabled",
    Comments => "EM Skip Reg",
    ArrayLength => "12",
    ArrayIndex => "1",
    MemLogicalWidth => "56",
    ResolutionStage0EmVerifier1Data => { #Structure Type: MemField; ArrayLength: 12; ArrayIndex: 1; ArrayLocationInName: 27;
      Name => "ResolutionStage0EmVerifier[n]Data",
      RegMem => "MemField",
      Description => "Verifier and payload data",
      Width => "56",
      Position => "55:0", # Excel Formula: =calc_position(F308,E309,TRUE)
    },
  },
  ResolutionStage0EmVerifier2 => { #Structure Type: Mem; ArrayLength: 12; ArrayIndex: 2; ArrayLocationInName: 27; Skip Register;
    Name => "ResolutionStage0EmVerifier[12]",
    RegMem => "Mem",
    Address => "4100000",
    Description => "Holds the verifier and the payload of the EM entry",
    Width => "56", # Excel Formula: =calc_mem_width(E309:E309,M308,F309,-1)
    Type => "Dynamic",
    UsedBy => "ResolutionStage0Em",
    MemEntries => "16384",
    MemWrapper => "2R1W Slow Write",
    MemProtect => "ExtECC",
    AdditionalInfo => "PackArrayToBus=Enabled,UseHardReset=1,SampleReadBeforeProt=2,SamplePhysicalMem=1,CpuReadAccess=Enabled,CpuWriteAccess=Enabled,WriteActivityFactor=0,ReadActivityFactor=100,DisableSameAddressErr=Enabled,EnableNonCpuRdWrSameAddress=Enabled,PortErrPropagate=Disabled",
    Comments => "EM Skip Reg",
    ArrayLength => "12",
    ArrayIndex => "2",
    MemLogicalWidth => "56",
    ResolutionStage0EmVerifier2Data => { #Structure Type: MemField; ArrayLength: 12; ArrayIndex: 2; ArrayLocationInName: 27;
      Name => "ResolutionStage0EmVerifier[n]Data",
      RegMem => "MemField",
      Description => "Verifier and payload data",
      Width => "56",
      Position => "55:0", # Excel Formula: =calc_position(F308,E309,TRUE)
    },
  },
  ResolutionStage0EmVerifier3 => { #Structure Type: Mem; ArrayLength: 12; ArrayIndex: 3; ArrayLocationInName: 27; Skip Register;
    Name => "ResolutionStage0EmVerifier[12]",
    RegMem => "Mem",
    Address => "4200000",
    Description => "Holds the verifier and the payload of the EM entry",
    Width => "56", # Excel Formula: =calc_mem_width(E309:E309,M308,F309,-1)
    Type => "Dynamic",
    UsedBy => "ResolutionStage0Em",
    MemEntries => "16384",
    MemWrapper => "2R1W Slow Write",
    MemProtect => "ExtECC",
    AdditionalInfo => "PackArrayToBus=Enabled,UseHardReset=1,SampleReadBeforeProt=2,SamplePhysicalMem=1,CpuReadAccess=Enabled,CpuWriteAccess=Enabled,WriteActivityFactor=0,ReadActivityFactor=100,DisableSameAddressErr=Enabled,EnableNonCpuRdWrSameAddress=Enabled,PortErrPropagate=Disabled",
    Comments => "EM Skip Reg",
    ArrayLength => "12",
    ArrayIndex => "3",
    MemLogicalWidth => "56",
    ResolutionStage0EmVerifier3Data => { #Structure Type: MemField; ArrayLength: 12; ArrayIndex: 3; ArrayLocationInName: 27;
      Name => "ResolutionStage0EmVerifier[n]Data",
      RegMem => "MemField",
      Description => "Verifier and payload data",
      Width => "56",
      Position => "55:0", # Excel Formula: =calc_position(F308,E309,TRUE)
    },
  },
  ResolutionStage0EmVerifier4 => { #Structure Type: Mem; ArrayLength: 12; ArrayIndex: 4; ArrayLocationInName: 27; Skip Register;
    Name => "ResolutionStage0EmVerifier[12]",
    RegMem => "Mem",
    Address => "4300000",
    Description => "Holds the verifier and the payload of the EM entry",
    Width => "56", # Excel Formula: =calc_mem_width(E309:E309,M308,F309,-1)
    Type => "Dynamic",
    UsedBy => "ResolutionStage0Em",
    MemEntries => "16384",
    MemWrapper => "2R1W Slow Write",
    MemProtect => "ExtECC",
    AdditionalInfo => "PackArrayToBus=Enabled,UseHardReset=1,SampleReadBeforeProt=2,SamplePhysicalMem=1,CpuReadAccess=Enabled,CpuWriteAccess=Enabled,WriteActivityFactor=0,ReadActivityFactor=100,DisableSameAddressErr=Enabled,EnableNonCpuRdWrSameAddress=Enabled,PortErrPropagate=Disabled",
    Comments => "EM Skip Reg",
    ArrayLength => "12",
    ArrayIndex => "4",
    MemLogicalWidth => "56",
    ResolutionStage0EmVerifier4Data => { #Structure Type: MemField; ArrayLength: 12; ArrayIndex: 4; ArrayLocationInName: 27;
      Name => "ResolutionStage0EmVerifier[n]Data",
      RegMem => "MemField",
      Description => "Verifier and payload data",
      Width => "56",
      Position => "55:0", # Excel Formula: =calc_position(F308,E309,TRUE)
    },
  },
  ResolutionStage0EmVerifier5 => { #Structure Type: Mem; ArrayLength: 12; ArrayIndex: 5; ArrayLocationInName: 27; Skip Register;
    Name => "ResolutionStage0EmVerifier[12]",
    RegMem => "Mem",
    Address => "4400000",
    Description => "Holds the verifier and the payload of the EM entry",
    Width => "56", # Excel Formula: =calc_mem_width(E309:E309,M308,F309,-1)
    Type => "Dynamic",
    UsedBy => "ResolutionStage0Em",
    MemEntries => "16384",
    MemWrapper => "2R1W Slow Write",
    MemProtect => "ExtECC",
    AdditionalInfo => "PackArrayToBus=Enabled,UseHardReset=1,SampleReadBeforeProt=2,SamplePhysicalMem=1,CpuReadAccess=Enabled,CpuWriteAccess=Enabled,WriteActivityFactor=0,ReadActivityFactor=100,DisableSameAddressErr=Enabled,EnableNonCpuRdWrSameAddress=Enabled,PortErrPropagate=Disabled",
    Comments => "EM Skip Reg",
    ArrayLength => "12",
    ArrayIndex => "5",
    MemLogicalWidth => "56",
    ResolutionStage0EmVerifier5Data => { #Structure Type: MemField; ArrayLength: 12; ArrayIndex: 5; ArrayLocationInName: 27;
      Name => "ResolutionStage0EmVerifier[n]Data",
      RegMem => "MemField",
      Description => "Verifier and payload data",
      Width => "56",
      Position => "55:0", # Excel Formula: =calc_position(F308,E309,TRUE)
    },
  },
  ResolutionStage0EmVerifier6 => { #Structure Type: Mem; ArrayLength: 12; ArrayIndex: 6; ArrayLocationInName: 27; Skip Register;
    Name => "ResolutionStage0EmVerifier[12]",
    RegMem => "Mem",
    Address => "4500000",
    Description => "Holds the verifier and the payload of the EM entry",
    Width => "56", # Excel Formula: =calc_mem_width(E309:E309,M308,F309,-1)
    Type => "Dynamic",
    UsedBy => "ResolutionStage0Em",
    MemEntries => "16384",
    MemWrapper => "2R1W Slow Write",
    MemProtect => "ExtECC",
    AdditionalInfo => "PackArrayToBus=Enabled,UseHardReset=1,SampleReadBeforeProt=2,SamplePhysicalMem=1,CpuReadAccess=Enabled,CpuWriteAccess=Enabled,WriteActivityFactor=0,ReadActivityFactor=100,DisableSameAddressErr=Enabled,EnableNonCpuRdWrSameAddress=Enabled,PortErrPropagate=Disabled",
    Comments => "EM Skip Reg",
    ArrayLength => "12",
    ArrayIndex => "6",
    MemLogicalWidth => "56",
    ResolutionStage0EmVerifier6Data => { #Structure Type: MemField; ArrayLength: 12; ArrayIndex: 6; ArrayLocationInName: 27;
      Name => "ResolutionStage0EmVerifier[n]Data",
      RegMem => "MemField",
      Description => "Verifier and payload data",
      Width => "56",
      Position => "55:0", # Excel Formula: =calc_position(F308,E309,TRUE)
    },
  },
  ResolutionStage0EmVerifier7 => { #Structure Type: Mem; ArrayLength: 12; ArrayIndex: 7; ArrayLocationInName: 27; Skip Register;
    Name => "ResolutionStage0EmVerifier[12]",
    RegMem => "Mem",
    Address => "4600000",
    Description => "Holds the verifier and the payload of the EM entry",
    Width => "56", # Excel Formula: =calc_mem_width(E309:E309,M308,F309,-1)
    Type => "Dynamic",
    UsedBy => "ResolutionStage0Em",
    MemEntries => "16384",
    MemWrapper => "2R1W Slow Write",
    MemProtect => "ExtECC",
    AdditionalInfo => "PackArrayToBus=Enabled,UseHardReset=1,SampleReadBeforeProt=2,SamplePhysicalMem=1,CpuReadAccess=Enabled,CpuWriteAccess=Enabled,WriteActivityFactor=0,ReadActivityFactor=100,DisableSameAddressErr=Enabled,EnableNonCpuRdWrSameAddress=Enabled,PortErrPropagate=Disabled",
    Comments => "EM Skip Reg",
    ArrayLength => "12",
    ArrayIndex => "7",
    MemLogicalWidth => "56",
    ResolutionStage0EmVerifier7Data => { #Structure Type: MemField; ArrayLength: 12; ArrayIndex: 7; ArrayLocationInName: 27;
      Name => "ResolutionStage0EmVerifier[n]Data",
      RegMem => "MemField",
      Description => "Verifier and payload data",
      Width => "56",
      Position => "55:0", # Excel Formula: =calc_position(F308,E309,TRUE)
    },
  },
  ResolutionStage0EmVerifier8 => { #Structure Type: Mem; ArrayLength: 12; ArrayIndex: 8; ArrayLocationInName: 27; Skip Register;
    Name => "ResolutionStage0EmVerifier[12]",
    RegMem => "Mem",
    Address => "4700000",
    Description => "Holds the verifier and the payload of the EM entry",
    Width => "56", # Excel Formula: =calc_mem_width(E309:E309,M308,F309,-1)
    Type => "Dynamic",
    UsedBy => "ResolutionStage0Em",
    MemEntries => "16384",
    MemWrapper => "2R1W Slow Write",
    MemProtect => "ExtECC",
    AdditionalInfo => "PackArrayToBus=Enabled,UseHardReset=1,SampleReadBeforeProt=2,SamplePhysicalMem=1,CpuReadAccess=Enabled,CpuWriteAccess=Enabled,WriteActivityFactor=0,ReadActivityFactor=100,DisableSameAddressErr=Enabled,EnableNonCpuRdWrSameAddress=Enabled,PortErrPropagate=Disabled",
    Comments => "EM Skip Reg",
    ArrayLength => "12",
    ArrayIndex => "8",
    MemLogicalWidth => "56",
    ResolutionStage0EmVerifier8Data => { #Structure Type: MemField; ArrayLength: 12; ArrayIndex: 8; ArrayLocationInName: 27;
      Name => "ResolutionStage0EmVerifier[n]Data",
      RegMem => "MemField",
      Description => "Verifier and payload data",
      Width => "56",
      Position => "55:0", # Excel Formula: =calc_position(F308,E309,TRUE)
    },
  },
  ResolutionStage0EmVerifier9 => { #Structure Type: Mem; ArrayLength: 12; ArrayIndex: 9; ArrayLocationInName: 27; Skip Register;
    Name => "ResolutionStage0EmVerifier[12]",
    RegMem => "Mem",
    Address => "4800000",
    Description => "Holds the verifier and the payload of the EM entry",
    Width => "56", # Excel Formula: =calc_mem_width(E309:E309,M308,F309,-1)
    Type => "Dynamic",
    UsedBy => "ResolutionStage0Em",
    MemEntries => "16384",
    MemWrapper => "2R1W Slow Write",
    MemProtect => "ExtECC",
    AdditionalInfo => "PackArrayToBus=Enabled,UseHardReset=1,SampleReadBeforeProt=2,SamplePhysicalMem=1,CpuReadAccess=Enabled,CpuWriteAccess=Enabled,WriteActivityFactor=0,ReadActivityFactor=100,DisableSameAddressErr=Enabled,EnableNonCpuRdWrSameAddress=Enabled,PortErrPropagate=Disabled",
    Comments => "EM Skip Reg",
    ArrayLength => "12",
    ArrayIndex => "9",
    MemLogicalWidth => "56",
    ResolutionStage0EmVerifier9Data => { #Structure Type: MemField; ArrayLength: 12; ArrayIndex: 9; ArrayLocationInName: 27;
      Name => "ResolutionStage0EmVerifier[n]Data",
      RegMem => "MemField",
      Description => "Verifier and payload data",
      Width => "56",
      Position => "55:0", # Excel Formula: =calc_position(F308,E309,TRUE)
    },
  },
  ResolutionStage0EmVerifier10 => { #Structure Type: Mem; ArrayLength: 12; ArrayIndex: 10; ArrayLocationInName: 27; Skip Register;
    Name => "ResolutionStage0EmVerifier[12]",
    RegMem => "Mem",
    Address => "4900000",
    Description => "Holds the verifier and the payload of the EM entry",
    Width => "56", # Excel Formula: =calc_mem_width(E309:E309,M308,F309,-1)
    Type => "Dynamic",
    UsedBy => "ResolutionStage0Em",
    MemEntries => "16384",
    MemWrapper => "2R1W Slow Write",
    MemProtect => "ExtECC",
    AdditionalInfo => "PackArrayToBus=Enabled,UseHardReset=1,SampleReadBeforeProt=2,SamplePhysicalMem=1,CpuReadAccess=Enabled,CpuWriteAccess=Enabled,WriteActivityFactor=0,ReadActivityFactor=100,DisableSameAddressErr=Enabled,EnableNonCpuRdWrSameAddress=Enabled,PortErrPropagate=Disabled",
    Comments => "EM Skip Reg",
    ArrayLength => "12",
    ArrayIndex => "10",
    MemLogicalWidth => "56",
    ResolutionStage0EmVerifier10Data => { #Structure Type: MemField; ArrayLength: 12; ArrayIndex: 10; ArrayLocationInName: 27;
      Name => "ResolutionStage0EmVerifier[n]Data",
      RegMem => "MemField",
      Description => "Verifier and payload data",
      Width => "56",
      Position => "55:0", # Excel Formula: =calc_position(F308,E309,TRUE)
    },
  },
  ResolutionStage0EmVerifier11 => { #Structure Type: Mem; ArrayLength: 12; ArrayIndex: 11; ArrayLocationInName: 27; Skip Register;
    Name => "ResolutionStage0EmVerifier[12]",
    RegMem => "Mem",
    Address => "4A00000",
    Description => "Holds the verifier and the payload of the EM entry",
    Width => "56", # Excel Formula: =calc_mem_width(E309:E309,M308,F309,-1)
    Type => "Dynamic",
    UsedBy => "ResolutionStage0Em",
    MemEntries => "16384",
    MemWrapper => "2R1W Slow Write",
    MemProtect => "ExtECC",
    AdditionalInfo => "PackArrayToBus=Enabled,UseHardReset=1,SampleReadBeforeProt=2,SamplePhysicalMem=1,CpuReadAccess=Enabled,CpuWriteAccess=Enabled,WriteActivityFactor=0,ReadActivityFactor=100,DisableSameAddressErr=Enabled,EnableNonCpuRdWrSameAddress=Enabled,PortErrPropagate=Disabled",
    Comments => "EM Skip Reg",
    ArrayLength => "12",
    ArrayIndex => "11",
    MemLogicalWidth => "56",
    ResolutionStage0EmVerifier11Data => { #Structure Type: MemField; ArrayLength: 12; ArrayIndex: 11; ArrayLocationInName: 27;
      Name => "ResolutionStage0EmVerifier[n]Data",
      RegMem => "MemField",
      Description => "Verifier and payload data",
      Width => "56",
      Position => "55:0", # Excel Formula: =calc_position(F308,E309,TRUE)
    },
  },
  ResolutionStage0EmPerBankReg0 => { #Structure Type: Reg; ArrayLength: 12; ArrayIndex: 0; ArrayLocationInName: 29; Skip Register;
    Name => "ResolutionStage0EmPerBankReg[12]",
    RegMem => "Reg",
    Address => "135", # Excel Formula: =calc_reg_address(C159,A159,G159)
    Description => "EM bank configurations, see fields description",
    Width => "50", # Excel Formula: =calc_reg_width(E311:E313,F313)
    Type => "Config",
    AdditionalInfo => "PackArrayToBus",
    Comments => "EM Skip Reg",
    ArrayLength => "12",
    ArrayIndex => "0",
    ResolutionStage0EmActiveBanks0 => { #Structure Type: RegField; ArrayLength: 12; ArrayIndex: 0; ArrayLocationInName: 30;
      Name => "ResolutionStage0EmActiveBanks[n]",
      RegMem => "RegField",
      Description => "0 - EM bank is inactive
1 - EM bank is active",
      Width => "1",
      Position => "0", # Excel Formula: =calc_position(F310,E311,TRUE)
      Type => "Config",
      UsedBy => "ResolutionStage0Em",
      DefaultValue => "d1",
    },
    ResolutionStage0EmHashKey0 => { #Structure Type: RegField; ArrayLength: 12; ArrayIndex: 0; ArrayLocationInName: 26;
      Name => "ResolutionStage0EmHashKey[n]",
      RegMem => "RegField",
      Description => "Seed for the EM hash",
      Width => "48",
      Position => "48:1", # Excel Formula: =calc_position(F311,E312)
      Type => "Config",
      UsedBy => "ResolutionStage0Em",
      DefaultValue => "h0",
    },
    ResolutionStage0EmUsePrimitiveCrc0 => { #Structure Type: RegField; ArrayLength: 12; ArrayIndex: 0; ArrayLocationInName: 34;
      Name => "ResolutionStage0EmUsePrimitiveCrc[n]",
      RegMem => "RegField",
      Description => "0 - use non primitive polynom for the hash CRC
1 - use primitive polynom for the hash CRC",
      Width => "1",
      Position => "49", # Excel Formula: =calc_position(F312,E313)
      Type => "Config",
      UsedBy => "ResolutionStage0Em",
      DefaultValue => "h0",
    },
  },
  ResolutionStage0EmPerBankReg1 => { #Structure Type: Reg; ArrayLength: 12; ArrayIndex: 1; ArrayLocationInName: 29; Skip Register;
    Name => "ResolutionStage0EmPerBankReg[12]",
    RegMem => "Reg",
    Address => "136",
    Description => "EM bank configurations, see fields description",
    Width => "50", # Excel Formula: =calc_reg_width(E311:E313,F313)
    Type => "Config",
    AdditionalInfo => "PackArrayToBus",
    Comments => "EM Skip Reg",
    ArrayLength => "12",
    ArrayIndex => "1",
    ResolutionStage0EmActiveBanks1 => { #Structure Type: RegField; ArrayLength: 12; ArrayIndex: 1; ArrayLocationInName: 30;
      Name => "ResolutionStage0EmActiveBanks[n]",
      RegMem => "RegField",
      Description => "0 - EM bank is inactive
1 - EM bank is active",
      Width => "1",
      Position => "0", # Excel Formula: =calc_position(F310,E311,TRUE)
      Type => "Config",
      UsedBy => "ResolutionStage0Em",
      DefaultValue => "d1",
    },
    ResolutionStage0EmHashKey1 => { #Structure Type: RegField; ArrayLength: 12; ArrayIndex: 1; ArrayLocationInName: 26;
      Name => "ResolutionStage0EmHashKey[n]",
      RegMem => "RegField",
      Description => "Seed for the EM hash",
      Width => "48",
      Position => "48:1", # Excel Formula: =calc_position(F311,E312)
      Type => "Config",
      UsedBy => "ResolutionStage0Em",
      DefaultValue => "h0",
    },
    ResolutionStage0EmUsePrimitiveCrc1 => { #Structure Type: RegField; ArrayLength: 12; ArrayIndex: 1; ArrayLocationInName: 34;
      Name => "ResolutionStage0EmUsePrimitiveCrc[n]",
      RegMem => "RegField",
      Description => "0 - use non primitive polynom for the hash CRC
1 - use primitive polynom for the hash CRC",
      Width => "1",
      Position => "49", # Excel Formula: =calc_position(F312,E313)
      Type => "Config",
      UsedBy => "ResolutionStage0Em",
      DefaultValue => "h0",
    },
  },
  ResolutionStage0EmPerBankReg2 => { #Structure Type: Reg; ArrayLength: 12; ArrayIndex: 2; ArrayLocationInName: 29; Skip Register;
    Name => "ResolutionStage0EmPerBankReg[12]",
    RegMem => "Reg",
    Address => "137",
    Description => "EM bank configurations, see fields description",
    Width => "50", # Excel Formula: =calc_reg_width(E311:E313,F313)
    Type => "Config",
    AdditionalInfo => "PackArrayToBus",
    Comments => "EM Skip Reg",
    ArrayLength => "12",
    ArrayIndex => "2",
    ResolutionStage0EmActiveBanks2 => { #Structure Type: RegField; ArrayLength: 12; ArrayIndex: 2; ArrayLocationInName: 30;
      Name => "ResolutionStage0EmActiveBanks[n]",
      RegMem => "RegField",
      Description => "0 - EM bank is inactive
1 - EM bank is active",
      Width => "1",
      Position => "0", # Excel Formula: =calc_position(F310,E311,TRUE)
      Type => "Config",
      UsedBy => "ResolutionStage0Em",
      DefaultValue => "d1",
    },
    ResolutionStage0EmHashKey2 => { #Structure Type: RegField; ArrayLength: 12; ArrayIndex: 2; ArrayLocationInName: 26;
      Name => "ResolutionStage0EmHashKey[n]",
      RegMem => "RegField",
      Description => "Seed for the EM hash",
      Width => "48",
      Position => "48:1", # Excel Formula: =calc_position(F311,E312)
      Type => "Config",
      UsedBy => "ResolutionStage0Em",
      DefaultValue => "h0",
    },
    ResolutionStage0EmUsePrimitiveCrc2 => { #Structure Type: RegField; ArrayLength: 12; ArrayIndex: 2; ArrayLocationInName: 34;
      Name => "ResolutionStage0EmUsePrimitiveCrc[n]",
      RegMem => "RegField",
      Description => "0 - use non primitive polynom for the hash CRC
1 - use primitive polynom for the hash CRC",
      Width => "1",
      Position => "49", # Excel Formula: =calc_position(F312,E313)
      Type => "Config",
      UsedBy => "ResolutionStage0Em",
      DefaultValue => "h0",
    },
  },
  ResolutionStage0EmPerBankReg3 => { #Structure Type: Reg; ArrayLength: 12; ArrayIndex: 3; ArrayLocationInName: 29; Skip Register;
    Name => "ResolutionStage0EmPerBankReg[12]",
    RegMem => "Reg",
    Address => "138",
    Description => "EM bank configurations, see fields description",
    Width => "50", # Excel Formula: =calc_reg_width(E311:E313,F313)
    Type => "Config",
    AdditionalInfo => "PackArrayToBus",
    Comments => "EM Skip Reg",
    ArrayLength => "12",
    ArrayIndex => "3",
    ResolutionStage0EmActiveBanks3 => { #Structure Type: RegField; ArrayLength: 12; ArrayIndex: 3; ArrayLocationInName: 30;
      Name => "ResolutionStage0EmActiveBanks[n]",
      RegMem => "RegField",
      Description => "0 - EM bank is inactive
1 - EM bank is active",
      Width => "1",
      Position => "0", # Excel Formula: =calc_position(F310,E311,TRUE)
      Type => "Config",
      UsedBy => "ResolutionStage0Em",
      DefaultValue => "d1",
    },
    ResolutionStage0EmHashKey3 => { #Structure Type: RegField; ArrayLength: 12; ArrayIndex: 3; ArrayLocationInName: 26;
      Name => "ResolutionStage0EmHashKey[n]",
      RegMem => "RegField",
      Description => "Seed for the EM hash",
      Width => "48",
      Position => "48:1", # Excel Formula: =calc_position(F311,E312)
      Type => "Config",
      UsedBy => "ResolutionStage0Em",
      DefaultValue => "h0",
    },
    ResolutionStage0EmUsePrimitiveCrc3 => { #Structure Type: RegField; ArrayLength: 12; ArrayIndex: 3; ArrayLocationInName: 34;
      Name => "ResolutionStage0EmUsePrimitiveCrc[n]",
      RegMem => "RegField",
      Description => "0 - use non primitive polynom for the hash CRC
1 - use primitive polynom for the hash CRC",
      Width => "1",
      Position => "49", # Excel Formula: =calc_position(F312,E313)
      Type => "Config",
      UsedBy => "ResolutionStage0Em",
      DefaultValue => "h0",
    },
  },
  ResolutionStage0EmPerBankReg4 => { #Structure Type: Reg; ArrayLength: 12; ArrayIndex: 4; ArrayLocationInName: 29; Skip Register;
    Name => "ResolutionStage0EmPerBankReg[12]",
    RegMem => "Reg",
    Address => "139",
    Description => "EM bank configurations, see fields description",
    Width => "50", # Excel Formula: =calc_reg_width(E311:E313,F313)
    Type => "Config",
    AdditionalInfo => "PackArrayToBus",
    Comments => "EM Skip Reg",
    ArrayLength => "12",
    ArrayIndex => "4",
    ResolutionStage0EmActiveBanks4 => { #Structure Type: RegField; ArrayLength: 12; ArrayIndex: 4; ArrayLocationInName: 30;
      Name => "ResolutionStage0EmActiveBanks[n]",
      RegMem => "RegField",
      Description => "0 - EM bank is inactive
1 - EM bank is active",
      Width => "1",
      Position => "0", # Excel Formula: =calc_position(F310,E311,TRUE)
      Type => "Config",
      UsedBy => "ResolutionStage0Em",
      DefaultValue => "d1",
    },
    ResolutionStage0EmHashKey4 => { #Structure Type: RegField; ArrayLength: 12; ArrayIndex: 4; ArrayLocationInName: 26;
      Name => "ResolutionStage0EmHashKey[n]",
      RegMem => "RegField",
      Description => "Seed for the EM hash",
      Width => "48",
      Position => "48:1", # Excel Formula: =calc_position(F311,E312)
      Type => "Config",
      UsedBy => "ResolutionStage0Em",
      DefaultValue => "h0",
    },
    ResolutionStage0EmUsePrimitiveCrc4 => { #Structure Type: RegField; ArrayLength: 12; ArrayIndex: 4; ArrayLocationInName: 34;
      Name => "ResolutionStage0EmUsePrimitiveCrc[n]",
      RegMem => "RegField",
      Description => "0 - use non primitive polynom for the hash CRC
1 - use primitive polynom for the hash CRC",
      Width => "1",
      Position => "49", # Excel Formula: =calc_position(F312,E313)
      Type => "Config",
      UsedBy => "ResolutionStage0Em",
      DefaultValue => "h0",
    },
  },
  ResolutionStage0EmPerBankReg5 => { #Structure Type: Reg; ArrayLength: 12; ArrayIndex: 5; ArrayLocationInName: 29; Skip Register;
    Name => "ResolutionStage0EmPerBankReg[12]",
    RegMem => "Reg",
    Address => "13A",
    Description => "EM bank configurations, see fields description",
    Width => "50", # Excel Formula: =calc_reg_width(E311:E313,F313)
    Type => "Config",
    AdditionalInfo => "PackArrayToBus",
    Comments => "EM Skip Reg",
    ArrayLength => "12",
    ArrayIndex => "5",
    ResolutionStage0EmActiveBanks5 => { #Structure Type: RegField; ArrayLength: 12; ArrayIndex: 5; ArrayLocationInName: 30;
      Name => "ResolutionStage0EmActiveBanks[n]",
      RegMem => "RegField",
      Description => "0 - EM bank is inactive
1 - EM bank is active",
      Width => "1",
      Position => "0", # Excel Formula: =calc_position(F310,E311,TRUE)
      Type => "Config",
      UsedBy => "ResolutionStage0Em",
      DefaultValue => "d1",
    },
    ResolutionStage0EmHashKey5 => { #Structure Type: RegField; ArrayLength: 12; ArrayIndex: 5; ArrayLocationInName: 26;
      Name => "ResolutionStage0EmHashKey[n]",
      RegMem => "RegField",
      Description => "Seed for the EM hash",
      Width => "48",
      Position => "48:1", # Excel Formula: =calc_position(F311,E312)
      Type => "Config",
      UsedBy => "ResolutionStage0Em",
      DefaultValue => "h0",
    },
    ResolutionStage0EmUsePrimitiveCrc5 => { #Structure Type: RegField; ArrayLength: 12; ArrayIndex: 5; ArrayLocationInName: 34;
      Name => "ResolutionStage0EmUsePrimitiveCrc[n]",
      RegMem => "RegField",
      Description => "0 - use non primitive polynom for the hash CRC
1 - use primitive polynom for the hash CRC",
      Width => "1",
      Position => "49", # Excel Formula: =calc_position(F312,E313)
      Type => "Config",
      UsedBy => "ResolutionStage0Em",
      DefaultValue => "h0",
    },
  },
  ResolutionStage0EmPerBankReg6 => { #Structure Type: Reg; ArrayLength: 12; ArrayIndex: 6; ArrayLocationInName: 29; Skip Register;
    Name => "ResolutionStage0EmPerBankReg[12]",
    RegMem => "Reg",
    Address => "13B",
    Description => "EM bank configurations, see fields description",
    Width => "50", # Excel Formula: =calc_reg_width(E311:E313,F313)
    Type => "Config",
    AdditionalInfo => "PackArrayToBus",
    Comments => "EM Skip Reg",
    ArrayLength => "12",
    ArrayIndex => "6",
    ResolutionStage0EmActiveBanks6 => { #Structure Type: RegField; ArrayLength: 12; ArrayIndex: 6; ArrayLocationInName: 30;
      Name => "ResolutionStage0EmActiveBanks[n]",
      RegMem => "RegField",
      Description => "0 - EM bank is inactive
1 - EM bank is active",
      Width => "1",
      Position => "0", # Excel Formula: =calc_position(F310,E311,TRUE)
      Type => "Config",
      UsedBy => "ResolutionStage0Em",
      DefaultValue => "d1",
    },
    ResolutionStage0EmHashKey6 => { #Structure Type: RegField; ArrayLength: 12; ArrayIndex: 6; ArrayLocationInName: 26;
      Name => "ResolutionStage0EmHashKey[n]",
      RegMem => "RegField",
      Description => "Seed for the EM hash",
      Width => "48",
      Position => "48:1", # Excel Formula: =calc_position(F311,E312)
      Type => "Config",
      UsedBy => "ResolutionStage0Em",
      DefaultValue => "h0",
    },
    ResolutionStage0EmUsePrimitiveCrc6 => { #Structure Type: RegField; ArrayLength: 12; ArrayIndex: 6; ArrayLocationInName: 34;
      Name => "ResolutionStage0EmUsePrimitiveCrc[n]",
      RegMem => "RegField",
      Description => "0 - use non primitive polynom for the hash CRC
1 - use primitive polynom for the hash CRC",
      Width => "1",
      Position => "49", # Excel Formula: =calc_position(F312,E313)
      Type => "Config",
      UsedBy => "ResolutionStage0Em",
      DefaultValue => "h0",
    },
  },
  ResolutionStage0EmPerBankReg7 => { #Structure Type: Reg; ArrayLength: 12; ArrayIndex: 7; ArrayLocationInName: 29; Skip Register;
    Name => "ResolutionStage0EmPerBankReg[12]",
    RegMem => "Reg",
    Address => "13C",
    Description => "EM bank configurations, see fields description",
    Width => "50", # Excel Formula: =calc_reg_width(E311:E313,F313)
    Type => "Config",
    AdditionalInfo => "PackArrayToBus",
    Comments => "EM Skip Reg",
    ArrayLength => "12",
    ArrayIndex => "7",
    ResolutionStage0EmActiveBanks7 => { #Structure Type: RegField; ArrayLength: 12; ArrayIndex: 7; ArrayLocationInName: 30;
      Name => "ResolutionStage0EmActiveBanks[n]",
      RegMem => "RegField",
      Description => "0 - EM bank is inactive
1 - EM bank is active",
      Width => "1",
      Position => "0", # Excel Formula: =calc_position(F310,E311,TRUE)
      Type => "Config",
      UsedBy => "ResolutionStage0Em",
      DefaultValue => "d1",
    },
    ResolutionStage0EmHashKey7 => { #Structure Type: RegField; ArrayLength: 12; ArrayIndex: 7; ArrayLocationInName: 26;
      Name => "ResolutionStage0EmHashKey[n]",
      RegMem => "RegField",
      Description => "Seed for the EM hash",
      Width => "48",
      Position => "48:1", # Excel Formula: =calc_position(F311,E312)
      Type => "Config",
      UsedBy => "ResolutionStage0Em",
      DefaultValue => "h0",
    },
    ResolutionStage0EmUsePrimitiveCrc7 => { #Structure Type: RegField; ArrayLength: 12; ArrayIndex: 7; ArrayLocationInName: 34;
      Name => "ResolutionStage0EmUsePrimitiveCrc[n]",
      RegMem => "RegField",
      Description => "0 - use non primitive polynom for the hash CRC
1 - use primitive polynom for the hash CRC",
      Width => "1",
      Position => "49", # Excel Formula: =calc_position(F312,E313)
      Type => "Config",
      UsedBy => "ResolutionStage0Em",
      DefaultValue => "h0",
    },
  },
  ResolutionStage0EmPerBankReg8 => { #Structure Type: Reg; ArrayLength: 12; ArrayIndex: 8; ArrayLocationInName: 29; Skip Register;
    Name => "ResolutionStage0EmPerBankReg[12]",
    RegMem => "Reg",
    Address => "13D",
    Description => "EM bank configurations, see fields description",
    Width => "50", # Excel Formula: =calc_reg_width(E311:E313,F313)
    Type => "Config",
    AdditionalInfo => "PackArrayToBus",
    Comments => "EM Skip Reg",
    ArrayLength => "12",
    ArrayIndex => "8",
    ResolutionStage0EmActiveBanks8 => { #Structure Type: RegField; ArrayLength: 12; ArrayIndex: 8; ArrayLocationInName: 30;
      Name => "ResolutionStage0EmActiveBanks[n]",
      RegMem => "RegField",
      Description => "0 - EM bank is inactive
1 - EM bank is active",
      Width => "1",
      Position => "0", # Excel Formula: =calc_position(F310,E311,TRUE)
      Type => "Config",
      UsedBy => "ResolutionStage0Em",
      DefaultValue => "d1",
    },
    ResolutionStage0EmHashKey8 => { #Structure Type: RegField; ArrayLength: 12; ArrayIndex: 8; ArrayLocationInName: 26;
      Name => "ResolutionStage0EmHashKey[n]",
      RegMem => "RegField",
      Description => "Seed for the EM hash",
      Width => "48",
      Position => "48:1", # Excel Formula: =calc_position(F311,E312)
      Type => "Config",
      UsedBy => "ResolutionStage0Em",
      DefaultValue => "h0",
    },
    ResolutionStage0EmUsePrimitiveCrc8 => { #Structure Type: RegField; ArrayLength: 12; ArrayIndex: 8; ArrayLocationInName: 34;
      Name => "ResolutionStage0EmUsePrimitiveCrc[n]",
      RegMem => "RegField",
      Description => "0 - use non primitive polynom for the hash CRC
1 - use primitive polynom for the hash CRC",
      Width => "1",
      Position => "49", # Excel Formula: =calc_position(F312,E313)
      Type => "Config",
      UsedBy => "ResolutionStage0Em",
      DefaultValue => "h0",
    },
  },
  ResolutionStage0EmPerBankReg9 => { #Structure Type: Reg; ArrayLength: 12; ArrayIndex: 9; ArrayLocationInName: 29; Skip Register;
    Name => "ResolutionStage0EmPerBankReg[12]",
    RegMem => "Reg",
    Address => "13E",
    Description => "EM bank configurations, see fields description",
    Width => "50", # Excel Formula: =calc_reg_width(E311:E313,F313)
    Type => "Config",
    AdditionalInfo => "PackArrayToBus",
    Comments => "EM Skip Reg",
    ArrayLength => "12",
    ArrayIndex => "9",
    ResolutionStage0EmActiveBanks9 => { #Structure Type: RegField; ArrayLength: 12; ArrayIndex: 9; ArrayLocationInName: 30;
      Name => "ResolutionStage0EmActiveBanks[n]",
      RegMem => "RegField",
      Description => "0 - EM bank is inactive
1 - EM bank is active",
      Width => "1",
      Position => "0", # Excel Formula: =calc_position(F310,E311,TRUE)
      Type => "Config",
      UsedBy => "ResolutionStage0Em",
      DefaultValue => "d1",
    },
    ResolutionStage0EmHashKey9 => { #Structure Type: RegField; ArrayLength: 12; ArrayIndex: 9; ArrayLocationInName: 26;
      Name => "ResolutionStage0EmHashKey[n]",
      RegMem => "RegField",
      Description => "Seed for the EM hash",
      Width => "48",
      Position => "48:1", # Excel Formula: =calc_position(F311,E312)
      Type => "Config",
      UsedBy => "ResolutionStage0Em",
      DefaultValue => "h0",
    },
    ResolutionStage0EmUsePrimitiveCrc9 => { #Structure Type: RegField; ArrayLength: 12; ArrayIndex: 9; ArrayLocationInName: 34;
      Name => "ResolutionStage0EmUsePrimitiveCrc[n]",
      RegMem => "RegField",
      Description => "0 - use non primitive polynom for the hash CRC
1 - use primitive polynom for the hash CRC",
      Width => "1",
      Position => "49", # Excel Formula: =calc_position(F312,E313)
      Type => "Config",
      UsedBy => "ResolutionStage0Em",
      DefaultValue => "h0",
    },
  },
  ResolutionStage0EmPerBankReg10 => { #Structure Type: Reg; ArrayLength: 12; ArrayIndex: 10; ArrayLocationInName: 29; Skip Register;
    Name => "ResolutionStage0EmPerBankReg[12]",
    RegMem => "Reg",
    Address => "13F",
    Description => "EM bank configurations, see fields description",
    Width => "50", # Excel Formula: =calc_reg_width(E311:E313,F313)
    Type => "Config",
    AdditionalInfo => "PackArrayToBus",
    Comments => "EM Skip Reg",
    ArrayLength => "12",
    ArrayIndex => "10",
    ResolutionStage0EmActiveBanks10 => { #Structure Type: RegField; ArrayLength: 12; ArrayIndex: 10; ArrayLocationInName: 30;
      Name => "ResolutionStage0EmActiveBanks[n]",
      RegMem => "RegField",
      Description => "0 - EM bank is inactive
1 - EM bank is active",
      Width => "1",
      Position => "0", # Excel Formula: =calc_position(F310,E311,TRUE)
      Type => "Config",
      UsedBy => "ResolutionStage0Em",
      DefaultValue => "d1",
    },
    ResolutionStage0EmHashKey10 => { #Structure Type: RegField; ArrayLength: 12; ArrayIndex: 10; ArrayLocationInName: 26;
      Name => "ResolutionStage0EmHashKey[n]",
      RegMem => "RegField",
      Description => "Seed for the EM hash",
      Width => "48",
      Position => "48:1", # Excel Formula: =calc_position(F311,E312)
      Type => "Config",
      UsedBy => "ResolutionStage0Em",
      DefaultValue => "h0",
    },
    ResolutionStage0EmUsePrimitiveCrc10 => { #Structure Type: RegField; ArrayLength: 12; ArrayIndex: 10; ArrayLocationInName: 34;
      Name => "ResolutionStage0EmUsePrimitiveCrc[n]",
      RegMem => "RegField",
      Description => "0 - use non primitive polynom for the hash CRC
1 - use primitive polynom for the hash CRC",
      Width => "1",
      Position => "49", # Excel Formula: =calc_position(F312,E313)
      Type => "Config",
      UsedBy => "ResolutionStage0Em",
      DefaultValue => "h0",
    },
  },
  ResolutionStage0EmPerBankReg11 => { #Structure Type: Reg; ArrayLength: 12; ArrayIndex: 11; ArrayLocationInName: 29; Skip Register;
    Name => "ResolutionStage0EmPerBankReg[12]",
    RegMem => "Reg",
    Address => "140",
    Description => "EM bank configurations, see fields description",
    Width => "50", # Excel Formula: =calc_reg_width(E311:E313,F313)
    Type => "Config",
    AdditionalInfo => "PackArrayToBus",
    Comments => "EM Skip Reg",
    ArrayLength => "12",
    ArrayIndex => "11",
    ResolutionStage0EmActiveBanks11 => { #Structure Type: RegField; ArrayLength: 12; ArrayIndex: 11; ArrayLocationInName: 30;
      Name => "ResolutionStage0EmActiveBanks[n]",
      RegMem => "RegField",
      Description => "0 - EM bank is inactive
1 - EM bank is active",
      Width => "1",
      Position => "0", # Excel Formula: =calc_position(F310,E311,TRUE)
      Type => "Config",
      UsedBy => "ResolutionStage0Em",
      DefaultValue => "d1",
    },
    ResolutionStage0EmHashKey11 => { #Structure Type: RegField; ArrayLength: 12; ArrayIndex: 11; ArrayLocationInName: 26;
      Name => "ResolutionStage0EmHashKey[n]",
      RegMem => "RegField",
      Description => "Seed for the EM hash",
      Width => "48",
      Position => "48:1", # Excel Formula: =calc_position(F311,E312)
      Type => "Config",
      UsedBy => "ResolutionStage0Em",
      DefaultValue => "h0",
    },
    ResolutionStage0EmUsePrimitiveCrc11 => { #Structure Type: RegField; ArrayLength: 12; ArrayIndex: 11; ArrayLocationInName: 34;
      Name => "ResolutionStage0EmUsePrimitiveCrc[n]",
      RegMem => "RegField",
      Description => "0 - use non primitive polynom for the hash CRC
1 - use primitive polynom for the hash CRC",
      Width => "1",
      Position => "49", # Excel Formula: =calc_position(F312,E313)
      Type => "Config",
      UsedBy => "ResolutionStage0Em",
      DefaultValue => "h0",
    },
  },
  ResolutionStage0EmPerEmReg0 => { #Structure Type: Reg; ArrayLength: 1; ArrayIndex: 0; ArrayLocationInName: 27; Skip Register;
    Name => "ResolutionStage0EmPerEmReg[1]",
    RegMem => "Reg",
    Address => "141", # Excel Formula: =calc_reg_address(C310,A310,G310)
    Description => "EM configurations, see fields description",
    Width => "33", # Excel Formula: =calc_reg_width(E315:E317,F317)
    Type => "Config",
    AdditionalInfo => "PackArrayToBus",
    Comments => "EM Skip Reg",
    ArrayLength => "1",
    ArrayIndex => "0",
    ResolutionStage0EmKeyWidth0 => { #Structure Type: RegField; ArrayLength: 1; ArrayIndex: 0; ArrayLocationInName: 27;
      Name => "ResolutionStage0EmKeyWidth[n]",
      RegMem => "RegField",
      Description => "Map the 4 key LSBs to key width",
      Width => "16",
      Position => "15:0", # Excel Formula: =calc_position(F314,E315,TRUE)
      Type => "Config",
      UsedBy => "ResolutionStage0Em",
      DefaultValue => "h0",
    },
    ResolutionStage0EmAutoBubbleReq0 => { #Structure Type: RegField; ArrayLength: 1; ArrayIndex: 0; ArrayLocationInName: 32;
      Name => "ResolutionStage0EmAutoBubbleReq[n]",
      RegMem => "RegField",
      Description => "Generate bubble request to the pipe automatically",
      Width => "1",
      Position => "16", # Excel Formula: =calc_position(F315,E316)
      Type => "Config",
      UsedBy => "ResolutionStage0Em",
      DefaultValue => "h0",
    },
    ResolutionStage0EmBubbleReqThreshold0 => { #Structure Type: RegField; ArrayLength: 1; ArrayIndex: 0; ArrayLocationInName: 37;
      Name => "ResolutionStage0EmBubbleReqThreshold[n]",
      RegMem => "RegField",
      Description => "Number of consecutive pipe lookups before generating CPU bubble request",
      Width => "16",
      Position => "32:17", # Excel Formula: =calc_position(F316,E317)
      Type => "Config",
      UsedBy => "ResolutionStage0Em",
      DefaultValue => "h0",
    },
  },
  ResolutionStage0EmCamWmMaxReg0 => { #Structure Type: Reg; ArrayLength: 1; ArrayIndex: 0; ArrayLocationInName: 30; Skip Register;
    Name => "ResolutionStage0EmCamWmMaxReg[1]",
    RegMem => "Reg",
    Address => "142", # Excel Formula: =calc_reg_address(C314,A314,G314)
    Description => "EM debug indications, see fields description",
    Width => "8", # Excel Formula: =calc_reg_width(E319:E319,F319)
    Type => "ReadOnly",
    AdditionalInfo => "PackArrayToBus",
    Comments => "EM Skip Reg",
    ArrayLength => "1",
    ArrayIndex => "0",
    ResolutionStage0EmCamWmMax0 => { #Structure Type: RegField; ArrayLength: 1; ArrayIndex: 0; ArrayLocationInName: 27;
      Name => "ResolutionStage0EmCamWmMax[n]",
      RegMem => "RegField",
      Description => "CAM max watermark",
      Width => "8",
      Position => "7:0", # Excel Formula: =calc_position(F318,E319,TRUE)
      Type => "MaxWmk",
      UsedBy => "emdb",
      AdditionalInfo => "CounterIncrWidth=1",
    },
  },
  ResolutionStage0EmAccessRegister0 => { #Structure Type: Reg; ArrayLength: 1; ArrayIndex: 0; ArrayLocationInName: 33; Skip Register;
    Name => "ResolutionStage0EmAccessRegister[1]",
    RegMem => "Reg",
    Address => "143", # Excel Formula: =calc_reg_address(C318,A318,G318)
    Description => "EM indirect access configurations",
    Width => "93", # Excel Formula: =calc_reg_width(E321:E321,F321)
    Type => "External",
    UsedBy => "em_top",
    Comments => "EM Skip Reg",
    ArrayLength => "1",
    ArrayIndex => "0",
    ResolutionStage0EmAccessReg0 => { #Structure Type: RegField; ArrayLength: 1; ArrayIndex: 0; ArrayLocationInName: 28;
      Name => "ResolutionStage0EmAccessReg[n]",
      RegMem => "RegField",
      Description => "See EM spec for register usage",
      Width => "93",
      Position => "92:0", # Excel Formula: =calc_position(F320,E321,TRUE)
      Type => "External",
    },
  },
  ResolutionStage0EmResponseRegister0 => { #Structure Type: Reg; ArrayLength: 1; ArrayIndex: 0; ArrayLocationInName: 35; Skip Register;
    Name => "ResolutionStage0EmResponseRegister[1]",
    RegMem => "Reg",
    Address => "144", # Excel Formula: =calc_reg_address(C320,A320,G320)
    Description => "EM indirect access data",
    Width => "87", # Excel Formula: =calc_reg_width(E323:E324,F324)
    Type => "ReadOnly",
    Comments => "EM Skip Reg",
    ArrayLength => "1",
    ArrayIndex => "0",
    ResolutionStage0EmResponseValid0 => { #Structure Type: RegField; ArrayLength: 1; ArrayIndex: 0; ArrayLocationInName: 32;
      Name => "ResolutionStage0EmResponseValid[n]",
      RegMem => "RegField",
      Description => "EM indirect access data is valid",
      Width => "1",
      Position => "0", # Excel Formula: =calc_position(F322,E323,TRUE)
      Type => "Event",
      UsedBy => "emdb",
    },
    ResolutionStage0EmResponseReg0 => { #Structure Type: RegField; ArrayLength: 1; ArrayIndex: 0; ArrayLocationInName: 30;
      Name => "ResolutionStage0EmResponseReg[n]",
      RegMem => "RegField",
      Description => "EM indirect access data, see EM spec for register usage",
      Width => "86",
      Position => "86:1", # Excel Formula: =calc_position(F323,E324)
      Type => "Capture",
      UsedBy => "emdb",
    },
  },
  ResolutionStage0EmCam => { #Structure Type: Mem; Skip Register;
    Name => "ResolutionStage0EmCam",
    RegMem => "Mem",
    Address => "4B00000", # Excel Formula: =calc_mem_address(C308,A308,G325,L325)
    Description => "EM fallback CAM",
    Width => "63", # Excel Formula: =calc_mem_width(E326:E328,"None",F328,-1)
    Type => "Dynamic",
    UsedBy => "ResolutionStage0Em",
    MemEntries => "32",
    MemWrapper => "TCAM",
    MemProtect => "None",
    AdditionalInfo => "NumOfKeys=1,RegTcamPayloadWidth=38,CAM=Enabled,CpuReadAccess=Enabled,CpuWriteAccess=Enabled,NumCamLookupClients=2",
    Comments => "EM Skip Reg",
    MemLogicalWidth => "63",
    ResolutionStage0EmCam_key => { #Structure Type: MemField;
      Name => "ResolutionStage0EmCam_key",
      RegMem => "MemField",
      Description => "CAM key",
      Width => "24",
      Position => "23:0", # Excel Formula: =calc_position(F325,E326,TRUE)
    },
    ResolutionStage0EmCam_payload => { #Structure Type: MemField;
      Name => "ResolutionStage0EmCam_payload",
      RegMem => "MemField",
      Description => "CAM payload",
      Width => "38",
      Position => "61:24", # Excel Formula: =calc_position(F326,E327)
    },
    ResolutionStage0EmCam_valid => { #Structure Type: MemField;
      Name => "ResolutionStage0EmCam_valid",
      RegMem => "MemField",
      Description => "CAM entry is valid",
      Width => "1",
      Position => "62", # Excel Formula: =calc_position(F327,E328)
    },
  },
  LpQueuingEmVerifier0 => { #Structure Type: Mem; ArrayLength: 5; ArrayIndex: 0; ArrayLocationInName: 20; Skip Register;
    Name => "LpQueuingEmVerifier[5]",
    RegMem => "Mem",
    Address => "4C00000", # Excel Formula: =calc_mem_address(C325,A325,G329,L329)
    Description => "Holds the verifier and the payload of the EM entry",
    Width => "72", # Excel Formula: =calc_mem_width(E330:E330,M329,F330,-1)
    Type => "Dynamic",
    UsedBy => "LpQueuingEm",
    MemEntries => "4096",
    MemWrapper => "2R1W Slow Write",
    MemProtect => "ExtECC",
    AdditionalInfo => "PackArrayToBus=Enabled,UseHardReset=1,SampleReadBeforeProt=2,SamplePhysicalMem=1,CpuReadAccess=Enabled,CpuWriteAccess=Enabled,WriteActivityFactor=0,ReadActivityFactor=100,DisableSameAddressErr=Enabled,EnableNonCpuRdWrSameAddress=Enabled,PortErrPropagate=Disabled",
    Comments => "EM Skip Reg",
    ArrayLength => "5",
    ArrayIndex => "0",
    MemLogicalWidth => "72",
    LpQueuingEmVerifier0Data => { #Structure Type: MemField; ArrayLength: 5; ArrayIndex: 0; ArrayLocationInName: 20;
      Name => "LpQueuingEmVerifier[n]Data",
      RegMem => "MemField",
      Description => "Verifier and payload data",
      Width => "72",
      Position => "71:0", # Excel Formula: =calc_position(F329,E330,TRUE)
    },
  },
  LpQueuingEmVerifier1 => { #Structure Type: Mem; ArrayLength: 5; ArrayIndex: 1; ArrayLocationInName: 20; Skip Register;
    Name => "LpQueuingEmVerifier[5]",
    RegMem => "Mem",
    Address => "4D00000",
    Description => "Holds the verifier and the payload of the EM entry",
    Width => "72", # Excel Formula: =calc_mem_width(E330:E330,M329,F330,-1)
    Type => "Dynamic",
    UsedBy => "LpQueuingEm",
    MemEntries => "4096",
    MemWrapper => "2R1W Slow Write",
    MemProtect => "ExtECC",
    AdditionalInfo => "PackArrayToBus=Enabled,UseHardReset=1,SampleReadBeforeProt=2,SamplePhysicalMem=1,CpuReadAccess=Enabled,CpuWriteAccess=Enabled,WriteActivityFactor=0,ReadActivityFactor=100,DisableSameAddressErr=Enabled,EnableNonCpuRdWrSameAddress=Enabled,PortErrPropagate=Disabled",
    Comments => "EM Skip Reg",
    ArrayLength => "5",
    ArrayIndex => "1",
    MemLogicalWidth => "72",
    LpQueuingEmVerifier1Data => { #Structure Type: MemField; ArrayLength: 5; ArrayIndex: 1; ArrayLocationInName: 20;
      Name => "LpQueuingEmVerifier[n]Data",
      RegMem => "MemField",
      Description => "Verifier and payload data",
      Width => "72",
      Position => "71:0", # Excel Formula: =calc_position(F329,E330,TRUE)
    },
  },
  LpQueuingEmVerifier2 => { #Structure Type: Mem; ArrayLength: 5; ArrayIndex: 2; ArrayLocationInName: 20; Skip Register;
    Name => "LpQueuingEmVerifier[5]",
    RegMem => "Mem",
    Address => "4E00000",
    Description => "Holds the verifier and the payload of the EM entry",
    Width => "72", # Excel Formula: =calc_mem_width(E330:E330,M329,F330,-1)
    Type => "Dynamic",
    UsedBy => "LpQueuingEm",
    MemEntries => "4096",
    MemWrapper => "2R1W Slow Write",
    MemProtect => "ExtECC",
    AdditionalInfo => "PackArrayToBus=Enabled,UseHardReset=1,SampleReadBeforeProt=2,SamplePhysicalMem=1,CpuReadAccess=Enabled,CpuWriteAccess=Enabled,WriteActivityFactor=0,ReadActivityFactor=100,DisableSameAddressErr=Enabled,EnableNonCpuRdWrSameAddress=Enabled,PortErrPropagate=Disabled",
    Comments => "EM Skip Reg",
    ArrayLength => "5",
    ArrayIndex => "2",
    MemLogicalWidth => "72",
    LpQueuingEmVerifier2Data => { #Structure Type: MemField; ArrayLength: 5; ArrayIndex: 2; ArrayLocationInName: 20;
      Name => "LpQueuingEmVerifier[n]Data",
      RegMem => "MemField",
      Description => "Verifier and payload data",
      Width => "72",
      Position => "71:0", # Excel Formula: =calc_position(F329,E330,TRUE)
    },
  },
  LpQueuingEmVerifier3 => { #Structure Type: Mem; ArrayLength: 5; ArrayIndex: 3; ArrayLocationInName: 20; Skip Register;
    Name => "LpQueuingEmVerifier[5]",
    RegMem => "Mem",
    Address => "4F00000",
    Description => "Holds the verifier and the payload of the EM entry",
    Width => "72", # Excel Formula: =calc_mem_width(E330:E330,M329,F330,-1)
    Type => "Dynamic",
    UsedBy => "LpQueuingEm",
    MemEntries => "4096",
    MemWrapper => "2R1W Slow Write",
    MemProtect => "ExtECC",
    AdditionalInfo => "PackArrayToBus=Enabled,UseHardReset=1,SampleReadBeforeProt=2,SamplePhysicalMem=1,CpuReadAccess=Enabled,CpuWriteAccess=Enabled,WriteActivityFactor=0,ReadActivityFactor=100,DisableSameAddressErr=Enabled,EnableNonCpuRdWrSameAddress=Enabled,PortErrPropagate=Disabled",
    Comments => "EM Skip Reg",
    ArrayLength => "5",
    ArrayIndex => "3",
    MemLogicalWidth => "72",
    LpQueuingEmVerifier3Data => { #Structure Type: MemField; ArrayLength: 5; ArrayIndex: 3; ArrayLocationInName: 20;
      Name => "LpQueuingEmVerifier[n]Data",
      RegMem => "MemField",
      Description => "Verifier and payload data",
      Width => "72",
      Position => "71:0", # Excel Formula: =calc_position(F329,E330,TRUE)
    },
  },
  LpQueuingEmVerifier4 => { #Structure Type: Mem; ArrayLength: 5; ArrayIndex: 4; ArrayLocationInName: 20; Skip Register;
    Name => "LpQueuingEmVerifier[5]",
    RegMem => "Mem",
    Address => "5000000",
    Description => "Holds the verifier and the payload of the EM entry",
    Width => "72", # Excel Formula: =calc_mem_width(E330:E330,M329,F330,-1)
    Type => "Dynamic",
    UsedBy => "LpQueuingEm",
    MemEntries => "4096",
    MemWrapper => "2R1W Slow Write",
    MemProtect => "ExtECC",
    AdditionalInfo => "PackArrayToBus=Enabled,UseHardReset=1,SampleReadBeforeProt=2,SamplePhysicalMem=1,CpuReadAccess=Enabled,CpuWriteAccess=Enabled,WriteActivityFactor=0,ReadActivityFactor=100,DisableSameAddressErr=Enabled,EnableNonCpuRdWrSameAddress=Enabled,PortErrPropagate=Disabled",
    Comments => "EM Skip Reg",
    ArrayLength => "5",
    ArrayIndex => "4",
    MemLogicalWidth => "72",
    LpQueuingEmVerifier4Data => { #Structure Type: MemField; ArrayLength: 5; ArrayIndex: 4; ArrayLocationInName: 20;
      Name => "LpQueuingEmVerifier[n]Data",
      RegMem => "MemField",
      Description => "Verifier and payload data",
      Width => "72",
      Position => "71:0", # Excel Formula: =calc_position(F329,E330,TRUE)
    },
  },
  LpQueuingEmPerBankReg0 => { #Structure Type: Reg; ArrayLength: 5; ArrayIndex: 0; ArrayLocationInName: 22; Skip Register;
    Name => "LpQueuingEmPerBankReg[5]",
    RegMem => "Reg",
    Address => "145", # Excel Formula: =calc_reg_address(C322,A322,G322)
    Description => "EM bank configurations, see fields description",
    Width => "114", # Excel Formula: =calc_reg_width(E332:E334,F334)
    Type => "Config",
    AdditionalInfo => "PackArrayToBus",
    Comments => "EM Skip Reg",
    ArrayLength => "5",
    ArrayIndex => "0",
    LpQueuingEmActiveBanks0 => { #Structure Type: RegField; ArrayLength: 5; ArrayIndex: 0; ArrayLocationInName: 23;
      Name => "LpQueuingEmActiveBanks[n]",
      RegMem => "RegField",
      Description => "0 - EM bank is inactive
1 - EM bank is active",
      Width => "1",
      Position => "0", # Excel Formula: =calc_position(F331,E332,TRUE)
      Type => "Config",
      UsedBy => "LpQueuingEm",
      DefaultValue => "d1",
    },
    LpQueuingEmHashKey0 => { #Structure Type: RegField; ArrayLength: 5; ArrayIndex: 0; ArrayLocationInName: 19;
      Name => "LpQueuingEmHashKey[n]",
      RegMem => "RegField",
      Description => "Seed for the EM hash",
      Width => "112",
      Position => "112:1", # Excel Formula: =calc_position(F332,E333)
      Type => "Config",
      UsedBy => "LpQueuingEm",
      DefaultValue => "h0",
    },
    LpQueuingEmUsePrimitiveCrc0 => { #Structure Type: RegField; ArrayLength: 5; ArrayIndex: 0; ArrayLocationInName: 27;
      Name => "LpQueuingEmUsePrimitiveCrc[n]",
      RegMem => "RegField",
      Description => "0 - use non primitive polynom for the hash CRC
1 - use primitive polynom for the hash CRC",
      Width => "1",
      Position => "113", # Excel Formula: =calc_position(F333,E334)
      Type => "Config",
      UsedBy => "LpQueuingEm",
      DefaultValue => "h0",
    },
  },
  LpQueuingEmPerBankReg1 => { #Structure Type: Reg; ArrayLength: 5; ArrayIndex: 1; ArrayLocationInName: 22; Skip Register;
    Name => "LpQueuingEmPerBankReg[5]",
    RegMem => "Reg",
    Address => "146",
    Description => "EM bank configurations, see fields description",
    Width => "114", # Excel Formula: =calc_reg_width(E332:E334,F334)
    Type => "Config",
    AdditionalInfo => "PackArrayToBus",
    Comments => "EM Skip Reg",
    ArrayLength => "5",
    ArrayIndex => "1",
    LpQueuingEmActiveBanks1 => { #Structure Type: RegField; ArrayLength: 5; ArrayIndex: 1; ArrayLocationInName: 23;
      Name => "LpQueuingEmActiveBanks[n]",
      RegMem => "RegField",
      Description => "0 - EM bank is inactive
1 - EM bank is active",
      Width => "1",
      Position => "0", # Excel Formula: =calc_position(F331,E332,TRUE)
      Type => "Config",
      UsedBy => "LpQueuingEm",
      DefaultValue => "d1",
    },
    LpQueuingEmHashKey1 => { #Structure Type: RegField; ArrayLength: 5; ArrayIndex: 1; ArrayLocationInName: 19;
      Name => "LpQueuingEmHashKey[n]",
      RegMem => "RegField",
      Description => "Seed for the EM hash",
      Width => "112",
      Position => "112:1", # Excel Formula: =calc_position(F332,E333)
      Type => "Config",
      UsedBy => "LpQueuingEm",
      DefaultValue => "h0",
    },
    LpQueuingEmUsePrimitiveCrc1 => { #Structure Type: RegField; ArrayLength: 5; ArrayIndex: 1; ArrayLocationInName: 27;
      Name => "LpQueuingEmUsePrimitiveCrc[n]",
      RegMem => "RegField",
      Description => "0 - use non primitive polynom for the hash CRC
1 - use primitive polynom for the hash CRC",
      Width => "1",
      Position => "113", # Excel Formula: =calc_position(F333,E334)
      Type => "Config",
      UsedBy => "LpQueuingEm",
      DefaultValue => "h0",
    },
  },
  LpQueuingEmPerBankReg2 => { #Structure Type: Reg; ArrayLength: 5; ArrayIndex: 2; ArrayLocationInName: 22; Skip Register;
    Name => "LpQueuingEmPerBankReg[5]",
    RegMem => "Reg",
    Address => "147",
    Description => "EM bank configurations, see fields description",
    Width => "114", # Excel Formula: =calc_reg_width(E332:E334,F334)
    Type => "Config",
    AdditionalInfo => "PackArrayToBus",
    Comments => "EM Skip Reg",
    ArrayLength => "5",
    ArrayIndex => "2",
    LpQueuingEmActiveBanks2 => { #Structure Type: RegField; ArrayLength: 5; ArrayIndex: 2; ArrayLocationInName: 23;
      Name => "LpQueuingEmActiveBanks[n]",
      RegMem => "RegField",
      Description => "0 - EM bank is inactive
1 - EM bank is active",
      Width => "1",
      Position => "0", # Excel Formula: =calc_position(F331,E332,TRUE)
      Type => "Config",
      UsedBy => "LpQueuingEm",
      DefaultValue => "d1",
    },
    LpQueuingEmHashKey2 => { #Structure Type: RegField; ArrayLength: 5; ArrayIndex: 2; ArrayLocationInName: 19;
      Name => "LpQueuingEmHashKey[n]",
      RegMem => "RegField",
      Description => "Seed for the EM hash",
      Width => "112",
      Position => "112:1", # Excel Formula: =calc_position(F332,E333)
      Type => "Config",
      UsedBy => "LpQueuingEm",
      DefaultValue => "h0",
    },
    LpQueuingEmUsePrimitiveCrc2 => { #Structure Type: RegField; ArrayLength: 5; ArrayIndex: 2; ArrayLocationInName: 27;
      Name => "LpQueuingEmUsePrimitiveCrc[n]",
      RegMem => "RegField",
      Description => "0 - use non primitive polynom for the hash CRC
1 - use primitive polynom for the hash CRC",
      Width => "1",
      Position => "113", # Excel Formula: =calc_position(F333,E334)
      Type => "Config",
      UsedBy => "LpQueuingEm",
      DefaultValue => "h0",
    },
  },
  LpQueuingEmPerBankReg3 => { #Structure Type: Reg; ArrayLength: 5; ArrayIndex: 3; ArrayLocationInName: 22; Skip Register;
    Name => "LpQueuingEmPerBankReg[5]",
    RegMem => "Reg",
    Address => "148",
    Description => "EM bank configurations, see fields description",
    Width => "114", # Excel Formula: =calc_reg_width(E332:E334,F334)
    Type => "Config",
    AdditionalInfo => "PackArrayToBus",
    Comments => "EM Skip Reg",
    ArrayLength => "5",
    ArrayIndex => "3",
    LpQueuingEmActiveBanks3 => { #Structure Type: RegField; ArrayLength: 5; ArrayIndex: 3; ArrayLocationInName: 23;
      Name => "LpQueuingEmActiveBanks[n]",
      RegMem => "RegField",
      Description => "0 - EM bank is inactive
1 - EM bank is active",
      Width => "1",
      Position => "0", # Excel Formula: =calc_position(F331,E332,TRUE)
      Type => "Config",
      UsedBy => "LpQueuingEm",
      DefaultValue => "d1",
    },
    LpQueuingEmHashKey3 => { #Structure Type: RegField; ArrayLength: 5; ArrayIndex: 3; ArrayLocationInName: 19;
      Name => "LpQueuingEmHashKey[n]",
      RegMem => "RegField",
      Description => "Seed for the EM hash",
      Width => "112",
      Position => "112:1", # Excel Formula: =calc_position(F332,E333)
      Type => "Config",
      UsedBy => "LpQueuingEm",
      DefaultValue => "h0",
    },
    LpQueuingEmUsePrimitiveCrc3 => { #Structure Type: RegField; ArrayLength: 5; ArrayIndex: 3; ArrayLocationInName: 27;
      Name => "LpQueuingEmUsePrimitiveCrc[n]",
      RegMem => "RegField",
      Description => "0 - use non primitive polynom for the hash CRC
1 - use primitive polynom for the hash CRC",
      Width => "1",
      Position => "113", # Excel Formula: =calc_position(F333,E334)
      Type => "Config",
      UsedBy => "LpQueuingEm",
      DefaultValue => "h0",
    },
  },
  LpQueuingEmPerBankReg4 => { #Structure Type: Reg; ArrayLength: 5; ArrayIndex: 4; ArrayLocationInName: 22; Skip Register;
    Name => "LpQueuingEmPerBankReg[5]",
    RegMem => "Reg",
    Address => "149",
    Description => "EM bank configurations, see fields description",
    Width => "114", # Excel Formula: =calc_reg_width(E332:E334,F334)
    Type => "Config",
    AdditionalInfo => "PackArrayToBus",
    Comments => "EM Skip Reg",
    ArrayLength => "5",
    ArrayIndex => "4",
    LpQueuingEmActiveBanks4 => { #Structure Type: RegField; ArrayLength: 5; ArrayIndex: 4; ArrayLocationInName: 23;
      Name => "LpQueuingEmActiveBanks[n]",
      RegMem => "RegField",
      Description => "0 - EM bank is inactive
1 - EM bank is active",
      Width => "1",
      Position => "0", # Excel Formula: =calc_position(F331,E332,TRUE)
      Type => "Config",
      UsedBy => "LpQueuingEm",
      DefaultValue => "d1",
    },
    LpQueuingEmHashKey4 => { #Structure Type: RegField; ArrayLength: 5; ArrayIndex: 4; ArrayLocationInName: 19;
      Name => "LpQueuingEmHashKey[n]",
      RegMem => "RegField",
      Description => "Seed for the EM hash",
      Width => "112",
      Position => "112:1", # Excel Formula: =calc_position(F332,E333)
      Type => "Config",
      UsedBy => "LpQueuingEm",
      DefaultValue => "h0",
    },
    LpQueuingEmUsePrimitiveCrc4 => { #Structure Type: RegField; ArrayLength: 5; ArrayIndex: 4; ArrayLocationInName: 27;
      Name => "LpQueuingEmUsePrimitiveCrc[n]",
      RegMem => "RegField",
      Description => "0 - use non primitive polynom for the hash CRC
1 - use primitive polynom for the hash CRC",
      Width => "1",
      Position => "113", # Excel Formula: =calc_position(F333,E334)
      Type => "Config",
      UsedBy => "LpQueuingEm",
      DefaultValue => "h0",
    },
  },
  LpQueuingEmPerEmReg0 => { #Structure Type: Reg; ArrayLength: 1; ArrayIndex: 0; ArrayLocationInName: 20; Skip Register;
    Name => "LpQueuingEmPerEmReg[1]",
    RegMem => "Reg",
    Address => "14A", # Excel Formula: =calc_reg_address(C331,A331,G331)
    Description => "EM configurations, see fields description",
    Width => "33", # Excel Formula: =calc_reg_width(E336:E338,F338)
    Type => "Config",
    AdditionalInfo => "PackArrayToBus",
    Comments => "EM Skip Reg",
    ArrayLength => "1",
    ArrayIndex => "0",
    LpQueuingEmKeyWidth0 => { #Structure Type: RegField; ArrayLength: 1; ArrayIndex: 0; ArrayLocationInName: 20;
      Name => "LpQueuingEmKeyWidth[n]",
      RegMem => "RegField",
      Description => "Map the 4 key LSBs to key width",
      Width => "16",
      Position => "15:0", # Excel Formula: =calc_position(F335,E336,TRUE)
      Type => "Config",
      UsedBy => "LpQueuingEm",
      DefaultValue => "h0",
    },
    LpQueuingEmAutoBubbleReq0 => { #Structure Type: RegField; ArrayLength: 1; ArrayIndex: 0; ArrayLocationInName: 25;
      Name => "LpQueuingEmAutoBubbleReq[n]",
      RegMem => "RegField",
      Description => "Generate bubble request to the pipe automatically",
      Width => "1",
      Position => "16", # Excel Formula: =calc_position(F336,E337)
      Type => "Config",
      UsedBy => "LpQueuingEm",
      DefaultValue => "h0",
    },
    LpQueuingEmBubbleReqThreshold0 => { #Structure Type: RegField; ArrayLength: 1; ArrayIndex: 0; ArrayLocationInName: 30;
      Name => "LpQueuingEmBubbleReqThreshold[n]",
      RegMem => "RegField",
      Description => "Number of consecutive pipe lookups before generating CPU bubble request",
      Width => "16",
      Position => "32:17", # Excel Formula: =calc_position(F337,E338)
      Type => "Config",
      UsedBy => "LpQueuingEm",
      DefaultValue => "h0",
    },
  },
  LpQueuingEmCamWmMaxReg0 => { #Structure Type: Reg; ArrayLength: 1; ArrayIndex: 0; ArrayLocationInName: 23; Skip Register;
    Name => "LpQueuingEmCamWmMaxReg[1]",
    RegMem => "Reg",
    Address => "14B", # Excel Formula: =calc_reg_address(C335,A335,G335)
    Description => "EM debug indications, see fields description",
    Width => "8", # Excel Formula: =calc_reg_width(E340:E340,F340)
    Type => "ReadOnly",
    AdditionalInfo => "PackArrayToBus",
    Comments => "EM Skip Reg",
    ArrayLength => "1",
    ArrayIndex => "0",
    LpQueuingEmCamWmMax0 => { #Structure Type: RegField; ArrayLength: 1; ArrayIndex: 0; ArrayLocationInName: 20;
      Name => "LpQueuingEmCamWmMax[n]",
      RegMem => "RegField",
      Description => "CAM max watermark",
      Width => "8",
      Position => "7:0", # Excel Formula: =calc_position(F339,E340,TRUE)
      Type => "MaxWmk",
      UsedBy => "emdb",
      AdditionalInfo => "CounterIncrWidth=1",
    },
  },
  LpQueuingEmAccessRegister0 => { #Structure Type: Reg; ArrayLength: 1; ArrayIndex: 0; ArrayLocationInName: 26; Skip Register;
    Name => "LpQueuingEmAccessRegister[1]",
    RegMem => "Reg",
    Address => "14C", # Excel Formula: =calc_reg_address(C339,A339,G339)
    Description => "EM indirect access configurations",
    Width => "97", # Excel Formula: =calc_reg_width(E342:E342,F342)
    Type => "External",
    UsedBy => "em_top",
    Comments => "EM Skip Reg",
    ArrayLength => "1",
    ArrayIndex => "0",
    LpQueuingEmAccessReg0 => { #Structure Type: RegField; ArrayLength: 1; ArrayIndex: 0; ArrayLocationInName: 21;
      Name => "LpQueuingEmAccessReg[n]",
      RegMem => "RegField",
      Description => "See EM spec for register usage",
      Width => "97",
      Position => "96:0", # Excel Formula: =calc_position(F341,E342,TRUE)
      Type => "External",
    },
  },
  LpQueuingEmResponseRegister0 => { #Structure Type: Reg; ArrayLength: 1; ArrayIndex: 0; ArrayLocationInName: 28; Skip Register;
    Name => "LpQueuingEmResponseRegister[1]",
    RegMem => "Reg",
    Address => "14D", # Excel Formula: =calc_reg_address(C341,A341,G341)
    Description => "EM indirect access data",
    Width => "97", # Excel Formula: =calc_reg_width(E344:E345,F345)
    Type => "ReadOnly",
    Comments => "EM Skip Reg",
    ArrayLength => "1",
    ArrayIndex => "0",
    LpQueuingEmResponseValid0 => { #Structure Type: RegField; ArrayLength: 1; ArrayIndex: 0; ArrayLocationInName: 25;
      Name => "LpQueuingEmResponseValid[n]",
      RegMem => "RegField",
      Description => "EM indirect access data is valid",
      Width => "1",
      Position => "0", # Excel Formula: =calc_position(F343,E344,TRUE)
      Type => "Event",
      UsedBy => "emdb",
    },
    LpQueuingEmResponseReg0 => { #Structure Type: RegField; ArrayLength: 1; ArrayIndex: 0; ArrayLocationInName: 23;
      Name => "LpQueuingEmResponseReg[n]",
      RegMem => "RegField",
      Description => "EM indirect access data, see EM spec for register usage",
      Width => "96",
      Position => "96:1", # Excel Formula: =calc_position(F344,E345)
      Type => "Capture",
      UsedBy => "emdb",
    },
  },
  LpQueuingEmCam => { #Structure Type: Mem; Skip Register;
    Name => "LpQueuingEmCam",
    RegMem => "Mem",
    Address => "5100000", # Excel Formula: =calc_mem_address(C329,A329,G346,L346)
    Description => "EM fallback CAM",
    Width => "76", # Excel Formula: =calc_mem_width(E347:E349,"None",F349,-1)
    Type => "Dynamic",
    UsedBy => "LpQueuingEm",
    MemEntries => "32",
    MemWrapper => "TCAM",
    MemProtect => "None",
    AdditionalInfo => "NumOfKeys=1,RegTcamPayloadWidth=19,CAM=Enabled,CpuReadAccess=Enabled,CpuWriteAccess=Enabled,NumCamLookupClients=2",
    Comments => "EM Skip Reg",
    MemLogicalWidth => "76",
    LpQueuingEmCam_key => { #Structure Type: MemField;
      Name => "LpQueuingEmCam_key",
      RegMem => "MemField",
      Description => "CAM key",
      Width => "56",
      Position => "55:0", # Excel Formula: =calc_position(F346,E347,TRUE)
    },
    LpQueuingEmCam_payload => { #Structure Type: MemField;
      Name => "LpQueuingEmCam_payload",
      RegMem => "MemField",
      Description => "CAM payload",
      Width => "19",
      Position => "74:56", # Excel Formula: =calc_position(F347,E348)
    },
    LpQueuingEmCam_valid => { #Structure Type: MemField;
      Name => "LpQueuingEmCam_valid",
      RegMem => "MemField",
      Description => "CAM entry is valid",
      Width => "1",
      Position => "75", # Excel Formula: =calc_position(F348,E349)
    },
  },
  ResolutionStage1EmVerifier0 => { #Structure Type: Mem; ArrayLength: 4; ArrayIndex: 0; ArrayLocationInName: 27; Skip Register;
    Name => "ResolutionStage1EmVerifier[4]",
    RegMem => "Mem",
    Address => "5200000", # Excel Formula: =calc_mem_address(C346,A346,G350,L350)
    Description => "Holds the verifier and the payload of the EM entry",
    Width => "54", # Excel Formula: =calc_mem_width(E351:E351,M350,F351,-1)
    Type => "Dynamic",
    UsedBy => "ResolutionStage1Em",
    MemEntries => "8192",
    MemWrapper => "2R1W Slow Write",
    MemProtect => "ExtECC",
    AdditionalInfo => "PackArrayToBus=Enabled,UseHardReset=1,SampleReadBeforeProt=2,SamplePhysicalMem=1,CpuReadAccess=Enabled,CpuWriteAccess=Enabled,WriteActivityFactor=0,ReadActivityFactor=100,DisableSameAddressErr=Enabled,EnableNonCpuRdWrSameAddress=Enabled,PortErrPropagate=Disabled",
    Comments => "EM Skip Reg",
    ArrayLength => "4",
    ArrayIndex => "0",
    MemLogicalWidth => "54",
    ResolutionStage1EmVerifier0Data => { #Structure Type: MemField; ArrayLength: 4; ArrayIndex: 0; ArrayLocationInName: 27;
      Name => "ResolutionStage1EmVerifier[n]Data",
      RegMem => "MemField",
      Description => "Verifier and payload data",
      Width => "54",
      Position => "53:0", # Excel Formula: =calc_position(F350,E351,TRUE)
    },
  },
  ResolutionStage1EmVerifier1 => { #Structure Type: Mem; ArrayLength: 4; ArrayIndex: 1; ArrayLocationInName: 27; Skip Register;
    Name => "ResolutionStage1EmVerifier[4]",
    RegMem => "Mem",
    Address => "5300000",
    Description => "Holds the verifier and the payload of the EM entry",
    Width => "54", # Excel Formula: =calc_mem_width(E351:E351,M350,F351,-1)
    Type => "Dynamic",
    UsedBy => "ResolutionStage1Em",
    MemEntries => "8192",
    MemWrapper => "2R1W Slow Write",
    MemProtect => "ExtECC",
    AdditionalInfo => "PackArrayToBus=Enabled,UseHardReset=1,SampleReadBeforeProt=2,SamplePhysicalMem=1,CpuReadAccess=Enabled,CpuWriteAccess=Enabled,WriteActivityFactor=0,ReadActivityFactor=100,DisableSameAddressErr=Enabled,EnableNonCpuRdWrSameAddress=Enabled,PortErrPropagate=Disabled",
    Comments => "EM Skip Reg",
    ArrayLength => "4",
    ArrayIndex => "1",
    MemLogicalWidth => "54",
    ResolutionStage1EmVerifier1Data => { #Structure Type: MemField; ArrayLength: 4; ArrayIndex: 1; ArrayLocationInName: 27;
      Name => "ResolutionStage1EmVerifier[n]Data",
      RegMem => "MemField",
      Description => "Verifier and payload data",
      Width => "54",
      Position => "53:0", # Excel Formula: =calc_position(F350,E351,TRUE)
    },
  },
  ResolutionStage1EmVerifier2 => { #Structure Type: Mem; ArrayLength: 4; ArrayIndex: 2; ArrayLocationInName: 27; Skip Register;
    Name => "ResolutionStage1EmVerifier[4]",
    RegMem => "Mem",
    Address => "5400000",
    Description => "Holds the verifier and the payload of the EM entry",
    Width => "54", # Excel Formula: =calc_mem_width(E351:E351,M350,F351,-1)
    Type => "Dynamic",
    UsedBy => "ResolutionStage1Em",
    MemEntries => "8192",
    MemWrapper => "2R1W Slow Write",
    MemProtect => "ExtECC",
    AdditionalInfo => "PackArrayToBus=Enabled,UseHardReset=1,SampleReadBeforeProt=2,SamplePhysicalMem=1,CpuReadAccess=Enabled,CpuWriteAccess=Enabled,WriteActivityFactor=0,ReadActivityFactor=100,DisableSameAddressErr=Enabled,EnableNonCpuRdWrSameAddress=Enabled,PortErrPropagate=Disabled",
    Comments => "EM Skip Reg",
    ArrayLength => "4",
    ArrayIndex => "2",
    MemLogicalWidth => "54",
    ResolutionStage1EmVerifier2Data => { #Structure Type: MemField; ArrayLength: 4; ArrayIndex: 2; ArrayLocationInName: 27;
      Name => "ResolutionStage1EmVerifier[n]Data",
      RegMem => "MemField",
      Description => "Verifier and payload data",
      Width => "54",
      Position => "53:0", # Excel Formula: =calc_position(F350,E351,TRUE)
    },
  },
  ResolutionStage1EmVerifier3 => { #Structure Type: Mem; ArrayLength: 4; ArrayIndex: 3; ArrayLocationInName: 27; Skip Register;
    Name => "ResolutionStage1EmVerifier[4]",
    RegMem => "Mem",
    Address => "5500000",
    Description => "Holds the verifier and the payload of the EM entry",
    Width => "54", # Excel Formula: =calc_mem_width(E351:E351,M350,F351,-1)
    Type => "Dynamic",
    UsedBy => "ResolutionStage1Em",
    MemEntries => "8192",
    MemWrapper => "2R1W Slow Write",
    MemProtect => "ExtECC",
    AdditionalInfo => "PackArrayToBus=Enabled,UseHardReset=1,SampleReadBeforeProt=2,SamplePhysicalMem=1,CpuReadAccess=Enabled,CpuWriteAccess=Enabled,WriteActivityFactor=0,ReadActivityFactor=100,DisableSameAddressErr=Enabled,EnableNonCpuRdWrSameAddress=Enabled,PortErrPropagate=Disabled",
    Comments => "EM Skip Reg",
    ArrayLength => "4",
    ArrayIndex => "3",
    MemLogicalWidth => "54",
    ResolutionStage1EmVerifier3Data => { #Structure Type: MemField; ArrayLength: 4; ArrayIndex: 3; ArrayLocationInName: 27;
      Name => "ResolutionStage1EmVerifier[n]Data",
      RegMem => "MemField",
      Description => "Verifier and payload data",
      Width => "54",
      Position => "53:0", # Excel Formula: =calc_position(F350,E351,TRUE)
    },
  },
  ResolutionStage1EmPerBankReg0 => { #Structure Type: Reg; ArrayLength: 4; ArrayIndex: 0; ArrayLocationInName: 29; Skip Register;
    Name => "ResolutionStage1EmPerBankReg[4]",
    RegMem => "Reg",
    Address => "14E", # Excel Formula: =calc_reg_address(C343,A343,G343)
    Description => "EM bank configurations, see fields description",
    Width => "50", # Excel Formula: =calc_reg_width(E353:E355,F355)
    Type => "Config",
    AdditionalInfo => "PackArrayToBus",
    Comments => "EM Skip Reg",
    ArrayLength => "4",
    ArrayIndex => "0",
    ResolutionStage1EmActiveBanks0 => { #Structure Type: RegField; ArrayLength: 4; ArrayIndex: 0; ArrayLocationInName: 30;
      Name => "ResolutionStage1EmActiveBanks[n]",
      RegMem => "RegField",
      Description => "0 - EM bank is inactive
1 - EM bank is active",
      Width => "1",
      Position => "0", # Excel Formula: =calc_position(F352,E353,TRUE)
      Type => "Config",
      UsedBy => "ResolutionStage1Em",
      DefaultValue => "d1",
    },
    ResolutionStage1EmHashKey0 => { #Structure Type: RegField; ArrayLength: 4; ArrayIndex: 0; ArrayLocationInName: 26;
      Name => "ResolutionStage1EmHashKey[n]",
      RegMem => "RegField",
      Description => "Seed for the EM hash",
      Width => "48",
      Position => "48:1", # Excel Formula: =calc_position(F353,E354)
      Type => "Config",
      UsedBy => "ResolutionStage1Em",
      DefaultValue => "h0",
    },
    ResolutionStage1EmUsePrimitiveCrc0 => { #Structure Type: RegField; ArrayLength: 4; ArrayIndex: 0; ArrayLocationInName: 34;
      Name => "ResolutionStage1EmUsePrimitiveCrc[n]",
      RegMem => "RegField",
      Description => "0 - use non primitive polynom for the hash CRC
1 - use primitive polynom for the hash CRC",
      Width => "1",
      Position => "49", # Excel Formula: =calc_position(F354,E355)
      Type => "Config",
      UsedBy => "ResolutionStage1Em",
      DefaultValue => "h0",
    },
  },
  ResolutionStage1EmPerBankReg1 => { #Structure Type: Reg; ArrayLength: 4; ArrayIndex: 1; ArrayLocationInName: 29; Skip Register;
    Name => "ResolutionStage1EmPerBankReg[4]",
    RegMem => "Reg",
    Address => "14F",
    Description => "EM bank configurations, see fields description",
    Width => "50", # Excel Formula: =calc_reg_width(E353:E355,F355)
    Type => "Config",
    AdditionalInfo => "PackArrayToBus",
    Comments => "EM Skip Reg",
    ArrayLength => "4",
    ArrayIndex => "1",
    ResolutionStage1EmActiveBanks1 => { #Structure Type: RegField; ArrayLength: 4; ArrayIndex: 1; ArrayLocationInName: 30;
      Name => "ResolutionStage1EmActiveBanks[n]",
      RegMem => "RegField",
      Description => "0 - EM bank is inactive
1 - EM bank is active",
      Width => "1",
      Position => "0", # Excel Formula: =calc_position(F352,E353,TRUE)
      Type => "Config",
      UsedBy => "ResolutionStage1Em",
      DefaultValue => "d1",
    },
    ResolutionStage1EmHashKey1 => { #Structure Type: RegField; ArrayLength: 4; ArrayIndex: 1; ArrayLocationInName: 26;
      Name => "ResolutionStage1EmHashKey[n]",
      RegMem => "RegField",
      Description => "Seed for the EM hash",
      Width => "48",
      Position => "48:1", # Excel Formula: =calc_position(F353,E354)
      Type => "Config",
      UsedBy => "ResolutionStage1Em",
      DefaultValue => "h0",
    },
    ResolutionStage1EmUsePrimitiveCrc1 => { #Structure Type: RegField; ArrayLength: 4; ArrayIndex: 1; ArrayLocationInName: 34;
      Name => "ResolutionStage1EmUsePrimitiveCrc[n]",
      RegMem => "RegField",
      Description => "0 - use non primitive polynom for the hash CRC
1 - use primitive polynom for the hash CRC",
      Width => "1",
      Position => "49", # Excel Formula: =calc_position(F354,E355)
      Type => "Config",
      UsedBy => "ResolutionStage1Em",
      DefaultValue => "h0",
    },
  },
  ResolutionStage1EmPerBankReg2 => { #Structure Type: Reg; ArrayLength: 4; ArrayIndex: 2; ArrayLocationInName: 29; Skip Register;
    Name => "ResolutionStage1EmPerBankReg[4]",
    RegMem => "Reg",
    Address => "150",
    Description => "EM bank configurations, see fields description",
    Width => "50", # Excel Formula: =calc_reg_width(E353:E355,F355)
    Type => "Config",
    AdditionalInfo => "PackArrayToBus",
    Comments => "EM Skip Reg",
    ArrayLength => "4",
    ArrayIndex => "2",
    ResolutionStage1EmActiveBanks2 => { #Structure Type: RegField; ArrayLength: 4; ArrayIndex: 2; ArrayLocationInName: 30;
      Name => "ResolutionStage1EmActiveBanks[n]",
      RegMem => "RegField",
      Description => "0 - EM bank is inactive
1 - EM bank is active",
      Width => "1",
      Position => "0", # Excel Formula: =calc_position(F352,E353,TRUE)
      Type => "Config",
      UsedBy => "ResolutionStage1Em",
      DefaultValue => "d1",
    },
    ResolutionStage1EmHashKey2 => { #Structure Type: RegField; ArrayLength: 4; ArrayIndex: 2; ArrayLocationInName: 26;
      Name => "ResolutionStage1EmHashKey[n]",
      RegMem => "RegField",
      Description => "Seed for the EM hash",
      Width => "48",
      Position => "48:1", # Excel Formula: =calc_position(F353,E354)
      Type => "Config",
      UsedBy => "ResolutionStage1Em",
      DefaultValue => "h0",
    },
    ResolutionStage1EmUsePrimitiveCrc2 => { #Structure Type: RegField; ArrayLength: 4; ArrayIndex: 2; ArrayLocationInName: 34;
      Name => "ResolutionStage1EmUsePrimitiveCrc[n]",
      RegMem => "RegField",
      Description => "0 - use non primitive polynom for the hash CRC
1 - use primitive polynom for the hash CRC",
      Width => "1",
      Position => "49", # Excel Formula: =calc_position(F354,E355)
      Type => "Config",
      UsedBy => "ResolutionStage1Em",
      DefaultValue => "h0",
    },
  },
  ResolutionStage1EmPerBankReg3 => { #Structure Type: Reg; ArrayLength: 4; ArrayIndex: 3; ArrayLocationInName: 29; Skip Register;
    Name => "ResolutionStage1EmPerBankReg[4]",
    RegMem => "Reg",
    Address => "151",
    Description => "EM bank configurations, see fields description",
    Width => "50", # Excel Formula: =calc_reg_width(E353:E355,F355)
    Type => "Config",
    AdditionalInfo => "PackArrayToBus",
    Comments => "EM Skip Reg",
    ArrayLength => "4",
    ArrayIndex => "3",
    ResolutionStage1EmActiveBanks3 => { #Structure Type: RegField; ArrayLength: 4; ArrayIndex: 3; ArrayLocationInName: 30;
      Name => "ResolutionStage1EmActiveBanks[n]",
      RegMem => "RegField",
      Description => "0 - EM bank is inactive
1 - EM bank is active",
      Width => "1",
      Position => "0", # Excel Formula: =calc_position(F352,E353,TRUE)
      Type => "Config",
      UsedBy => "ResolutionStage1Em",
      DefaultValue => "d1",
    },
    ResolutionStage1EmHashKey3 => { #Structure Type: RegField; ArrayLength: 4; ArrayIndex: 3; ArrayLocationInName: 26;
      Name => "ResolutionStage1EmHashKey[n]",
      RegMem => "RegField",
      Description => "Seed for the EM hash",
      Width => "48",
      Position => "48:1", # Excel Formula: =calc_position(F353,E354)
      Type => "Config",
      UsedBy => "ResolutionStage1Em",
      DefaultValue => "h0",
    },
    ResolutionStage1EmUsePrimitiveCrc3 => { #Structure Type: RegField; ArrayLength: 4; ArrayIndex: 3; ArrayLocationInName: 34;
      Name => "ResolutionStage1EmUsePrimitiveCrc[n]",
      RegMem => "RegField",
      Description => "0 - use non primitive polynom for the hash CRC
1 - use primitive polynom for the hash CRC",
      Width => "1",
      Position => "49", # Excel Formula: =calc_position(F354,E355)
      Type => "Config",
      UsedBy => "ResolutionStage1Em",
      DefaultValue => "h0",
    },
  },
  ResolutionStage1EmPerEmReg0 => { #Structure Type: Reg; ArrayLength: 1; ArrayIndex: 0; ArrayLocationInName: 27; Skip Register;
    Name => "ResolutionStage1EmPerEmReg[1]",
    RegMem => "Reg",
    Address => "152", # Excel Formula: =calc_reg_address(C352,A352,G352)
    Description => "EM configurations, see fields description",
    Width => "33", # Excel Formula: =calc_reg_width(E357:E359,F359)
    Type => "Config",
    AdditionalInfo => "PackArrayToBus",
    Comments => "EM Skip Reg",
    ArrayLength => "1",
    ArrayIndex => "0",
    ResolutionStage1EmKeyWidth0 => { #Structure Type: RegField; ArrayLength: 1; ArrayIndex: 0; ArrayLocationInName: 27;
      Name => "ResolutionStage1EmKeyWidth[n]",
      RegMem => "RegField",
      Description => "Map the 4 key LSBs to key width",
      Width => "16",
      Position => "15:0", # Excel Formula: =calc_position(F356,E357,TRUE)
      Type => "Config",
      UsedBy => "ResolutionStage1Em",
      DefaultValue => "h0",
    },
    ResolutionStage1EmAutoBubbleReq0 => { #Structure Type: RegField; ArrayLength: 1; ArrayIndex: 0; ArrayLocationInName: 32;
      Name => "ResolutionStage1EmAutoBubbleReq[n]",
      RegMem => "RegField",
      Description => "Generate bubble request to the pipe automatically",
      Width => "1",
      Position => "16", # Excel Formula: =calc_position(F357,E358)
      Type => "Config",
      UsedBy => "ResolutionStage1Em",
      DefaultValue => "h0",
    },
    ResolutionStage1EmBubbleReqThreshold0 => { #Structure Type: RegField; ArrayLength: 1; ArrayIndex: 0; ArrayLocationInName: 37;
      Name => "ResolutionStage1EmBubbleReqThreshold[n]",
      RegMem => "RegField",
      Description => "Number of consecutive pipe lookups before generating CPU bubble request",
      Width => "16",
      Position => "32:17", # Excel Formula: =calc_position(F358,E359)
      Type => "Config",
      UsedBy => "ResolutionStage1Em",
      DefaultValue => "h0",
    },
  },
  ResolutionStage1EmCamWmMaxReg0 => { #Structure Type: Reg; ArrayLength: 1; ArrayIndex: 0; ArrayLocationInName: 30; Skip Register;
    Name => "ResolutionStage1EmCamWmMaxReg[1]",
    RegMem => "Reg",
    Address => "153", # Excel Formula: =calc_reg_address(C356,A356,G356)
    Description => "EM debug indications, see fields description",
    Width => "8", # Excel Formula: =calc_reg_width(E361:E361,F361)
    Type => "ReadOnly",
    AdditionalInfo => "PackArrayToBus",
    Comments => "EM Skip Reg",
    ArrayLength => "1",
    ArrayIndex => "0",
    ResolutionStage1EmCamWmMax0 => { #Structure Type: RegField; ArrayLength: 1; ArrayIndex: 0; ArrayLocationInName: 27;
      Name => "ResolutionStage1EmCamWmMax[n]",
      RegMem => "RegField",
      Description => "CAM max watermark",
      Width => "8",
      Position => "7:0", # Excel Formula: =calc_position(F360,E361,TRUE)
      Type => "MaxWmk",
      UsedBy => "emdb",
      AdditionalInfo => "CounterIncrWidth=1",
    },
  },
  ResolutionStage1EmAccessRegister0 => { #Structure Type: Reg; ArrayLength: 1; ArrayIndex: 0; ArrayLocationInName: 33; Skip Register;
    Name => "ResolutionStage1EmAccessRegister[1]",
    RegMem => "Reg",
    Address => "154", # Excel Formula: =calc_reg_address(C360,A360,G360)
    Description => "EM indirect access configurations",
    Width => "81", # Excel Formula: =calc_reg_width(E363:E363,F363)
    Type => "External",
    UsedBy => "em_top",
    Comments => "EM Skip Reg",
    ArrayLength => "1",
    ArrayIndex => "0",
    ResolutionStage1EmAccessReg0 => { #Structure Type: RegField; ArrayLength: 1; ArrayIndex: 0; ArrayLocationInName: 28;
      Name => "ResolutionStage1EmAccessReg[n]",
      RegMem => "RegField",
      Description => "See EM spec for register usage",
      Width => "81",
      Position => "80:0", # Excel Formula: =calc_position(F362,E363,TRUE)
      Type => "External",
    },
  },
  ResolutionStage1EmResponseRegister0 => { #Structure Type: Reg; ArrayLength: 1; ArrayIndex: 0; ArrayLocationInName: 35; Skip Register;
    Name => "ResolutionStage1EmResponseRegister[1]",
    RegMem => "Reg",
    Address => "155", # Excel Formula: =calc_reg_address(C362,A362,G362)
    Description => "EM indirect access data",
    Width => "81", # Excel Formula: =calc_reg_width(E365:E366,F366)
    Type => "ReadOnly",
    Comments => "EM Skip Reg",
    ArrayLength => "1",
    ArrayIndex => "0",
    ResolutionStage1EmResponseValid0 => { #Structure Type: RegField; ArrayLength: 1; ArrayIndex: 0; ArrayLocationInName: 32;
      Name => "ResolutionStage1EmResponseValid[n]",
      RegMem => "RegField",
      Description => "EM indirect access data is valid",
      Width => "1",
      Position => "0", # Excel Formula: =calc_position(F364,E365,TRUE)
      Type => "Event",
      UsedBy => "emdb",
    },
    ResolutionStage1EmResponseReg0 => { #Structure Type: RegField; ArrayLength: 1; ArrayIndex: 0; ArrayLocationInName: 30;
      Name => "ResolutionStage1EmResponseReg[n]",
      RegMem => "RegField",
      Description => "EM indirect access data, see EM spec for register usage",
      Width => "80",
      Position => "80:1", # Excel Formula: =calc_position(F365,E366)
      Type => "Capture",
      UsedBy => "emdb",
    },
  },
  ResolutionStage1EmCam => { #Structure Type: Mem; Skip Register;
    Name => "ResolutionStage1EmCam",
    RegMem => "Mem",
    Address => "5600000", # Excel Formula: =calc_mem_address(C350,A350,G367,L367)
    Description => "EM fallback CAM",
    Width => "60", # Excel Formula: =calc_mem_width(E368:E370,"None",F370,-1)
    Type => "Dynamic",
    UsedBy => "ResolutionStage1Em",
    MemEntries => "32",
    MemWrapper => "TCAM",
    MemProtect => "None",
    AdditionalInfo => "NumOfKeys=1,RegTcamPayloadWidth=35,CAM=Enabled,CpuReadAccess=Enabled,CpuWriteAccess=Enabled,NumCamLookupClients=2",
    Comments => "EM Skip Reg",
    MemLogicalWidth => "60",
    ResolutionStage1EmCam_key => { #Structure Type: MemField;
      Name => "ResolutionStage1EmCam_key",
      RegMem => "MemField",
      Description => "CAM key",
      Width => "24",
      Position => "23:0", # Excel Formula: =calc_position(F367,E368,TRUE)
    },
    ResolutionStage1EmCam_payload => { #Structure Type: MemField;
      Name => "ResolutionStage1EmCam_payload",
      RegMem => "MemField",
      Description => "CAM payload",
      Width => "35",
      Position => "58:24", # Excel Formula: =calc_position(F368,E369)
    },
    ResolutionStage1EmCam_valid => { #Structure Type: MemField;
      Name => "ResolutionStage1EmCam_valid",
      RegMem => "MemField",
      Description => "CAM entry is valid",
      Width => "1",
      Position => "59", # Excel Formula: =calc_position(F369,E370)
    },
  },
  ResolutionStage2EmVerifier0 => { #Structure Type: Mem; ArrayLength: 4; ArrayIndex: 0; ArrayLocationInName: 27; Skip Register;
    Name => "ResolutionStage2EmVerifier[4]",
    RegMem => "Mem",
    Address => "5700000", # Excel Formula: =calc_mem_address(C367,A367,G371,L371)
    Description => "Holds the verifier and the payload of the EM entry",
    Width => "54", # Excel Formula: =calc_mem_width(E372:E372,M371,F372,-1)
    Type => "Dynamic",
    UsedBy => "ResolutionStage2Em",
    MemEntries => "8192",
    MemWrapper => "2R1W Slow Write",
    MemProtect => "ExtECC",
    AdditionalInfo => "PackArrayToBus=Enabled,UseHardReset=1,SampleReadBeforeProt=2,SamplePhysicalMem=1,CpuReadAccess=Enabled,CpuWriteAccess=Enabled,WriteActivityFactor=0,ReadActivityFactor=100,DisableSameAddressErr=Enabled,EnableNonCpuRdWrSameAddress=Enabled,PortErrPropagate=Disabled",
    Comments => "EM Skip Reg",
    ArrayLength => "4",
    ArrayIndex => "0",
    MemLogicalWidth => "54",
    ResolutionStage2EmVerifier0Data => { #Structure Type: MemField; ArrayLength: 4; ArrayIndex: 0; ArrayLocationInName: 27;
      Name => "ResolutionStage2EmVerifier[n]Data",
      RegMem => "MemField",
      Description => "Verifier and payload data",
      Width => "54",
      Position => "53:0", # Excel Formula: =calc_position(F371,E372,TRUE)
    },
  },
  ResolutionStage2EmVerifier1 => { #Structure Type: Mem; ArrayLength: 4; ArrayIndex: 1; ArrayLocationInName: 27; Skip Register;
    Name => "ResolutionStage2EmVerifier[4]",
    RegMem => "Mem",
    Address => "5800000",
    Description => "Holds the verifier and the payload of the EM entry",
    Width => "54", # Excel Formula: =calc_mem_width(E372:E372,M371,F372,-1)
    Type => "Dynamic",
    UsedBy => "ResolutionStage2Em",
    MemEntries => "8192",
    MemWrapper => "2R1W Slow Write",
    MemProtect => "ExtECC",
    AdditionalInfo => "PackArrayToBus=Enabled,UseHardReset=1,SampleReadBeforeProt=2,SamplePhysicalMem=1,CpuReadAccess=Enabled,CpuWriteAccess=Enabled,WriteActivityFactor=0,ReadActivityFactor=100,DisableSameAddressErr=Enabled,EnableNonCpuRdWrSameAddress=Enabled,PortErrPropagate=Disabled",
    Comments => "EM Skip Reg",
    ArrayLength => "4",
    ArrayIndex => "1",
    MemLogicalWidth => "54",
    ResolutionStage2EmVerifier1Data => { #Structure Type: MemField; ArrayLength: 4; ArrayIndex: 1; ArrayLocationInName: 27;
      Name => "ResolutionStage2EmVerifier[n]Data",
      RegMem => "MemField",
      Description => "Verifier and payload data",
      Width => "54",
      Position => "53:0", # Excel Formula: =calc_position(F371,E372,TRUE)
    },
  },
  ResolutionStage2EmVerifier2 => { #Structure Type: Mem; ArrayLength: 4; ArrayIndex: 2; ArrayLocationInName: 27; Skip Register;
    Name => "ResolutionStage2EmVerifier[4]",
    RegMem => "Mem",
    Address => "5900000",
    Description => "Holds the verifier and the payload of the EM entry",
    Width => "54", # Excel Formula: =calc_mem_width(E372:E372,M371,F372,-1)
    Type => "Dynamic",
    UsedBy => "ResolutionStage2Em",
    MemEntries => "8192",
    MemWrapper => "2R1W Slow Write",
    MemProtect => "ExtECC",
    AdditionalInfo => "PackArrayToBus=Enabled,UseHardReset=1,SampleReadBeforeProt=2,SamplePhysicalMem=1,CpuReadAccess=Enabled,CpuWriteAccess=Enabled,WriteActivityFactor=0,ReadActivityFactor=100,DisableSameAddressErr=Enabled,EnableNonCpuRdWrSameAddress=Enabled,PortErrPropagate=Disabled",
    Comments => "EM Skip Reg",
    ArrayLength => "4",
    ArrayIndex => "2",
    MemLogicalWidth => "54",
    ResolutionStage2EmVerifier2Data => { #Structure Type: MemField; ArrayLength: 4; ArrayIndex: 2; ArrayLocationInName: 27;
      Name => "ResolutionStage2EmVerifier[n]Data",
      RegMem => "MemField",
      Description => "Verifier and payload data",
      Width => "54",
      Position => "53:0", # Excel Formula: =calc_position(F371,E372,TRUE)
    },
  },
  ResolutionStage2EmVerifier3 => { #Structure Type: Mem; ArrayLength: 4; ArrayIndex: 3; ArrayLocationInName: 27; Skip Register;
    Name => "ResolutionStage2EmVerifier[4]",
    RegMem => "Mem",
    Address => "5A00000",
    Description => "Holds the verifier and the payload of the EM entry",
    Width => "54", # Excel Formula: =calc_mem_width(E372:E372,M371,F372,-1)
    Type => "Dynamic",
    UsedBy => "ResolutionStage2Em",
    MemEntries => "8192",
    MemWrapper => "2R1W Slow Write",
    MemProtect => "ExtECC",
    AdditionalInfo => "PackArrayToBus=Enabled,UseHardReset=1,SampleReadBeforeProt=2,SamplePhysicalMem=1,CpuReadAccess=Enabled,CpuWriteAccess=Enabled,WriteActivityFactor=0,ReadActivityFactor=100,DisableSameAddressErr=Enabled,EnableNonCpuRdWrSameAddress=Enabled,PortErrPropagate=Disabled",
    Comments => "EM Skip Reg",
    ArrayLength => "4",
    ArrayIndex => "3",
    MemLogicalWidth => "54",
    ResolutionStage2EmVerifier3Data => { #Structure Type: MemField; ArrayLength: 4; ArrayIndex: 3; ArrayLocationInName: 27;
      Name => "ResolutionStage2EmVerifier[n]Data",
      RegMem => "MemField",
      Description => "Verifier and payload data",
      Width => "54",
      Position => "53:0", # Excel Formula: =calc_position(F371,E372,TRUE)
    },
  },
  ResolutionStage2EmPerBankReg0 => { #Structure Type: Reg; ArrayLength: 4; ArrayIndex: 0; ArrayLocationInName: 29; Skip Register;
    Name => "ResolutionStage2EmPerBankReg[4]",
    RegMem => "Reg",
    Address => "156", # Excel Formula: =calc_reg_address(C364,A364,G364)
    Description => "EM bank configurations, see fields description",
    Width => "50", # Excel Formula: =calc_reg_width(E374:E376,F376)
    Type => "Config",
    AdditionalInfo => "PackArrayToBus",
    Comments => "EM Skip Reg",
    ArrayLength => "4",
    ArrayIndex => "0",
    ResolutionStage2EmActiveBanks0 => { #Structure Type: RegField; ArrayLength: 4; ArrayIndex: 0; ArrayLocationInName: 30;
      Name => "ResolutionStage2EmActiveBanks[n]",
      RegMem => "RegField",
      Description => "0 - EM bank is inactive
1 - EM bank is active",
      Width => "1",
      Position => "0", # Excel Formula: =calc_position(F373,E374,TRUE)
      Type => "Config",
      UsedBy => "ResolutionStage2Em",
      DefaultValue => "d1",
    },
    ResolutionStage2EmHashKey0 => { #Structure Type: RegField; ArrayLength: 4; ArrayIndex: 0; ArrayLocationInName: 26;
      Name => "ResolutionStage2EmHashKey[n]",
      RegMem => "RegField",
      Description => "Seed for the EM hash",
      Width => "48",
      Position => "48:1", # Excel Formula: =calc_position(F374,E375)
      Type => "Config",
      UsedBy => "ResolutionStage2Em",
      DefaultValue => "h0",
    },
    ResolutionStage2EmUsePrimitiveCrc0 => { #Structure Type: RegField; ArrayLength: 4; ArrayIndex: 0; ArrayLocationInName: 34;
      Name => "ResolutionStage2EmUsePrimitiveCrc[n]",
      RegMem => "RegField",
      Description => "0 - use non primitive polynom for the hash CRC
1 - use primitive polynom for the hash CRC",
      Width => "1",
      Position => "49", # Excel Formula: =calc_position(F375,E376)
      Type => "Config",
      UsedBy => "ResolutionStage2Em",
      DefaultValue => "h0",
    },
  },
  ResolutionStage2EmPerBankReg1 => { #Structure Type: Reg; ArrayLength: 4; ArrayIndex: 1; ArrayLocationInName: 29; Skip Register;
    Name => "ResolutionStage2EmPerBankReg[4]",
    RegMem => "Reg",
    Address => "157",
    Description => "EM bank configurations, see fields description",
    Width => "50", # Excel Formula: =calc_reg_width(E374:E376,F376)
    Type => "Config",
    AdditionalInfo => "PackArrayToBus",
    Comments => "EM Skip Reg",
    ArrayLength => "4",
    ArrayIndex => "1",
    ResolutionStage2EmActiveBanks1 => { #Structure Type: RegField; ArrayLength: 4; ArrayIndex: 1; ArrayLocationInName: 30;
      Name => "ResolutionStage2EmActiveBanks[n]",
      RegMem => "RegField",
      Description => "0 - EM bank is inactive
1 - EM bank is active",
      Width => "1",
      Position => "0", # Excel Formula: =calc_position(F373,E374,TRUE)
      Type => "Config",
      UsedBy => "ResolutionStage2Em",
      DefaultValue => "d1",
    },
    ResolutionStage2EmHashKey1 => { #Structure Type: RegField; ArrayLength: 4; ArrayIndex: 1; ArrayLocationInName: 26;
      Name => "ResolutionStage2EmHashKey[n]",
      RegMem => "RegField",
      Description => "Seed for the EM hash",
      Width => "48",
      Position => "48:1", # Excel Formula: =calc_position(F374,E375)
      Type => "Config",
      UsedBy => "ResolutionStage2Em",
      DefaultValue => "h0",
    },
    ResolutionStage2EmUsePrimitiveCrc1 => { #Structure Type: RegField; ArrayLength: 4; ArrayIndex: 1; ArrayLocationInName: 34;
      Name => "ResolutionStage2EmUsePrimitiveCrc[n]",
      RegMem => "RegField",
      Description => "0 - use non primitive polynom for the hash CRC
1 - use primitive polynom for the hash CRC",
      Width => "1",
      Position => "49", # Excel Formula: =calc_position(F375,E376)
      Type => "Config",
      UsedBy => "ResolutionStage2Em",
      DefaultValue => "h0",
    },
  },
  ResolutionStage2EmPerBankReg2 => { #Structure Type: Reg; ArrayLength: 4; ArrayIndex: 2; ArrayLocationInName: 29; Skip Register;
    Name => "ResolutionStage2EmPerBankReg[4]",
    RegMem => "Reg",
    Address => "158",
    Description => "EM bank configurations, see fields description",
    Width => "50", # Excel Formula: =calc_reg_width(E374:E376,F376)
    Type => "Config",
    AdditionalInfo => "PackArrayToBus",
    Comments => "EM Skip Reg",
    ArrayLength => "4",
    ArrayIndex => "2",
    ResolutionStage2EmActiveBanks2 => { #Structure Type: RegField; ArrayLength: 4; ArrayIndex: 2; ArrayLocationInName: 30;
      Name => "ResolutionStage2EmActiveBanks[n]",
      RegMem => "RegField",
      Description => "0 - EM bank is inactive
1 - EM bank is active",
      Width => "1",
      Position => "0", # Excel Formula: =calc_position(F373,E374,TRUE)
      Type => "Config",
      UsedBy => "ResolutionStage2Em",
      DefaultValue => "d1",
    },
    ResolutionStage2EmHashKey2 => { #Structure Type: RegField; ArrayLength: 4; ArrayIndex: 2; ArrayLocationInName: 26;
      Name => "ResolutionStage2EmHashKey[n]",
      RegMem => "RegField",
      Description => "Seed for the EM hash",
      Width => "48",
      Position => "48:1", # Excel Formula: =calc_position(F374,E375)
      Type => "Config",
      UsedBy => "ResolutionStage2Em",
      DefaultValue => "h0",
    },
    ResolutionStage2EmUsePrimitiveCrc2 => { #Structure Type: RegField; ArrayLength: 4; ArrayIndex: 2; ArrayLocationInName: 34;
      Name => "ResolutionStage2EmUsePrimitiveCrc[n]",
      RegMem => "RegField",
      Description => "0 - use non primitive polynom for the hash CRC
1 - use primitive polynom for the hash CRC",
      Width => "1",
      Position => "49", # Excel Formula: =calc_position(F375,E376)
      Type => "Config",
      UsedBy => "ResolutionStage2Em",
      DefaultValue => "h0",
    },
  },
  ResolutionStage2EmPerBankReg3 => { #Structure Type: Reg; ArrayLength: 4; ArrayIndex: 3; ArrayLocationInName: 29; Skip Register;
    Name => "ResolutionStage2EmPerBankReg[4]",
    RegMem => "Reg",
    Address => "159",
    Description => "EM bank configurations, see fields description",
    Width => "50", # Excel Formula: =calc_reg_width(E374:E376,F376)
    Type => "Config",
    AdditionalInfo => "PackArrayToBus",
    Comments => "EM Skip Reg",
    ArrayLength => "4",
    ArrayIndex => "3",
    ResolutionStage2EmActiveBanks3 => { #Structure Type: RegField; ArrayLength: 4; ArrayIndex: 3; ArrayLocationInName: 30;
      Name => "ResolutionStage2EmActiveBanks[n]",
      RegMem => "RegField",
      Description => "0 - EM bank is inactive
1 - EM bank is active",
      Width => "1",
      Position => "0", # Excel Formula: =calc_position(F373,E374,TRUE)
      Type => "Config",
      UsedBy => "ResolutionStage2Em",
      DefaultValue => "d1",
    },
    ResolutionStage2EmHashKey3 => { #Structure Type: RegField; ArrayLength: 4; ArrayIndex: 3; ArrayLocationInName: 26;
      Name => "ResolutionStage2EmHashKey[n]",
      RegMem => "RegField",
      Description => "Seed for the EM hash",
      Width => "48",
      Position => "48:1", # Excel Formula: =calc_position(F374,E375)
      Type => "Config",
      UsedBy => "ResolutionStage2Em",
      DefaultValue => "h0",
    },
    ResolutionStage2EmUsePrimitiveCrc3 => { #Structure Type: RegField; ArrayLength: 4; ArrayIndex: 3; ArrayLocationInName: 34;
      Name => "ResolutionStage2EmUsePrimitiveCrc[n]",
      RegMem => "RegField",
      Description => "0 - use non primitive polynom for the hash CRC
1 - use primitive polynom for the hash CRC",
      Width => "1",
      Position => "49", # Excel Formula: =calc_position(F375,E376)
      Type => "Config",
      UsedBy => "ResolutionStage2Em",
      DefaultValue => "h0",
    },
  },
  ResolutionStage2EmPerEmReg0 => { #Structure Type: Reg; ArrayLength: 1; ArrayIndex: 0; ArrayLocationInName: 27; Skip Register;
    Name => "ResolutionStage2EmPerEmReg[1]",
    RegMem => "Reg",
    Address => "15A", # Excel Formula: =calc_reg_address(C373,A373,G373)
    Description => "EM configurations, see fields description",
    Width => "33", # Excel Formula: =calc_reg_width(E378:E380,F380)
    Type => "Config",
    AdditionalInfo => "PackArrayToBus",
    Comments => "EM Skip Reg",
    ArrayLength => "1",
    ArrayIndex => "0",
    ResolutionStage2EmKeyWidth0 => { #Structure Type: RegField; ArrayLength: 1; ArrayIndex: 0; ArrayLocationInName: 27;
      Name => "ResolutionStage2EmKeyWidth[n]",
      RegMem => "RegField",
      Description => "Map the 4 key LSBs to key width",
      Width => "16",
      Position => "15:0", # Excel Formula: =calc_position(F377,E378,TRUE)
      Type => "Config",
      UsedBy => "ResolutionStage2Em",
      DefaultValue => "h0",
    },
    ResolutionStage2EmAutoBubbleReq0 => { #Structure Type: RegField; ArrayLength: 1; ArrayIndex: 0; ArrayLocationInName: 32;
      Name => "ResolutionStage2EmAutoBubbleReq[n]",
      RegMem => "RegField",
      Description => "Generate bubble request to the pipe automatically",
      Width => "1",
      Position => "16", # Excel Formula: =calc_position(F378,E379)
      Type => "Config",
      UsedBy => "ResolutionStage2Em",
      DefaultValue => "h0",
    },
    ResolutionStage2EmBubbleReqThreshold0 => { #Structure Type: RegField; ArrayLength: 1; ArrayIndex: 0; ArrayLocationInName: 37;
      Name => "ResolutionStage2EmBubbleReqThreshold[n]",
      RegMem => "RegField",
      Description => "Number of consecutive pipe lookups before generating CPU bubble request",
      Width => "16",
      Position => "32:17", # Excel Formula: =calc_position(F379,E380)
      Type => "Config",
      UsedBy => "ResolutionStage2Em",
      DefaultValue => "h0",
    },
  },
  ResolutionStage2EmCamWmMaxReg0 => { #Structure Type: Reg; ArrayLength: 1; ArrayIndex: 0; ArrayLocationInName: 30; Skip Register;
    Name => "ResolutionStage2EmCamWmMaxReg[1]",
    RegMem => "Reg",
    Address => "15B", # Excel Formula: =calc_reg_address(C377,A377,G377)
    Description => "EM debug indications, see fields description",
    Width => "8", # Excel Formula: =calc_reg_width(E382:E382,F382)
    Type => "ReadOnly",
    AdditionalInfo => "PackArrayToBus",
    Comments => "EM Skip Reg",
    ArrayLength => "1",
    ArrayIndex => "0",
    ResolutionStage2EmCamWmMax0 => { #Structure Type: RegField; ArrayLength: 1; ArrayIndex: 0; ArrayLocationInName: 27;
      Name => "ResolutionStage2EmCamWmMax[n]",
      RegMem => "RegField",
      Description => "CAM max watermark",
      Width => "8",
      Position => "7:0", # Excel Formula: =calc_position(F381,E382,TRUE)
      Type => "MaxWmk",
      UsedBy => "emdb",
      AdditionalInfo => "CounterIncrWidth=1",
    },
  },
  ResolutionStage2EmAccessRegister0 => { #Structure Type: Reg; ArrayLength: 1; ArrayIndex: 0; ArrayLocationInName: 33; Skip Register;
    Name => "ResolutionStage2EmAccessRegister[1]",
    RegMem => "Reg",
    Address => "15C", # Excel Formula: =calc_reg_address(C381,A381,G381)
    Description => "EM indirect access configurations",
    Width => "81", # Excel Formula: =calc_reg_width(E384:E384,F384)
    Type => "External",
    UsedBy => "em_top",
    Comments => "EM Skip Reg",
    ArrayLength => "1",
    ArrayIndex => "0",
    ResolutionStage2EmAccessReg0 => { #Structure Type: RegField; ArrayLength: 1; ArrayIndex: 0; ArrayLocationInName: 28;
      Name => "ResolutionStage2EmAccessReg[n]",
      RegMem => "RegField",
      Description => "See EM spec for register usage",
      Width => "81",
      Position => "80:0", # Excel Formula: =calc_position(F383,E384,TRUE)
      Type => "External",
    },
  },
  ResolutionStage2EmResponseRegister0 => { #Structure Type: Reg; ArrayLength: 1; ArrayIndex: 0; ArrayLocationInName: 35; Skip Register;
    Name => "ResolutionStage2EmResponseRegister[1]",
    RegMem => "Reg",
    Address => "15D", # Excel Formula: =calc_reg_address(C383,A383,G383)
    Description => "EM indirect access data",
    Width => "81", # Excel Formula: =calc_reg_width(E386:E387,F387)
    Type => "ReadOnly",
    Comments => "EM Skip Reg",
    ArrayLength => "1",
    ArrayIndex => "0",
    ResolutionStage2EmResponseValid0 => { #Structure Type: RegField; ArrayLength: 1; ArrayIndex: 0; ArrayLocationInName: 32;
      Name => "ResolutionStage2EmResponseValid[n]",
      RegMem => "RegField",
      Description => "EM indirect access data is valid",
      Width => "1",
      Position => "0", # Excel Formula: =calc_position(F385,E386,TRUE)
      Type => "Event",
      UsedBy => "emdb",
    },
    ResolutionStage2EmResponseReg0 => { #Structure Type: RegField; ArrayLength: 1; ArrayIndex: 0; ArrayLocationInName: 30;
      Name => "ResolutionStage2EmResponseReg[n]",
      RegMem => "RegField",
      Description => "EM indirect access data, see EM spec for register usage",
      Width => "80",
      Position => "80:1", # Excel Formula: =calc_position(F386,E387)
      Type => "Capture",
      UsedBy => "emdb",
    },
  },
  ResolutionStage2EmCam => { #Structure Type: Mem; Skip Register;
    Name => "ResolutionStage2EmCam",
    RegMem => "Mem",
    Address => "5B00000", # Excel Formula: =calc_mem_address(C371,A371,G388,L388)
    Description => "EM fallback CAM",
    Width => "60", # Excel Formula: =calc_mem_width(E389:E391,"None",F391,-1)
    Type => "Dynamic",
    UsedBy => "ResolutionStage2Em",
    MemEntries => "32",
    MemWrapper => "TCAM",
    MemProtect => "None",
    AdditionalInfo => "NumOfKeys=1,RegTcamPayloadWidth=35,CAM=Enabled,CpuReadAccess=Enabled,CpuWriteAccess=Enabled,NumCamLookupClients=2",
    Comments => "EM Skip Reg",
    MemLogicalWidth => "60",
    ResolutionStage2EmCam_key => { #Structure Type: MemField;
      Name => "ResolutionStage2EmCam_key",
      RegMem => "MemField",
      Description => "CAM key",
      Width => "24",
      Position => "23:0", # Excel Formula: =calc_position(F388,E389,TRUE)
    },
    ResolutionStage2EmCam_payload => { #Structure Type: MemField;
      Name => "ResolutionStage2EmCam_payload",
      RegMem => "MemField",
      Description => "CAM payload",
      Width => "35",
      Position => "58:24", # Excel Formula: =calc_position(F389,E390)
    },
    ResolutionStage2EmCam_valid => { #Structure Type: MemField;
      Name => "ResolutionStage2EmCam_valid",
      RegMem => "MemField",
      Description => "CAM entry is valid",
      Width => "1",
      Position => "59", # Excel Formula: =calc_position(F390,E391)
    },
  },
  ResolutionStage3EmVerifier0 => { #Structure Type: Mem; ArrayLength: 6; ArrayIndex: 0; ArrayLocationInName: 27; Skip Register;
    Name => "ResolutionStage3EmVerifier[6]",
    RegMem => "Mem",
    Address => "5C00000", # Excel Formula: =calc_mem_address(C388,A388,G392,L392)
    Description => "Holds the verifier and the payload of the EM entry",
    Width => "55", # Excel Formula: =calc_mem_width(E393:E393,M392,F393,-1)
    Type => "Dynamic",
    UsedBy => "ResolutionStage3Em",
    MemEntries => "2048",
    MemWrapper => "2R1W Slow Write",
    MemProtect => "ExtECC",
    AdditionalInfo => "PackArrayToBus=Enabled,UseHardReset=1,SampleReadBeforeProt=2,SamplePhysicalMem=1,CpuReadAccess=Enabled,CpuWriteAccess=Enabled,WriteActivityFactor=0,ReadActivityFactor=100,DisableSameAddressErr=Enabled,EnableNonCpuRdWrSameAddress=Enabled,PortErrPropagate=Disabled",
    Comments => "EM Skip Reg",
    ArrayLength => "6",
    ArrayIndex => "0",
    MemLogicalWidth => "55",
    ResolutionStage3EmVerifier0Data => { #Structure Type: MemField; ArrayLength: 6; ArrayIndex: 0; ArrayLocationInName: 27;
      Name => "ResolutionStage3EmVerifier[n]Data",
      RegMem => "MemField",
      Description => "Verifier and payload data",
      Width => "55",
      Position => "54:0", # Excel Formula: =calc_position(F392,E393,TRUE)
    },
  },
  ResolutionStage3EmVerifier1 => { #Structure Type: Mem; ArrayLength: 6; ArrayIndex: 1; ArrayLocationInName: 27; Skip Register;
    Name => "ResolutionStage3EmVerifier[6]",
    RegMem => "Mem",
    Address => "5D00000",
    Description => "Holds the verifier and the payload of the EM entry",
    Width => "55", # Excel Formula: =calc_mem_width(E393:E393,M392,F393,-1)
    Type => "Dynamic",
    UsedBy => "ResolutionStage3Em",
    MemEntries => "2048",
    MemWrapper => "2R1W Slow Write",
    MemProtect => "ExtECC",
    AdditionalInfo => "PackArrayToBus=Enabled,UseHardReset=1,SampleReadBeforeProt=2,SamplePhysicalMem=1,CpuReadAccess=Enabled,CpuWriteAccess=Enabled,WriteActivityFactor=0,ReadActivityFactor=100,DisableSameAddressErr=Enabled,EnableNonCpuRdWrSameAddress=Enabled,PortErrPropagate=Disabled",
    Comments => "EM Skip Reg",
    ArrayLength => "6",
    ArrayIndex => "1",
    MemLogicalWidth => "55",
    ResolutionStage3EmVerifier1Data => { #Structure Type: MemField; ArrayLength: 6; ArrayIndex: 1; ArrayLocationInName: 27;
      Name => "ResolutionStage3EmVerifier[n]Data",
      RegMem => "MemField",
      Description => "Verifier and payload data",
      Width => "55",
      Position => "54:0", # Excel Formula: =calc_position(F392,E393,TRUE)
    },
  },
  ResolutionStage3EmVerifier2 => { #Structure Type: Mem; ArrayLength: 6; ArrayIndex: 2; ArrayLocationInName: 27; Skip Register;
    Name => "ResolutionStage3EmVerifier[6]",
    RegMem => "Mem",
    Address => "5E00000",
    Description => "Holds the verifier and the payload of the EM entry",
    Width => "55", # Excel Formula: =calc_mem_width(E393:E393,M392,F393,-1)
    Type => "Dynamic",
    UsedBy => "ResolutionStage3Em",
    MemEntries => "2048",
    MemWrapper => "2R1W Slow Write",
    MemProtect => "ExtECC",
    AdditionalInfo => "PackArrayToBus=Enabled,UseHardReset=1,SampleReadBeforeProt=2,SamplePhysicalMem=1,CpuReadAccess=Enabled,CpuWriteAccess=Enabled,WriteActivityFactor=0,ReadActivityFactor=100,DisableSameAddressErr=Enabled,EnableNonCpuRdWrSameAddress=Enabled,PortErrPropagate=Disabled",
    Comments => "EM Skip Reg",
    ArrayLength => "6",
    ArrayIndex => "2",
    MemLogicalWidth => "55",
    ResolutionStage3EmVerifier2Data => { #Structure Type: MemField; ArrayLength: 6; ArrayIndex: 2; ArrayLocationInName: 27;
      Name => "ResolutionStage3EmVerifier[n]Data",
      RegMem => "MemField",
      Description => "Verifier and payload data",
      Width => "55",
      Position => "54:0", # Excel Formula: =calc_position(F392,E393,TRUE)
    },
  },
  ResolutionStage3EmVerifier3 => { #Structure Type: Mem; ArrayLength: 6; ArrayIndex: 3; ArrayLocationInName: 27; Skip Register;
    Name => "ResolutionStage3EmVerifier[6]",
    RegMem => "Mem",
    Address => "5F00000",
    Description => "Holds the verifier and the payload of the EM entry",
    Width => "55", # Excel Formula: =calc_mem_width(E393:E393,M392,F393,-1)
    Type => "Dynamic",
    UsedBy => "ResolutionStage3Em",
    MemEntries => "2048",
    MemWrapper => "2R1W Slow Write",
    MemProtect => "ExtECC",
    AdditionalInfo => "PackArrayToBus=Enabled,UseHardReset=1,SampleReadBeforeProt=2,SamplePhysicalMem=1,CpuReadAccess=Enabled,CpuWriteAccess=Enabled,WriteActivityFactor=0,ReadActivityFactor=100,DisableSameAddressErr=Enabled,EnableNonCpuRdWrSameAddress=Enabled,PortErrPropagate=Disabled",
    Comments => "EM Skip Reg",
    ArrayLength => "6",
    ArrayIndex => "3",
    MemLogicalWidth => "55",
    ResolutionStage3EmVerifier3Data => { #Structure Type: MemField; ArrayLength: 6; ArrayIndex: 3; ArrayLocationInName: 27;
      Name => "ResolutionStage3EmVerifier[n]Data",
      RegMem => "MemField",
      Description => "Verifier and payload data",
      Width => "55",
      Position => "54:0", # Excel Formula: =calc_position(F392,E393,TRUE)
    },
  },
  ResolutionStage3EmVerifier4 => { #Structure Type: Mem; ArrayLength: 6; ArrayIndex: 4; ArrayLocationInName: 27; Skip Register;
    Name => "ResolutionStage3EmVerifier[6]",
    RegMem => "Mem",
    Address => "6000000",
    Description => "Holds the verifier and the payload of the EM entry",
    Width => "55", # Excel Formula: =calc_mem_width(E393:E393,M392,F393,-1)
    Type => "Dynamic",
    UsedBy => "ResolutionStage3Em",
    MemEntries => "2048",
    MemWrapper => "2R1W Slow Write",
    MemProtect => "ExtECC",
    AdditionalInfo => "PackArrayToBus=Enabled,UseHardReset=1,SampleReadBeforeProt=2,SamplePhysicalMem=1,CpuReadAccess=Enabled,CpuWriteAccess=Enabled,WriteActivityFactor=0,ReadActivityFactor=100,DisableSameAddressErr=Enabled,EnableNonCpuRdWrSameAddress=Enabled,PortErrPropagate=Disabled",
    Comments => "EM Skip Reg",
    ArrayLength => "6",
    ArrayIndex => "4",
    MemLogicalWidth => "55",
    ResolutionStage3EmVerifier4Data => { #Structure Type: MemField; ArrayLength: 6; ArrayIndex: 4; ArrayLocationInName: 27;
      Name => "ResolutionStage3EmVerifier[n]Data",
      RegMem => "MemField",
      Description => "Verifier and payload data",
      Width => "55",
      Position => "54:0", # Excel Formula: =calc_position(F392,E393,TRUE)
    },
  },
  ResolutionStage3EmVerifier5 => { #Structure Type: Mem; ArrayLength: 6; ArrayIndex: 5; ArrayLocationInName: 27; Skip Register;
    Name => "ResolutionStage3EmVerifier[6]",
    RegMem => "Mem",
    Address => "6100000",
    Description => "Holds the verifier and the payload of the EM entry",
    Width => "55", # Excel Formula: =calc_mem_width(E393:E393,M392,F393,-1)
    Type => "Dynamic",
    UsedBy => "ResolutionStage3Em",
    MemEntries => "2048",
    MemWrapper => "2R1W Slow Write",
    MemProtect => "ExtECC",
    AdditionalInfo => "PackArrayToBus=Enabled,UseHardReset=1,SampleReadBeforeProt=2,SamplePhysicalMem=1,CpuReadAccess=Enabled,CpuWriteAccess=Enabled,WriteActivityFactor=0,ReadActivityFactor=100,DisableSameAddressErr=Enabled,EnableNonCpuRdWrSameAddress=Enabled,PortErrPropagate=Disabled",
    Comments => "EM Skip Reg",
    ArrayLength => "6",
    ArrayIndex => "5",
    MemLogicalWidth => "55",
    ResolutionStage3EmVerifier5Data => { #Structure Type: MemField; ArrayLength: 6; ArrayIndex: 5; ArrayLocationInName: 27;
      Name => "ResolutionStage3EmVerifier[n]Data",
      RegMem => "MemField",
      Description => "Verifier and payload data",
      Width => "55",
      Position => "54:0", # Excel Formula: =calc_position(F392,E393,TRUE)
    },
  },
  ResolutionStage3EmPerBankReg0 => { #Structure Type: Reg; ArrayLength: 6; ArrayIndex: 0; ArrayLocationInName: 29; Skip Register;
    Name => "ResolutionStage3EmPerBankReg[6]",
    RegMem => "Reg",
    Address => "15E", # Excel Formula: =calc_reg_address(C385,A385,G385)
    Description => "EM bank configurations, see fields description",
    Width => "50", # Excel Formula: =calc_reg_width(E395:E397,F397)
    Type => "Config",
    AdditionalInfo => "PackArrayToBus",
    Comments => "EM Skip Reg",
    ArrayLength => "6",
    ArrayIndex => "0",
    ResolutionStage3EmActiveBanks0 => { #Structure Type: RegField; ArrayLength: 6; ArrayIndex: 0; ArrayLocationInName: 30;
      Name => "ResolutionStage3EmActiveBanks[n]",
      RegMem => "RegField",
      Description => "0 - EM bank is inactive
1 - EM bank is active",
      Width => "1",
      Position => "0", # Excel Formula: =calc_position(F394,E395,TRUE)
      Type => "Config",
      UsedBy => "ResolutionStage3Em",
      DefaultValue => "d1",
    },
    ResolutionStage3EmHashKey0 => { #Structure Type: RegField; ArrayLength: 6; ArrayIndex: 0; ArrayLocationInName: 26;
      Name => "ResolutionStage3EmHashKey[n]",
      RegMem => "RegField",
      Description => "Seed for the EM hash",
      Width => "48",
      Position => "48:1", # Excel Formula: =calc_position(F395,E396)
      Type => "Config",
      UsedBy => "ResolutionStage3Em",
      DefaultValue => "h0",
    },
    ResolutionStage3EmUsePrimitiveCrc0 => { #Structure Type: RegField; ArrayLength: 6; ArrayIndex: 0; ArrayLocationInName: 34;
      Name => "ResolutionStage3EmUsePrimitiveCrc[n]",
      RegMem => "RegField",
      Description => "0 - use non primitive polynom for the hash CRC
1 - use primitive polynom for the hash CRC",
      Width => "1",
      Position => "49", # Excel Formula: =calc_position(F396,E397)
      Type => "Config",
      UsedBy => "ResolutionStage3Em",
      DefaultValue => "h0",
    },
  },
  ResolutionStage3EmPerBankReg1 => { #Structure Type: Reg; ArrayLength: 6; ArrayIndex: 1; ArrayLocationInName: 29; Skip Register;
    Name => "ResolutionStage3EmPerBankReg[6]",
    RegMem => "Reg",
    Address => "15F",
    Description => "EM bank configurations, see fields description",
    Width => "50", # Excel Formula: =calc_reg_width(E395:E397,F397)
    Type => "Config",
    AdditionalInfo => "PackArrayToBus",
    Comments => "EM Skip Reg",
    ArrayLength => "6",
    ArrayIndex => "1",
    ResolutionStage3EmActiveBanks1 => { #Structure Type: RegField; ArrayLength: 6; ArrayIndex: 1; ArrayLocationInName: 30;
      Name => "ResolutionStage3EmActiveBanks[n]",
      RegMem => "RegField",
      Description => "0 - EM bank is inactive
1 - EM bank is active",
      Width => "1",
      Position => "0", # Excel Formula: =calc_position(F394,E395,TRUE)
      Type => "Config",
      UsedBy => "ResolutionStage3Em",
      DefaultValue => "d1",
    },
    ResolutionStage3EmHashKey1 => { #Structure Type: RegField; ArrayLength: 6; ArrayIndex: 1; ArrayLocationInName: 26;
      Name => "ResolutionStage3EmHashKey[n]",
      RegMem => "RegField",
      Description => "Seed for the EM hash",
      Width => "48",
      Position => "48:1", # Excel Formula: =calc_position(F395,E396)
      Type => "Config",
      UsedBy => "ResolutionStage3Em",
      DefaultValue => "h0",
    },
    ResolutionStage3EmUsePrimitiveCrc1 => { #Structure Type: RegField; ArrayLength: 6; ArrayIndex: 1; ArrayLocationInName: 34;
      Name => "ResolutionStage3EmUsePrimitiveCrc[n]",
      RegMem => "RegField",
      Description => "0 - use non primitive polynom for the hash CRC
1 - use primitive polynom for the hash CRC",
      Width => "1",
      Position => "49", # Excel Formula: =calc_position(F396,E397)
      Type => "Config",
      UsedBy => "ResolutionStage3Em",
      DefaultValue => "h0",
    },
  },
  ResolutionStage3EmPerBankReg2 => { #Structure Type: Reg; ArrayLength: 6; ArrayIndex: 2; ArrayLocationInName: 29; Skip Register;
    Name => "ResolutionStage3EmPerBankReg[6]",
    RegMem => "Reg",
    Address => "160",
    Description => "EM bank configurations, see fields description",
    Width => "50", # Excel Formula: =calc_reg_width(E395:E397,F397)
    Type => "Config",
    AdditionalInfo => "PackArrayToBus",
    Comments => "EM Skip Reg",
    ArrayLength => "6",
    ArrayIndex => "2",
    ResolutionStage3EmActiveBanks2 => { #Structure Type: RegField; ArrayLength: 6; ArrayIndex: 2; ArrayLocationInName: 30;
      Name => "ResolutionStage3EmActiveBanks[n]",
      RegMem => "RegField",
      Description => "0 - EM bank is inactive
1 - EM bank is active",
      Width => "1",
      Position => "0", # Excel Formula: =calc_position(F394,E395,TRUE)
      Type => "Config",
      UsedBy => "ResolutionStage3Em",
      DefaultValue => "d1",
    },
    ResolutionStage3EmHashKey2 => { #Structure Type: RegField; ArrayLength: 6; ArrayIndex: 2; ArrayLocationInName: 26;
      Name => "ResolutionStage3EmHashKey[n]",
      RegMem => "RegField",
      Description => "Seed for the EM hash",
      Width => "48",
      Position => "48:1", # Excel Formula: =calc_position(F395,E396)
      Type => "Config",
      UsedBy => "ResolutionStage3Em",
      DefaultValue => "h0",
    },
    ResolutionStage3EmUsePrimitiveCrc2 => { #Structure Type: RegField; ArrayLength: 6; ArrayIndex: 2; ArrayLocationInName: 34;
      Name => "ResolutionStage3EmUsePrimitiveCrc[n]",
      RegMem => "RegField",
      Description => "0 - use non primitive polynom for the hash CRC
1 - use primitive polynom for the hash CRC",
      Width => "1",
      Position => "49", # Excel Formula: =calc_position(F396,E397)
      Type => "Config",
      UsedBy => "ResolutionStage3Em",
      DefaultValue => "h0",
    },
  },
  ResolutionStage3EmPerBankReg3 => { #Structure Type: Reg; ArrayLength: 6; ArrayIndex: 3; ArrayLocationInName: 29; Skip Register;
    Name => "ResolutionStage3EmPerBankReg[6]",
    RegMem => "Reg",
    Address => "161",
    Description => "EM bank configurations, see fields description",
    Width => "50", # Excel Formula: =calc_reg_width(E395:E397,F397)
    Type => "Config",
    AdditionalInfo => "PackArrayToBus",
    Comments => "EM Skip Reg",
    ArrayLength => "6",
    ArrayIndex => "3",
    ResolutionStage3EmActiveBanks3 => { #Structure Type: RegField; ArrayLength: 6; ArrayIndex: 3; ArrayLocationInName: 30;
      Name => "ResolutionStage3EmActiveBanks[n]",
      RegMem => "RegField",
      Description => "0 - EM bank is inactive
1 - EM bank is active",
      Width => "1",
      Position => "0", # Excel Formula: =calc_position(F394,E395,TRUE)
      Type => "Config",
      UsedBy => "ResolutionStage3Em",
      DefaultValue => "d1",
    },
    ResolutionStage3EmHashKey3 => { #Structure Type: RegField; ArrayLength: 6; ArrayIndex: 3; ArrayLocationInName: 26;
      Name => "ResolutionStage3EmHashKey[n]",
      RegMem => "RegField",
      Description => "Seed for the EM hash",
      Width => "48",
      Position => "48:1", # Excel Formula: =calc_position(F395,E396)
      Type => "Config",
      UsedBy => "ResolutionStage3Em",
      DefaultValue => "h0",
    },
    ResolutionStage3EmUsePrimitiveCrc3 => { #Structure Type: RegField; ArrayLength: 6; ArrayIndex: 3; ArrayLocationInName: 34;
      Name => "ResolutionStage3EmUsePrimitiveCrc[n]",
      RegMem => "RegField",
      Description => "0 - use non primitive polynom for the hash CRC
1 - use primitive polynom for the hash CRC",
      Width => "1",
      Position => "49", # Excel Formula: =calc_position(F396,E397)
      Type => "Config",
      UsedBy => "ResolutionStage3Em",
      DefaultValue => "h0",
    },
  },
  ResolutionStage3EmPerBankReg4 => { #Structure Type: Reg; ArrayLength: 6; ArrayIndex: 4; ArrayLocationInName: 29; Skip Register;
    Name => "ResolutionStage3EmPerBankReg[6]",
    RegMem => "Reg",
    Address => "162",
    Description => "EM bank configurations, see fields description",
    Width => "50", # Excel Formula: =calc_reg_width(E395:E397,F397)
    Type => "Config",
    AdditionalInfo => "PackArrayToBus",
    Comments => "EM Skip Reg",
    ArrayLength => "6",
    ArrayIndex => "4",
    ResolutionStage3EmActiveBanks4 => { #Structure Type: RegField; ArrayLength: 6; ArrayIndex: 4; ArrayLocationInName: 30;
      Name => "ResolutionStage3EmActiveBanks[n]",
      RegMem => "RegField",
      Description => "0 - EM bank is inactive
1 - EM bank is active",
      Width => "1",
      Position => "0", # Excel Formula: =calc_position(F394,E395,TRUE)
      Type => "Config",
      UsedBy => "ResolutionStage3Em",
      DefaultValue => "d1",
    },
    ResolutionStage3EmHashKey4 => { #Structure Type: RegField; ArrayLength: 6; ArrayIndex: 4; ArrayLocationInName: 26;
      Name => "ResolutionStage3EmHashKey[n]",
      RegMem => "RegField",
      Description => "Seed for the EM hash",
      Width => "48",
      Position => "48:1", # Excel Formula: =calc_position(F395,E396)
      Type => "Config",
      UsedBy => "ResolutionStage3Em",
      DefaultValue => "h0",
    },
    ResolutionStage3EmUsePrimitiveCrc4 => { #Structure Type: RegField; ArrayLength: 6; ArrayIndex: 4; ArrayLocationInName: 34;
      Name => "ResolutionStage3EmUsePrimitiveCrc[n]",
      RegMem => "RegField",
      Description => "0 - use non primitive polynom for the hash CRC
1 - use primitive polynom for the hash CRC",
      Width => "1",
      Position => "49", # Excel Formula: =calc_position(F396,E397)
      Type => "Config",
      UsedBy => "ResolutionStage3Em",
      DefaultValue => "h0",
    },
  },
  ResolutionStage3EmPerBankReg5 => { #Structure Type: Reg; ArrayLength: 6; ArrayIndex: 5; ArrayLocationInName: 29; Skip Register;
    Name => "ResolutionStage3EmPerBankReg[6]",
    RegMem => "Reg",
    Address => "163",
    Description => "EM bank configurations, see fields description",
    Width => "50", # Excel Formula: =calc_reg_width(E395:E397,F397)
    Type => "Config",
    AdditionalInfo => "PackArrayToBus",
    Comments => "EM Skip Reg",
    ArrayLength => "6",
    ArrayIndex => "5",
    ResolutionStage3EmActiveBanks5 => { #Structure Type: RegField; ArrayLength: 6; ArrayIndex: 5; ArrayLocationInName: 30;
      Name => "ResolutionStage3EmActiveBanks[n]",
      RegMem => "RegField",
      Description => "0 - EM bank is inactive
1 - EM bank is active",
      Width => "1",
      Position => "0", # Excel Formula: =calc_position(F394,E395,TRUE)
      Type => "Config",
      UsedBy => "ResolutionStage3Em",
      DefaultValue => "d1",
    },
    ResolutionStage3EmHashKey5 => { #Structure Type: RegField; ArrayLength: 6; ArrayIndex: 5; ArrayLocationInName: 26;
      Name => "ResolutionStage3EmHashKey[n]",
      RegMem => "RegField",
      Description => "Seed for the EM hash",
      Width => "48",
      Position => "48:1", # Excel Formula: =calc_position(F395,E396)
      Type => "Config",
      UsedBy => "ResolutionStage3Em",
      DefaultValue => "h0",
    },
    ResolutionStage3EmUsePrimitiveCrc5 => { #Structure Type: RegField; ArrayLength: 6; ArrayIndex: 5; ArrayLocationInName: 34;
      Name => "ResolutionStage3EmUsePrimitiveCrc[n]",
      RegMem => "RegField",
      Description => "0 - use non primitive polynom for the hash CRC
1 - use primitive polynom for the hash CRC",
      Width => "1",
      Position => "49", # Excel Formula: =calc_position(F396,E397)
      Type => "Config",
      UsedBy => "ResolutionStage3Em",
      DefaultValue => "h0",
    },
  },
  ResolutionStage3EmPerEmReg0 => { #Structure Type: Reg; ArrayLength: 1; ArrayIndex: 0; ArrayLocationInName: 27; Skip Register;
    Name => "ResolutionStage3EmPerEmReg[1]",
    RegMem => "Reg",
    Address => "164", # Excel Formula: =calc_reg_address(C394,A394,G394)
    Description => "EM configurations, see fields description",
    Width => "33", # Excel Formula: =calc_reg_width(E399:E401,F401)
    Type => "Config",
    AdditionalInfo => "PackArrayToBus",
    Comments => "EM Skip Reg",
    ArrayLength => "1",
    ArrayIndex => "0",
    ResolutionStage3EmKeyWidth0 => { #Structure Type: RegField; ArrayLength: 1; ArrayIndex: 0; ArrayLocationInName: 27;
      Name => "ResolutionStage3EmKeyWidth[n]",
      RegMem => "RegField",
      Description => "Map the 4 key LSBs to key width",
      Width => "16",
      Position => "15:0", # Excel Formula: =calc_position(F398,E399,TRUE)
      Type => "Config",
      UsedBy => "ResolutionStage3Em",
      DefaultValue => "h0",
    },
    ResolutionStage3EmAutoBubbleReq0 => { #Structure Type: RegField; ArrayLength: 1; ArrayIndex: 0; ArrayLocationInName: 32;
      Name => "ResolutionStage3EmAutoBubbleReq[n]",
      RegMem => "RegField",
      Description => "Generate bubble request to the pipe automatically",
      Width => "1",
      Position => "16", # Excel Formula: =calc_position(F399,E400)
      Type => "Config",
      UsedBy => "ResolutionStage3Em",
      DefaultValue => "h0",
    },
    ResolutionStage3EmBubbleReqThreshold0 => { #Structure Type: RegField; ArrayLength: 1; ArrayIndex: 0; ArrayLocationInName: 37;
      Name => "ResolutionStage3EmBubbleReqThreshold[n]",
      RegMem => "RegField",
      Description => "Number of consecutive pipe lookups before generating CPU bubble request",
      Width => "16",
      Position => "32:17", # Excel Formula: =calc_position(F400,E401)
      Type => "Config",
      UsedBy => "ResolutionStage3Em",
      DefaultValue => "h0",
    },
  },
  ResolutionStage3EmCamWmMaxReg0 => { #Structure Type: Reg; ArrayLength: 1; ArrayIndex: 0; ArrayLocationInName: 30; Skip Register;
    Name => "ResolutionStage3EmCamWmMaxReg[1]",
    RegMem => "Reg",
    Address => "165", # Excel Formula: =calc_reg_address(C398,A398,G398)
    Description => "EM debug indications, see fields description",
    Width => "8", # Excel Formula: =calc_reg_width(E403:E403,F403)
    Type => "ReadOnly",
    AdditionalInfo => "PackArrayToBus",
    Comments => "EM Skip Reg",
    ArrayLength => "1",
    ArrayIndex => "0",
    ResolutionStage3EmCamWmMax0 => { #Structure Type: RegField; ArrayLength: 1; ArrayIndex: 0; ArrayLocationInName: 27;
      Name => "ResolutionStage3EmCamWmMax[n]",
      RegMem => "RegField",
      Description => "CAM max watermark",
      Width => "8",
      Position => "7:0", # Excel Formula: =calc_position(F402,E403,TRUE)
      Type => "MaxWmk",
      UsedBy => "emdb",
      AdditionalInfo => "CounterIncrWidth=1",
    },
  },
  ResolutionStage3EmAccessRegister0 => { #Structure Type: Reg; ArrayLength: 1; ArrayIndex: 0; ArrayLocationInName: 33; Skip Register;
    Name => "ResolutionStage3EmAccessRegister[1]",
    RegMem => "Reg",
    Address => "166", # Excel Formula: =calc_reg_address(C402,A402,G402)
    Description => "EM indirect access configurations",
    Width => "80", # Excel Formula: =calc_reg_width(E405:E405,F405)
    Type => "External",
    UsedBy => "em_top",
    Comments => "EM Skip Reg",
    ArrayLength => "1",
    ArrayIndex => "0",
    ResolutionStage3EmAccessReg0 => { #Structure Type: RegField; ArrayLength: 1; ArrayIndex: 0; ArrayLocationInName: 28;
      Name => "ResolutionStage3EmAccessReg[n]",
      RegMem => "RegField",
      Description => "See EM spec for register usage",
      Width => "80",
      Position => "79:0", # Excel Formula: =calc_position(F404,E405,TRUE)
      Type => "External",
    },
  },
  ResolutionStage3EmResponseRegister0 => { #Structure Type: Reg; ArrayLength: 1; ArrayIndex: 0; ArrayLocationInName: 35; Skip Register;
    Name => "ResolutionStage3EmResponseRegister[1]",
    RegMem => "Reg",
    Address => "167", # Excel Formula: =calc_reg_address(C404,A404,G404)
    Description => "EM indirect access data",
    Width => "79", # Excel Formula: =calc_reg_width(E407:E408,F408)
    Type => "ReadOnly",
    Comments => "EM Skip Reg",
    ArrayLength => "1",
    ArrayIndex => "0",
    ResolutionStage3EmResponseValid0 => { #Structure Type: RegField; ArrayLength: 1; ArrayIndex: 0; ArrayLocationInName: 32;
      Name => "ResolutionStage3EmResponseValid[n]",
      RegMem => "RegField",
      Description => "EM indirect access data is valid",
      Width => "1",
      Position => "0", # Excel Formula: =calc_position(F406,E407,TRUE)
      Type => "Event",
      UsedBy => "emdb",
    },
    ResolutionStage3EmResponseReg0 => { #Structure Type: RegField; ArrayLength: 1; ArrayIndex: 0; ArrayLocationInName: 30;
      Name => "ResolutionStage3EmResponseReg[n]",
      RegMem => "RegField",
      Description => "EM indirect access data, see EM spec for register usage",
      Width => "78",
      Position => "78:1", # Excel Formula: =calc_position(F407,E408)
      Type => "Capture",
      UsedBy => "emdb",
    },
  },
  ResolutionStage3EmCam => { #Structure Type: Mem; Skip Register;
    Name => "ResolutionStage3EmCam",
    RegMem => "Mem",
    Address => "6200000", # Excel Formula: =calc_mem_address(C392,A392,G409,L409)
    Description => "EM fallback CAM",
    Width => "59", # Excel Formula: =calc_mem_width(E410:E412,"None",F412,-1)
    Type => "Dynamic",
    UsedBy => "ResolutionStage3Em",
    MemEntries => "32",
    MemWrapper => "TCAM",
    MemProtect => "None",
    AdditionalInfo => "NumOfKeys=1,RegTcamPayloadWidth=34,CAM=Enabled,CpuReadAccess=Enabled,CpuWriteAccess=Enabled,NumCamLookupClients=2",
    Comments => "EM Skip Reg",
    MemLogicalWidth => "59",
    ResolutionStage3EmCam_key => { #Structure Type: MemField;
      Name => "ResolutionStage3EmCam_key",
      RegMem => "MemField",
      Description => "CAM key",
      Width => "24",
      Position => "23:0", # Excel Formula: =calc_position(F409,E410,TRUE)
    },
    ResolutionStage3EmCam_payload => { #Structure Type: MemField;
      Name => "ResolutionStage3EmCam_payload",
      RegMem => "MemField",
      Description => "CAM payload",
      Width => "34",
      Position => "57:24", # Excel Formula: =calc_position(F410,E411)
    },
    ResolutionStage3EmCam_valid => { #Structure Type: MemField;
      Name => "ResolutionStage3EmCam_valid",
      RegMem => "MemField",
      Description => "CAM entry is valid",
      Width => "1",
      Position => "58", # Excel Formula: =calc_position(F411,E412)
    },
  },
  EmResponseInterrupt => { #Structure Type: Reg; Skip Register;
    Name => "EmResponseInterrupt",
    RegMem => "Reg",
    Address => "168", # Excel Formula: =calc_reg_address(C406,A406,G406)
    Description => "EM indirect access data is valid",
    Width => "5", # Excel Formula: =calc_reg_width(E414:E418,F418)
    Type => "Interrupt",
    Comments => "EM Skip Reg",
    ResolutionStage0EmResp => { #Structure Type: RegField;
      Name => "ResolutionStage0EmResp",
      RegMem => "RegField",
      Description => "Relevant EM indirect access data is valid",
      Width => "1",
      Position => "0", # Excel Formula: =calc_position(F413,E414,TRUE)
      Type => "Interrupt",
      UsedBy => "emdb",
    },
    LpQueuingEmResp => { #Structure Type: RegField;
      Name => "LpQueuingEmResp",
      RegMem => "RegField",
      Description => "Relevant EM indirect access data is valid",
      Width => "1",
      Position => "1", # Excel Formula: =calc_position(F414,E415)
      Type => "Interrupt",
      UsedBy => "emdb",
    },
    ResolutionStage1EmResp => { #Structure Type: RegField;
      Name => "ResolutionStage1EmResp",
      RegMem => "RegField",
      Description => "Relevant EM indirect access data is valid",
      Width => "1",
      Position => "2", # Excel Formula: =calc_position(F415,E416)
      Type => "Interrupt",
      UsedBy => "emdb",
    },
    ResolutionStage2EmResp => { #Structure Type: RegField;
      Name => "ResolutionStage2EmResp",
      RegMem => "RegField",
      Description => "Relevant EM indirect access data is valid",
      Width => "1",
      Position => "3", # Excel Formula: =calc_position(F416,E417)
      Type => "Interrupt",
      UsedBy => "emdb",
    },
    ResolutionStage3EmResp => { #Structure Type: RegField;
      Name => "ResolutionStage3EmResp",
      RegMem => "RegField",
      Description => "Relevant EM indirect access data is valid",
      Width => "1",
      Position => "4", # Excel Formula: =calc_position(F417,E418)
      Type => "Interrupt",
      UsedBy => "emdb",
    },
  },
  EmResponseInterruptMask => { #Structure Type: Reg; Skip Register; Skip Register;
    Name => "EmResponseInterruptMask",
    RegMem => "Reg",
    Address => "169",
    Description => "This register masks EmResponseInterrupt interrupt register",
    Width => "5", # Excel Formula: =calc_reg_width(E414:E418,F418)
    Type => "InterruptMask",
    Comments => "EM Skip Reg",
    ResolutionStage0EmRespMask => { #Structure Type: RegField;
      Name => "ResolutionStage0EmRespMask",
      RegMem => "RegField",
      Description => "This field masks ResolutionStage0EmResp interrupt",
      Width => "1",
      Position => "0", # Excel Formula: =calc_position(F413,E414,TRUE)
      Type => "InterruptMask",
      UsedBy => "",
      DefaultValue => "b1",
    },
    LpQueuingEmRespMask => { #Structure Type: RegField;
      Name => "LpQueuingEmRespMask",
      RegMem => "RegField",
      Description => "This field masks LpQueuingEmResp interrupt",
      Width => "1",
      Position => "1", # Excel Formula: =calc_position(F414,E415)
      Type => "InterruptMask",
      UsedBy => "",
      DefaultValue => "b1",
    },
    ResolutionStage1EmRespMask => { #Structure Type: RegField;
      Name => "ResolutionStage1EmRespMask",
      RegMem => "RegField",
      Description => "This field masks ResolutionStage1EmResp interrupt",
      Width => "1",
      Position => "2", # Excel Formula: =calc_position(F415,E416)
      Type => "InterruptMask",
      UsedBy => "",
      DefaultValue => "b1",
    },
    ResolutionStage2EmRespMask => { #Structure Type: RegField;
      Name => "ResolutionStage2EmRespMask",
      RegMem => "RegField",
      Description => "This field masks ResolutionStage2EmResp interrupt",
      Width => "1",
      Position => "3", # Excel Formula: =calc_position(F416,E417)
      Type => "InterruptMask",
      UsedBy => "",
      DefaultValue => "b1",
    },
    ResolutionStage3EmRespMask => { #Structure Type: RegField;
      Name => "ResolutionStage3EmRespMask",
      RegMem => "RegField",
      Description => "This field masks ResolutionStage3EmResp interrupt",
      Width => "1",
      Position => "4", # Excel Formula: =calc_position(F417,E418)
      Type => "InterruptMask",
      UsedBy => "",
      DefaultValue => "b1",
    },
  },
  EmResponseInterruptTest => { #Structure Type: Reg; Skip Register; Skip Register;
    Name => "EmResponseInterruptTest",
    RegMem => "Reg",
    Address => "16A",
    Description => "This register tests EmResponseInterrupt interrupt register",
    Width => "5", # Excel Formula: =calc_reg_width(E414:E418,F418)
    Type => "InterruptTest",
    Comments => "EM Skip Reg",
    ResolutionStage0EmRespTest => { #Structure Type: RegField;
      Name => "ResolutionStage0EmRespTest",
      RegMem => "RegField",
      Description => "This field tests ResolutionStage0EmResp interrupt",
      Width => "1",
      Position => "0", # Excel Formula: =calc_position(F413,E414,TRUE)
      Type => "InterruptTest",
      UsedBy => "",
      DefaultValue => "b0",
    },
    LpQueuingEmRespTest => { #Structure Type: RegField;
      Name => "LpQueuingEmRespTest",
      RegMem => "RegField",
      Description => "This field tests LpQueuingEmResp interrupt",
      Width => "1",
      Position => "1", # Excel Formula: =calc_position(F414,E415)
      Type => "InterruptTest",
      UsedBy => "",
      DefaultValue => "b0",
    },
    ResolutionStage1EmRespTest => { #Structure Type: RegField;
      Name => "ResolutionStage1EmRespTest",
      RegMem => "RegField",
      Description => "This field tests ResolutionStage1EmResp interrupt",
      Width => "1",
      Position => "2", # Excel Formula: =calc_position(F415,E416)
      Type => "InterruptTest",
      UsedBy => "",
      DefaultValue => "b0",
    },
    ResolutionStage2EmRespTest => { #Structure Type: RegField;
      Name => "ResolutionStage2EmRespTest",
      RegMem => "RegField",
      Description => "This field tests ResolutionStage2EmResp interrupt",
      Width => "1",
      Position => "3", # Excel Formula: =calc_position(F416,E417)
      Type => "InterruptTest",
      UsedBy => "",
      DefaultValue => "b0",
    },
    ResolutionStage3EmRespTest => { #Structure Type: RegField;
      Name => "ResolutionStage3EmRespTest",
      RegMem => "RegField",
      Description => "This field tests ResolutionStage3EmResp interrupt",
      Width => "1",
      Position => "4", # Excel Formula: =calc_position(F417,E418)
      Type => "InterruptTest",
      UsedBy => "",
      DefaultValue => "b0",
    },
  },
  ResolutionStage0AssociatedDataBubbleReqCfg => { #Structure Type: Reg; Skip Register;
    Name => "ResolutionStage0AssociatedDataBubbleReqCfg",
    RegMem => "Reg",
    Address => "16B", # Excel Formula: =calc_reg_address(C413,A413,G413)
    Description => "Bubble request configurations for ResolutionStage0AssociatedData memory",
    Width => "16", # Excel Formula: =calc_reg_width(E420:E420,F420)
    Type => "Config",
    Comments => "EM Skip Reg",
    ResolutionStage0AssociatedDataBubbleTimerCfg => { #Structure Type: RegField;
      Name => "ResolutionStage0AssociatedDataBubbleTimerCfg",
      RegMem => "RegField",
      Description => "Number of consecutive pipe accesses before generating CPU bubble request",
      Width => "16",
      Position => "15:0", # Excel Formula: =calc_position(F419,E420,TRUE)
      Type => "Config",
      UsedBy => "MEM",
      DefaultValue => "d1",
    },
  },
  FecTableBubbleReqCfg => { #Structure Type: Reg; Skip Register;
    Name => "FecTableBubbleReqCfg",
    RegMem => "Reg",
    Address => "16C", # Excel Formula: =calc_reg_address(C419,A419,G419)
    Description => "Bubble request configurations for FecTable memory",
    Width => "16", # Excel Formula: =calc_reg_width(E422:E422,F422)
    Type => "Config",
    Comments => "EM Skip Reg",
    FecTableBubbleTimerCfg => { #Structure Type: RegField;
      Name => "FecTableBubbleTimerCfg",
      RegMem => "RegField",
      Description => "Number of consecutive pipe accesses before generating CPU bubble request",
      Width => "16",
      Position => "15:0", # Excel Formula: =calc_position(F421,E422,TRUE)
      Type => "Config",
      UsedBy => "MEM",
      DefaultValue => "d1",
    },
  },
  ResolutionStage1AssociatedDataBubbleReqCfg => { #Structure Type: Reg; Skip Register;
    Name => "ResolutionStage1AssociatedDataBubbleReqCfg",
    RegMem => "Reg",
    Address => "16D", # Excel Formula: =calc_reg_address(C421,A421,G421)
    Description => "Bubble request configurations for ResolutionStage1AssociatedData memory",
    Width => "16", # Excel Formula: =calc_reg_width(E424:E424,F424)
    Type => "Config",
    Comments => "EM Skip Reg",
    ResolutionStage1AssociatedDataBubbleTimerCfg => { #Structure Type: RegField;
      Name => "ResolutionStage1AssociatedDataBubbleTimerCfg",
      RegMem => "RegField",
      Description => "Number of consecutive pipe accesses before generating CPU bubble request",
      Width => "16",
      Position => "15:0", # Excel Formula: =calc_position(F423,E424,TRUE)
      Type => "Config",
      UsedBy => "MEM",
      DefaultValue => "d1",
    },
  },
  ResolutionStage2AssociatedDataBubbleReqCfg => { #Structure Type: Reg; Skip Register;
    Name => "ResolutionStage2AssociatedDataBubbleReqCfg",
    RegMem => "Reg",
    Address => "16E", # Excel Formula: =calc_reg_address(C423,A423,G423)
    Description => "Bubble request configurations for ResolutionStage2AssociatedData memory",
    Width => "16", # Excel Formula: =calc_reg_width(E426:E426,F426)
    Type => "Config",
    Comments => "EM Skip Reg",
    ResolutionStage2AssociatedDataBubbleTimerCfg => { #Structure Type: RegField;
      Name => "ResolutionStage2AssociatedDataBubbleTimerCfg",
      RegMem => "RegField",
      Description => "Number of consecutive pipe accesses before generating CPU bubble request",
      Width => "16",
      Position => "15:0", # Excel Formula: =calc_position(F425,E426,TRUE)
      Type => "Config",
      UsedBy => "MEM",
      DefaultValue => "d1",
    },
  },
  ResolutionStage3AssociatedDataBubbleReqCfg => { #Structure Type: Reg; Skip Register;
    Name => "ResolutionStage3AssociatedDataBubbleReqCfg",
    RegMem => "Reg",
    Address => "16F", # Excel Formula: =calc_reg_address(C425,A425,G425)
    Description => "Bubble request configurations for ResolutionStage3AssociatedData memory",
    Width => "16", # Excel Formula: =calc_reg_width(E428:E428,F428)
    Type => "Config",
    Comments => "EM Skip Reg",
    ResolutionStage3AssociatedDataBubbleTimerCfg => { #Structure Type: RegField;
      Name => "ResolutionStage3AssociatedDataBubbleTimerCfg",
      RegMem => "RegField",
      Description => "Number of consecutive pipe accesses before generating CPU bubble request",
      Width => "16",
      Position => "15:0", # Excel Formula: =calc_position(F427,E428,TRUE)
      Type => "Config",
      UsedBy => "MEM",
      DefaultValue => "d1",
    },
  },
  ResolutionStage0EmVerifier0BubbleReqCfg => { #Structure Type: Reg; ArrayLength: 12; ArrayIndex: 0; ArrayLocationInName: 27; Skip Register;
    Name => "ResolutionStage0EmVerifier[12]BubbleReqCfg",
    RegMem => "Reg",
    Address => "170", # Excel Formula: =calc_reg_address(C427,A427,G427)
    Description => "Bubble request configurations for ResolutionStage0EmVerifier[n] memory",
    Width => "16", # Excel Formula: =calc_reg_width(E430:E430,F430)
    Type => "Config",
    Comments => "EM Skip Reg",
    ArrayLength => "12",
    ArrayIndex => "0",
    ResolutionStage0EmVerifier0BubbleTimerCfg => { #Structure Type: RegField; ArrayLength: 12; ArrayIndex: 0; ArrayLocationInName: 27;
      Name => "ResolutionStage0EmVerifier[n]BubbleTimerCfg",
      RegMem => "RegField",
      Description => "Number of consecutive pipe accesses before generating CPU bubble request",
      Width => "16",
      Position => "15:0", # Excel Formula: =calc_position(F429,E430,TRUE)
      Type => "Config",
      UsedBy => "MEM",
      DefaultValue => "d1",
    },
  },
  ResolutionStage0EmVerifier1BubbleReqCfg => { #Structure Type: Reg; ArrayLength: 12; ArrayIndex: 1; ArrayLocationInName: 27; Skip Register;
    Name => "ResolutionStage0EmVerifier[12]BubbleReqCfg",
    RegMem => "Reg",
    Address => "171",
    Description => "Bubble request configurations for ResolutionStage0EmVerifier[n] memory",
    Width => "16", # Excel Formula: =calc_reg_width(E430:E430,F430)
    Type => "Config",
    Comments => "EM Skip Reg",
    ArrayLength => "12",
    ArrayIndex => "1",
    ResolutionStage0EmVerifier1BubbleTimerCfg => { #Structure Type: RegField; ArrayLength: 12; ArrayIndex: 1; ArrayLocationInName: 27;
      Name => "ResolutionStage0EmVerifier[n]BubbleTimerCfg",
      RegMem => "RegField",
      Description => "Number of consecutive pipe accesses before generating CPU bubble request",
      Width => "16",
      Position => "15:0", # Excel Formula: =calc_position(F429,E430,TRUE)
      Type => "Config",
      UsedBy => "MEM",
      DefaultValue => "d1",
    },
  },
  ResolutionStage0EmVerifier2BubbleReqCfg => { #Structure Type: Reg; ArrayLength: 12; ArrayIndex: 2; ArrayLocationInName: 27; Skip Register;
    Name => "ResolutionStage0EmVerifier[12]BubbleReqCfg",
    RegMem => "Reg",
    Address => "172",
    Description => "Bubble request configurations for ResolutionStage0EmVerifier[n] memory",
    Width => "16", # Excel Formula: =calc_reg_width(E430:E430,F430)
    Type => "Config",
    Comments => "EM Skip Reg",
    ArrayLength => "12",
    ArrayIndex => "2",
    ResolutionStage0EmVerifier2BubbleTimerCfg => { #Structure Type: RegField; ArrayLength: 12; ArrayIndex: 2; ArrayLocationInName: 27;
      Name => "ResolutionStage0EmVerifier[n]BubbleTimerCfg",
      RegMem => "RegField",
      Description => "Number of consecutive pipe accesses before generating CPU bubble request",
      Width => "16",
      Position => "15:0", # Excel Formula: =calc_position(F429,E430,TRUE)
      Type => "Config",
      UsedBy => "MEM",
      DefaultValue => "d1",
    },
  },
  ResolutionStage0EmVerifier3BubbleReqCfg => { #Structure Type: Reg; ArrayLength: 12; ArrayIndex: 3; ArrayLocationInName: 27; Skip Register;
    Name => "ResolutionStage0EmVerifier[12]BubbleReqCfg",
    RegMem => "Reg",
    Address => "173",
    Description => "Bubble request configurations for ResolutionStage0EmVerifier[n] memory",
    Width => "16", # Excel Formula: =calc_reg_width(E430:E430,F430)
    Type => "Config",
    Comments => "EM Skip Reg",
    ArrayLength => "12",
    ArrayIndex => "3",
    ResolutionStage0EmVerifier3BubbleTimerCfg => { #Structure Type: RegField; ArrayLength: 12; ArrayIndex: 3; ArrayLocationInName: 27;
      Name => "ResolutionStage0EmVerifier[n]BubbleTimerCfg",
      RegMem => "RegField",
      Description => "Number of consecutive pipe accesses before generating CPU bubble request",
      Width => "16",
      Position => "15:0", # Excel Formula: =calc_position(F429,E430,TRUE)
      Type => "Config",
      UsedBy => "MEM",
      DefaultValue => "d1",
    },
  },
  ResolutionStage0EmVerifier4BubbleReqCfg => { #Structure Type: Reg; ArrayLength: 12; ArrayIndex: 4; ArrayLocationInName: 27; Skip Register;
    Name => "ResolutionStage0EmVerifier[12]BubbleReqCfg",
    RegMem => "Reg",
    Address => "174",
    Description => "Bubble request configurations for ResolutionStage0EmVerifier[n] memory",
    Width => "16", # Excel Formula: =calc_reg_width(E430:E430,F430)
    Type => "Config",
    Comments => "EM Skip Reg",
    ArrayLength => "12",
    ArrayIndex => "4",
    ResolutionStage0EmVerifier4BubbleTimerCfg => { #Structure Type: RegField; ArrayLength: 12; ArrayIndex: 4; ArrayLocationInName: 27;
      Name => "ResolutionStage0EmVerifier[n]BubbleTimerCfg",
      RegMem => "RegField",
      Description => "Number of consecutive pipe accesses before generating CPU bubble request",
      Width => "16",
      Position => "15:0", # Excel Formula: =calc_position(F429,E430,TRUE)
      Type => "Config",
      UsedBy => "MEM",
      DefaultValue => "d1",
    },
  },
  ResolutionStage0EmVerifier5BubbleReqCfg => { #Structure Type: Reg; ArrayLength: 12; ArrayIndex: 5; ArrayLocationInName: 27; Skip Register;
    Name => "ResolutionStage0EmVerifier[12]BubbleReqCfg",
    RegMem => "Reg",
    Address => "175",
    Description => "Bubble request configurations for ResolutionStage0EmVerifier[n] memory",
    Width => "16", # Excel Formula: =calc_reg_width(E430:E430,F430)
    Type => "Config",
    Comments => "EM Skip Reg",
    ArrayLength => "12",
    ArrayIndex => "5",
    ResolutionStage0EmVerifier5BubbleTimerCfg => { #Structure Type: RegField; ArrayLength: 12; ArrayIndex: 5; ArrayLocationInName: 27;
      Name => "ResolutionStage0EmVerifier[n]BubbleTimerCfg",
      RegMem => "RegField",
      Description => "Number of consecutive pipe accesses before generating CPU bubble request",
      Width => "16",
      Position => "15:0", # Excel Formula: =calc_position(F429,E430,TRUE)
      Type => "Config",
      UsedBy => "MEM",
      DefaultValue => "d1",
    },
  },
  ResolutionStage0EmVerifier6BubbleReqCfg => { #Structure Type: Reg; ArrayLength: 12; ArrayIndex: 6; ArrayLocationInName: 27; Skip Register;
    Name => "ResolutionStage0EmVerifier[12]BubbleReqCfg",
    RegMem => "Reg",
    Address => "176",
    Description => "Bubble request configurations for ResolutionStage0EmVerifier[n] memory",
    Width => "16", # Excel Formula: =calc_reg_width(E430:E430,F430)
    Type => "Config",
    Comments => "EM Skip Reg",
    ArrayLength => "12",
    ArrayIndex => "6",
    ResolutionStage0EmVerifier6BubbleTimerCfg => { #Structure Type: RegField; ArrayLength: 12; ArrayIndex: 6; ArrayLocationInName: 27;
      Name => "ResolutionStage0EmVerifier[n]BubbleTimerCfg",
      RegMem => "RegField",
      Description => "Number of consecutive pipe accesses before generating CPU bubble request",
      Width => "16",
      Position => "15:0", # Excel Formula: =calc_position(F429,E430,TRUE)
      Type => "Config",
      UsedBy => "MEM",
      DefaultValue => "d1",
    },
  },
  ResolutionStage0EmVerifier7BubbleReqCfg => { #Structure Type: Reg; ArrayLength: 12; ArrayIndex: 7; ArrayLocationInName: 27; Skip Register;
    Name => "ResolutionStage0EmVerifier[12]BubbleReqCfg",
    RegMem => "Reg",
    Address => "177",
    Description => "Bubble request configurations for ResolutionStage0EmVerifier[n] memory",
    Width => "16", # Excel Formula: =calc_reg_width(E430:E430,F430)
    Type => "Config",
    Comments => "EM Skip Reg",
    ArrayLength => "12",
    ArrayIndex => "7",
    ResolutionStage0EmVerifier7BubbleTimerCfg => { #Structure Type: RegField; ArrayLength: 12; ArrayIndex: 7; ArrayLocationInName: 27;
      Name => "ResolutionStage0EmVerifier[n]BubbleTimerCfg",
      RegMem => "RegField",
      Description => "Number of consecutive pipe accesses before generating CPU bubble request",
      Width => "16",
      Position => "15:0", # Excel Formula: =calc_position(F429,E430,TRUE)
      Type => "Config",
      UsedBy => "MEM",
      DefaultValue => "d1",
    },
  },
  ResolutionStage0EmVerifier8BubbleReqCfg => { #Structure Type: Reg; ArrayLength: 12; ArrayIndex: 8; ArrayLocationInName: 27; Skip Register;
    Name => "ResolutionStage0EmVerifier[12]BubbleReqCfg",
    RegMem => "Reg",
    Address => "178",
    Description => "Bubble request configurations for ResolutionStage0EmVerifier[n] memory",
    Width => "16", # Excel Formula: =calc_reg_width(E430:E430,F430)
    Type => "Config",
    Comments => "EM Skip Reg",
    ArrayLength => "12",
    ArrayIndex => "8",
    ResolutionStage0EmVerifier8BubbleTimerCfg => { #Structure Type: RegField; ArrayLength: 12; ArrayIndex: 8; ArrayLocationInName: 27;
      Name => "ResolutionStage0EmVerifier[n]BubbleTimerCfg",
      RegMem => "RegField",
      Description => "Number of consecutive pipe accesses before generating CPU bubble request",
      Width => "16",
      Position => "15:0", # Excel Formula: =calc_position(F429,E430,TRUE)
      Type => "Config",
      UsedBy => "MEM",
      DefaultValue => "d1",
    },
  },
  ResolutionStage0EmVerifier9BubbleReqCfg => { #Structure Type: Reg; ArrayLength: 12; ArrayIndex: 9; ArrayLocationInName: 27; Skip Register;
    Name => "ResolutionStage0EmVerifier[12]BubbleReqCfg",
    RegMem => "Reg",
    Address => "179",
    Description => "Bubble request configurations for ResolutionStage0EmVerifier[n] memory",
    Width => "16", # Excel Formula: =calc_reg_width(E430:E430,F430)
    Type => "Config",
    Comments => "EM Skip Reg",
    ArrayLength => "12",
    ArrayIndex => "9",
    ResolutionStage0EmVerifier9BubbleTimerCfg => { #Structure Type: RegField; ArrayLength: 12; ArrayIndex: 9; ArrayLocationInName: 27;
      Name => "ResolutionStage0EmVerifier[n]BubbleTimerCfg",
      RegMem => "RegField",
      Description => "Number of consecutive pipe accesses before generating CPU bubble request",
      Width => "16",
      Position => "15:0", # Excel Formula: =calc_position(F429,E430,TRUE)
      Type => "Config",
      UsedBy => "MEM",
      DefaultValue => "d1",
    },
  },
  ResolutionStage0EmVerifier10BubbleReqCfg => { #Structure Type: Reg; ArrayLength: 12; ArrayIndex: 10; ArrayLocationInName: 27; Skip Register;
    Name => "ResolutionStage0EmVerifier[12]BubbleReqCfg",
    RegMem => "Reg",
    Address => "17A",
    Description => "Bubble request configurations for ResolutionStage0EmVerifier[n] memory",
    Width => "16", # Excel Formula: =calc_reg_width(E430:E430,F430)
    Type => "Config",
    Comments => "EM Skip Reg",
    ArrayLength => "12",
    ArrayIndex => "10",
    ResolutionStage0EmVerifier10BubbleTimerCfg => { #Structure Type: RegField; ArrayLength: 12; ArrayIndex: 10; ArrayLocationInName: 27;
      Name => "ResolutionStage0EmVerifier[n]BubbleTimerCfg",
      RegMem => "RegField",
      Description => "Number of consecutive pipe accesses before generating CPU bubble request",
      Width => "16",
      Position => "15:0", # Excel Formula: =calc_position(F429,E430,TRUE)
      Type => "Config",
      UsedBy => "MEM",
      DefaultValue => "d1",
    },
  },
  ResolutionStage0EmVerifier11BubbleReqCfg => { #Structure Type: Reg; ArrayLength: 12; ArrayIndex: 11; ArrayLocationInName: 27; Skip Register;
    Name => "ResolutionStage0EmVerifier[12]BubbleReqCfg",
    RegMem => "Reg",
    Address => "17B",
    Description => "Bubble request configurations for ResolutionStage0EmVerifier[n] memory",
    Width => "16", # Excel Formula: =calc_reg_width(E430:E430,F430)
    Type => "Config",
    Comments => "EM Skip Reg",
    ArrayLength => "12",
    ArrayIndex => "11",
    ResolutionStage0EmVerifier11BubbleTimerCfg => { #Structure Type: RegField; ArrayLength: 12; ArrayIndex: 11; ArrayLocationInName: 27;
      Name => "ResolutionStage0EmVerifier[n]BubbleTimerCfg",
      RegMem => "RegField",
      Description => "Number of consecutive pipe accesses before generating CPU bubble request",
      Width => "16",
      Position => "15:0", # Excel Formula: =calc_position(F429,E430,TRUE)
      Type => "Config",
      UsedBy => "MEM",
      DefaultValue => "d1",
    },
  },
  LpQueuingEmVerifier0BubbleReqCfg => { #Structure Type: Reg; ArrayLength: 5; ArrayIndex: 0; ArrayLocationInName: 20; Skip Register;
    Name => "LpQueuingEmVerifier[5]BubbleReqCfg",
    RegMem => "Reg",
    Address => "17C", # Excel Formula: =calc_reg_address(C429,A429,G429)
    Description => "Bubble request configurations for LpQueuingEmVerifier[n] memory",
    Width => "16", # Excel Formula: =calc_reg_width(E432:E432,F432)
    Type => "Config",
    Comments => "EM Skip Reg",
    ArrayLength => "5",
    ArrayIndex => "0",
    LpQueuingEmVerifier0BubbleTimerCfg => { #Structure Type: RegField; ArrayLength: 5; ArrayIndex: 0; ArrayLocationInName: 20;
      Name => "LpQueuingEmVerifier[n]BubbleTimerCfg",
      RegMem => "RegField",
      Description => "Number of consecutive pipe accesses before generating CPU bubble request",
      Width => "16",
      Position => "15:0", # Excel Formula: =calc_position(F431,E432,TRUE)
      Type => "Config",
      UsedBy => "MEM",
      DefaultValue => "d1",
    },
  },
  LpQueuingEmVerifier1BubbleReqCfg => { #Structure Type: Reg; ArrayLength: 5; ArrayIndex: 1; ArrayLocationInName: 20; Skip Register;
    Name => "LpQueuingEmVerifier[5]BubbleReqCfg",
    RegMem => "Reg",
    Address => "17D",
    Description => "Bubble request configurations for LpQueuingEmVerifier[n] memory",
    Width => "16", # Excel Formula: =calc_reg_width(E432:E432,F432)
    Type => "Config",
    Comments => "EM Skip Reg",
    ArrayLength => "5",
    ArrayIndex => "1",
    LpQueuingEmVerifier1BubbleTimerCfg => { #Structure Type: RegField; ArrayLength: 5; ArrayIndex: 1; ArrayLocationInName: 20;
      Name => "LpQueuingEmVerifier[n]BubbleTimerCfg",
      RegMem => "RegField",
      Description => "Number of consecutive pipe accesses before generating CPU bubble request",
      Width => "16",
      Position => "15:0", # Excel Formula: =calc_position(F431,E432,TRUE)
      Type => "Config",
      UsedBy => "MEM",
      DefaultValue => "d1",
    },
  },
  LpQueuingEmVerifier2BubbleReqCfg => { #Structure Type: Reg; ArrayLength: 5; ArrayIndex: 2; ArrayLocationInName: 20; Skip Register;
    Name => "LpQueuingEmVerifier[5]BubbleReqCfg",
    RegMem => "Reg",
    Address => "17E",
    Description => "Bubble request configurations for LpQueuingEmVerifier[n] memory",
    Width => "16", # Excel Formula: =calc_reg_width(E432:E432,F432)
    Type => "Config",
    Comments => "EM Skip Reg",
    ArrayLength => "5",
    ArrayIndex => "2",
    LpQueuingEmVerifier2BubbleTimerCfg => { #Structure Type: RegField; ArrayLength: 5; ArrayIndex: 2; ArrayLocationInName: 20;
      Name => "LpQueuingEmVerifier[n]BubbleTimerCfg",
      RegMem => "RegField",
      Description => "Number of consecutive pipe accesses before generating CPU bubble request",
      Width => "16",
      Position => "15:0", # Excel Formula: =calc_position(F431,E432,TRUE)
      Type => "Config",
      UsedBy => "MEM",
      DefaultValue => "d1",
    },
  },
  LpQueuingEmVerifier3BubbleReqCfg => { #Structure Type: Reg; ArrayLength: 5; ArrayIndex: 3; ArrayLocationInName: 20; Skip Register;
    Name => "LpQueuingEmVerifier[5]BubbleReqCfg",
    RegMem => "Reg",
    Address => "17F",
    Description => "Bubble request configurations for LpQueuingEmVerifier[n] memory",
    Width => "16", # Excel Formula: =calc_reg_width(E432:E432,F432)
    Type => "Config",
    Comments => "EM Skip Reg",
    ArrayLength => "5",
    ArrayIndex => "3",
    LpQueuingEmVerifier3BubbleTimerCfg => { #Structure Type: RegField; ArrayLength: 5; ArrayIndex: 3; ArrayLocationInName: 20;
      Name => "LpQueuingEmVerifier[n]BubbleTimerCfg",
      RegMem => "RegField",
      Description => "Number of consecutive pipe accesses before generating CPU bubble request",
      Width => "16",
      Position => "15:0", # Excel Formula: =calc_position(F431,E432,TRUE)
      Type => "Config",
      UsedBy => "MEM",
      DefaultValue => "d1",
    },
  },
  LpQueuingEmVerifier4BubbleReqCfg => { #Structure Type: Reg; ArrayLength: 5; ArrayIndex: 4; ArrayLocationInName: 20; Skip Register;
    Name => "LpQueuingEmVerifier[5]BubbleReqCfg",
    RegMem => "Reg",
    Address => "180",
    Description => "Bubble request configurations for LpQueuingEmVerifier[n] memory",
    Width => "16", # Excel Formula: =calc_reg_width(E432:E432,F432)
    Type => "Config",
    Comments => "EM Skip Reg",
    ArrayLength => "5",
    ArrayIndex => "4",
    LpQueuingEmVerifier4BubbleTimerCfg => { #Structure Type: RegField; ArrayLength: 5; ArrayIndex: 4; ArrayLocationInName: 20;
      Name => "LpQueuingEmVerifier[n]BubbleTimerCfg",
      RegMem => "RegField",
      Description => "Number of consecutive pipe accesses before generating CPU bubble request",
      Width => "16",
      Position => "15:0", # Excel Formula: =calc_position(F431,E432,TRUE)
      Type => "Config",
      UsedBy => "MEM",
      DefaultValue => "d1",
    },
  },
  ResolutionStage1EmVerifier0BubbleReqCfg => { #Structure Type: Reg; ArrayLength: 4; ArrayIndex: 0; ArrayLocationInName: 27; Skip Register;
    Name => "ResolutionStage1EmVerifier[4]BubbleReqCfg",
    RegMem => "Reg",
    Address => "181", # Excel Formula: =calc_reg_address(C431,A431,G431)
    Description => "Bubble request configurations for ResolutionStage1EmVerifier[n] memory",
    Width => "16", # Excel Formula: =calc_reg_width(E434:E434,F434)
    Type => "Config",
    Comments => "EM Skip Reg",
    ArrayLength => "4",
    ArrayIndex => "0",
    ResolutionStage1EmVerifier0BubbleTimerCfg => { #Structure Type: RegField; ArrayLength: 4; ArrayIndex: 0; ArrayLocationInName: 27;
      Name => "ResolutionStage1EmVerifier[n]BubbleTimerCfg",
      RegMem => "RegField",
      Description => "Number of consecutive pipe accesses before generating CPU bubble request",
      Width => "16",
      Position => "15:0", # Excel Formula: =calc_position(F433,E434,TRUE)
      Type => "Config",
      UsedBy => "MEM",
      DefaultValue => "d1",
    },
  },
  ResolutionStage1EmVerifier1BubbleReqCfg => { #Structure Type: Reg; ArrayLength: 4; ArrayIndex: 1; ArrayLocationInName: 27; Skip Register;
    Name => "ResolutionStage1EmVerifier[4]BubbleReqCfg",
    RegMem => "Reg",
    Address => "182",
    Description => "Bubble request configurations for ResolutionStage1EmVerifier[n] memory",
    Width => "16", # Excel Formula: =calc_reg_width(E434:E434,F434)
    Type => "Config",
    Comments => "EM Skip Reg",
    ArrayLength => "4",
    ArrayIndex => "1",
    ResolutionStage1EmVerifier1BubbleTimerCfg => { #Structure Type: RegField; ArrayLength: 4; ArrayIndex: 1; ArrayLocationInName: 27;
      Name => "ResolutionStage1EmVerifier[n]BubbleTimerCfg",
      RegMem => "RegField",
      Description => "Number of consecutive pipe accesses before generating CPU bubble request",
      Width => "16",
      Position => "15:0", # Excel Formula: =calc_position(F433,E434,TRUE)
      Type => "Config",
      UsedBy => "MEM",
      DefaultValue => "d1",
    },
  },
  ResolutionStage1EmVerifier2BubbleReqCfg => { #Structure Type: Reg; ArrayLength: 4; ArrayIndex: 2; ArrayLocationInName: 27; Skip Register;
    Name => "ResolutionStage1EmVerifier[4]BubbleReqCfg",
    RegMem => "Reg",
    Address => "183",
    Description => "Bubble request configurations for ResolutionStage1EmVerifier[n] memory",
    Width => "16", # Excel Formula: =calc_reg_width(E434:E434,F434)
    Type => "Config",
    Comments => "EM Skip Reg",
    ArrayLength => "4",
    ArrayIndex => "2",
    ResolutionStage1EmVerifier2BubbleTimerCfg => { #Structure Type: RegField; ArrayLength: 4; ArrayIndex: 2; ArrayLocationInName: 27;
      Name => "ResolutionStage1EmVerifier[n]BubbleTimerCfg",
      RegMem => "RegField",
      Description => "Number of consecutive pipe accesses before generating CPU bubble request",
      Width => "16",
      Position => "15:0", # Excel Formula: =calc_position(F433,E434,TRUE)
      Type => "Config",
      UsedBy => "MEM",
      DefaultValue => "d1",
    },
  },
  ResolutionStage1EmVerifier3BubbleReqCfg => { #Structure Type: Reg; ArrayLength: 4; ArrayIndex: 3; ArrayLocationInName: 27; Skip Register;
    Name => "ResolutionStage1EmVerifier[4]BubbleReqCfg",
    RegMem => "Reg",
    Address => "184",
    Description => "Bubble request configurations for ResolutionStage1EmVerifier[n] memory",
    Width => "16", # Excel Formula: =calc_reg_width(E434:E434,F434)
    Type => "Config",
    Comments => "EM Skip Reg",
    ArrayLength => "4",
    ArrayIndex => "3",
    ResolutionStage1EmVerifier3BubbleTimerCfg => { #Structure Type: RegField; ArrayLength: 4; ArrayIndex: 3; ArrayLocationInName: 27;
      Name => "ResolutionStage1EmVerifier[n]BubbleTimerCfg",
      RegMem => "RegField",
      Description => "Number of consecutive pipe accesses before generating CPU bubble request",
      Width => "16",
      Position => "15:0", # Excel Formula: =calc_position(F433,E434,TRUE)
      Type => "Config",
      UsedBy => "MEM",
      DefaultValue => "d1",
    },
  },
  ResolutionStage2EmVerifier0BubbleReqCfg => { #Structure Type: Reg; ArrayLength: 4; ArrayIndex: 0; ArrayLocationInName: 27; Skip Register;
    Name => "ResolutionStage2EmVerifier[4]BubbleReqCfg",
    RegMem => "Reg",
    Address => "185", # Excel Formula: =calc_reg_address(C433,A433,G433)
    Description => "Bubble request configurations for ResolutionStage2EmVerifier[n] memory",
    Width => "16", # Excel Formula: =calc_reg_width(E436:E436,F436)
    Type => "Config",
    Comments => "EM Skip Reg",
    ArrayLength => "4",
    ArrayIndex => "0",
    ResolutionStage2EmVerifier0BubbleTimerCfg => { #Structure Type: RegField; ArrayLength: 4; ArrayIndex: 0; ArrayLocationInName: 27;
      Name => "ResolutionStage2EmVerifier[n]BubbleTimerCfg",
      RegMem => "RegField",
      Description => "Number of consecutive pipe accesses before generating CPU bubble request",
      Width => "16",
      Position => "15:0", # Excel Formula: =calc_position(F435,E436,TRUE)
      Type => "Config",
      UsedBy => "MEM",
      DefaultValue => "d1",
    },
  },
  ResolutionStage2EmVerifier1BubbleReqCfg => { #Structure Type: Reg; ArrayLength: 4; ArrayIndex: 1; ArrayLocationInName: 27; Skip Register;
    Name => "ResolutionStage2EmVerifier[4]BubbleReqCfg",
    RegMem => "Reg",
    Address => "186",
    Description => "Bubble request configurations for ResolutionStage2EmVerifier[n] memory",
    Width => "16", # Excel Formula: =calc_reg_width(E436:E436,F436)
    Type => "Config",
    Comments => "EM Skip Reg",
    ArrayLength => "4",
    ArrayIndex => "1",
    ResolutionStage2EmVerifier1BubbleTimerCfg => { #Structure Type: RegField; ArrayLength: 4; ArrayIndex: 1; ArrayLocationInName: 27;
      Name => "ResolutionStage2EmVerifier[n]BubbleTimerCfg",
      RegMem => "RegField",
      Description => "Number of consecutive pipe accesses before generating CPU bubble request",
      Width => "16",
      Position => "15:0", # Excel Formula: =calc_position(F435,E436,TRUE)
      Type => "Config",
      UsedBy => "MEM",
      DefaultValue => "d1",
    },
  },
  ResolutionStage2EmVerifier2BubbleReqCfg => { #Structure Type: Reg; ArrayLength: 4; ArrayIndex: 2; ArrayLocationInName: 27; Skip Register;
    Name => "ResolutionStage2EmVerifier[4]BubbleReqCfg",
    RegMem => "Reg",
    Address => "187",
    Description => "Bubble request configurations for ResolutionStage2EmVerifier[n] memory",
    Width => "16", # Excel Formula: =calc_reg_width(E436:E436,F436)
    Type => "Config",
    Comments => "EM Skip Reg",
    ArrayLength => "4",
    ArrayIndex => "2",
    ResolutionStage2EmVerifier2BubbleTimerCfg => { #Structure Type: RegField; ArrayLength: 4; ArrayIndex: 2; ArrayLocationInName: 27;
      Name => "ResolutionStage2EmVerifier[n]BubbleTimerCfg",
      RegMem => "RegField",
      Description => "Number of consecutive pipe accesses before generating CPU bubble request",
      Width => "16",
      Position => "15:0", # Excel Formula: =calc_position(F435,E436,TRUE)
      Type => "Config",
      UsedBy => "MEM",
      DefaultValue => "d1",
    },
  },
  ResolutionStage2EmVerifier3BubbleReqCfg => { #Structure Type: Reg; ArrayLength: 4; ArrayIndex: 3; ArrayLocationInName: 27; Skip Register;
    Name => "ResolutionStage2EmVerifier[4]BubbleReqCfg",
    RegMem => "Reg",
    Address => "188",
    Description => "Bubble request configurations for ResolutionStage2EmVerifier[n] memory",
    Width => "16", # Excel Formula: =calc_reg_width(E436:E436,F436)
    Type => "Config",
    Comments => "EM Skip Reg",
    ArrayLength => "4",
    ArrayIndex => "3",
    ResolutionStage2EmVerifier3BubbleTimerCfg => { #Structure Type: RegField; ArrayLength: 4; ArrayIndex: 3; ArrayLocationInName: 27;
      Name => "ResolutionStage2EmVerifier[n]BubbleTimerCfg",
      RegMem => "RegField",
      Description => "Number of consecutive pipe accesses before generating CPU bubble request",
      Width => "16",
      Position => "15:0", # Excel Formula: =calc_position(F435,E436,TRUE)
      Type => "Config",
      UsedBy => "MEM",
      DefaultValue => "d1",
    },
  },
  ResolutionStage3EmVerifier0BubbleReqCfg => { #Structure Type: Reg; ArrayLength: 6; ArrayIndex: 0; ArrayLocationInName: 27; Skip Register;
    Name => "ResolutionStage3EmVerifier[6]BubbleReqCfg",
    RegMem => "Reg",
    Address => "189", # Excel Formula: =calc_reg_address(C435,A435,G435)
    Description => "Bubble request configurations for ResolutionStage3EmVerifier[n] memory",
    Width => "16", # Excel Formula: =calc_reg_width(E438:E438,F438)
    Type => "Config",
    Comments => "EM Skip Reg",
    ArrayLength => "6",
    ArrayIndex => "0",
    ResolutionStage3EmVerifier0BubbleTimerCfg => { #Structure Type: RegField; ArrayLength: 6; ArrayIndex: 0; ArrayLocationInName: 27;
      Name => "ResolutionStage3EmVerifier[n]BubbleTimerCfg",
      RegMem => "RegField",
      Description => "Number of consecutive pipe accesses before generating CPU bubble request",
      Width => "16",
      Position => "15:0", # Excel Formula: =calc_position(F437,E438,TRUE)
      Type => "Config",
      UsedBy => "MEM",
      DefaultValue => "d1",
    },
  },
  ResolutionStage3EmVerifier1BubbleReqCfg => { #Structure Type: Reg; ArrayLength: 6; ArrayIndex: 1; ArrayLocationInName: 27; Skip Register;
    Name => "ResolutionStage3EmVerifier[6]BubbleReqCfg",
    RegMem => "Reg",
    Address => "18A",
    Description => "Bubble request configurations for ResolutionStage3EmVerifier[n] memory",
    Width => "16", # Excel Formula: =calc_reg_width(E438:E438,F438)
    Type => "Config",
    Comments => "EM Skip Reg",
    ArrayLength => "6",
    ArrayIndex => "1",
    ResolutionStage3EmVerifier1BubbleTimerCfg => { #Structure Type: RegField; ArrayLength: 6; ArrayIndex: 1; ArrayLocationInName: 27;
      Name => "ResolutionStage3EmVerifier[n]BubbleTimerCfg",
      RegMem => "RegField",
      Description => "Number of consecutive pipe accesses before generating CPU bubble request",
      Width => "16",
      Position => "15:0", # Excel Formula: =calc_position(F437,E438,TRUE)
      Type => "Config",
      UsedBy => "MEM",
      DefaultValue => "d1",
    },
  },
  ResolutionStage3EmVerifier2BubbleReqCfg => { #Structure Type: Reg; ArrayLength: 6; ArrayIndex: 2; ArrayLocationInName: 27; Skip Register;
    Name => "ResolutionStage3EmVerifier[6]BubbleReqCfg",
    RegMem => "Reg",
    Address => "18B",
    Description => "Bubble request configurations for ResolutionStage3EmVerifier[n] memory",
    Width => "16", # Excel Formula: =calc_reg_width(E438:E438,F438)
    Type => "Config",
    Comments => "EM Skip Reg",
    ArrayLength => "6",
    ArrayIndex => "2",
    ResolutionStage3EmVerifier2BubbleTimerCfg => { #Structure Type: RegField; ArrayLength: 6; ArrayIndex: 2; ArrayLocationInName: 27;
      Name => "ResolutionStage3EmVerifier[n]BubbleTimerCfg",
      RegMem => "RegField",
      Description => "Number of consecutive pipe accesses before generating CPU bubble request",
      Width => "16",
      Position => "15:0", # Excel Formula: =calc_position(F437,E438,TRUE)
      Type => "Config",
      UsedBy => "MEM",
      DefaultValue => "d1",
    },
  },
  ResolutionStage3EmVerifier3BubbleReqCfg => { #Structure Type: Reg; ArrayLength: 6; ArrayIndex: 3; ArrayLocationInName: 27; Skip Register;
    Name => "ResolutionStage3EmVerifier[6]BubbleReqCfg",
    RegMem => "Reg",
    Address => "18C",
    Description => "Bubble request configurations for ResolutionStage3EmVerifier[n] memory",
    Width => "16", # Excel Formula: =calc_reg_width(E438:E438,F438)
    Type => "Config",
    Comments => "EM Skip Reg",
    ArrayLength => "6",
    ArrayIndex => "3",
    ResolutionStage3EmVerifier3BubbleTimerCfg => { #Structure Type: RegField; ArrayLength: 6; ArrayIndex: 3; ArrayLocationInName: 27;
      Name => "ResolutionStage3EmVerifier[n]BubbleTimerCfg",
      RegMem => "RegField",
      Description => "Number of consecutive pipe accesses before generating CPU bubble request",
      Width => "16",
      Position => "15:0", # Excel Formula: =calc_position(F437,E438,TRUE)
      Type => "Config",
      UsedBy => "MEM",
      DefaultValue => "d1",
    },
  },
  ResolutionStage3EmVerifier4BubbleReqCfg => { #Structure Type: Reg; ArrayLength: 6; ArrayIndex: 4; ArrayLocationInName: 27; Skip Register;
    Name => "ResolutionStage3EmVerifier[6]BubbleReqCfg",
    RegMem => "Reg",
    Address => "18D",
    Description => "Bubble request configurations for ResolutionStage3EmVerifier[n] memory",
    Width => "16", # Excel Formula: =calc_reg_width(E438:E438,F438)
    Type => "Config",
    Comments => "EM Skip Reg",
    ArrayLength => "6",
    ArrayIndex => "4",
    ResolutionStage3EmVerifier4BubbleTimerCfg => { #Structure Type: RegField; ArrayLength: 6; ArrayIndex: 4; ArrayLocationInName: 27;
      Name => "ResolutionStage3EmVerifier[n]BubbleTimerCfg",
      RegMem => "RegField",
      Description => "Number of consecutive pipe accesses before generating CPU bubble request",
      Width => "16",
      Position => "15:0", # Excel Formula: =calc_position(F437,E438,TRUE)
      Type => "Config",
      UsedBy => "MEM",
      DefaultValue => "d1",
    },
  },
  ResolutionStage3EmVerifier5BubbleReqCfg => { #Structure Type: Reg; ArrayLength: 6; ArrayIndex: 5; ArrayLocationInName: 27; Skip Register;
    Name => "ResolutionStage3EmVerifier[6]BubbleReqCfg",
    RegMem => "Reg",
    Address => "18E",
    Description => "Bubble request configurations for ResolutionStage3EmVerifier[n] memory",
    Width => "16", # Excel Formula: =calc_reg_width(E438:E438,F438)
    Type => "Config",
    Comments => "EM Skip Reg",
    ArrayLength => "6",
    ArrayIndex => "5",
    ResolutionStage3EmVerifier5BubbleTimerCfg => { #Structure Type: RegField; ArrayLength: 6; ArrayIndex: 5; ArrayLocationInName: 27;
      Name => "ResolutionStage3EmVerifier[n]BubbleTimerCfg",
      RegMem => "RegField",
      Description => "Number of consecutive pipe accesses before generating CPU bubble request",
      Width => "16",
      Position => "15:0", # Excel Formula: =calc_position(F437,E438,TRUE)
      Type => "Config",
      UsedBy => "MEM",
      DefaultValue => "d1",
    },
  },
};
