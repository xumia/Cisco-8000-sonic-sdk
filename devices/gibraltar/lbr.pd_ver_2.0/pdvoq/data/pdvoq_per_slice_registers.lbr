$block{PDVOQ_SLICE} = {
  Defines_db => "..\\verilog\\pdvoq_defines.v,..\\..\\defines\\pd_fd_defines.v,..\\..\\defines\\control_common_defines.v,..\\..\\voq_cgm\\verilog\\voq_cgm_defines.v,..\\..\\defines\\gibraltar_common_defines.v",
  ProjectName => "Gibraltar",
  InterruptRegister => { #Structure Type: Reg; Skip Register;
    Name => "InterruptRegister",
    RegMem => "Reg",
    Address => "0",
    Description => "Master Interrupt Register",
    Width => "2",
    Type => "Interrupt",
    MemProtectInterruptSummary => { #Structure Type: RegField;
      Name => "MemProtectInterruptSummary",
      RegMem => "RegField",
      Description => "When this bit is set, MemProtectInterrupt has asserted interrupt",
      Width => "1",
      Position => "0",
      Type => "Interrupt",
    },
    GeneralInterruptRegisterSummary => { #Structure Type: RegField;
      Name => "GeneralInterruptRegisterSummary",
      RegMem => "RegField",
      Description => "When this bit is set, GeneralInterruptRegister has asserted interrupt",
      Width => "1",
      Position => "1",
      Type => "Interrupt",
    },
  },
  MemProtectInterrupt => { #Structure Type: Reg; Skip Register;
    Name => "MemProtectInterrupt",
    RegMem => "Reg",
    Address => "1",
    Description => "ECC/Parity Interrupt Register",
    Width => "3",
    Type => "Interrupt",
    Ecc_1bErrInterrupt => { #Structure Type: RegField;
      Name => "Ecc_1bErrInterrupt",
      RegMem => "RegField",
      Description => "When this bit is set, ECC 1b error was detected",
      Width => "1",
      Position => "0",
      Type => "Interrupt",
      UsedBy => "SER",
    },
    Ecc_2bErrInterrupt => { #Structure Type: RegField;
      Name => "Ecc_2bErrInterrupt",
      RegMem => "RegField",
      Description => "When this bit is set, ECC 2b error was detected",
      Width => "1",
      Position => "1",
      Type => "Interrupt",
      UsedBy => "SER",
    },
    ParityErrInterrupt => { #Structure Type: RegField;
      Name => "ParityErrInterrupt",
      RegMem => "RegField",
      Description => "When this bit is set, Parity error was detected",
      Width => "1",
      Position => "2",
      Type => "Interrupt",
      UsedBy => "SER",
    },
  },
  MemProtectInterruptTest => { #Structure Type: Reg; Skip Register;
    Name => "MemProtectInterruptTest",
    RegMem => "Reg",
    Address => "2",
    Description => "ECC/Parity Interrupt test register",
    Width => "3",
    Type => "InterruptTest",
    Ecc_1bErrInterruptTest => { #Structure Type: RegField;
      Name => "Ecc_1bErrInterruptTest",
      RegMem => "RegField",
      Description => "Setting this filed to 1 triggers an assertion of the interrupt that is associated with this test field",
      Width => "1",
      Position => "0",
      Type => "InterruptTest",
      UsedBy => "",
      DefaultValue => "b0",
    },
    Ecc_2bErrInterruptTest => { #Structure Type: RegField;
      Name => "Ecc_2bErrInterruptTest",
      RegMem => "RegField",
      Description => "Setting this filed to 1 triggers an assertion of the interrupt that is associated with this test field",
      Width => "1",
      Position => "1",
      Type => "InterruptTest",
      UsedBy => "",
      DefaultValue => "b0",
    },
    ParityErrInterruptTest => { #Structure Type: RegField;
      Name => "ParityErrInterruptTest",
      RegMem => "RegField",
      Description => "Setting this filed to 1 triggers an assertion of the interrupt that is associated with this test field",
      Width => "1",
      Position => "2",
      Type => "InterruptTest",
      UsedBy => "",
      DefaultValue => "b0",
    },
  },
  Ecc_1bErrInterruptRegisterMask => { #Structure Type: Reg; Skip Register;
    Name => "Ecc_1bErrInterruptRegisterMask",
    RegMem => "Reg",
    Address => "3",
    Description => "ECC 1b Error Interrupt Mask Register",
    Width => "53",
    Type => "Config",
    rdrqsnEcc_1bErrInterruptMask => { #Structure Type: RegField;
      Name => "rdrqsnEcc_1bErrInterruptMask",
      RegMem => "RegField",
      Description => "When this bit is set, ECC 1b Error indication will be masked",
      Width => "1",
      Position => "0",
      Type => "Config",
      UsedBy => "SER",
      DefaultValue => "b1",
    },
    rdsnEcc_1bErrInterruptMask => { #Structure Type: RegField;
      Name => "rdsnEcc_1bErrInterruptMask",
      RegMem => "RegField",
      Description => "When this bit is set, ECC 1b Error indication will be masked",
      Width => "1",
      Position => "1",
      Type => "Config",
      UsedBy => "SER",
      DefaultValue => "b1",
    },
    rdbcEcc_1bErrInterruptMask => { #Structure Type: RegField;
      Name => "rdbcEcc_1bErrInterruptMask",
      RegMem => "RegField",
      Description => "When this bit is set, ECC 1b Error indication will be masked",
      Width => "1",
      Position => "2",
      Type => "Config",
      UsedBy => "SER",
      DefaultValue => "b1",
    },
    rdbufcntEcc_1bErrInterruptMask => { #Structure Type: RegField;
      Name => "rdbufcntEcc_1bErrInterruptMask",
      RegMem => "RegField",
      Description => "When this bit is set, ECC 1b Error indication will be masked",
      Width => "1",
      Position => "3",
      Type => "Config",
      UsedBy => "SER",
      DefaultValue => "b1",
    },
    wrrqsnEcc_1bErrInterruptMask => { #Structure Type: RegField;
      Name => "wrrqsnEcc_1bErrInterruptMask",
      RegMem => "RegField",
      Description => "When this bit is set, ECC 1b Error indication will be masked",
      Width => "1",
      Position => "4",
      Type => "Config",
      UsedBy => "SER",
      DefaultValue => "b1",
    },
    wrsnEcc_1bErrInterruptMask => { #Structure Type: RegField;
      Name => "wrsnEcc_1bErrInterruptMask",
      RegMem => "RegField",
      Description => "When this bit is set, ECC 1b Error indication will be masked",
      Width => "1",
      Position => "5",
      Type => "Config",
      UsedBy => "SER",
      DefaultValue => "b1",
    },
    wrbcEcc_1bErrInterruptMask => { #Structure Type: RegField;
      Name => "wrbcEcc_1bErrInterruptMask",
      RegMem => "RegField",
      Description => "When this bit is set, ECC 1b Error indication will be masked",
      Width => "1",
      Position => "6",
      Type => "Config",
      UsedBy => "SER",
      DefaultValue => "b1",
    },
    wrbufcntEcc_1bErrInterruptMask => { #Structure Type: RegField;
      Name => "wrbufcntEcc_1bErrInterruptMask",
      RegMem => "RegField",
      Description => "When this bit is set, ECC 1b Error indication will be masked",
      Width => "1",
      Position => "7",
      Type => "Config",
      UsedBy => "SER",
      DefaultValue => "b1",
    },
    voq2contextEcc_1bErrInterruptMask => { #Structure Type: RegField;
      Name => "voq2contextEcc_1bErrInterruptMask",
      RegMem => "RegField",
      Description => "When this bit is set, ECC 1b Error indication will be masked",
      Width => "1",
      Position => "8",
      Type => "Config",
      UsedBy => "SER",
      DefaultValue => "b1",
    },
    CandRelFifoEcc_1bErrInterruptMask => { #Structure Type: RegField;
      Name => "CandRelFifoEcc_1bErrInterruptMask",
      RegMem => "RegField",
      Description => "When this bit is set, ECC 1b Error indication will be masked",
      Width => "1",
      Position => "9",
      Type => "Config",
      UsedBy => "SER",
      DefaultValue => "b1",
    },
    InCandRelFifoSetEcc_1bErrInterruptMask => { #Structure Type: RegField;
      Name => "InCandRelFifoSetEcc_1bErrInterruptMask",
      RegMem => "RegField",
      Description => "When this bit is set, ECC 1b Error indication will be masked",
      Width => "1",
      Position => "10",
      Type => "Config",
      UsedBy => "SER",
      DefaultValue => "b1",
    },
    InCandRelFifoClrEcc_1bErrInterruptMask => { #Structure Type: RegField;
      Name => "InCandRelFifoClrEcc_1bErrInterruptMask",
      RegMem => "RegField",
      Description => "When this bit is set, ECC 1b Error indication will be masked",
      Width => "1",
      Position => "11",
      Type => "Config",
      UsedBy => "SER",
      DefaultValue => "b1",
    },
    ContextReleaseEligibleSetEcc_1bErrInterruptMask => { #Structure Type: RegField;
      Name => "ContextReleaseEligibleSetEcc_1bErrInterruptMask",
      RegMem => "RegField",
      Description => "When this bit is set, ECC 1b Error indication will be masked",
      Width => "1",
      Position => "12",
      Type => "Config",
      UsedBy => "SER",
      DefaultValue => "b1",
    },
    ContextReleaseEligibleClrEcc_1bErrInterruptMask => { #Structure Type: RegField;
      Name => "ContextReleaseEligibleClrEcc_1bErrInterruptMask",
      RegMem => "RegField",
      Description => "When this bit is set, ECC 1b Error indication will be masked",
      Width => "1",
      Position => "13",
      Type => "Config",
      UsedBy => "SER",
      DefaultValue => "b1",
    },
    ContextInDramSetEcc_1bErrInterruptMask => { #Structure Type: RegField;
      Name => "ContextInDramSetEcc_1bErrInterruptMask",
      RegMem => "RegField",
      Description => "When this bit is set, ECC 1b Error indication will be masked",
      Width => "1",
      Position => "14",
      Type => "Config",
      UsedBy => "SER",
      DefaultValue => "b1",
    },
    ContextInDramClrEcc_1bErrInterruptMask => { #Structure Type: RegField;
      Name => "ContextInDramClrEcc_1bErrInterruptMask",
      RegMem => "RegField",
      Description => "When this bit is set, ECC 1b Error indication will be masked",
      Width => "1",
      Position => "15",
      Type => "Config",
      UsedBy => "SER",
      DefaultValue => "b1",
    },
    ContextMapValidSetEcc_1bErrInterruptMask => { #Structure Type: RegField;
      Name => "ContextMapValidSetEcc_1bErrInterruptMask",
      RegMem => "RegField",
      Description => "When this bit is set, ECC 1b Error indication will be masked",
      Width => "1",
      Position => "16",
      Type => "Config",
      UsedBy => "SER",
      DefaultValue => "b1",
    },
    ContextMapValidClrEcc_1bErrInterruptMask => { #Structure Type: RegField;
      Name => "ContextMapValidClrEcc_1bErrInterruptMask",
      RegMem => "RegField",
      Description => "When this bit is set, ECC 1b Error indication will be masked",
      Width => "1",
      Position => "17",
      Type => "Config",
      UsedBy => "SER",
      DefaultValue => "b1",
    },
    contextfbmBmpEcc_1bErrInterruptMask => { #Structure Type: RegField;
      Name => "contextfbmBmpEcc_1bErrInterruptMask",
      RegMem => "RegField",
      Description => "When this bit is set, ECC 1b Error indication will be masked",
      Width => "1",
      Position => "18",
      Type => "Config",
      UsedBy => "SER",
      DefaultValue => "b1",
    },
    NewVoqSetEcc_1bErrInterruptMask => { #Structure Type: RegField;
      Name => "NewVoqSetEcc_1bErrInterruptMask",
      RegMem => "RegField",
      Description => "When this bit is set, ECC 1b Error indication will be masked",
      Width => "1",
      Position => "19",
      Type => "Config",
      UsedBy => "SER",
      DefaultValue => "b1",
    },
    NewVoqClrEcc_1bErrInterruptMask => { #Structure Type: RegField;
      Name => "NewVoqClrEcc_1bErrInterruptMask",
      RegMem => "RegField",
      Description => "When this bit is set, ECC 1b Error indication will be masked",
      Width => "1",
      Position => "20",
      Type => "Config",
      UsedBy => "SER",
      DefaultValue => "b1",
    },
    voqPropertiesEcc_1bErrInterruptMask => { #Structure Type: RegField;
      Name => "voqPropertiesEcc_1bErrInterruptMask",
      RegMem => "RegField",
      Description => "When this bit is set, ECC 1b Error indication will be masked",
      Width => "1",
      Position => "21",
      Type => "Config",
      UsedBy => "SER",
      DefaultValue => "b1",
    },
    staticMappingEcc_1bErrInterruptMask => { #Structure Type: RegField;
      Name => "staticMappingEcc_1bErrInterruptMask",
      RegMem => "RegField",
      Description => "When this bit is set, ECC 1b Error indication will be masked",
      Width => "1",
      Position => "22",
      Type => "Config",
      UsedBy => "SER",
      DefaultValue => "b1",
    },
    context_allocate_set_masterEcc_1bErrInterruptMask => { #Structure Type: RegField;
      Name => "context_allocate_set_masterEcc_1bErrInterruptMask",
      RegMem => "RegField",
      Description => "When this bit is set, ECC 1b Error indication will be masked",
      Width => "1",
      Position => "23",
      Type => "Config",
      UsedBy => "SER",
      DefaultValue => "b1",
    },
    context_allocate_set_slaveEcc_1bErrInterruptMask => { #Structure Type: RegField;
      Name => "context_allocate_set_slaveEcc_1bErrInterruptMask",
      RegMem => "RegField",
      Description => "When this bit is set, ECC 1b Error indication will be masked",
      Width => "1",
      Position => "24",
      Type => "Config",
      UsedBy => "SER",
      DefaultValue => "b1",
    },
    context_allocate_clr_masterEcc_1bErrInterruptMask => { #Structure Type: RegField;
      Name => "context_allocate_clr_masterEcc_1bErrInterruptMask",
      RegMem => "RegField",
      Description => "When this bit is set, ECC 1b Error indication will be masked",
      Width => "1",
      Position => "25",
      Type => "Config",
      UsedBy => "SER",
      DefaultValue => "b1",
    },
    context_allocate_clr_slaveEcc_1bErrInterruptMask => { #Structure Type: RegField;
      Name => "context_allocate_clr_slaveEcc_1bErrInterruptMask",
      RegMem => "RegField",
      Description => "When this bit is set, ECC 1b Error indication will be masked",
      Width => "1",
      Position => "26",
      Type => "Config",
      UsedBy => "SER",
      DefaultValue => "b1",
    },
    context_allocate_grant_setEcc_1bErrInterruptMask => { #Structure Type: RegField;
      Name => "context_allocate_grant_setEcc_1bErrInterruptMask",
      RegMem => "RegField",
      Description => "When this bit is set, ECC 1b Error indication will be masked",
      Width => "1",
      Position => "27",
      Type => "Config",
      UsedBy => "SER",
      DefaultValue => "b1",
    },
    context_allocate_grant_clrEcc_1bErrInterruptMask => { #Structure Type: RegField;
      Name => "context_allocate_grant_clrEcc_1bErrInterruptMask",
      RegMem => "RegField",
      Description => "When this bit is set, ECC 1b Error indication will be masked",
      Width => "1",
      Position => "28",
      Type => "Config",
      UsedBy => "SER",
      DefaultValue => "b1",
    },
    Context2voqEcc_1bErrInterruptMask => { #Structure Type: RegField;
      Name => "Context2voqEcc_1bErrInterruptMask",
      RegMem => "RegField",
      Description => "When this bit is set, ECC 1b Error indication will be masked",
      Width => "1",
      Position => "29",
      Type => "Config",
      UsedBy => "SER",
      DefaultValue => "b1",
    },
    RqmFreeFifoEcc_1bErrInterruptMask => { #Structure Type: RegField;
      Name => "RqmFreeFifoEcc_1bErrInterruptMask",
      RegMem => "RegField",
      Description => "When this bit is set, ECC 1b Error indication will be masked",
      Width => "1",
      Position => "30",
      Type => "Config",
      UsedBy => "SER",
      DefaultValue => "b1",
    },
    voqcgmProfileEcc_1bErrInterruptMask => { #Structure Type: RegField;
      Name => "voqcgmProfileEcc_1bErrInterruptMask",
      RegMem => "RegField",
      Description => "When this bit is set, ECC 1b Error indication will be masked",
      Width => "1",
      Position => "31",
      Type => "Config",
      UsedBy => "SER",
      DefaultValue => "b1",
    },
    BuffersConsumptionLutForEnqEcc_1bErrInterruptMask => { #Structure Type: RegField;
      Name => "BuffersConsumptionLutForEnqEcc_1bErrInterruptMask",
      RegMem => "RegField",
      Description => "When this bit is set, ECC 1b Error indication will be masked",
      Width => "1",
      Position => "32",
      Type => "Config",
      UsedBy => "SER",
      DefaultValue => "b1",
    },
    PdConsumptionLutForEnqEcc_1bErrInterruptMask => { #Structure Type: RegField;
      Name => "PdConsumptionLutForEnqEcc_1bErrInterruptMask",
      RegMem => "RegField",
      Description => "When this bit is set, ECC 1b Error indication will be masked",
      Width => "1",
      Position => "33",
      Type => "Config",
      UsedBy => "SER",
      DefaultValue => "b1",
    },
    VoqEnqRptSizeEcc_1bErrInterruptMask => { #Structure Type: RegField;
      Name => "VoqEnqRptSizeEcc_1bErrInterruptMask",
      RegMem => "RegField",
      Description => "When this bit is set, ECC 1b Error indication will be masked",
      Width => "1",
      Position => "34",
      Type => "Config",
      UsedBy => "SER",
      DefaultValue => "b1",
    },
    VoqDeqRptSizeEcc_1bErrInterruptMask => { #Structure Type: RegField;
      Name => "VoqDeqRptSizeEcc_1bErrInterruptMask",
      RegMem => "RegField",
      Description => "When this bit is set, ECC 1b Error indication will be masked",
      Width => "1",
      Position => "35",
      Type => "Config",
      UsedBy => "SER",
      DefaultValue => "b1",
    },
    LastRptEnqSetMemEcc_1bErrInterruptMask => { #Structure Type: RegField;
      Name => "LastRptEnqSetMemEcc_1bErrInterruptMask",
      RegMem => "RegField",
      Description => "When this bit is set, ECC 1b Error indication will be masked",
      Width => "1",
      Position => "36",
      Type => "Config",
      UsedBy => "SER",
      DefaultValue => "b1",
    },
    LastRptEnqSetMemExtraEcc_1bErrInterruptMask => { #Structure Type: RegField;
      Name => "LastRptEnqSetMemExtraEcc_1bErrInterruptMask",
      RegMem => "RegField",
      Description => "When this bit is set, ECC 1b Error indication will be masked",
      Width => "1",
      Position => "37",
      Type => "Config",
      UsedBy => "SER",
      DefaultValue => "b1",
    },
    LastRptEnqClrMemEcc_1bErrInterruptMask => { #Structure Type: RegField;
      Name => "LastRptEnqClrMemEcc_1bErrInterruptMask",
      RegMem => "RegField",
      Description => "When this bit is set, ECC 1b Error indication will be masked",
      Width => "1",
      Position => "38",
      Type => "Config",
      UsedBy => "SER",
      DefaultValue => "b1",
    },
    LastRptEnqClrMemExtraEcc_1bErrInterruptMask => { #Structure Type: RegField;
      Name => "LastRptEnqClrMemExtraEcc_1bErrInterruptMask",
      RegMem => "RegField",
      Description => "When this bit is set, ECC 1b Error indication will be masked",
      Width => "1",
      Position => "39",
      Type => "Config",
      UsedBy => "SER",
      DefaultValue => "b1",
    },
    VoqTenqHeadEnqEcc_1bErrInterruptMask => { #Structure Type: RegField;
      Name => "VoqTenqHeadEnqEcc_1bErrInterruptMask",
      RegMem => "RegField",
      Description => "When this bit is set, ECC 1b Error indication will be masked",
      Width => "1",
      Position => "40",
      Type => "Config",
      UsedBy => "SER",
      DefaultValue => "b1",
    },
    VoqTenqHeadRdEcc_1bErrInterruptMask => { #Structure Type: RegField;
      Name => "VoqTenqHeadRdEcc_1bErrInterruptMask",
      RegMem => "RegField",
      Description => "When this bit is set, ECC 1b Error indication will be masked",
      Width => "1",
      Position => "41",
      Type => "Config",
      UsedBy => "SER",
      DefaultValue => "b1",
    },
    VoqTenqHeadMsbEnqEcc_1bErrInterruptMask => { #Structure Type: RegField;
      Name => "VoqTenqHeadMsbEnqEcc_1bErrInterruptMask",
      RegMem => "RegField",
      Description => "When this bit is set, ECC 1b Error indication will be masked",
      Width => "1",
      Position => "42",
      Type => "Config",
      UsedBy => "SER",
      DefaultValue => "b1",
    },
    VoqTenqHeadMsbRdEcc_1bErrInterruptMask => { #Structure Type: RegField;
      Name => "VoqTenqHeadMsbRdEcc_1bErrInterruptMask",
      RegMem => "RegField",
      Description => "When this bit is set, ECC 1b Error indication will be masked",
      Width => "1",
      Position => "43",
      Type => "Config",
      UsedBy => "SER",
      DefaultValue => "b1",
    },
    HeadTimeEnqSetMemEcc_1bErrInterruptMask => { #Structure Type: RegField;
      Name => "HeadTimeEnqSetMemEcc_1bErrInterruptMask",
      RegMem => "RegField",
      Description => "When this bit is set, ECC 1b Error indication will be masked",
      Width => "1",
      Position => "44",
      Type => "Config",
      UsedBy => "SER",
      DefaultValue => "b1",
    },
    HeadTimeEnqSetMemExtraEcc_1bErrInterruptMask => { #Structure Type: RegField;
      Name => "HeadTimeEnqSetMemExtraEcc_1bErrInterruptMask",
      RegMem => "RegField",
      Description => "When this bit is set, ECC 1b Error indication will be masked",
      Width => "1",
      Position => "45",
      Type => "Config",
      UsedBy => "SER",
      DefaultValue => "b1",
    },
    HeadTimeEnqClrMemEcc_1bErrInterruptMask => { #Structure Type: RegField;
      Name => "HeadTimeEnqClrMemEcc_1bErrInterruptMask",
      RegMem => "RegField",
      Description => "When this bit is set, ECC 1b Error indication will be masked",
      Width => "1",
      Position => "46",
      Type => "Config",
      UsedBy => "SER",
      DefaultValue => "b1",
    },
    HeadTimeEnqClrMemExtraEcc_1bErrInterruptMask => { #Structure Type: RegField;
      Name => "HeadTimeEnqClrMemExtraEcc_1bErrInterruptMask",
      RegMem => "RegField",
      Description => "When this bit is set, ECC 1b Error indication will be masked",
      Width => "1",
      Position => "47",
      Type => "Config",
      UsedBy => "SER",
      DefaultValue => "b1",
    },
    IsAgingSetMemEcc_1bErrInterruptMask => { #Structure Type: RegField;
      Name => "IsAgingSetMemEcc_1bErrInterruptMask",
      RegMem => "RegField",
      Description => "When this bit is set, ECC 1b Error indication will be masked",
      Width => "1",
      Position => "48",
      Type => "Config",
      UsedBy => "SER",
      DefaultValue => "b1",
    },
    IsAgingClrMemEcc_1bErrInterruptMask => { #Structure Type: RegField;
      Name => "IsAgingClrMemEcc_1bErrInterruptMask",
      RegMem => "RegField",
      Description => "When this bit is set, ECC 1b Error indication will be masked",
      Width => "1",
      Position => "49",
      Type => "Config",
      UsedBy => "SER",
      DefaultValue => "b1",
    },
    AdmissionResultDramEcc_1bErrInterruptMask => { #Structure Type: RegField;
      Name => "AdmissionResultDramEcc_1bErrInterruptMask",
      RegMem => "RegField",
      Description => "When this bit is set, ECC 1b Error indication will be masked",
      Width => "1",
      Position => "50",
      Type => "Config",
      UsedBy => "SER",
      DefaultValue => "b1",
    },
    DropGreenProbabilitySelectorEcc_1bErrInterruptMask => { #Structure Type: RegField;
      Name => "DropGreenProbabilitySelectorEcc_1bErrInterruptMask",
      RegMem => "RegField",
      Description => "When this bit is set, ECC 1b Error indication will be masked",
      Width => "1",
      Position => "51",
      Type => "Config",
      UsedBy => "SER",
      DefaultValue => "b1",
    },
    DropYellowProbabilitySelectorEcc_1bErrInterruptMask => { #Structure Type: RegField;
      Name => "DropYellowProbabilitySelectorEcc_1bErrInterruptMask",
      RegMem => "RegField",
      Description => "When this bit is set, ECC 1b Error indication will be masked",
      Width => "1",
      Position => "52",
      Type => "Config",
      UsedBy => "SER",
      DefaultValue => "b1",
    },
  },
  Ecc_2bErrInterruptRegisterMask => { #Structure Type: Reg; Skip Register;
    Name => "Ecc_2bErrInterruptRegisterMask",
    RegMem => "Reg",
    Address => "4",
    Description => "ECC 2b Error Interrupt Mask Register",
    Width => "53",
    Type => "Config",
    rdrqsnEcc_2bErrInterruptMask => { #Structure Type: RegField;
      Name => "rdrqsnEcc_2bErrInterruptMask",
      RegMem => "RegField",
      Description => "When this bit is set, ECC 2b Error indication will be masked",
      Width => "1",
      Position => "0",
      Type => "Config",
      UsedBy => "SER",
      DefaultValue => "b1",
    },
    rdsnEcc_2bErrInterruptMask => { #Structure Type: RegField;
      Name => "rdsnEcc_2bErrInterruptMask",
      RegMem => "RegField",
      Description => "When this bit is set, ECC 2b Error indication will be masked",
      Width => "1",
      Position => "1",
      Type => "Config",
      UsedBy => "SER",
      DefaultValue => "b1",
    },
    rdbcEcc_2bErrInterruptMask => { #Structure Type: RegField;
      Name => "rdbcEcc_2bErrInterruptMask",
      RegMem => "RegField",
      Description => "When this bit is set, ECC 2b Error indication will be masked",
      Width => "1",
      Position => "2",
      Type => "Config",
      UsedBy => "SER",
      DefaultValue => "b1",
    },
    rdbufcntEcc_2bErrInterruptMask => { #Structure Type: RegField;
      Name => "rdbufcntEcc_2bErrInterruptMask",
      RegMem => "RegField",
      Description => "When this bit is set, ECC 2b Error indication will be masked",
      Width => "1",
      Position => "3",
      Type => "Config",
      UsedBy => "SER",
      DefaultValue => "b1",
    },
    wrrqsnEcc_2bErrInterruptMask => { #Structure Type: RegField;
      Name => "wrrqsnEcc_2bErrInterruptMask",
      RegMem => "RegField",
      Description => "When this bit is set, ECC 2b Error indication will be masked",
      Width => "1",
      Position => "4",
      Type => "Config",
      UsedBy => "SER",
      DefaultValue => "b1",
    },
    wrsnEcc_2bErrInterruptMask => { #Structure Type: RegField;
      Name => "wrsnEcc_2bErrInterruptMask",
      RegMem => "RegField",
      Description => "When this bit is set, ECC 2b Error indication will be masked",
      Width => "1",
      Position => "5",
      Type => "Config",
      UsedBy => "SER",
      DefaultValue => "b1",
    },
    wrbcEcc_2bErrInterruptMask => { #Structure Type: RegField;
      Name => "wrbcEcc_2bErrInterruptMask",
      RegMem => "RegField",
      Description => "When this bit is set, ECC 2b Error indication will be masked",
      Width => "1",
      Position => "6",
      Type => "Config",
      UsedBy => "SER",
      DefaultValue => "b1",
    },
    wrbufcntEcc_2bErrInterruptMask => { #Structure Type: RegField;
      Name => "wrbufcntEcc_2bErrInterruptMask",
      RegMem => "RegField",
      Description => "When this bit is set, ECC 2b Error indication will be masked",
      Width => "1",
      Position => "7",
      Type => "Config",
      UsedBy => "SER",
      DefaultValue => "b1",
    },
    voq2contextEcc_2bErrInterruptMask => { #Structure Type: RegField;
      Name => "voq2contextEcc_2bErrInterruptMask",
      RegMem => "RegField",
      Description => "When this bit is set, ECC 2b Error indication will be masked",
      Width => "1",
      Position => "8",
      Type => "Config",
      UsedBy => "SER",
      DefaultValue => "b1",
    },
    CandRelFifoEcc_2bErrInterruptMask => { #Structure Type: RegField;
      Name => "CandRelFifoEcc_2bErrInterruptMask",
      RegMem => "RegField",
      Description => "When this bit is set, ECC 2b Error indication will be masked",
      Width => "1",
      Position => "9",
      Type => "Config",
      UsedBy => "SER",
      DefaultValue => "b1",
    },
    InCandRelFifoSetEcc_2bErrInterruptMask => { #Structure Type: RegField;
      Name => "InCandRelFifoSetEcc_2bErrInterruptMask",
      RegMem => "RegField",
      Description => "When this bit is set, ECC 2b Error indication will be masked",
      Width => "1",
      Position => "10",
      Type => "Config",
      UsedBy => "SER",
      DefaultValue => "b1",
    },
    InCandRelFifoClrEcc_2bErrInterruptMask => { #Structure Type: RegField;
      Name => "InCandRelFifoClrEcc_2bErrInterruptMask",
      RegMem => "RegField",
      Description => "When this bit is set, ECC 2b Error indication will be masked",
      Width => "1",
      Position => "11",
      Type => "Config",
      UsedBy => "SER",
      DefaultValue => "b1",
    },
    ContextReleaseEligibleSetEcc_2bErrInterruptMask => { #Structure Type: RegField;
      Name => "ContextReleaseEligibleSetEcc_2bErrInterruptMask",
      RegMem => "RegField",
      Description => "When this bit is set, ECC 2b Error indication will be masked",
      Width => "1",
      Position => "12",
      Type => "Config",
      UsedBy => "SER",
      DefaultValue => "b1",
    },
    ContextReleaseEligibleClrEcc_2bErrInterruptMask => { #Structure Type: RegField;
      Name => "ContextReleaseEligibleClrEcc_2bErrInterruptMask",
      RegMem => "RegField",
      Description => "When this bit is set, ECC 2b Error indication will be masked",
      Width => "1",
      Position => "13",
      Type => "Config",
      UsedBy => "SER",
      DefaultValue => "b1",
    },
    ContextInDramSetEcc_2bErrInterruptMask => { #Structure Type: RegField;
      Name => "ContextInDramSetEcc_2bErrInterruptMask",
      RegMem => "RegField",
      Description => "When this bit is set, ECC 2b Error indication will be masked",
      Width => "1",
      Position => "14",
      Type => "Config",
      UsedBy => "SER",
      DefaultValue => "b1",
    },
    ContextInDramClrEcc_2bErrInterruptMask => { #Structure Type: RegField;
      Name => "ContextInDramClrEcc_2bErrInterruptMask",
      RegMem => "RegField",
      Description => "When this bit is set, ECC 2b Error indication will be masked",
      Width => "1",
      Position => "15",
      Type => "Config",
      UsedBy => "SER",
      DefaultValue => "b1",
    },
    ContextMapValidSetEcc_2bErrInterruptMask => { #Structure Type: RegField;
      Name => "ContextMapValidSetEcc_2bErrInterruptMask",
      RegMem => "RegField",
      Description => "When this bit is set, ECC 2b Error indication will be masked",
      Width => "1",
      Position => "16",
      Type => "Config",
      UsedBy => "SER",
      DefaultValue => "b1",
    },
    ContextMapValidClrEcc_2bErrInterruptMask => { #Structure Type: RegField;
      Name => "ContextMapValidClrEcc_2bErrInterruptMask",
      RegMem => "RegField",
      Description => "When this bit is set, ECC 2b Error indication will be masked",
      Width => "1",
      Position => "17",
      Type => "Config",
      UsedBy => "SER",
      DefaultValue => "b1",
    },
    contextfbmBmpEcc_2bErrInterruptMask => { #Structure Type: RegField;
      Name => "contextfbmBmpEcc_2bErrInterruptMask",
      RegMem => "RegField",
      Description => "When this bit is set, ECC 2b Error indication will be masked",
      Width => "1",
      Position => "18",
      Type => "Config",
      UsedBy => "SER",
      DefaultValue => "b1",
    },
    NewVoqSetEcc_2bErrInterruptMask => { #Structure Type: RegField;
      Name => "NewVoqSetEcc_2bErrInterruptMask",
      RegMem => "RegField",
      Description => "When this bit is set, ECC 2b Error indication will be masked",
      Width => "1",
      Position => "19",
      Type => "Config",
      UsedBy => "SER",
      DefaultValue => "b1",
    },
    NewVoqClrEcc_2bErrInterruptMask => { #Structure Type: RegField;
      Name => "NewVoqClrEcc_2bErrInterruptMask",
      RegMem => "RegField",
      Description => "When this bit is set, ECC 2b Error indication will be masked",
      Width => "1",
      Position => "20",
      Type => "Config",
      UsedBy => "SER",
      DefaultValue => "b1",
    },
    voqPropertiesEcc_2bErrInterruptMask => { #Structure Type: RegField;
      Name => "voqPropertiesEcc_2bErrInterruptMask",
      RegMem => "RegField",
      Description => "When this bit is set, ECC 2b Error indication will be masked",
      Width => "1",
      Position => "21",
      Type => "Config",
      UsedBy => "SER",
      DefaultValue => "b1",
    },
    staticMappingEcc_2bErrInterruptMask => { #Structure Type: RegField;
      Name => "staticMappingEcc_2bErrInterruptMask",
      RegMem => "RegField",
      Description => "When this bit is set, ECC 2b Error indication will be masked",
      Width => "1",
      Position => "22",
      Type => "Config",
      UsedBy => "SER",
      DefaultValue => "b1",
    },
    context_allocate_set_masterEcc_2bErrInterruptMask => { #Structure Type: RegField;
      Name => "context_allocate_set_masterEcc_2bErrInterruptMask",
      RegMem => "RegField",
      Description => "When this bit is set, ECC 2b Error indication will be masked",
      Width => "1",
      Position => "23",
      Type => "Config",
      UsedBy => "SER",
      DefaultValue => "b1",
    },
    context_allocate_set_slaveEcc_2bErrInterruptMask => { #Structure Type: RegField;
      Name => "context_allocate_set_slaveEcc_2bErrInterruptMask",
      RegMem => "RegField",
      Description => "When this bit is set, ECC 2b Error indication will be masked",
      Width => "1",
      Position => "24",
      Type => "Config",
      UsedBy => "SER",
      DefaultValue => "b1",
    },
    context_allocate_clr_masterEcc_2bErrInterruptMask => { #Structure Type: RegField;
      Name => "context_allocate_clr_masterEcc_2bErrInterruptMask",
      RegMem => "RegField",
      Description => "When this bit is set, ECC 2b Error indication will be masked",
      Width => "1",
      Position => "25",
      Type => "Config",
      UsedBy => "SER",
      DefaultValue => "b1",
    },
    context_allocate_clr_slaveEcc_2bErrInterruptMask => { #Structure Type: RegField;
      Name => "context_allocate_clr_slaveEcc_2bErrInterruptMask",
      RegMem => "RegField",
      Description => "When this bit is set, ECC 2b Error indication will be masked",
      Width => "1",
      Position => "26",
      Type => "Config",
      UsedBy => "SER",
      DefaultValue => "b1",
    },
    context_allocate_grant_setEcc_2bErrInterruptMask => { #Structure Type: RegField;
      Name => "context_allocate_grant_setEcc_2bErrInterruptMask",
      RegMem => "RegField",
      Description => "When this bit is set, ECC 2b Error indication will be masked",
      Width => "1",
      Position => "27",
      Type => "Config",
      UsedBy => "SER",
      DefaultValue => "b1",
    },
    context_allocate_grant_clrEcc_2bErrInterruptMask => { #Structure Type: RegField;
      Name => "context_allocate_grant_clrEcc_2bErrInterruptMask",
      RegMem => "RegField",
      Description => "When this bit is set, ECC 2b Error indication will be masked",
      Width => "1",
      Position => "28",
      Type => "Config",
      UsedBy => "SER",
      DefaultValue => "b1",
    },
    Context2voqEcc_2bErrInterruptMask => { #Structure Type: RegField;
      Name => "Context2voqEcc_2bErrInterruptMask",
      RegMem => "RegField",
      Description => "When this bit is set, ECC 2b Error indication will be masked",
      Width => "1",
      Position => "29",
      Type => "Config",
      UsedBy => "SER",
      DefaultValue => "b1",
    },
    RqmFreeFifoEcc_2bErrInterruptMask => { #Structure Type: RegField;
      Name => "RqmFreeFifoEcc_2bErrInterruptMask",
      RegMem => "RegField",
      Description => "When this bit is set, ECC 2b Error indication will be masked",
      Width => "1",
      Position => "30",
      Type => "Config",
      UsedBy => "SER",
      DefaultValue => "b1",
    },
    voqcgmProfileEcc_2bErrInterruptMask => { #Structure Type: RegField;
      Name => "voqcgmProfileEcc_2bErrInterruptMask",
      RegMem => "RegField",
      Description => "When this bit is set, ECC 2b Error indication will be masked",
      Width => "1",
      Position => "31",
      Type => "Config",
      UsedBy => "SER",
      DefaultValue => "b1",
    },
    BuffersConsumptionLutForEnqEcc_2bErrInterruptMask => { #Structure Type: RegField;
      Name => "BuffersConsumptionLutForEnqEcc_2bErrInterruptMask",
      RegMem => "RegField",
      Description => "When this bit is set, ECC 2b Error indication will be masked",
      Width => "1",
      Position => "32",
      Type => "Config",
      UsedBy => "SER",
      DefaultValue => "b1",
    },
    PdConsumptionLutForEnqEcc_2bErrInterruptMask => { #Structure Type: RegField;
      Name => "PdConsumptionLutForEnqEcc_2bErrInterruptMask",
      RegMem => "RegField",
      Description => "When this bit is set, ECC 2b Error indication will be masked",
      Width => "1",
      Position => "33",
      Type => "Config",
      UsedBy => "SER",
      DefaultValue => "b1",
    },
    VoqEnqRptSizeEcc_2bErrInterruptMask => { #Structure Type: RegField;
      Name => "VoqEnqRptSizeEcc_2bErrInterruptMask",
      RegMem => "RegField",
      Description => "When this bit is set, ECC 2b Error indication will be masked",
      Width => "1",
      Position => "34",
      Type => "Config",
      UsedBy => "SER",
      DefaultValue => "b1",
    },
    VoqDeqRptSizeEcc_2bErrInterruptMask => { #Structure Type: RegField;
      Name => "VoqDeqRptSizeEcc_2bErrInterruptMask",
      RegMem => "RegField",
      Description => "When this bit is set, ECC 2b Error indication will be masked",
      Width => "1",
      Position => "35",
      Type => "Config",
      UsedBy => "SER",
      DefaultValue => "b1",
    },
    LastRptEnqSetMemEcc_2bErrInterruptMask => { #Structure Type: RegField;
      Name => "LastRptEnqSetMemEcc_2bErrInterruptMask",
      RegMem => "RegField",
      Description => "When this bit is set, ECC 2b Error indication will be masked",
      Width => "1",
      Position => "36",
      Type => "Config",
      UsedBy => "SER",
      DefaultValue => "b1",
    },
    LastRptEnqSetMemExtraEcc_2bErrInterruptMask => { #Structure Type: RegField;
      Name => "LastRptEnqSetMemExtraEcc_2bErrInterruptMask",
      RegMem => "RegField",
      Description => "When this bit is set, ECC 2b Error indication will be masked",
      Width => "1",
      Position => "37",
      Type => "Config",
      UsedBy => "SER",
      DefaultValue => "b1",
    },
    LastRptEnqClrMemEcc_2bErrInterruptMask => { #Structure Type: RegField;
      Name => "LastRptEnqClrMemEcc_2bErrInterruptMask",
      RegMem => "RegField",
      Description => "When this bit is set, ECC 2b Error indication will be masked",
      Width => "1",
      Position => "38",
      Type => "Config",
      UsedBy => "SER",
      DefaultValue => "b1",
    },
    LastRptEnqClrMemExtraEcc_2bErrInterruptMask => { #Structure Type: RegField;
      Name => "LastRptEnqClrMemExtraEcc_2bErrInterruptMask",
      RegMem => "RegField",
      Description => "When this bit is set, ECC 2b Error indication will be masked",
      Width => "1",
      Position => "39",
      Type => "Config",
      UsedBy => "SER",
      DefaultValue => "b1",
    },
    VoqTenqHeadEnqEcc_2bErrInterruptMask => { #Structure Type: RegField;
      Name => "VoqTenqHeadEnqEcc_2bErrInterruptMask",
      RegMem => "RegField",
      Description => "When this bit is set, ECC 2b Error indication will be masked",
      Width => "1",
      Position => "40",
      Type => "Config",
      UsedBy => "SER",
      DefaultValue => "b1",
    },
    VoqTenqHeadRdEcc_2bErrInterruptMask => { #Structure Type: RegField;
      Name => "VoqTenqHeadRdEcc_2bErrInterruptMask",
      RegMem => "RegField",
      Description => "When this bit is set, ECC 2b Error indication will be masked",
      Width => "1",
      Position => "41",
      Type => "Config",
      UsedBy => "SER",
      DefaultValue => "b1",
    },
    VoqTenqHeadMsbEnqEcc_2bErrInterruptMask => { #Structure Type: RegField;
      Name => "VoqTenqHeadMsbEnqEcc_2bErrInterruptMask",
      RegMem => "RegField",
      Description => "When this bit is set, ECC 2b Error indication will be masked",
      Width => "1",
      Position => "42",
      Type => "Config",
      UsedBy => "SER",
      DefaultValue => "b1",
    },
    VoqTenqHeadMsbRdEcc_2bErrInterruptMask => { #Structure Type: RegField;
      Name => "VoqTenqHeadMsbRdEcc_2bErrInterruptMask",
      RegMem => "RegField",
      Description => "When this bit is set, ECC 2b Error indication will be masked",
      Width => "1",
      Position => "43",
      Type => "Config",
      UsedBy => "SER",
      DefaultValue => "b1",
    },
    HeadTimeEnqSetMemEcc_2bErrInterruptMask => { #Structure Type: RegField;
      Name => "HeadTimeEnqSetMemEcc_2bErrInterruptMask",
      RegMem => "RegField",
      Description => "When this bit is set, ECC 2b Error indication will be masked",
      Width => "1",
      Position => "44",
      Type => "Config",
      UsedBy => "SER",
      DefaultValue => "b1",
    },
    HeadTimeEnqSetMemExtraEcc_2bErrInterruptMask => { #Structure Type: RegField;
      Name => "HeadTimeEnqSetMemExtraEcc_2bErrInterruptMask",
      RegMem => "RegField",
      Description => "When this bit is set, ECC 2b Error indication will be masked",
      Width => "1",
      Position => "45",
      Type => "Config",
      UsedBy => "SER",
      DefaultValue => "b1",
    },
    HeadTimeEnqClrMemEcc_2bErrInterruptMask => { #Structure Type: RegField;
      Name => "HeadTimeEnqClrMemEcc_2bErrInterruptMask",
      RegMem => "RegField",
      Description => "When this bit is set, ECC 2b Error indication will be masked",
      Width => "1",
      Position => "46",
      Type => "Config",
      UsedBy => "SER",
      DefaultValue => "b1",
    },
    HeadTimeEnqClrMemExtraEcc_2bErrInterruptMask => { #Structure Type: RegField;
      Name => "HeadTimeEnqClrMemExtraEcc_2bErrInterruptMask",
      RegMem => "RegField",
      Description => "When this bit is set, ECC 2b Error indication will be masked",
      Width => "1",
      Position => "47",
      Type => "Config",
      UsedBy => "SER",
      DefaultValue => "b1",
    },
    IsAgingSetMemEcc_2bErrInterruptMask => { #Structure Type: RegField;
      Name => "IsAgingSetMemEcc_2bErrInterruptMask",
      RegMem => "RegField",
      Description => "When this bit is set, ECC 2b Error indication will be masked",
      Width => "1",
      Position => "48",
      Type => "Config",
      UsedBy => "SER",
      DefaultValue => "b1",
    },
    IsAgingClrMemEcc_2bErrInterruptMask => { #Structure Type: RegField;
      Name => "IsAgingClrMemEcc_2bErrInterruptMask",
      RegMem => "RegField",
      Description => "When this bit is set, ECC 2b Error indication will be masked",
      Width => "1",
      Position => "49",
      Type => "Config",
      UsedBy => "SER",
      DefaultValue => "b1",
    },
    AdmissionResultDramEcc_2bErrInterruptMask => { #Structure Type: RegField;
      Name => "AdmissionResultDramEcc_2bErrInterruptMask",
      RegMem => "RegField",
      Description => "When this bit is set, ECC 2b Error indication will be masked",
      Width => "1",
      Position => "50",
      Type => "Config",
      UsedBy => "SER",
      DefaultValue => "b1",
    },
    DropGreenProbabilitySelectorEcc_2bErrInterruptMask => { #Structure Type: RegField;
      Name => "DropGreenProbabilitySelectorEcc_2bErrInterruptMask",
      RegMem => "RegField",
      Description => "When this bit is set, ECC 2b Error indication will be masked",
      Width => "1",
      Position => "51",
      Type => "Config",
      UsedBy => "SER",
      DefaultValue => "b1",
    },
    DropYellowProbabilitySelectorEcc_2bErrInterruptMask => { #Structure Type: RegField;
      Name => "DropYellowProbabilitySelectorEcc_2bErrInterruptMask",
      RegMem => "RegField",
      Description => "When this bit is set, ECC 2b Error indication will be masked",
      Width => "1",
      Position => "52",
      Type => "Config",
      UsedBy => "SER",
      DefaultValue => "b1",
    },
  },

  Ecc_1bErrInitiateRegister => { #Structure Type: Reg; Skip Register;
    Name => "Ecc_1bErrInitiateRegister",
    RegMem => "Reg",
    Address => "30",
    Description => "ECC 1b Error Initiator Register",
    Width => "53",
    Type => "Config",
    rdrqsnEcc_1bErrInitiate => { #Structure Type: RegField;
      Name => "rdrqsnEcc_1bErrInitiate",
      RegMem => "RegField",
      Description => "When this bit is set, ECC 1b Error will be initiated",
      Width => "1",
      Position => "0",
      Type => "Config",
      UsedBy => "MEM",
      DefaultValue => "b0",
    },
    rdsnEcc_1bErrInitiate => { #Structure Type: RegField;
      Name => "rdsnEcc_1bErrInitiate",
      RegMem => "RegField",
      Description => "When this bit is set, ECC 1b Error will be initiated",
      Width => "1",
      Position => "1",
      Type => "Config",
      UsedBy => "MEM",
      DefaultValue => "b0",
    },
    rdbcEcc_1bErrInitiate => { #Structure Type: RegField;
      Name => "rdbcEcc_1bErrInitiate",
      RegMem => "RegField",
      Description => "When this bit is set, ECC 1b Error will be initiated",
      Width => "1",
      Position => "2",
      Type => "Config",
      UsedBy => "MEM",
      DefaultValue => "b0",
    },
    rdbufcntEcc_1bErrInitiate => { #Structure Type: RegField;
      Name => "rdbufcntEcc_1bErrInitiate",
      RegMem => "RegField",
      Description => "When this bit is set, ECC 1b Error will be initiated",
      Width => "1",
      Position => "3",
      Type => "Config",
      UsedBy => "MEM",
      DefaultValue => "b0",
    },
    wrrqsnEcc_1bErrInitiate => { #Structure Type: RegField;
      Name => "wrrqsnEcc_1bErrInitiate",
      RegMem => "RegField",
      Description => "When this bit is set, ECC 1b Error will be initiated",
      Width => "1",
      Position => "4",
      Type => "Config",
      UsedBy => "MEM",
      DefaultValue => "b0",
    },
    wrsnEcc_1bErrInitiate => { #Structure Type: RegField;
      Name => "wrsnEcc_1bErrInitiate",
      RegMem => "RegField",
      Description => "When this bit is set, ECC 1b Error will be initiated",
      Width => "1",
      Position => "5",
      Type => "Config",
      UsedBy => "MEM",
      DefaultValue => "b0",
    },
    wrbcEcc_1bErrInitiate => { #Structure Type: RegField;
      Name => "wrbcEcc_1bErrInitiate",
      RegMem => "RegField",
      Description => "When this bit is set, ECC 1b Error will be initiated",
      Width => "1",
      Position => "6",
      Type => "Config",
      UsedBy => "MEM",
      DefaultValue => "b0",
    },
    wrbufcntEcc_1bErrInitiate => { #Structure Type: RegField;
      Name => "wrbufcntEcc_1bErrInitiate",
      RegMem => "RegField",
      Description => "When this bit is set, ECC 1b Error will be initiated",
      Width => "1",
      Position => "7",
      Type => "Config",
      UsedBy => "MEM",
      DefaultValue => "b0",
    },
    voq2contextEcc_1bErrInitiate => { #Structure Type: RegField;
      Name => "voq2contextEcc_1bErrInitiate",
      RegMem => "RegField",
      Description => "When this bit is set, ECC 1b Error will be initiated",
      Width => "1",
      Position => "8",
      Type => "Config",
      UsedBy => "MEM",
      DefaultValue => "b0",
    },
    CandRelFifoEcc_1bErrInitiate => { #Structure Type: RegField;
      Name => "CandRelFifoEcc_1bErrInitiate",
      RegMem => "RegField",
      Description => "When this bit is set, ECC 1b Error will be initiated",
      Width => "1",
      Position => "9",
      Type => "Config",
      UsedBy => "MEM",
      DefaultValue => "b0",
    },
    InCandRelFifoSetEcc_1bErrInitiate => { #Structure Type: RegField;
      Name => "InCandRelFifoSetEcc_1bErrInitiate",
      RegMem => "RegField",
      Description => "When this bit is set, ECC 1b Error will be initiated",
      Width => "1",
      Position => "10",
      Type => "Config",
      UsedBy => "MEM",
      DefaultValue => "b0",
    },
    InCandRelFifoClrEcc_1bErrInitiate => { #Structure Type: RegField;
      Name => "InCandRelFifoClrEcc_1bErrInitiate",
      RegMem => "RegField",
      Description => "When this bit is set, ECC 1b Error will be initiated",
      Width => "1",
      Position => "11",
      Type => "Config",
      UsedBy => "MEM",
      DefaultValue => "b0",
    },
    ContextReleaseEligibleSetEcc_1bErrInitiate => { #Structure Type: RegField;
      Name => "ContextReleaseEligibleSetEcc_1bErrInitiate",
      RegMem => "RegField",
      Description => "When this bit is set, ECC 1b Error will be initiated",
      Width => "1",
      Position => "12",
      Type => "Config",
      UsedBy => "MEM",
      DefaultValue => "b0",
    },
    ContextReleaseEligibleClrEcc_1bErrInitiate => { #Structure Type: RegField;
      Name => "ContextReleaseEligibleClrEcc_1bErrInitiate",
      RegMem => "RegField",
      Description => "When this bit is set, ECC 1b Error will be initiated",
      Width => "1",
      Position => "13",
      Type => "Config",
      UsedBy => "MEM",
      DefaultValue => "b0",
    },
    ContextInDramSetEcc_1bErrInitiate => { #Structure Type: RegField;
      Name => "ContextInDramSetEcc_1bErrInitiate",
      RegMem => "RegField",
      Description => "When this bit is set, ECC 1b Error will be initiated",
      Width => "1",
      Position => "14",
      Type => "Config",
      UsedBy => "MEM",
      DefaultValue => "b0",
    },
    ContextInDramClrEcc_1bErrInitiate => { #Structure Type: RegField;
      Name => "ContextInDramClrEcc_1bErrInitiate",
      RegMem => "RegField",
      Description => "When this bit is set, ECC 1b Error will be initiated",
      Width => "1",
      Position => "15",
      Type => "Config",
      UsedBy => "MEM",
      DefaultValue => "b0",
    },
    ContextMapValidSetEcc_1bErrInitiate => { #Structure Type: RegField;
      Name => "ContextMapValidSetEcc_1bErrInitiate",
      RegMem => "RegField",
      Description => "When this bit is set, ECC 1b Error will be initiated",
      Width => "1",
      Position => "16",
      Type => "Config",
      UsedBy => "MEM",
      DefaultValue => "b0",
    },
    ContextMapValidClrEcc_1bErrInitiate => { #Structure Type: RegField;
      Name => "ContextMapValidClrEcc_1bErrInitiate",
      RegMem => "RegField",
      Description => "When this bit is set, ECC 1b Error will be initiated",
      Width => "1",
      Position => "17",
      Type => "Config",
      UsedBy => "MEM",
      DefaultValue => "b0",
    },
    contextfbmBmpEcc_1bErrInitiate => { #Structure Type: RegField;
      Name => "contextfbmBmpEcc_1bErrInitiate",
      RegMem => "RegField",
      Description => "When this bit is set, ECC 1b Error will be initiated",
      Width => "1",
      Position => "18",
      Type => "Config",
      UsedBy => "MEM",
      DefaultValue => "b0",
    },
    NewVoqSetEcc_1bErrInitiate => { #Structure Type: RegField;
      Name => "NewVoqSetEcc_1bErrInitiate",
      RegMem => "RegField",
      Description => "When this bit is set, ECC 1b Error will be initiated",
      Width => "1",
      Position => "19",
      Type => "Config",
      UsedBy => "MEM",
      DefaultValue => "b0",
    },
    NewVoqClrEcc_1bErrInitiate => { #Structure Type: RegField;
      Name => "NewVoqClrEcc_1bErrInitiate",
      RegMem => "RegField",
      Description => "When this bit is set, ECC 1b Error will be initiated",
      Width => "1",
      Position => "20",
      Type => "Config",
      UsedBy => "MEM",
      DefaultValue => "b0",
    },
    voqPropertiesEcc_1bErrInitiate => { #Structure Type: RegField;
      Name => "voqPropertiesEcc_1bErrInitiate",
      RegMem => "RegField",
      Description => "When this bit is set, ECC 1b Error will be initiated",
      Width => "1",
      Position => "21",
      Type => "Config",
      UsedBy => "MEM",
      DefaultValue => "b0",
    },
    staticMappingEcc_1bErrInitiate => { #Structure Type: RegField;
      Name => "staticMappingEcc_1bErrInitiate",
      RegMem => "RegField",
      Description => "When this bit is set, ECC 1b Error will be initiated",
      Width => "1",
      Position => "22",
      Type => "Config",
      UsedBy => "MEM",
      DefaultValue => "b0",
    },
    context_allocate_set_masterEcc_1bErrInitiate => { #Structure Type: RegField;
      Name => "context_allocate_set_masterEcc_1bErrInitiate",
      RegMem => "RegField",
      Description => "When this bit is set, ECC 1b Error will be initiated",
      Width => "1",
      Position => "23",
      Type => "Config",
      UsedBy => "MEM",
      DefaultValue => "b0",
    },
    context_allocate_set_slaveEcc_1bErrInitiate => { #Structure Type: RegField;
      Name => "context_allocate_set_slaveEcc_1bErrInitiate",
      RegMem => "RegField",
      Description => "When this bit is set, ECC 1b Error will be initiated",
      Width => "1",
      Position => "24",
      Type => "Config",
      UsedBy => "MEM",
      DefaultValue => "b0",
    },
    context_allocate_clr_masterEcc_1bErrInitiate => { #Structure Type: RegField;
      Name => "context_allocate_clr_masterEcc_1bErrInitiate",
      RegMem => "RegField",
      Description => "When this bit is set, ECC 1b Error will be initiated",
      Width => "1",
      Position => "25",
      Type => "Config",
      UsedBy => "MEM",
      DefaultValue => "b0",
    },
    context_allocate_clr_slaveEcc_1bErrInitiate => { #Structure Type: RegField;
      Name => "context_allocate_clr_slaveEcc_1bErrInitiate",
      RegMem => "RegField",
      Description => "When this bit is set, ECC 1b Error will be initiated",
      Width => "1",
      Position => "26",
      Type => "Config",
      UsedBy => "MEM",
      DefaultValue => "b0",
    },
    context_allocate_grant_setEcc_1bErrInitiate => { #Structure Type: RegField;
      Name => "context_allocate_grant_setEcc_1bErrInitiate",
      RegMem => "RegField",
      Description => "When this bit is set, ECC 1b Error will be initiated",
      Width => "1",
      Position => "27",
      Type => "Config",
      UsedBy => "MEM",
      DefaultValue => "b0",
    },
    context_allocate_grant_clrEcc_1bErrInitiate => { #Structure Type: RegField;
      Name => "context_allocate_grant_clrEcc_1bErrInitiate",
      RegMem => "RegField",
      Description => "When this bit is set, ECC 1b Error will be initiated",
      Width => "1",
      Position => "28",
      Type => "Config",
      UsedBy => "MEM",
      DefaultValue => "b0",
    },
    Context2voqEcc_1bErrInitiate => { #Structure Type: RegField;
      Name => "Context2voqEcc_1bErrInitiate",
      RegMem => "RegField",
      Description => "When this bit is set, ECC 1b Error will be initiated",
      Width => "1",
      Position => "29",
      Type => "Config",
      UsedBy => "MEM",
      DefaultValue => "b0",
    },
    RqmFreeFifoEcc_1bErrInitiate => { #Structure Type: RegField;
      Name => "RqmFreeFifoEcc_1bErrInitiate",
      RegMem => "RegField",
      Description => "When this bit is set, ECC 1b Error will be initiated",
      Width => "1",
      Position => "30",
      Type => "Config",
      UsedBy => "MEM",
      DefaultValue => "b0",
    },
    voqcgmProfileEcc_1bErrInitiate => { #Structure Type: RegField;
      Name => "voqcgmProfileEcc_1bErrInitiate",
      RegMem => "RegField",
      Description => "When this bit is set, ECC 1b Error will be initiated",
      Width => "1",
      Position => "31",
      Type => "Config",
      UsedBy => "MEM",
      DefaultValue => "b0",
    },
    BuffersConsumptionLutForEnqEcc_1bErrInitiate => { #Structure Type: RegField;
      Name => "BuffersConsumptionLutForEnqEcc_1bErrInitiate",
      RegMem => "RegField",
      Description => "When this bit is set, ECC 1b Error will be initiated",
      Width => "1",
      Position => "32",
      Type => "Config",
      UsedBy => "MEM",
      DefaultValue => "b0",
    },
    PdConsumptionLutForEnqEcc_1bErrInitiate => { #Structure Type: RegField;
      Name => "PdConsumptionLutForEnqEcc_1bErrInitiate",
      RegMem => "RegField",
      Description => "When this bit is set, ECC 1b Error will be initiated",
      Width => "1",
      Position => "33",
      Type => "Config",
      UsedBy => "MEM",
      DefaultValue => "b0",
    },
    VoqEnqRptSizeEcc_1bErrInitiate => { #Structure Type: RegField;
      Name => "VoqEnqRptSizeEcc_1bErrInitiate",
      RegMem => "RegField",
      Description => "When this bit is set, ECC 1b Error will be initiated",
      Width => "1",
      Position => "34",
      Type => "Config",
      UsedBy => "MEM",
      DefaultValue => "b0",
    },
    VoqDeqRptSizeEcc_1bErrInitiate => { #Structure Type: RegField;
      Name => "VoqDeqRptSizeEcc_1bErrInitiate",
      RegMem => "RegField",
      Description => "When this bit is set, ECC 1b Error will be initiated",
      Width => "1",
      Position => "35",
      Type => "Config",
      UsedBy => "MEM",
      DefaultValue => "b0",
    },
    LastRptEnqSetMemEcc_1bErrInitiate => { #Structure Type: RegField;
      Name => "LastRptEnqSetMemEcc_1bErrInitiate",
      RegMem => "RegField",
      Description => "When this bit is set, ECC 1b Error will be initiated",
      Width => "1",
      Position => "36",
      Type => "Config",
      UsedBy => "MEM",
      DefaultValue => "b0",
    },
    LastRptEnqSetMemExtraEcc_1bErrInitiate => { #Structure Type: RegField;
      Name => "LastRptEnqSetMemExtraEcc_1bErrInitiate",
      RegMem => "RegField",
      Description => "When this bit is set, ECC 1b Error will be initiated",
      Width => "1",
      Position => "37",
      Type => "Config",
      UsedBy => "MEM",
      DefaultValue => "b0",
    },
    LastRptEnqClrMemEcc_1bErrInitiate => { #Structure Type: RegField;
      Name => "LastRptEnqClrMemEcc_1bErrInitiate",
      RegMem => "RegField",
      Description => "When this bit is set, ECC 1b Error will be initiated",
      Width => "1",
      Position => "38",
      Type => "Config",
      UsedBy => "MEM",
      DefaultValue => "b0",
    },
    LastRptEnqClrMemExtraEcc_1bErrInitiate => { #Structure Type: RegField;
      Name => "LastRptEnqClrMemExtraEcc_1bErrInitiate",
      RegMem => "RegField",
      Description => "When this bit is set, ECC 1b Error will be initiated",
      Width => "1",
      Position => "39",
      Type => "Config",
      UsedBy => "MEM",
      DefaultValue => "b0",
    },
    VoqTenqHeadEnqEcc_1bErrInitiate => { #Structure Type: RegField;
      Name => "VoqTenqHeadEnqEcc_1bErrInitiate",
      RegMem => "RegField",
      Description => "When this bit is set, ECC 1b Error will be initiated",
      Width => "1",
      Position => "40",
      Type => "Config",
      UsedBy => "MEM",
      DefaultValue => "b0",
    },
    VoqTenqHeadRdEcc_1bErrInitiate => { #Structure Type: RegField;
      Name => "VoqTenqHeadRdEcc_1bErrInitiate",
      RegMem => "RegField",
      Description => "When this bit is set, ECC 1b Error will be initiated",
      Width => "1",
      Position => "41",
      Type => "Config",
      UsedBy => "MEM",
      DefaultValue => "b0",
    },
    VoqTenqHeadMsbEnqEcc_1bErrInitiate => { #Structure Type: RegField;
      Name => "VoqTenqHeadMsbEnqEcc_1bErrInitiate",
      RegMem => "RegField",
      Description => "When this bit is set, ECC 1b Error will be initiated",
      Width => "1",
      Position => "42",
      Type => "Config",
      UsedBy => "MEM",
      DefaultValue => "b0",
    },
    VoqTenqHeadMsbRdEcc_1bErrInitiate => { #Structure Type: RegField;
      Name => "VoqTenqHeadMsbRdEcc_1bErrInitiate",
      RegMem => "RegField",
      Description => "When this bit is set, ECC 1b Error will be initiated",
      Width => "1",
      Position => "43",
      Type => "Config",
      UsedBy => "MEM",
      DefaultValue => "b0",
    },
    HeadTimeEnqSetMemEcc_1bErrInitiate => { #Structure Type: RegField;
      Name => "HeadTimeEnqSetMemEcc_1bErrInitiate",
      RegMem => "RegField",
      Description => "When this bit is set, ECC 1b Error will be initiated",
      Width => "1",
      Position => "44",
      Type => "Config",
      UsedBy => "MEM",
      DefaultValue => "b0",
    },
    HeadTimeEnqSetMemExtraEcc_1bErrInitiate => { #Structure Type: RegField;
      Name => "HeadTimeEnqSetMemExtraEcc_1bErrInitiate",
      RegMem => "RegField",
      Description => "When this bit is set, ECC 1b Error will be initiated",
      Width => "1",
      Position => "45",
      Type => "Config",
      UsedBy => "MEM",
      DefaultValue => "b0",
    },
    HeadTimeEnqClrMemEcc_1bErrInitiate => { #Structure Type: RegField;
      Name => "HeadTimeEnqClrMemEcc_1bErrInitiate",
      RegMem => "RegField",
      Description => "When this bit is set, ECC 1b Error will be initiated",
      Width => "1",
      Position => "46",
      Type => "Config",
      UsedBy => "MEM",
      DefaultValue => "b0",
    },
    HeadTimeEnqClrMemExtraEcc_1bErrInitiate => { #Structure Type: RegField;
      Name => "HeadTimeEnqClrMemExtraEcc_1bErrInitiate",
      RegMem => "RegField",
      Description => "When this bit is set, ECC 1b Error will be initiated",
      Width => "1",
      Position => "47",
      Type => "Config",
      UsedBy => "MEM",
      DefaultValue => "b0",
    },
    IsAgingSetMemEcc_1bErrInitiate => { #Structure Type: RegField;
      Name => "IsAgingSetMemEcc_1bErrInitiate",
      RegMem => "RegField",
      Description => "When this bit is set, ECC 1b Error will be initiated",
      Width => "1",
      Position => "48",
      Type => "Config",
      UsedBy => "MEM",
      DefaultValue => "b0",
    },
    IsAgingClrMemEcc_1bErrInitiate => { #Structure Type: RegField;
      Name => "IsAgingClrMemEcc_1bErrInitiate",
      RegMem => "RegField",
      Description => "When this bit is set, ECC 1b Error will be initiated",
      Width => "1",
      Position => "49",
      Type => "Config",
      UsedBy => "MEM",
      DefaultValue => "b0",
    },
    AdmissionResultDramEcc_1bErrInitiate => { #Structure Type: RegField;
      Name => "AdmissionResultDramEcc_1bErrInitiate",
      RegMem => "RegField",
      Description => "When this bit is set, ECC 1b Error will be initiated",
      Width => "1",
      Position => "50",
      Type => "Config",
      UsedBy => "MEM",
      DefaultValue => "b0",
    },
    DropGreenProbabilitySelectorEcc_1bErrInitiate => { #Structure Type: RegField;
      Name => "DropGreenProbabilitySelectorEcc_1bErrInitiate",
      RegMem => "RegField",
      Description => "When this bit is set, ECC 1b Error will be initiated",
      Width => "1",
      Position => "51",
      Type => "Config",
      UsedBy => "MEM",
      DefaultValue => "b0",
    },
    DropYellowProbabilitySelectorEcc_1bErrInitiate => { #Structure Type: RegField;
      Name => "DropYellowProbabilitySelectorEcc_1bErrInitiate",
      RegMem => "RegField",
      Description => "When this bit is set, ECC 1b Error will be initiated",
      Width => "1",
      Position => "52",
      Type => "Config",
      UsedBy => "MEM",
      DefaultValue => "b0",
    },
  },
  Ecc_2bErrInitiateRegister => { #Structure Type: Reg; Skip Register;
    Name => "Ecc_2bErrInitiateRegister",
    RegMem => "Reg",
    Address => "31",
    Description => "ECC 2b Error Initiator Register",
    Width => "53",
    Type => "Config",
    rdrqsnEcc_2bErrInitiate => { #Structure Type: RegField;
      Name => "rdrqsnEcc_2bErrInitiate",
      RegMem => "RegField",
      Description => "When this bit is set, ECC 2b Error will be initiated",
      Width => "1",
      Position => "0",
      Type => "Config",
      UsedBy => "MEM",
      DefaultValue => "b0",
    },
    rdsnEcc_2bErrInitiate => { #Structure Type: RegField;
      Name => "rdsnEcc_2bErrInitiate",
      RegMem => "RegField",
      Description => "When this bit is set, ECC 2b Error will be initiated",
      Width => "1",
      Position => "1",
      Type => "Config",
      UsedBy => "MEM",
      DefaultValue => "b0",
    },
    rdbcEcc_2bErrInitiate => { #Structure Type: RegField;
      Name => "rdbcEcc_2bErrInitiate",
      RegMem => "RegField",
      Description => "When this bit is set, ECC 2b Error will be initiated",
      Width => "1",
      Position => "2",
      Type => "Config",
      UsedBy => "MEM",
      DefaultValue => "b0",
    },
    rdbufcntEcc_2bErrInitiate => { #Structure Type: RegField;
      Name => "rdbufcntEcc_2bErrInitiate",
      RegMem => "RegField",
      Description => "When this bit is set, ECC 2b Error will be initiated",
      Width => "1",
      Position => "3",
      Type => "Config",
      UsedBy => "MEM",
      DefaultValue => "b0",
    },
    wrrqsnEcc_2bErrInitiate => { #Structure Type: RegField;
      Name => "wrrqsnEcc_2bErrInitiate",
      RegMem => "RegField",
      Description => "When this bit is set, ECC 2b Error will be initiated",
      Width => "1",
      Position => "4",
      Type => "Config",
      UsedBy => "MEM",
      DefaultValue => "b0",
    },
    wrsnEcc_2bErrInitiate => { #Structure Type: RegField;
      Name => "wrsnEcc_2bErrInitiate",
      RegMem => "RegField",
      Description => "When this bit is set, ECC 2b Error will be initiated",
      Width => "1",
      Position => "5",
      Type => "Config",
      UsedBy => "MEM",
      DefaultValue => "b0",
    },
    wrbcEcc_2bErrInitiate => { #Structure Type: RegField;
      Name => "wrbcEcc_2bErrInitiate",
      RegMem => "RegField",
      Description => "When this bit is set, ECC 2b Error will be initiated",
      Width => "1",
      Position => "6",
      Type => "Config",
      UsedBy => "MEM",
      DefaultValue => "b0",
    },
    wrbufcntEcc_2bErrInitiate => { #Structure Type: RegField;
      Name => "wrbufcntEcc_2bErrInitiate",
      RegMem => "RegField",
      Description => "When this bit is set, ECC 2b Error will be initiated",
      Width => "1",
      Position => "7",
      Type => "Config",
      UsedBy => "MEM",
      DefaultValue => "b0",
    },
    voq2contextEcc_2bErrInitiate => { #Structure Type: RegField;
      Name => "voq2contextEcc_2bErrInitiate",
      RegMem => "RegField",
      Description => "When this bit is set, ECC 2b Error will be initiated",
      Width => "1",
      Position => "8",
      Type => "Config",
      UsedBy => "MEM",
      DefaultValue => "b0",
    },
    CandRelFifoEcc_2bErrInitiate => { #Structure Type: RegField;
      Name => "CandRelFifoEcc_2bErrInitiate",
      RegMem => "RegField",
      Description => "When this bit is set, ECC 2b Error will be initiated",
      Width => "1",
      Position => "9",
      Type => "Config",
      UsedBy => "MEM",
      DefaultValue => "b0",
    },
    InCandRelFifoSetEcc_2bErrInitiate => { #Structure Type: RegField;
      Name => "InCandRelFifoSetEcc_2bErrInitiate",
      RegMem => "RegField",
      Description => "When this bit is set, ECC 2b Error will be initiated",
      Width => "1",
      Position => "10",
      Type => "Config",
      UsedBy => "MEM",
      DefaultValue => "b0",
    },
    InCandRelFifoClrEcc_2bErrInitiate => { #Structure Type: RegField;
      Name => "InCandRelFifoClrEcc_2bErrInitiate",
      RegMem => "RegField",
      Description => "When this bit is set, ECC 2b Error will be initiated",
      Width => "1",
      Position => "11",
      Type => "Config",
      UsedBy => "MEM",
      DefaultValue => "b0",
    },
    ContextReleaseEligibleSetEcc_2bErrInitiate => { #Structure Type: RegField;
      Name => "ContextReleaseEligibleSetEcc_2bErrInitiate",
      RegMem => "RegField",
      Description => "When this bit is set, ECC 2b Error will be initiated",
      Width => "1",
      Position => "12",
      Type => "Config",
      UsedBy => "MEM",
      DefaultValue => "b0",
    },
    ContextReleaseEligibleClrEcc_2bErrInitiate => { #Structure Type: RegField;
      Name => "ContextReleaseEligibleClrEcc_2bErrInitiate",
      RegMem => "RegField",
      Description => "When this bit is set, ECC 2b Error will be initiated",
      Width => "1",
      Position => "13",
      Type => "Config",
      UsedBy => "MEM",
      DefaultValue => "b0",
    },
    ContextInDramSetEcc_2bErrInitiate => { #Structure Type: RegField;
      Name => "ContextInDramSetEcc_2bErrInitiate",
      RegMem => "RegField",
      Description => "When this bit is set, ECC 2b Error will be initiated",
      Width => "1",
      Position => "14",
      Type => "Config",
      UsedBy => "MEM",
      DefaultValue => "b0",
    },
    ContextInDramClrEcc_2bErrInitiate => { #Structure Type: RegField;
      Name => "ContextInDramClrEcc_2bErrInitiate",
      RegMem => "RegField",
      Description => "When this bit is set, ECC 2b Error will be initiated",
      Width => "1",
      Position => "15",
      Type => "Config",
      UsedBy => "MEM",
      DefaultValue => "b0",
    },
    ContextMapValidSetEcc_2bErrInitiate => { #Structure Type: RegField;
      Name => "ContextMapValidSetEcc_2bErrInitiate",
      RegMem => "RegField",
      Description => "When this bit is set, ECC 2b Error will be initiated",
      Width => "1",
      Position => "16",
      Type => "Config",
      UsedBy => "MEM",
      DefaultValue => "b0",
    },
    ContextMapValidClrEcc_2bErrInitiate => { #Structure Type: RegField;
      Name => "ContextMapValidClrEcc_2bErrInitiate",
      RegMem => "RegField",
      Description => "When this bit is set, ECC 2b Error will be initiated",
      Width => "1",
      Position => "17",
      Type => "Config",
      UsedBy => "MEM",
      DefaultValue => "b0",
    },
    contextfbmBmpEcc_2bErrInitiate => { #Structure Type: RegField;
      Name => "contextfbmBmpEcc_2bErrInitiate",
      RegMem => "RegField",
      Description => "When this bit is set, ECC 2b Error will be initiated",
      Width => "1",
      Position => "18",
      Type => "Config",
      UsedBy => "MEM",
      DefaultValue => "b0",
    },
    NewVoqSetEcc_2bErrInitiate => { #Structure Type: RegField;
      Name => "NewVoqSetEcc_2bErrInitiate",
      RegMem => "RegField",
      Description => "When this bit is set, ECC 2b Error will be initiated",
      Width => "1",
      Position => "19",
      Type => "Config",
      UsedBy => "MEM",
      DefaultValue => "b0",
    },
    NewVoqClrEcc_2bErrInitiate => { #Structure Type: RegField;
      Name => "NewVoqClrEcc_2bErrInitiate",
      RegMem => "RegField",
      Description => "When this bit is set, ECC 2b Error will be initiated",
      Width => "1",
      Position => "20",
      Type => "Config",
      UsedBy => "MEM",
      DefaultValue => "b0",
    },
    voqPropertiesEcc_2bErrInitiate => { #Structure Type: RegField;
      Name => "voqPropertiesEcc_2bErrInitiate",
      RegMem => "RegField",
      Description => "When this bit is set, ECC 2b Error will be initiated",
      Width => "1",
      Position => "21",
      Type => "Config",
      UsedBy => "MEM",
      DefaultValue => "b0",
    },
    staticMappingEcc_2bErrInitiate => { #Structure Type: RegField;
      Name => "staticMappingEcc_2bErrInitiate",
      RegMem => "RegField",
      Description => "When this bit is set, ECC 2b Error will be initiated",
      Width => "1",
      Position => "22",
      Type => "Config",
      UsedBy => "MEM",
      DefaultValue => "b0",
    },
    context_allocate_set_masterEcc_2bErrInitiate => { #Structure Type: RegField;
      Name => "context_allocate_set_masterEcc_2bErrInitiate",
      RegMem => "RegField",
      Description => "When this bit is set, ECC 2b Error will be initiated",
      Width => "1",
      Position => "23",
      Type => "Config",
      UsedBy => "MEM",
      DefaultValue => "b0",
    },
    context_allocate_set_slaveEcc_2bErrInitiate => { #Structure Type: RegField;
      Name => "context_allocate_set_slaveEcc_2bErrInitiate",
      RegMem => "RegField",
      Description => "When this bit is set, ECC 2b Error will be initiated",
      Width => "1",
      Position => "24",
      Type => "Config",
      UsedBy => "MEM",
      DefaultValue => "b0",
    },
    context_allocate_clr_masterEcc_2bErrInitiate => { #Structure Type: RegField;
      Name => "context_allocate_clr_masterEcc_2bErrInitiate",
      RegMem => "RegField",
      Description => "When this bit is set, ECC 2b Error will be initiated",
      Width => "1",
      Position => "25",
      Type => "Config",
      UsedBy => "MEM",
      DefaultValue => "b0",
    },
    context_allocate_clr_slaveEcc_2bErrInitiate => { #Structure Type: RegField;
      Name => "context_allocate_clr_slaveEcc_2bErrInitiate",
      RegMem => "RegField",
      Description => "When this bit is set, ECC 2b Error will be initiated",
      Width => "1",
      Position => "26",
      Type => "Config",
      UsedBy => "MEM",
      DefaultValue => "b0",
    },
    context_allocate_grant_setEcc_2bErrInitiate => { #Structure Type: RegField;
      Name => "context_allocate_grant_setEcc_2bErrInitiate",
      RegMem => "RegField",
      Description => "When this bit is set, ECC 2b Error will be initiated",
      Width => "1",
      Position => "27",
      Type => "Config",
      UsedBy => "MEM",
      DefaultValue => "b0",
    },
    context_allocate_grant_clrEcc_2bErrInitiate => { #Structure Type: RegField;
      Name => "context_allocate_grant_clrEcc_2bErrInitiate",
      RegMem => "RegField",
      Description => "When this bit is set, ECC 2b Error will be initiated",
      Width => "1",
      Position => "28",
      Type => "Config",
      UsedBy => "MEM",
      DefaultValue => "b0",
    },
    Context2voqEcc_2bErrInitiate => { #Structure Type: RegField;
      Name => "Context2voqEcc_2bErrInitiate",
      RegMem => "RegField",
      Description => "When this bit is set, ECC 2b Error will be initiated",
      Width => "1",
      Position => "29",
      Type => "Config",
      UsedBy => "MEM",
      DefaultValue => "b0",
    },
    RqmFreeFifoEcc_2bErrInitiate => { #Structure Type: RegField;
      Name => "RqmFreeFifoEcc_2bErrInitiate",
      RegMem => "RegField",
      Description => "When this bit is set, ECC 2b Error will be initiated",
      Width => "1",
      Position => "30",
      Type => "Config",
      UsedBy => "MEM",
      DefaultValue => "b0",
    },
    voqcgmProfileEcc_2bErrInitiate => { #Structure Type: RegField;
      Name => "voqcgmProfileEcc_2bErrInitiate",
      RegMem => "RegField",
      Description => "When this bit is set, ECC 2b Error will be initiated",
      Width => "1",
      Position => "31",
      Type => "Config",
      UsedBy => "MEM",
      DefaultValue => "b0",
    },
    BuffersConsumptionLutForEnqEcc_2bErrInitiate => { #Structure Type: RegField;
      Name => "BuffersConsumptionLutForEnqEcc_2bErrInitiate",
      RegMem => "RegField",
      Description => "When this bit is set, ECC 2b Error will be initiated",
      Width => "1",
      Position => "32",
      Type => "Config",
      UsedBy => "MEM",
      DefaultValue => "b0",
    },
    PdConsumptionLutForEnqEcc_2bErrInitiate => { #Structure Type: RegField;
      Name => "PdConsumptionLutForEnqEcc_2bErrInitiate",
      RegMem => "RegField",
      Description => "When this bit is set, ECC 2b Error will be initiated",
      Width => "1",
      Position => "33",
      Type => "Config",
      UsedBy => "MEM",
      DefaultValue => "b0",
    },
    VoqEnqRptSizeEcc_2bErrInitiate => { #Structure Type: RegField;
      Name => "VoqEnqRptSizeEcc_2bErrInitiate",
      RegMem => "RegField",
      Description => "When this bit is set, ECC 2b Error will be initiated",
      Width => "1",
      Position => "34",
      Type => "Config",
      UsedBy => "MEM",
      DefaultValue => "b0",
    },
    VoqDeqRptSizeEcc_2bErrInitiate => { #Structure Type: RegField;
      Name => "VoqDeqRptSizeEcc_2bErrInitiate",
      RegMem => "RegField",
      Description => "When this bit is set, ECC 2b Error will be initiated",
      Width => "1",
      Position => "35",
      Type => "Config",
      UsedBy => "MEM",
      DefaultValue => "b0",
    },
    LastRptEnqSetMemEcc_2bErrInitiate => { #Structure Type: RegField;
      Name => "LastRptEnqSetMemEcc_2bErrInitiate",
      RegMem => "RegField",
      Description => "When this bit is set, ECC 2b Error will be initiated",
      Width => "1",
      Position => "36",
      Type => "Config",
      UsedBy => "MEM",
      DefaultValue => "b0",
    },
    LastRptEnqSetMemExtraEcc_2bErrInitiate => { #Structure Type: RegField;
      Name => "LastRptEnqSetMemExtraEcc_2bErrInitiate",
      RegMem => "RegField",
      Description => "When this bit is set, ECC 2b Error will be initiated",
      Width => "1",
      Position => "37",
      Type => "Config",
      UsedBy => "MEM",
      DefaultValue => "b0",
    },
    LastRptEnqClrMemEcc_2bErrInitiate => { #Structure Type: RegField;
      Name => "LastRptEnqClrMemEcc_2bErrInitiate",
      RegMem => "RegField",
      Description => "When this bit is set, ECC 2b Error will be initiated",
      Width => "1",
      Position => "38",
      Type => "Config",
      UsedBy => "MEM",
      DefaultValue => "b0",
    },
    LastRptEnqClrMemExtraEcc_2bErrInitiate => { #Structure Type: RegField;
      Name => "LastRptEnqClrMemExtraEcc_2bErrInitiate",
      RegMem => "RegField",
      Description => "When this bit is set, ECC 2b Error will be initiated",
      Width => "1",
      Position => "39",
      Type => "Config",
      UsedBy => "MEM",
      DefaultValue => "b0",
    },
    VoqTenqHeadEnqEcc_2bErrInitiate => { #Structure Type: RegField;
      Name => "VoqTenqHeadEnqEcc_2bErrInitiate",
      RegMem => "RegField",
      Description => "When this bit is set, ECC 2b Error will be initiated",
      Width => "1",
      Position => "40",
      Type => "Config",
      UsedBy => "MEM",
      DefaultValue => "b0",
    },
    VoqTenqHeadRdEcc_2bErrInitiate => { #Structure Type: RegField;
      Name => "VoqTenqHeadRdEcc_2bErrInitiate",
      RegMem => "RegField",
      Description => "When this bit is set, ECC 2b Error will be initiated",
      Width => "1",
      Position => "41",
      Type => "Config",
      UsedBy => "MEM",
      DefaultValue => "b0",
    },
    VoqTenqHeadMsbEnqEcc_2bErrInitiate => { #Structure Type: RegField;
      Name => "VoqTenqHeadMsbEnqEcc_2bErrInitiate",
      RegMem => "RegField",
      Description => "When this bit is set, ECC 2b Error will be initiated",
      Width => "1",
      Position => "42",
      Type => "Config",
      UsedBy => "MEM",
      DefaultValue => "b0",
    },
    VoqTenqHeadMsbRdEcc_2bErrInitiate => { #Structure Type: RegField;
      Name => "VoqTenqHeadMsbRdEcc_2bErrInitiate",
      RegMem => "RegField",
      Description => "When this bit is set, ECC 2b Error will be initiated",
      Width => "1",
      Position => "43",
      Type => "Config",
      UsedBy => "MEM",
      DefaultValue => "b0",
    },
    HeadTimeEnqSetMemEcc_2bErrInitiate => { #Structure Type: RegField;
      Name => "HeadTimeEnqSetMemEcc_2bErrInitiate",
      RegMem => "RegField",
      Description => "When this bit is set, ECC 2b Error will be initiated",
      Width => "1",
      Position => "44",
      Type => "Config",
      UsedBy => "MEM",
      DefaultValue => "b0",
    },
    HeadTimeEnqSetMemExtraEcc_2bErrInitiate => { #Structure Type: RegField;
      Name => "HeadTimeEnqSetMemExtraEcc_2bErrInitiate",
      RegMem => "RegField",
      Description => "When this bit is set, ECC 2b Error will be initiated",
      Width => "1",
      Position => "45",
      Type => "Config",
      UsedBy => "MEM",
      DefaultValue => "b0",
    },
    HeadTimeEnqClrMemEcc_2bErrInitiate => { #Structure Type: RegField;
      Name => "HeadTimeEnqClrMemEcc_2bErrInitiate",
      RegMem => "RegField",
      Description => "When this bit is set, ECC 2b Error will be initiated",
      Width => "1",
      Position => "46",
      Type => "Config",
      UsedBy => "MEM",
      DefaultValue => "b0",
    },
    HeadTimeEnqClrMemExtraEcc_2bErrInitiate => { #Structure Type: RegField;
      Name => "HeadTimeEnqClrMemExtraEcc_2bErrInitiate",
      RegMem => "RegField",
      Description => "When this bit is set, ECC 2b Error will be initiated",
      Width => "1",
      Position => "47",
      Type => "Config",
      UsedBy => "MEM",
      DefaultValue => "b0",
    },
    IsAgingSetMemEcc_2bErrInitiate => { #Structure Type: RegField;
      Name => "IsAgingSetMemEcc_2bErrInitiate",
      RegMem => "RegField",
      Description => "When this bit is set, ECC 2b Error will be initiated",
      Width => "1",
      Position => "48",
      Type => "Config",
      UsedBy => "MEM",
      DefaultValue => "b0",
    },
    IsAgingClrMemEcc_2bErrInitiate => { #Structure Type: RegField;
      Name => "IsAgingClrMemEcc_2bErrInitiate",
      RegMem => "RegField",
      Description => "When this bit is set, ECC 2b Error will be initiated",
      Width => "1",
      Position => "49",
      Type => "Config",
      UsedBy => "MEM",
      DefaultValue => "b0",
    },
    AdmissionResultDramEcc_2bErrInitiate => { #Structure Type: RegField;
      Name => "AdmissionResultDramEcc_2bErrInitiate",
      RegMem => "RegField",
      Description => "When this bit is set, ECC 2b Error will be initiated",
      Width => "1",
      Position => "50",
      Type => "Config",
      UsedBy => "MEM",
      DefaultValue => "b0",
    },
    DropGreenProbabilitySelectorEcc_2bErrInitiate => { #Structure Type: RegField;
      Name => "DropGreenProbabilitySelectorEcc_2bErrInitiate",
      RegMem => "RegField",
      Description => "When this bit is set, ECC 2b Error will be initiated",
      Width => "1",
      Position => "51",
      Type => "Config",
      UsedBy => "MEM",
      DefaultValue => "b0",
    },
    DropYellowProbabilitySelectorEcc_2bErrInitiate => { #Structure Type: RegField;
      Name => "DropYellowProbabilitySelectorEcc_2bErrInitiate",
      RegMem => "RegField",
      Description => "When this bit is set, ECC 2b Error will be initiated",
      Width => "1",
      Position => "52",
      Type => "Config",
      UsedBy => "MEM",
      DefaultValue => "b0",
    },
  },
  MemProtectErrStatus => { #Structure Type: Reg; Skip Register;
    Name => "MemProtectErrStatus",
    RegMem => "Reg",
    Address => "33",
    Description => "Memory SER protected error status",
    Width => "53",
    Type => "ReadOnly",
    rdrqsnErrInt => { #Structure Type: RegField;
      Name => "rdrqsnErrInt",
      RegMem => "RegField",
      Description => "When this bit is set, SER Error occured",
      Width => "1",
      Position => "0",
      Type => "Status",
      UsedBy => "SER",
    },
    rdsnErrInt => { #Structure Type: RegField;
      Name => "rdsnErrInt",
      RegMem => "RegField",
      Description => "When this bit is set, SER Error occured",
      Width => "1",
      Position => "1",
      Type => "Status",
      UsedBy => "SER",
    },
    rdbcErrInt => { #Structure Type: RegField;
      Name => "rdbcErrInt",
      RegMem => "RegField",
      Description => "When this bit is set, SER Error occured",
      Width => "1",
      Position => "2",
      Type => "Status",
      UsedBy => "SER",
    },
    rdbufcntErrInt => { #Structure Type: RegField;
      Name => "rdbufcntErrInt",
      RegMem => "RegField",
      Description => "When this bit is set, SER Error occured",
      Width => "1",
      Position => "3",
      Type => "Status",
      UsedBy => "SER",
    },
    wrrqsnErrInt => { #Structure Type: RegField;
      Name => "wrrqsnErrInt",
      RegMem => "RegField",
      Description => "When this bit is set, SER Error occured",
      Width => "1",
      Position => "4",
      Type => "Status",
      UsedBy => "SER",
    },
    wrsnErrInt => { #Structure Type: RegField;
      Name => "wrsnErrInt",
      RegMem => "RegField",
      Description => "When this bit is set, SER Error occured",
      Width => "1",
      Position => "5",
      Type => "Status",
      UsedBy => "SER",
    },
    wrbcErrInt => { #Structure Type: RegField;
      Name => "wrbcErrInt",
      RegMem => "RegField",
      Description => "When this bit is set, SER Error occured",
      Width => "1",
      Position => "6",
      Type => "Status",
      UsedBy => "SER",
    },
    wrbufcntErrInt => { #Structure Type: RegField;
      Name => "wrbufcntErrInt",
      RegMem => "RegField",
      Description => "When this bit is set, SER Error occured",
      Width => "1",
      Position => "7",
      Type => "Status",
      UsedBy => "SER",
    },
    voq2contextErrInt => { #Structure Type: RegField;
      Name => "voq2contextErrInt",
      RegMem => "RegField",
      Description => "When this bit is set, SER Error occured",
      Width => "1",
      Position => "8",
      Type => "Status",
      UsedBy => "SER",
    },
    CandRelFifoErrInt => { #Structure Type: RegField;
      Name => "CandRelFifoErrInt",
      RegMem => "RegField",
      Description => "When this bit is set, SER Error occured",
      Width => "1",
      Position => "9",
      Type => "Status",
      UsedBy => "SER",
    },
    InCandRelFifoSetErrInt => { #Structure Type: RegField;
      Name => "InCandRelFifoSetErrInt",
      RegMem => "RegField",
      Description => "When this bit is set, SER Error occured",
      Width => "1",
      Position => "10",
      Type => "Status",
      UsedBy => "SER",
    },
    InCandRelFifoClrErrInt => { #Structure Type: RegField;
      Name => "InCandRelFifoClrErrInt",
      RegMem => "RegField",
      Description => "When this bit is set, SER Error occured",
      Width => "1",
      Position => "11",
      Type => "Status",
      UsedBy => "SER",
    },
    ContextReleaseEligibleSetErrInt => { #Structure Type: RegField;
      Name => "ContextReleaseEligibleSetErrInt",
      RegMem => "RegField",
      Description => "When this bit is set, SER Error occured",
      Width => "1",
      Position => "12",
      Type => "Status",
      UsedBy => "SER",
    },
    ContextReleaseEligibleClrErrInt => { #Structure Type: RegField;
      Name => "ContextReleaseEligibleClrErrInt",
      RegMem => "RegField",
      Description => "When this bit is set, SER Error occured",
      Width => "1",
      Position => "13",
      Type => "Status",
      UsedBy => "SER",
    },
    ContextInDramSetErrInt => { #Structure Type: RegField;
      Name => "ContextInDramSetErrInt",
      RegMem => "RegField",
      Description => "When this bit is set, SER Error occured",
      Width => "1",
      Position => "14",
      Type => "Status",
      UsedBy => "SER",
    },
    ContextInDramClrErrInt => { #Structure Type: RegField;
      Name => "ContextInDramClrErrInt",
      RegMem => "RegField",
      Description => "When this bit is set, SER Error occured",
      Width => "1",
      Position => "15",
      Type => "Status",
      UsedBy => "SER",
    },
    ContextMapValidSetErrInt => { #Structure Type: RegField;
      Name => "ContextMapValidSetErrInt",
      RegMem => "RegField",
      Description => "When this bit is set, SER Error occured",
      Width => "1",
      Position => "16",
      Type => "Status",
      UsedBy => "SER",
    },
    ContextMapValidClrErrInt => { #Structure Type: RegField;
      Name => "ContextMapValidClrErrInt",
      RegMem => "RegField",
      Description => "When this bit is set, SER Error occured",
      Width => "1",
      Position => "17",
      Type => "Status",
      UsedBy => "SER",
    },
    contextfbmBmpErrInt => { #Structure Type: RegField;
      Name => "contextfbmBmpErrInt",
      RegMem => "RegField",
      Description => "When this bit is set, SER Error occured",
      Width => "1",
      Position => "18",
      Type => "Status",
      UsedBy => "SER",
    },
    NewVoqSetErrInt => { #Structure Type: RegField;
      Name => "NewVoqSetErrInt",
      RegMem => "RegField",
      Description => "When this bit is set, SER Error occured",
      Width => "1",
      Position => "19",
      Type => "Status",
      UsedBy => "SER",
    },
    NewVoqClrErrInt => { #Structure Type: RegField;
      Name => "NewVoqClrErrInt",
      RegMem => "RegField",
      Description => "When this bit is set, SER Error occured",
      Width => "1",
      Position => "20",
      Type => "Status",
      UsedBy => "SER",
    },
    voqPropertiesErrInt => { #Structure Type: RegField;
      Name => "voqPropertiesErrInt",
      RegMem => "RegField",
      Description => "When this bit is set, SER Error occured",
      Width => "1",
      Position => "21",
      Type => "Status",
      UsedBy => "SER",
    },
    staticMappingErrInt => { #Structure Type: RegField;
      Name => "staticMappingErrInt",
      RegMem => "RegField",
      Description => "When this bit is set, SER Error occured",
      Width => "1",
      Position => "22",
      Type => "Status",
      UsedBy => "SER",
    },
    context_allocate_set_masterErrInt => { #Structure Type: RegField;
      Name => "context_allocate_set_masterErrInt",
      RegMem => "RegField",
      Description => "When this bit is set, SER Error occured",
      Width => "1",
      Position => "23",
      Type => "Status",
      UsedBy => "SER",
    },
    context_allocate_set_slaveErrInt => { #Structure Type: RegField;
      Name => "context_allocate_set_slaveErrInt",
      RegMem => "RegField",
      Description => "When this bit is set, SER Error occured",
      Width => "1",
      Position => "24",
      Type => "Status",
      UsedBy => "SER",
    },
    context_allocate_clr_masterErrInt => { #Structure Type: RegField;
      Name => "context_allocate_clr_masterErrInt",
      RegMem => "RegField",
      Description => "When this bit is set, SER Error occured",
      Width => "1",
      Position => "25",
      Type => "Status",
      UsedBy => "SER",
    },
    context_allocate_clr_slaveErrInt => { #Structure Type: RegField;
      Name => "context_allocate_clr_slaveErrInt",
      RegMem => "RegField",
      Description => "When this bit is set, SER Error occured",
      Width => "1",
      Position => "26",
      Type => "Status",
      UsedBy => "SER",
    },
    context_allocate_grant_setErrInt => { #Structure Type: RegField;
      Name => "context_allocate_grant_setErrInt",
      RegMem => "RegField",
      Description => "When this bit is set, SER Error occured",
      Width => "1",
      Position => "27",
      Type => "Status",
      UsedBy => "SER",
    },
    context_allocate_grant_clrErrInt => { #Structure Type: RegField;
      Name => "context_allocate_grant_clrErrInt",
      RegMem => "RegField",
      Description => "When this bit is set, SER Error occured",
      Width => "1",
      Position => "28",
      Type => "Status",
      UsedBy => "SER",
    },
    Context2voqErrInt => { #Structure Type: RegField;
      Name => "Context2voqErrInt",
      RegMem => "RegField",
      Description => "When this bit is set, SER Error occured",
      Width => "1",
      Position => "29",
      Type => "Status",
      UsedBy => "SER",
    },
    RqmFreeFifoErrInt => { #Structure Type: RegField;
      Name => "RqmFreeFifoErrInt",
      RegMem => "RegField",
      Description => "When this bit is set, SER Error occured",
      Width => "1",
      Position => "30",
      Type => "Status",
      UsedBy => "SER",
    },
    voqcgmProfileErrInt => { #Structure Type: RegField;
      Name => "voqcgmProfileErrInt",
      RegMem => "RegField",
      Description => "When this bit is set, SER Error occured",
      Width => "1",
      Position => "31",
      Type => "Status",
      UsedBy => "SER",
    },
    BuffersConsumptionLutForEnqErrInt => { #Structure Type: RegField;
      Name => "BuffersConsumptionLutForEnqErrInt",
      RegMem => "RegField",
      Description => "When this bit is set, SER Error occured",
      Width => "1",
      Position => "32",
      Type => "Status",
      UsedBy => "SER",
    },
    PdConsumptionLutForEnqErrInt => { #Structure Type: RegField;
      Name => "PdConsumptionLutForEnqErrInt",
      RegMem => "RegField",
      Description => "When this bit is set, SER Error occured",
      Width => "1",
      Position => "33",
      Type => "Status",
      UsedBy => "SER",
    },
    VoqEnqRptSizeErrInt => { #Structure Type: RegField;
      Name => "VoqEnqRptSizeErrInt",
      RegMem => "RegField",
      Description => "When this bit is set, SER Error occured",
      Width => "1",
      Position => "34",
      Type => "Status",
      UsedBy => "SER",
    },
    VoqDeqRptSizeErrInt => { #Structure Type: RegField;
      Name => "VoqDeqRptSizeErrInt",
      RegMem => "RegField",
      Description => "When this bit is set, SER Error occured",
      Width => "1",
      Position => "35",
      Type => "Status",
      UsedBy => "SER",
    },
    LastRptEnqSetMemErrInt => { #Structure Type: RegField;
      Name => "LastRptEnqSetMemErrInt",
      RegMem => "RegField",
      Description => "When this bit is set, SER Error occured",
      Width => "1",
      Position => "36",
      Type => "Status",
      UsedBy => "SER",
    },
    LastRptEnqSetMemExtraErrInt => { #Structure Type: RegField;
      Name => "LastRptEnqSetMemExtraErrInt",
      RegMem => "RegField",
      Description => "When this bit is set, SER Error occured",
      Width => "1",
      Position => "37",
      Type => "Status",
      UsedBy => "SER",
    },
    LastRptEnqClrMemErrInt => { #Structure Type: RegField;
      Name => "LastRptEnqClrMemErrInt",
      RegMem => "RegField",
      Description => "When this bit is set, SER Error occured",
      Width => "1",
      Position => "38",
      Type => "Status",
      UsedBy => "SER",
    },
    LastRptEnqClrMemExtraErrInt => { #Structure Type: RegField;
      Name => "LastRptEnqClrMemExtraErrInt",
      RegMem => "RegField",
      Description => "When this bit is set, SER Error occured",
      Width => "1",
      Position => "39",
      Type => "Status",
      UsedBy => "SER",
    },
    VoqTenqHeadEnqErrInt => { #Structure Type: RegField;
      Name => "VoqTenqHeadEnqErrInt",
      RegMem => "RegField",
      Description => "When this bit is set, SER Error occured",
      Width => "1",
      Position => "40",
      Type => "Status",
      UsedBy => "SER",
    },
    VoqTenqHeadRdErrInt => { #Structure Type: RegField;
      Name => "VoqTenqHeadRdErrInt",
      RegMem => "RegField",
      Description => "When this bit is set, SER Error occured",
      Width => "1",
      Position => "41",
      Type => "Status",
      UsedBy => "SER",
    },
    VoqTenqHeadMsbEnqErrInt => { #Structure Type: RegField;
      Name => "VoqTenqHeadMsbEnqErrInt",
      RegMem => "RegField",
      Description => "When this bit is set, SER Error occured",
      Width => "1",
      Position => "42",
      Type => "Status",
      UsedBy => "SER",
    },
    VoqTenqHeadMsbRdErrInt => { #Structure Type: RegField;
      Name => "VoqTenqHeadMsbRdErrInt",
      RegMem => "RegField",
      Description => "When this bit is set, SER Error occured",
      Width => "1",
      Position => "43",
      Type => "Status",
      UsedBy => "SER",
    },
    HeadTimeEnqSetMemErrInt => { #Structure Type: RegField;
      Name => "HeadTimeEnqSetMemErrInt",
      RegMem => "RegField",
      Description => "When this bit is set, SER Error occured",
      Width => "1",
      Position => "44",
      Type => "Status",
      UsedBy => "SER",
    },
    HeadTimeEnqSetMemExtraErrInt => { #Structure Type: RegField;
      Name => "HeadTimeEnqSetMemExtraErrInt",
      RegMem => "RegField",
      Description => "When this bit is set, SER Error occured",
      Width => "1",
      Position => "45",
      Type => "Status",
      UsedBy => "SER",
    },
    HeadTimeEnqClrMemErrInt => { #Structure Type: RegField;
      Name => "HeadTimeEnqClrMemErrInt",
      RegMem => "RegField",
      Description => "When this bit is set, SER Error occured",
      Width => "1",
      Position => "46",
      Type => "Status",
      UsedBy => "SER",
    },
    HeadTimeEnqClrMemExtraErrInt => { #Structure Type: RegField;
      Name => "HeadTimeEnqClrMemExtraErrInt",
      RegMem => "RegField",
      Description => "When this bit is set, SER Error occured",
      Width => "1",
      Position => "47",
      Type => "Status",
      UsedBy => "SER",
    },
    IsAgingSetMemErrInt => { #Structure Type: RegField;
      Name => "IsAgingSetMemErrInt",
      RegMem => "RegField",
      Description => "When this bit is set, SER Error occured",
      Width => "1",
      Position => "48",
      Type => "Status",
      UsedBy => "SER",
    },
    IsAgingClrMemErrInt => { #Structure Type: RegField;
      Name => "IsAgingClrMemErrInt",
      RegMem => "RegField",
      Description => "When this bit is set, SER Error occured",
      Width => "1",
      Position => "49",
      Type => "Status",
      UsedBy => "SER",
    },
    AdmissionResultDramErrInt => { #Structure Type: RegField;
      Name => "AdmissionResultDramErrInt",
      RegMem => "RegField",
      Description => "When this bit is set, SER Error occured",
      Width => "1",
      Position => "50",
      Type => "Status",
      UsedBy => "SER",
    },
    DropGreenProbabilitySelectorErrInt => { #Structure Type: RegField;
      Name => "DropGreenProbabilitySelectorErrInt",
      RegMem => "RegField",
      Description => "When this bit is set, SER Error occured",
      Width => "1",
      Position => "51",
      Type => "Status",
      UsedBy => "SER",
    },
    DropYellowProbabilitySelectorErrInt => { #Structure Type: RegField;
      Name => "DropYellowProbabilitySelectorErrInt",
      RegMem => "RegField",
      Description => "When this bit is set, SER Error occured",
      Width => "1",
      Position => "52",
      Type => "Status",
      UsedBy => "SER",
    },
  },
  SelectedSerErrorInfo => { #Structure Type: Reg; Skip Register;
    Name => "SelectedSerErrorInfo",
    RegMem => "Reg",
    Address => "34",
    Description => "Address and Type of SER error of selected memory",
    Width => "18",
    Type => "ReadOnly",
    MemErrAddr => { #Structure Type: RegField;
      Name => "MemErrAddr",
      RegMem => "RegField",
      Description => "Address of SER error of selected memory",
      Width => "16",
      Position => "15:0",
      Type => "Status",
      UsedBy => "SER",
    },
    MemErrType => { #Structure Type: RegField;
      Name => "MemErrType",
      RegMem => "RegField",
      Description => "0 = ECC 1b, 1 = ECC 2b, 2 = Parity",
      Width => "2",
      Position => "17:16",
      Type => "Status",
      UsedBy => "SER",
    },
  },
  SerErrorDebugConfiguration => { #Structure Type: Reg; Skip Register;
    Name => "SerErrorDebugConfiguration",
    RegMem => "Reg",
    Address => "35",
    Description => "Address and Type of SER error of selected memory",
    Width => "7",
    Type => "Config",
    ErroneousMemorySelector => { #Structure Type: RegField;
      Name => "ErroneousMemorySelector",
      RegMem => "RegField",
      Description => "Selects which memory error address and error type to set on the status register",
      Width => "6",
      Position => "5:0",
      Type => "Config",
      UsedBy => "SER",
      DefaultValue => "b0",
    },
    ResetMemoryErrors => { #Structure Type: RegField;
      Name => "ResetMemoryErrors",
      RegMem => "RegField",
      Description => "When set to 1 - all the memory SER errors are reset. Need to set back to 0 to resume error recording",
      Width => "1",
      Position => "6",
      Type => "Config",
      UsedBy => "SER",
      DefaultValue => "b0",
    },
  },
  Ecc_1bErrDebug => { #Structure Type: Reg; Skip Register;
    Name => "Ecc_1bErrDebug",
    RegMem => "Reg",
    Address => "36",
    Description => "ECC 1b Error Counter",
    Width => "16",
    Type => "ReadOnly",
    Ecc_1bErrCounter => { #Structure Type: RegField;
      Name => "Ecc_1bErrCounter",
      RegMem => "RegField",
      Description => "Counts number of ECC 1b errors",
      Width => "16",
      Position => "15:0",
      Type => "Counter",
      UsedBy => "SER",
      AdditionalInfo => "CounterIncrWidth=1",
    },
  },
  Ecc_2bErrDebug => { #Structure Type: Reg; Skip Register;
    Name => "Ecc_2bErrDebug",
    RegMem => "Reg",
    Address => "37",
    Description => "ECC 2b Error Counter",
    Width => "16",
    Type => "ReadOnly",
    Ecc_2bErrCounter => { #Structure Type: RegField;
      Name => "Ecc_2bErrCounter",
      RegMem => "RegField",
      Description => "Counts number of ECC 2b errors",
      Width => "16",
      Position => "15:0",
      Type => "Counter",
      UsedBy => "SER",
      AdditionalInfo => "CounterIncrWidth=1",
    },
  },

  CounterTimer => { #Structure Type: Reg; Skip Register;
    Name => "CounterTimer",
    RegMem => "Reg",
    Address => "40",
    Description => "Defines Counter Timer parameters",
    Width => "33", # Excel Formula: =calc_reg_width(E8:E9,F9)
    Type => "Config",
    CounterTimerEnable => { #Structure Type: RegField;
      Name => "CounterTimerEnable",
      RegMem => "RegField",
      Description => "If set, Counter Timer will applied for the counters, otherwise the counters are free running",
      Width => "1",
      Position => "0", # Excel Formula: =calc_position(F7,E8,TRUE)
      Type => "Config",
      UsedBy => "CIF",
      DefaultValue => "b0",
    },
    CounterTimerCycle => { #Structure Type: RegField;
      Name => "CounterTimerCycle",
      RegMem => "RegField",
      Description => "When activated, CounterTimer will count for CounterTimerCycle",
      Width => "32",
      Position => "32:1", # Excel Formula: =calc_position(F8,E9)
      Type => "Config",
      UsedBy => "CIF",
      DefaultValue => "h3B9ACA00",
    },
  },
  CounterTimerTriggerReg => { #Structure Type: Reg; Skip Register;
    Name => "CounterTimerTriggerReg",
    RegMem => "Reg",
    Address => "41", # Excel Formula: =calc_reg_address(C7,A7,G7)
    Description => "Activates Counter Timer",
    Width => "1", # Excel Formula: =calc_reg_width(E11:E11,F11)
    Type => "External",
    UsedBy => "CIF",
    CounterTimerTrigger => { #Structure Type: RegField;
      Name => "CounterTimerTrigger",
      RegMem => "RegField",
      Description => "When activated, CounterTimer will count for CounterTimerCycle",
      Width => "1",
      Position => "0", # Excel Formula: =calc_position(F10,E11,TRUE)
      Type => "External",
    },
  },
  MemoryAccessTimeout => { #Structure Type: Reg; Skip Register;
    Name => "MemoryAccessTimeout",
    RegMem => "Reg",
    Address => "42", # Excel Formula: =calc_reg_address(C10,A10,G10)
    Description => "Defines parameters for memory access timer expiry",
    Width => "38", # Excel Formula: =calc_reg_width(E13:E15,F15)
    Type => "Config",
    BubbleCounterThr => { #Structure Type: RegField;
      Name => "BubbleCounterThr",
      RegMem => "RegField",
      Description => "When BubbleCounterThr clocks passed from CIF memory access without grant, Bubble Request signal raised towards the block ",
      Width => "16",
      Position => "15:0", # Excel Formula: =calc_position(F12,E13,TRUE)
      Type => "Config",
      UsedBy => "CIF",
      DefaultValue => "d256",
    },
    TimeoutCounterThr => { #Structure Type: RegField;
      Name => "TimeoutCounterThr",
      RegMem => "RegField",
      Description => "When TimeoutCounterThr clocks passed from CIF memory access without grant, the access is terminated with error ",
      Width => "16",
      Position => "31:16", # Excel Formula: =calc_position(F13,E14)
      Type => "Config",
      UsedBy => "CIF",
      DefaultValue => "d4096",
    },
    AnsWindowCounterThr => { #Structure Type: RegField;
      Name => "AnsWindowCounterThr",
      RegMem => "RegField",
      Description => "When memory access is terminated because of  TimeoutCounterThr, the CIF waits AnsWindowCounterThr clocks for access termination",
      Width => "6",
      Position => "37:32", # Excel Formula: =calc_position(F14,E15)
      Type => "Config",
      UsedBy => "CIF",
      DefaultValue => "d16",
    },
  },
  BroadcastConfigReg => { #Structure Type: Reg; Skip Register;
    Name => "BroadcastConfigReg",
    RegMem => "Reg",
    Address => "43", # Excel Formula: =calc_reg_address(C12,A12,G12)
    Description => "Config Top broadcast parameters",
    Width => "12", # Excel Formula: =calc_reg_width(E17:E17,F17)
    Type => "Config",
    BroadcastId => { #Structure Type: RegField;
      Name => "BroadcastId",
      RegMem => "RegField",
      Description => "Broadcast ID used by Config Top protocol for broadcast messages",
      Width => "12",
      Position => "11:0", # Excel Formula: =calc_position(F16,E17,TRUE)
      Type => "Config",
      UsedBy => "CIF",
      DefaultValue => "hFFF",
    },
  },
  MemoryProtBypass => { #Structure Type: Reg; Skip Register;
    Name => "MemoryProtBypass",
    RegMem => "Reg",
    Address => "44", # Excel Formula: =calc_reg_address(C16,A16,G16)
    Description => "Bypass for ECC/Parity, used for debug",
    Width => "3", # Excel Formula: =calc_reg_width(E19:E21,F21)
    Type => "Config",
    DisableEcc => { #Structure Type: RegField;
      Name => "DisableEcc",
      RegMem => "RegField",
      Description => "If set, ECC fix is bypassed and is taken from payload",
      Width => "1",
      Position => "0", # Excel Formula: =calc_position(F18,E19,TRUE)
      Type => "Config",
      UsedBy => "MEM",
      DefaultValue => "b0",
    },
    CifProtGenBypass => { #Structure Type: RegField;
      Name => "CifProtGenBypass",
      RegMem => "RegField",
      Description => "If set, ECC/Parity generation is bypassed and is taken from payload for CIF access",
      Width => "1",
      Position => "1", # Excel Formula: =calc_position(F19,E20)
      Type => "Config",
      UsedBy => "MEM",
      DefaultValue => "b0",
    },
    CifProtFixBypass => { #Structure Type: RegField;
      Name => "CifProtFixBypass",
      RegMem => "RegField",
      Description => "If set, ECC/Parity fix is bypassed and original ECC/Parity is forwarded towards the CIF",
      Width => "1",
      Position => "2", # Excel Formula: =calc_position(F20,E21)
      Type => "Config",
      UsedBy => "MEM",
      DefaultValue => "b0",
    },
  },
  SoftResetConfiguration => { #Structure Type: Reg; Skip Register;
    Name => "SoftResetConfiguration",
    RegMem => "Reg",
    Address => "45", # Excel Formula: =calc_reg_address(C18,A18,G18)
    Description => "Soft Reset Configuration for the block",
    Width => "1", # Excel Formula: =calc_reg_width(E23:E23,F23)
    Type => "Config",
    SoftRstn => { #Structure Type: RegField;
      Name => "SoftRstn",
      RegMem => "RegField",
      Description => "Triggers soft reset signal for the block, active low register",
      Width => "1",
      Position => "0", # Excel Formula: =calc_position(F22,E23,TRUE)
      Type => "Config",
      UsedBy => "CIF",
      DefaultValue => "b0",
    },
  },
  MbistConfiguration => { #Structure Type: Reg; Skip Register;
    Name => "MbistConfiguration",
    RegMem => "Reg",
    Address => "46", # Excel Formula: =calc_reg_address(C22,A22,G22)
    Description => "MBIST Configuration for the block",
    Width => "73", # Excel Formula: =calc_reg_width(E25:E53,F53)
    Type => "Config",
    SACR1P_RME => { #Structure Type: RegField;
      Name => "SACR1P_RME",
      RegMem => "RegField",
      Description => "MBIST logic - Read Margin Enable",
      Width => "1",
      Position => "0", # Excel Formula: =calc_position(F24,E25,TRUE)
      Type => "Config",
      UsedBy => "MEM",
      DefaultValue => "b0",
    },
    SACR1P_RM => { #Structure Type: RegField;
      Name => "SACR1P_RM",
      RegMem => "RegField",
      Description => "MBIST logic - Read Margin",
      Width => "4",
      Position => "4:1", # Excel Formula: =calc_position(F25,E26)
      Type => "Config",
      UsedBy => "MEM",
      DefaultValue => "b0",
    },
    SACU2P_RME => { #Structure Type: RegField;
      Name => "SACU2P_RME",
      RegMem => "RegField",
      Description => "MBIST logic - Read Margin Enable",
      Width => "1",
      Position => "5", # Excel Formula: =calc_position(F26,E27)
      Type => "Config",
      UsedBy => "MEM",
      DefaultValue => "b0",
    },
    SACU2P_RM => { #Structure Type: RegField;
      Name => "SACU2P_RM",
      RegMem => "RegField",
      Description => "MBIST logic - Read Margin",
      Width => "4",
      Position => "9:6", # Excel Formula: =calc_position(F27,E28)
      Type => "Config",
      UsedBy => "MEM",
      DefaultValue => "b0",
    },
    SADC1P_RME => { #Structure Type: RegField;
      Name => "SADC1P_RME",
      RegMem => "RegField",
      Description => "MBIST logic - Read Margin Enable",
      Width => "1",
      Position => "10", # Excel Formula: =calc_position(F28,E29)
      Type => "Config",
      UsedBy => "MEM",
      DefaultValue => "b0",
    },
    SADC1P_RM => { #Structure Type: RegField;
      Name => "SADC1P_RM",
      RegMem => "RegField",
      Description => "MBIST logic - Read Margin",
      Width => "4",
      Position => "14:11", # Excel Formula: =calc_position(F29,E30)
      Type => "Config",
      UsedBy => "MEM",
      DefaultValue => "b0",
    },
    SADR2P_RMEA => { #Structure Type: RegField;
      Name => "SADR2P_RMEA",
      RegMem => "RegField",
      Description => "MBIST logic - Read Margin Enable port A",
      Width => "1",
      Position => "15", # Excel Formula: =calc_position(F30,E31)
      Type => "Config",
      UsedBy => "MEM",
      DefaultValue => "b0",
    },
    SADR2P_RMA => { #Structure Type: RegField;
      Name => "SADR2P_RMA",
      RegMem => "RegField",
      Description => "MBIST logic - Read Margin port A",
      Width => "4",
      Position => "19:16", # Excel Formula: =calc_position(F31,E32)
      Type => "Config",
      UsedBy => "MEM",
      DefaultValue => "b0",
    },
    SADR2P_RMEB => { #Structure Type: RegField;
      Name => "SADR2P_RMEB",
      RegMem => "RegField",
      Description => "MBIST logic - Read Margin Enable port B",
      Width => "1",
      Position => "20", # Excel Formula: =calc_position(F32,E33)
      Type => "Config",
      UsedBy => "MEM",
      DefaultValue => "b0",
    },
    SADR2P_RMB => { #Structure Type: RegField;
      Name => "SADR2P_RMB",
      RegMem => "RegField",
      Description => "MBIST logic - Read Margin port B",
      Width => "4",
      Position => "24:21", # Excel Formula: =calc_position(F33,E34)
      Type => "Config",
      UsedBy => "MEM",
      DefaultValue => "b0",
    },
    SADS2P_RMEA => { #Structure Type: RegField;
      Name => "SADS2P_RMEA",
      RegMem => "RegField",
      Description => "MBIST logic - Read Margin Enable port A",
      Width => "1",
      Position => "25", # Excel Formula: =calc_position(F34,E35)
      Type => "Config",
      UsedBy => "MEM",
      DefaultValue => "b0",
    },
    SADS2P_RMA => { #Structure Type: RegField;
      Name => "SADS2P_RMA",
      RegMem => "RegField",
      Description => "MBIST logic - Read Margin port A",
      Width => "4",
      Position => "29:26", # Excel Formula: =calc_position(F35,E36)
      Type => "Config",
      UsedBy => "MEM",
      DefaultValue => "b0",
    },
    SADS2P_RMEB => { #Structure Type: RegField;
      Name => "SADS2P_RMEB",
      RegMem => "RegField",
      Description => "MBIST logic - Read Margin Enable port B",
      Width => "1",
      Position => "30", # Excel Formula: =calc_position(F36,E37)
      Type => "Config",
      UsedBy => "MEM",
      DefaultValue => "b0",
    },
    SADS2P_RMB => { #Structure Type: RegField;
      Name => "SADS2P_RMB",
      RegMem => "RegField",
      Description => "MBIST logic - Read Margin port B",
      Width => "4",
      Position => "34:31", # Excel Formula: =calc_position(F37,E38)
      Type => "Config",
      UsedBy => "MEM",
      DefaultValue => "b0",
    },
    SASR1P_RME => { #Structure Type: RegField;
      Name => "SASR1P_RME",
      RegMem => "RegField",
      Description => "MBIST logic - Read Margin Enable",
      Width => "1",
      Position => "35", # Excel Formula: =calc_position(F38,E39)
      Type => "Config",
      UsedBy => "MEM",
      DefaultValue => "b0",
    },
    SASR1P_RM => { #Structure Type: RegField;
      Name => "SASR1P_RM",
      RegMem => "RegField",
      Description => "MBIST logic - Read Margin",
      Width => "4",
      Position => "39:36", # Excel Formula: =calc_position(F39,E40)
      Type => "Config",
      UsedBy => "MEM",
      DefaultValue => "b0",
    },
    SASS1P_RME => { #Structure Type: RegField;
      Name => "SASS1P_RME",
      RegMem => "RegField",
      Description => "MBIST logic - Read Margin Enable",
      Width => "1",
      Position => "40", # Excel Formula: =calc_position(F40,E41)
      Type => "Config",
      UsedBy => "MEM",
      DefaultValue => "b0",
    },
    SASS1P_RM => { #Structure Type: RegField;
      Name => "SASS1P_RM",
      RegMem => "RegField",
      Description => "MBIST logic - Read Margin",
      Width => "4",
      Position => "44:41", # Excel Formula: =calc_position(F41,E42)
      Type => "Config",
      UsedBy => "MEM",
      DefaultValue => "b0",
    },
    SASS2P_RMEA => { #Structure Type: RegField;
      Name => "SASS2P_RMEA",
      RegMem => "RegField",
      Description => "MBIST logic - Read Margin Enable port A",
      Width => "1",
      Position => "45", # Excel Formula: =calc_position(F42,E43)
      Type => "Config",
      UsedBy => "MEM",
      DefaultValue => "b0",
    },
    SASS2P_RMA => { #Structure Type: RegField;
      Name => "SASS2P_RMA",
      RegMem => "RegField",
      Description => "MBIST logic - Read Margin port A",
      Width => "4",
      Position => "49:46", # Excel Formula: =calc_position(F43,E44)
      Type => "Config",
      UsedBy => "MEM",
      DefaultValue => "b0",
    },
    SASS2P_RMEB => { #Structure Type: RegField;
      Name => "SASS2P_RMEB",
      RegMem => "RegField",
      Description => "MBIST logic - Read Margin Enable port B",
      Width => "1",
      Position => "50", # Excel Formula: =calc_position(F44,E45)
      Type => "Config",
      UsedBy => "MEM",
      DefaultValue => "b0",
    },
    SASS2P_RMB => { #Structure Type: RegField;
      Name => "SASS2P_RMB",
      RegMem => "RegField",
      Description => "MBIST logic - Read Margin port B",
      Width => "4",
      Position => "54:51", # Excel Formula: =calc_position(F45,E46)
      Type => "Config",
      UsedBy => "MEM",
      DefaultValue => "b0",
    },
    SASU2P_RME => { #Structure Type: RegField;
      Name => "SASU2P_RME",
      RegMem => "RegField",
      Description => "MBIST logic - Read Margin Enable",
      Width => "1",
      Position => "55", # Excel Formula: =calc_position(F46,E47)
      Type => "Config",
      UsedBy => "MEM",
      DefaultValue => "b0",
    },
    SASU2P_RM => { #Structure Type: RegField;
      Name => "SASU2P_RM",
      RegMem => "RegField",
      Description => "MBIST logic - Read Margin",
      Width => "4",
      Position => "59:56", # Excel Formula: =calc_position(F47,E48)
      Type => "Config",
      UsedBy => "MEM",
      DefaultValue => "b0",
    },
    SADU1P_RME => { #Structure Type: RegField;
      Name => "SADU1P_RME",
      RegMem => "RegField",
      Description => "MBIST logic - Read Margin Enable",
      Width => "1",
      Position => "60", # Excel Formula: =calc_position(F48,E49)
      Type => "Config",
      UsedBy => "MEM",
      DefaultValue => "b0",
    },
    SADU1P_RM => { #Structure Type: RegField;
      Name => "SADU1P_RM",
      RegMem => "RegField",
      Description => "MBIST logic - Read Margin",
      Width => "4",
      Position => "64:61", # Excel Formula: =calc_position(F49,E50)
      Type => "Config",
      UsedBy => "MEM",
      DefaultValue => "b0",
    },
    SADS2P_RA => { #Structure Type: RegField;
      Name => "SADS2P_RA",
      RegMem => "RegField",
      Description => "MBIST logic - Read Assist for Dual port",
      Width => "2",
      Position => "66:65", # Excel Formula: =calc_position(F50,E51)
      Type => "Config",
      UsedBy => "MEM",
      DefaultValue => "b0",
    },
    SADU1P_WA => { #Structure Type: RegField;
      Name => "SADU1P_WA",
      RegMem => "RegField",
      Description => "Write-Assist configuration for the SP SADU compiler",
      Width => "3",
      Position => "69:67", # Excel Formula: =calc_position(F51,E52)
      Type => "Config",
      UsedBy => "MEM",
      DefaultValue => "d5",
    },
    SADU1P_WPULSE => { #Structure Type: RegField;
      Name => "SADU1P_WPULSE",
      RegMem => "RegField",
      Description => "Write-Assist-Pulse configuration for the SP SADU compiler",
      Width => "3",
      Position => "72:70", # Excel Formula: =calc_position(F52,E53)
      Type => "Config",
      UsedBy => "MEM",
      DefaultValue => "b0",
    },
  },
  PowerDownConfiguration => { #Structure Type: Reg; Skip Register;
    Name => "PowerDownConfiguration",
    RegMem => "Reg",
    Address => "47", # Excel Formula: =calc_reg_address(C24,A24,G24)
    Description => "Power Down Configuration for the block",
    Width => "1", # Excel Formula: =calc_reg_width(E55:E55,F55)
    Type => "Config",
    PowerDown => { #Structure Type: RegField;
      Name => "PowerDown",
      RegMem => "RegField",
      Description => "If set, disables the clock of the block",
      Width => "1",
      Position => "0", # Excel Formula: =calc_position(F54,E55,TRUE)
      Type => "Config",
      UsedBy => "CIF",
      DefaultValue => "b0",
      Comments => "Default value should always be 0",
    },
  },
  SpareReg => { #Structure Type: Reg; Skip Register;
    Name => "SpareReg",
    RegMem => "Reg",
    Address => "48", # Excel Formula: =calc_reg_address(C54,A54,G54)
    Description => "Spare register",
    Width => "128", # Excel Formula: =calc_reg_width(E57:E57,F57)
    Type => "Config",
    SpareRegister => { #Structure Type: RegField;
      Name => "SpareRegister",
      RegMem => "RegField",
      Description => "Spare register ",
      Width => "128",
      Position => "127:0", # Excel Formula: =calc_position(F56,E57,TRUE)
      Type => "Config",
      UsedBy => "CIF",
      DefaultValue => "hffffffffffffffff",
    },
  },
  PmroCtrl => { #Structure Type: Reg; Skip Register;
    Name => "PmroCtrl",
    RegMem => "Reg",
    Address => "49", # Excel Formula: =calc_reg_address(C56,A56,G56)
    Description => "PMRO controller configuration",
    Width => "32", # Excel Formula: =calc_reg_width(E59:E63,F63)
    Type => "Config",
    PmroRstn => { #Structure Type: RegField;
      Name => "PmroRstn",
      RegMem => "RegField",
      Description => "PMRO reset, active low",
      Width => "1",
      Position => "0", # Excel Formula: =calc_position(F58,E59,TRUE)
      Type => "Config",
      UsedBy => "pmro",
      DefaultValue => "d0",
    },
    PmroConfigEn => { #Structure Type: RegField;
      Name => "PmroConfigEn",
      RegMem => "RegField",
      Description => "Enable pmro configuration, when equals to 0 configurations are locked",
      Width => "1",
      Position => "1", # Excel Formula: =calc_position(F59,E60)
      Type => "Config",
      UsedBy => "pmro",
      DefaultValue => "d0",
    },
    PmroStart => { #Structure Type: RegField;
      Name => "PmroStart",
      RegMem => "RegField",
      Description => "Start the pmro operation",
      Width => "1",
      Position => "2", # Excel Formula: =calc_position(F60,E61)
      Type => "Config",
      UsedBy => "pmro",
      DefaultValue => "d0",
    },
    PmroRingEn => { #Structure Type: RegField;
      Name => "PmroRingEn",
      RegMem => "RegField",
      Description => "Determines which PMRO ring to activate, should be configured as one hot",
      Width => "7",
      Position => "9:3", # Excel Formula: =calc_position(F61,E62)
      Type => "Config",
      UsedBy => "pmro",
      DefaultValue => "d1",
    },
    PmroCntPeriod => { #Structure Type: RegField;
      Name => "PmroCntPeriod",
      RegMem => "RegField",
      Description => "Number of core clock cycles on which PMRO is measured",
      Width => "22",
      Position => "31:10", # Excel Formula: =calc_position(F62,E63)
      Type => "Config",
      UsedBy => "pmro",
      DefaultValue => "h3FFFFF",
    },
  },
  PmroStatus => { #Structure Type: Reg; Skip Register;
    Name => "PmroStatus",
    RegMem => "Reg",
    Address => "4A", # Excel Formula: =calc_reg_address(C58,A58,G58)
    Description => "PMRO status configuration",
    Width => "23", # Excel Formula: =calc_reg_width(E65:E66,F66)
    Type => "ReadOnly",
    PmroCountOut => { #Structure Type: RegField;
      Name => "PmroCountOut",
      RegMem => "RegField",
      Description => "The ring oscilator counter value.",
      Width => "22",
      Position => "21:0", # Excel Formula: =calc_position(F64,E65,TRUE)
      Type => "Status",
      UsedBy => "pmro",
    },
    PmroDone => { #Structure Type: RegField;
      Name => "PmroDone",
      RegMem => "RegField",
      Description => "Pmro operation done, PmroCountOut is valid.",
      Width => "1",
      Position => "22", # Excel Formula: =calc_position(F65,E66)
      Type => "Status",
      UsedBy => "pmro",
    },
  },
  MirrorBusConfReg => { #Structure Type: Reg; Skip Register;
    Name => "MirrorBusConfReg",
    RegMem => "Reg",
    Address => "4B", # Excel Formula: =calc_reg_address(C64,A64,G64)
    Description => "Mirror Bus configurations",
    Width => "11", # Excel Formula: =calc_reg_width(E68:E69,F69)
    Type => "Config",
    MirrorBusEn => { #Structure Type: RegField;
      Name => "MirrorBusEn",
      RegMem => "RegField",
      Description => "Enable Mirror Bus",
      Width => "1",
      Position => "0", # Excel Formula: =calc_position(F67,E68,TRUE)
      Type => "Config",
      UsedBy => "BLOCK",
      DefaultValue => "h0",
    },
    MirrorBusSel => { #Structure Type: RegField;
      Name => "MirrorBusSel",
      RegMem => "RegField",
      Description => "Mirror Bus selector",
      Width => "10",
      Position => "10:1", # Excel Formula: =calc_position(F68,E69)
      Type => "Config",
      UsedBy => "BLOCK",
      DefaultValue => "h0",
    },
  },
  MirrorBusStatus => { #Structure Type: Reg; Skip Register;
    Name => "MirrorBusStatus",
    RegMem => "Reg",
    Address => "4C", # Excel Formula: =calc_reg_address(C67,A67,G67)
    Description => "Mirror Bus status result",
    Width => "32", # Excel Formula: =calc_reg_width(E71:E71,F71)
    Type => "ReadOnly",
    MirrorBus => { #Structure Type: RegField;
      Name => "MirrorBus",
      RegMem => "RegField",
      Description => "Mirror Bus status result",
      Width => "32",
      Position => "31:0", # Excel Formula: =calc_position(F70,E71,TRUE)
      Type => "Status",
      UsedBy => "BLOCK",
    },
  },
  DeviceTimeOffsetCfg => { #Structure Type: Reg; Skip Register;
    Name => "DeviceTimeOffsetCfg",
    RegMem => "Reg",
    Address => "4D", # Excel Formula: =calc_reg_address(C70,A70,G70)
    Description => "Define time offset configuration",
    Width => "10", # Excel Formula: =calc_reg_width(E73:E73,F73)
    Type => "Config",
    DeviceTimeOffset => { #Structure Type: RegField;
      Name => "DeviceTimeOffset",
      RegMem => "RegField",
      Description => "Define time offset",
      Width => "10",
      Position => "9:0", # Excel Formula: =calc_position(F72,E73,TRUE)
      Type => "Config",
      UsedBy => "CIF",
      DefaultValue => "h0",
    },
  },
  GeneralInterruptRegister => { #Structure Type: Reg;
    Name => "GeneralInterruptRegister",
    RegMem => "Reg",
    Address => "100",
    Description => "Interrupt",
    Width => "8", # Excel Formula: =calc_reg_width(E8:E15,F15)
    Type => "Interrupt",
    RdReqFifoOveflow => { #Structure Type: RegField;
      Name => "RdReqFifoOveflow",
      RegMem => "RegField",
      Width => "1",
      Position => "0", # Excel Formula: =calc_position(F7,E8,TRUE)
      Type => "Interrupt",
      UsedBy => "RQM",
    },
    DeqReqFifoOverflow => { #Structure Type: RegField;
      Name => "DeqReqFifoOverflow",
      RegMem => "RegField",
      Width => "1",
      Position => "1", # Excel Formula: =calc_position(F8,E9)
      Type => "Interrupt",
      UsedBy => "RQM",
    },
    InFifoOverflow => { #Structure Type: RegField;
      Name => "InFifoOverflow",
      RegMem => "RegField",
      Width => "1",
      Position => "2", # Excel Formula: =calc_position(F9,E10)
      Type => "Interrupt",
      UsedBy => "WQM",
    },
    dram_release_fifo_overflow => { #Structure Type: RegField;
      Name => "dram_release_fifo_overflow",
      RegMem => "RegField",
      Description => "Interrupt 0 description",
      Width => "1",
      Position => "3", # Excel Formula: =calc_position(F10,E11)
      Type => "Interrupt",
      UsedBy => "cmap",
    },
    ics_return_fifo_overflow => { #Structure Type: RegField;
      Name => "ics_return_fifo_overflow",
      RegMem => "RegField",
      Description => "Interrupt 1 description",
      Width => "1",
      Position => "4", # Excel Formula: =calc_position(F11,E12)
      Type => "Interrupt",
      UsedBy => "cmap",
    },
    cpu_return_fifo_overflow => { #Structure Type: RegField;
      Name => "cpu_return_fifo_overflow",
      RegMem => "RegField",
      Description => "Interrupt 1 description",
      Width => "1",
      Position => "5", # Excel Formula: =calc_position(F12,E13)
      Type => "Interrupt",
      UsedBy => "cmap",
    },
    back_to_tail_fifo_overflow => { #Structure Type: RegField;
      Name => "back_to_tail_fifo_overflow",
      RegMem => "RegField",
      Description => "Interrupt 1 description",
      Width => "1",
      Position => "6", # Excel Formula: =calc_position(F13,E14)
      Type => "Interrupt",
      UsedBy => "cmap",
    },
    fromDramCgmFifoOverflow => { #Structure Type: RegField;
      Name => "fromDramCgmFifoOverflow",
      RegMem => "RegField",
      Width => "1",
      Position => "7", # Excel Formula: =calc_position(F14,E15)
      Type => "Interrupt",
      UsedBy => "voq_cgm",
    },
  },
  GeneralInterruptRegisterMask => { #Structure Type: Reg; Skip Register;
    Name => "GeneralInterruptRegisterMask",
    RegMem => "Reg",
    Address => "101",
    Description => "This register masks GeneralInterruptRegister interrupt register",
    Width => "8", # Excel Formula: =calc_reg_width(E8:E15,F15)
    Type => "InterruptMask",
    RdReqFifoOveflowMask => { #Structure Type: RegField;
      Name => "RdReqFifoOveflowMask",
      RegMem => "RegField",
      Width => "1",
      Position => "0", # Excel Formula: =calc_position(F7,E8,TRUE)
      Type => "InterruptMask",
      UsedBy => "",
      DefaultValue => "b1",
    },
    DeqReqFifoOverflowMask => { #Structure Type: RegField;
      Name => "DeqReqFifoOverflowMask",
      RegMem => "RegField",
      Width => "1",
      Position => "1", # Excel Formula: =calc_position(F8,E9)
      Type => "InterruptMask",
      UsedBy => "",
      DefaultValue => "b1",
    },
    InFifoOverflowMask => { #Structure Type: RegField;
      Name => "InFifoOverflowMask",
      RegMem => "RegField",
      Width => "1",
      Position => "2", # Excel Formula: =calc_position(F9,E10)
      Type => "InterruptMask",
      UsedBy => "",
      DefaultValue => "b1",
    },
    dram_release_fifo_overflowMask => { #Structure Type: RegField;
      Name => "dram_release_fifo_overflowMask",
      RegMem => "RegField",
      Description => "This field masks dram_release_fifo_overflow interrupt",
      Width => "1",
      Position => "3", # Excel Formula: =calc_position(F10,E11)
      Type => "InterruptMask",
      UsedBy => "",
      DefaultValue => "b1",
    },
    ics_return_fifo_overflowMask => { #Structure Type: RegField;
      Name => "ics_return_fifo_overflowMask",
      RegMem => "RegField",
      Description => "This field masks ics_return_fifo_overflow interrupt",
      Width => "1",
      Position => "4", # Excel Formula: =calc_position(F11,E12)
      Type => "InterruptMask",
      UsedBy => "",
      DefaultValue => "b1",
    },
    cpu_return_fifo_overflowMask => { #Structure Type: RegField;
      Name => "cpu_return_fifo_overflowMask",
      RegMem => "RegField",
      Description => "This field masks cpu_return_fifo_overflow interrupt",
      Width => "1",
      Position => "5", # Excel Formula: =calc_position(F12,E13)
      Type => "InterruptMask",
      UsedBy => "",
      DefaultValue => "b1",
    },
    back_to_tail_fifo_overflowMask => { #Structure Type: RegField;
      Name => "back_to_tail_fifo_overflowMask",
      RegMem => "RegField",
      Description => "This field masks back_to_tail_fifo_overflow interrupt",
      Width => "1",
      Position => "6", # Excel Formula: =calc_position(F13,E14)
      Type => "InterruptMask",
      UsedBy => "",
      DefaultValue => "b1",
    },
    fromDramCgmFifoOverflowMask => { #Structure Type: RegField;
      Name => "fromDramCgmFifoOverflowMask",
      RegMem => "RegField",
      Width => "1",
      Position => "7", # Excel Formula: =calc_position(F14,E15)
      Type => "InterruptMask",
      UsedBy => "",
      DefaultValue => "b1",
    },
  },
  GeneralInterruptRegisterTest => { #Structure Type: Reg; Skip Register;
    Name => "GeneralInterruptRegisterTest",
    RegMem => "Reg",
    Address => "102",
    Description => "This register tests GeneralInterruptRegister interrupt register",
    Width => "8", # Excel Formula: =calc_reg_width(E8:E15,F15)
    Type => "InterruptTest",
    RdReqFifoOveflowTest => { #Structure Type: RegField;
      Name => "RdReqFifoOveflowTest",
      RegMem => "RegField",
      Width => "1",
      Position => "0", # Excel Formula: =calc_position(F7,E8,TRUE)
      Type => "InterruptTest",
      UsedBy => "",
      DefaultValue => "b0",
    },
    DeqReqFifoOverflowTest => { #Structure Type: RegField;
      Name => "DeqReqFifoOverflowTest",
      RegMem => "RegField",
      Width => "1",
      Position => "1", # Excel Formula: =calc_position(F8,E9)
      Type => "InterruptTest",
      UsedBy => "",
      DefaultValue => "b0",
    },
    InFifoOverflowTest => { #Structure Type: RegField;
      Name => "InFifoOverflowTest",
      RegMem => "RegField",
      Width => "1",
      Position => "2", # Excel Formula: =calc_position(F9,E10)
      Type => "InterruptTest",
      UsedBy => "",
      DefaultValue => "b0",
    },
    dram_release_fifo_overflowTest => { #Structure Type: RegField;
      Name => "dram_release_fifo_overflowTest",
      RegMem => "RegField",
      Description => "This field tests dram_release_fifo_overflow interrupt",
      Width => "1",
      Position => "3", # Excel Formula: =calc_position(F10,E11)
      Type => "InterruptTest",
      UsedBy => "",
      DefaultValue => "b0",
    },
    ics_return_fifo_overflowTest => { #Structure Type: RegField;
      Name => "ics_return_fifo_overflowTest",
      RegMem => "RegField",
      Description => "This field tests ics_return_fifo_overflow interrupt",
      Width => "1",
      Position => "4", # Excel Formula: =calc_position(F11,E12)
      Type => "InterruptTest",
      UsedBy => "",
      DefaultValue => "b0",
    },
    cpu_return_fifo_overflowTest => { #Structure Type: RegField;
      Name => "cpu_return_fifo_overflowTest",
      RegMem => "RegField",
      Description => "This field tests cpu_return_fifo_overflow interrupt",
      Width => "1",
      Position => "5", # Excel Formula: =calc_position(F12,E13)
      Type => "InterruptTest",
      UsedBy => "",
      DefaultValue => "b0",
    },
    back_to_tail_fifo_overflowTest => { #Structure Type: RegField;
      Name => "back_to_tail_fifo_overflowTest",
      RegMem => "RegField",
      Description => "This field tests back_to_tail_fifo_overflow interrupt",
      Width => "1",
      Position => "6", # Excel Formula: =calc_position(F13,E14)
      Type => "InterruptTest",
      UsedBy => "",
      DefaultValue => "b0",
    },
    fromDramCgmFifoOverflowTest => { #Structure Type: RegField;
      Name => "fromDramCgmFifoOverflowTest",
      RegMem => "RegField",
      Width => "1",
      Position => "7", # Excel Formula: =calc_position(F14,E15)
      Type => "InterruptTest",
      UsedBy => "",
      DefaultValue => "b0",
    },
  },
  StatusReg => { #Structure Type: Reg;
    Name => "StatusReg",
    RegMem => "Reg",
    Address => "103", # Excel Formula: =calc_reg_address(C7,A7,G7)
    Description => "Status",
    Width => "6", # Excel Formula: =calc_reg_width(E17:E17,F17)
    Type => "ReadOnly",
    InitActive => { #Structure Type: RegField;
      Name => "InitActive",
      RegMem => "RegField",
      Width => "6",
      Position => "5:0", # Excel Formula: =calc_position(F16,E17,TRUE)
      Type => "Status",
      UsedBy => "core",
    },
  },
  DebugCounters => { #Structure Type: Reg;
    Name => "DebugCounters",
    RegMem => "Reg",
    Address => "104", # Excel Formula: =calc_reg_address(C16,A16,G16)
    Width => "140", # Excel Formula: =calc_reg_width(E19:E25,F25)
    Type => "ReadOnly",
    tsmon2pdvoqCount => { #Structure Type: RegField;
      Name => "tsmon2pdvoqCount",
      RegMem => "RegField",
      Width => "20",
      Position => "19:0", # Excel Formula: =calc_position(F18,E19,TRUE)
      Type => "Counter",
      UsedBy => "CMAP",
      AdditionalInfo => "CounterIncrWidth=1",
    },
    deleteNoContextCount => { #Structure Type: RegField;
      Name => "deleteNoContextCount",
      RegMem => "RegField",
      Width => "20",
      Position => "39:20", # Excel Formula: =calc_position(F19,E20)
      Type => "Counter",
      UsedBy => "CMAP",
      AdditionalInfo => "CounterIncrWidth=1",
    },
    enqueueRptCount => { #Structure Type: RegField;
      Name => "enqueueRptCount",
      RegMem => "RegField",
      Width => "20",
      Position => "59:40", # Excel Formula: =calc_position(F20,E21)
      Type => "Counter",
      UsedBy => "WQM",
      AdditionalInfo => "CounterIncrWidth=1",
    },
    readReqCount => { #Structure Type: RegField;
      Name => "readReqCount",
      RegMem => "RegField",
      Width => "20",
      Position => "79:60", # Excel Formula: =calc_position(F21,E22)
      Type => "Counter",
      UsedBy => "RQM",
      AdditionalInfo => "CounterIncrWidth=1",
    },
    dequeueReqCount => { #Structure Type: RegField;
      Name => "dequeueReqCount",
      RegMem => "RegField",
      Width => "20",
      Position => "99:80", # Excel Formula: =calc_position(F22,E23)
      Type => "Counter",
      UsedBy => "RQM",
      AdditionalInfo => "CounterIncrWidth=1",
    },
    dequeueReqRetransmitCount => { #Structure Type: RegField;
      Name => "dequeueReqRetransmitCount",
      RegMem => "RegField",
      Width => "20",
      Position => "119:100", # Excel Formula: =calc_position(F23,E24)
      Type => "Counter",
      UsedBy => "RQM",
      AdditionalInfo => "CounterIncrWidth=1",
    },
    dequeueRptCount => { #Structure Type: RegField;
      Name => "dequeueRptCount",
      RegMem => "RegField",
      Width => "20",
      Position => "139:120", # Excel Formula: =calc_position(F24,E25)
      Type => "Counter",
      UsedBy => "RQM",
      AdditionalInfo => "CounterIncrWidth=1",
    },
  },
  FifosDebugReg => { #Structure Type: Reg;
    Name => "FifosDebugReg",
    RegMem => "Reg",
    Address => "105", # Excel Formula: =calc_reg_address(C18,A18,G18)
    Width => "104", # Excel Formula: =calc_reg_width(E27:E39,F39)
    Type => "ReadOnly",
    RdReqFifoStat => { #Structure Type: RegField;
      Name => "RdReqFifoStat",
      RegMem => "RegField",
      Description => "This field holds the number of used entries in the read request fifo in the read queue manager",
      Width => "5",
      Position => "4:0", # Excel Formula: =calc_position(F26,E27,TRUE)
      Type => "Status",
      UsedBy => "RQM",
    },
    DeqReqFifoStat => { #Structure Type: RegField;
      Name => "DeqReqFifoStat",
      RegMem => "RegField",
      Description => "This field holds the number of used entries in the dequeue request fifo in the read queue manager",
      Width => "6",
      Position => "10:5", # Excel Formula: =calc_position(F27,E28)
      Type => "Status",
      UsedBy => "RQM",
    },
    InFifoStat => { #Structure Type: RegField;
      Name => "InFifoStat",
      RegMem => "RegField",
      Description => "This field holds the number of used entries in the input  fifo in the write queue manager",
      Width => "6",
      Position => "16:11", # Excel Formula: =calc_position(F28,E29)
      Type => "Status",
      UsedBy => "WQM",
    },
    dram_release_fifo_stat => { #Structure Type: RegField;
      Name => "dram_release_fifo_stat",
      RegMem => "RegField",
      Description => "This field holds the number of used entries in the dram release  fifo in the dynamic context allocation machine",
      Width => "6",
      Position => "22:17", # Excel Formula: =calc_position(F29,E30)
      Type => "Status",
      UsedBy => "CMAP",
    },
    ics_return_fifo_stat => { #Structure Type: RegField;
      Name => "ics_return_fifo_stat",
      RegMem => "RegField",
      Description => "This field holds the number of used entries in the ICS return fifo in the dynamic context allocation machine",
      Width => "6",
      Position => "28:23", # Excel Formula: =calc_position(F30,E31)
      Type => "Status",
      UsedBy => "CMAP",
    },
    cpu_return_fifo_stat => { #Structure Type: RegField;
      Name => "cpu_return_fifo_stat",
      RegMem => "RegField",
      Description => "This field holds the number of used entries in the CPU return fifo in the dynamic context allocation machine",
      Width => "3",
      Position => "31:29", # Excel Formula: =calc_position(F31,E32)
      Type => "Status",
      UsedBy => "CMAP",
    },
    back_to_tail_fifo_stat => { #Structure Type: RegField;
      Name => "back_to_tail_fifo_stat",
      RegMem => "RegField",
      Description => "This field holds the number of used entries in the back-to-tail fifo in the dynamic context allocation machine",
      Width => "5",
      Position => "36:32", # Excel Formula: =calc_position(F32,E33)
      Type => "Status",
      UsedBy => "CMAP",
    },
    context_release_fifo_stat => { #Structure Type: RegField;
      Name => "context_release_fifo_stat",
      RegMem => "RegField",
      Description => "This field holds the number of used entries in the context-release-fifo in the dynamic context allocation machine",
      Width => "13",
      Position => "49:37", # Excel Formula: =calc_position(F33,E34)
      Type => "Status",
      UsedBy => "CMAP",
    },
    pool_fbm_stat => { #Structure Type: RegField;
      Name => "pool_fbm_stat",
      RegMem => "RegField",
      Description => "This field holds the number of free entries in the free-buffer-manager-pool in the dynamic context allocation machine",
      Width => "13",
      Position => "62:50", # Excel Formula: =calc_position(F34,E35)
      Type => "Status",
      UsedBy => "CMAP",
    },
    deleteContextQsize => { #Structure Type: RegField;
      Name => "deleteContextQsize",
      RegMem => "RegField",
      Description => "Unused - tied to 0",
      Width => "14", # Excel Formula: =calc_field_width_define("QSIZE_PKT_WIDTH")
      Position => "76:63", # Excel Formula: =calc_position(F35,E36)
      Type => "Status",
      UsedBy => "RQM",
    },
    tsmon2pdvoqCbrStatus => { #Structure Type: RegField;
      Name => "tsmon2pdvoqCbrStatus",
      RegMem => "RegField",
      Description => "This field holds the status of the tsmon2pdvoq CBR",
      Width => "5",
      Position => "81:77", # Excel Formula: =calc_position(F36,E37)
      Type => "Status",
      UsedBy => "top",
    },
    TotalPdsInSlice => { #Structure Type: RegField;
      Name => "TotalPdsInSlice",
      RegMem => "RegField",
      Description => "This field holds the total number of PDs in the slice. Increment every enqueue, decrement every dequeue and write fail",
      Width => "17",
      Position => "98:82", # Excel Formula: =calc_position(F37,E38)
      Type => "Status",
      UsedBy => "top",
    },
    FromDramCgmFifoStat => { #Structure Type: RegField;
      Name => "FromDramCgmFifoStat",
      RegMem => "RegField",
      Width => "5",
      Position => "103:99", # Excel Formula: =calc_position(F38,E39)
      Type => "Status",
      UsedBy => "voq_cgm",
    },
  },
  CmapThReg => { #Structure Type: Reg;
    Name => "CmapThReg",
    RegMem => "Reg",
    Address => "106", # Excel Formula: =calc_reg_address(C26,A26,G26)
    Description => "Status",
    Width => "112", # Excel Formula: =calc_reg_width(E41:E45,F45)
    Type => "Config",
    ContextPoolLowTh => { #Structure Type: RegField;
      Name => "ContextPoolLowTh",
      RegMem => "RegField",
      Description => "if context pool size smaller than this value start popping from the release fifo",
      Width => "12",
      Position => "11:0", # Excel Formula: =calc_position(F40,E41,TRUE)
      Type => "Config",
      UsedBy => "CMAP",
      DefaultValue => "d1000",
    },
    ContextPoolRetTh => { #Structure Type: RegField;
      Name => "ContextPoolRetTh",
      RegMem => "RegField",
      Description => "if context pool size smaller than this value - enable return of context to the pool",
      Width => "12",
      Position => "23:12", # Excel Formula: =calc_position(F41,E42)
      Type => "Config",
      UsedBy => "CMAP",
      DefaultValue => "d1000",
    },
    ReleaseFifoHighTh => { #Structure Type: RegField;
      Name => "ReleaseFifoHighTh",
      RegMem => "RegField",
      Description => "If release cintext fifo size is greater than this value start popping from release fifo",
      Width => "11",
      Position => "34:24", # Excel Formula: =calc_position(F42,E43)
      Type => "Config",
      UsedBy => "CMAP",
      DefaultValue => "d1000",
    },
    TotalFreeBuf => { #Structure Type: RegField;
      Name => "TotalFreeBuf",
      RegMem => "RegField",
      Description => "Total number of free buffers in the context allocation free buffer manager",
      Width => "13", # Excel Formula: =calc_field_width_define("CONTEXT_WIDTH") +1
      Position => "47:35", # Excel Formula: =calc_position(F43,E44)
      Type => "Config",
      UsedBy => "CMAP",
      DefaultValue => "d4095",
      InitValueSa => "INIT_AFTER_SOFT_RESET 4095",
      InitValueLcNwk => "INIT_AFTER_SOFT_RESET 4095",
      InitValueLcFab => "INIT_AFTER_SOFT_RESET 3663",
      InitValueFe => "INIT_AFTER_SOFT_RESET 3663",
    },
    NotEmptyEntry => { #Structure Type: RegField;
      Name => "NotEmptyEntry",
      RegMem => "RegField",
      Description => "Per entry of contextfbmBmp : '1' -this entry contains at least one free buffer",
      Width => "64", # Excel Formula: =K168
      Position => "111:48", # Excel Formula: =calc_position(F44,E45)
      Type => "Config",
      UsedBy => "CMAP",
      DefaultValue => "hFFFF_FFFF_FFFF_FFFF",
      InitValueSa => "INIT_AFTER_SOFT_RESET 'hFFFF_FFFF_FFFF_FFFF",
      InitValueLcNwk => "INIT_AFTER_SOFT_RESET 'hFFFF_FFFF_FFFF_FFFF",
      InitValueLcFab => "INIT_AFTER_SOFT_RESET 'hffffffffffffffc0",
      InitValueFe => "INIT_AFTER_SOFT_RESET 'hffffffffffffffc0",
    },
  },
  SliceModeReg => { #Structure Type: Reg;
    Name => "SliceModeReg",
    RegMem => "Reg",
    Address => "107", # Excel Formula: =calc_reg_address(C40,A40,G40)
    Width => "4", # Excel Formula: =calc_reg_width(E47:E47,F47)
    Type => "Config",
    SliceMode => { #Structure Type: RegField;
      Name => "SliceMode",
      RegMem => "RegField",
      Description => "0  // Linecard mode CRF TS network slice
1  // Linecard mode CRF SN network slice
2  // Linecard mode CRF TS fabric slice
3  // Linecard mode CRF SN fabric slice
4  // TOR mode network slice with SLB
5  // TOR mode network slice with PLB --> not supported
6  // TOR mode fabric slice with SLB
7  // TOR mode fabric slice with PLB --> not supported
8  // FE mode with TS
9  // FE mode with SN
10 // DRAM slice ",
      Width => "4",
      Position => "3:0", # Excel Formula: =calc_position(F46,E47,TRUE)
      Type => "Config",
      UsedBy => "ALL",
      DefaultValue => "d0",
      InitValueSa => "8",
      InitValueLcNwk => "0",
      InitValueLcFab => "2",
      InitValueFe => "2",
    },
  },
  AlmostFullConf => { #Structure Type: Reg;
    Name => "AlmostFullConf",
    RegMem => "Reg",
    Address => "108", # Excel Formula: =calc_reg_address(C46,A46,G46)
    Width => "56", # Excel Formula: =calc_reg_width(E49:E59,F59)
    Type => "Config",
    rqm2em_alm_full_cfg => { #Structure Type: RegField;
      Name => "rqm2em_alm_full_cfg",
      RegMem => "RegField",
      Width => "6",
      Position => "5:0", # Excel Formula: =calc_position(F48,E49,TRUE)
      Type => "Config",
      UsedBy => "RQM",
      DefaultValue => "d10",
    },
    release_alm_full_cfg => { #Structure Type: RegField;
      Name => "release_alm_full_cfg",
      RegMem => "RegField",
      Width => "5",
      Position => "10:6", # Excel Formula: =calc_position(F49,E50)
      Type => "Config",
      UsedBy => "CMAP",
      DefaultValue => "d10",
    },
    dram_release_alm_full_cfg => { #Structure Type: RegField;
      Name => "dram_release_alm_full_cfg",
      RegMem => "RegField",
      Width => "5",
      Position => "15:11", # Excel Formula: =calc_position(F50,E51)
      Type => "Config",
      UsedBy => "CMAP",
      DefaultValue => "d8",
    },
    ics_release_alm_full_cfg => { #Structure Type: RegField;
      Name => "ics_release_alm_full_cfg",
      RegMem => "RegField",
      Width => "5",
      Position => "20:16", # Excel Formula: =calc_position(F51,E52)
      Type => "Config",
      UsedBy => "CMAP",
      DefaultValue => "d8",
    },
    back_to_tail_alm_full_cfg => { #Structure Type: RegField;
      Name => "back_to_tail_alm_full_cfg",
      RegMem => "RegField",
      Width => "4",
      Position => "24:21", # Excel Formula: =calc_position(F52,E53)
      Type => "Config",
      UsedBy => "CMAP",
      DefaultValue => "d4",
    },
    rqm_del_deq_alm_full_cfg => { #Structure Type: RegField;
      Name => "rqm_del_deq_alm_full_cfg",
      RegMem => "RegField",
      Width => "5",
      Position => "29:25", # Excel Formula: =calc_position(F53,E54)
      Type => "Config",
      UsedBy => "RQM",
      DefaultValue => "d8",
    },
    rqm_deq_req_alm_full_cfg => { #Structure Type: RegField;
      Name => "rqm_deq_req_alm_full_cfg",
      RegMem => "RegField",
      Width => "6",
      Position => "35:30", # Excel Formula: =calc_position(F54,E55)
      Type => "Config",
      UsedBy => "RQM",
      DefaultValue => "d5",
      InitValueAllModes => "39",
    },
    rqm_rd_req_alm_full_cfg => { #Structure Type: RegField;
      Name => "rqm_rd_req_alm_full_cfg",
      RegMem => "RegField",
      Width => "5",
      Position => "40:36", # Excel Formula: =calc_position(F55,E56)
      Type => "Config",
      UsedBy => "RQM",
      DefaultValue => "d17",
      InitValueAllModes => "24",
    },
    wqm_input_alm_full_cfg => { #Structure Type: RegField;
      Name => "wqm_input_alm_full_cfg",
      RegMem => "RegField",
      Width => "6",
      Position => "46:41", # Excel Formula: =calc_position(F56,E57)
      Type => "Config",
      UsedBy => "WQM",
      DefaultValue => "d26",
    },
    wqm_cbt_alm_full_cfg => { #Structure Type: RegField;
      Name => "wqm_cbt_alm_full_cfg",
      RegMem => "RegField",
      Width => "5",
      Position => "51:47", # Excel Formula: =calc_position(F57,E58)
      Type => "Config",
      UsedBy => "WQM",
      DefaultValue => "d2",
    },
    FromDramCgmAlmFullCfg => { #Structure Type: RegField;
      Name => "FromDramCgmAlmFullCfg",
      RegMem => "RegField",
      Width => "4",
      Position => "55:52", # Excel Formula: =calc_position(F58,E59)
      Type => "Config",
      UsedBy => "voq_cgm",
      DefaultValue => "d4",
    },
  },
  GeneralConf => { #Structure Type: Reg;
    Name => "GeneralConf",
    RegMem => "Reg",
    Address => "109", # Excel Formula: =calc_reg_address(C48,A48,G48)
    Width => "3", # Excel Formula: =calc_reg_width(E61:E63,F63)
    Type => "Config",
    IgnoreCgm => { #Structure Type: RegField;
      Name => "IgnoreCgm",
      RegMem => "RegField",
      Description => "1- ignore voq-cgm slice recommandations (for debug)",
      Width => "1",
      Position => "0", # Excel Formula: =calc_position(F60,E61,TRUE)
      Type => "Config",
      UsedBy => "ALL",
      DefaultValue => "b0",
    },
    UcdvDiscardEn => { #Structure Type: RegField;
      Name => "UcdvDiscardEn",
      RegMem => "RegField",
      Description => "1 - enable the ucdv discard manipulation",
      Width => "1",
      Position => "1", # Excel Formula: =calc_position(F61,E62)
      Type => "Config",
      UsedBy => "UCDV",
      DefaultValue => "b1",
    },
    FbmRstnCfg => { #Structure Type: RegField;
      Name => "FbmRstnCfg",
      RegMem => "RegField",
      Description => "If set, FBM will init on soft reset.
In order to clear FBM entries, first clear this entry, then configure the FBM memory and set in order to start its init machine",
      Width => "1",
      Position => "2", # Excel Formula: =calc_position(F62,E63)
      Type => "Config",
      UsedBy => "CMAP",
      DefaultValue => "b1",
      InitValueAllModes => "0",
    },
  },
  CompensationPerIfg => { #Structure Type: Reg;
    Name => "CompensationPerIfg",
    RegMem => "Reg",
    Address => "10A", # Excel Formula: =calc_reg_address(C60,A60,G60)
    Width => "79", # Excel Formula: =calc_reg_width(E65:E68,F68)
    Type => "Config",
    IfgPerSourceIf => { #Structure Type: RegField;
      Name => "IfgPerSourceIf",
      RegMem => "RegField",
      Description => "bitmap addressed by PD.source-if[7:2] ;
'0' - IFG0 ; '1' - IFG1",
      Width => "64",
      Position => "63:0", # Excel Formula: =calc_position(F64,E65,TRUE)
      Type => "Config",
      UsedBy => "ALL",
      DefaultValue => "b0",
      InitValueAllModes => "0",
    },
    Ifg0Compensation => { #Structure Type: RegField;
      Name => "Ifg0Compensation",
      RegMem => "RegField",
      Description => "Compensation size if the source of ther PD is IFG0; Two's complement value",
      Width => "7", # Excel Formula: =calc_field_width_define("IFG_COMPENSATION_WIDTH")
      Position => "70:64", # Excel Formula: =calc_position(F65,E66)
      Type => "Config",
      UsedBy => "ALL",
      DefaultValue => "d10",
      InitValueAllModes => "0",
    },
    Ifg1Compensation => { #Structure Type: RegField;
      Name => "Ifg1Compensation",
      RegMem => "RegField",
      Description => "Compensation size if the source of ther PD is IFG1; Two's complement value",
      Width => "7", # Excel Formula: =calc_field_width_define("IFG_COMPENSATION_WIDTH")
      Position => "77:71", # Excel Formula: =calc_position(F66,E67)
      Type => "Config",
      UsedBy => "ALL",
      DefaultValue => "d20",
      InitValueAllModes => "0",
    },
    FabricSlice => { #Structure Type: RegField;
      Name => "FabricSlice",
      RegMem => "RegField",
      Description => "1' - fabric slice - thus dunt perform compensation
'0' -non fabric slice - thus perform compensation",
      Width => "1",
      Position => "78", # Excel Formula: =calc_position(F67,E68)
      Type => "Config",
      UsedBy => "ALL",
      DefaultValue => "d0",
      InitValueSa => "0",
      InitValueLcNwk => "0",
      InitValueLcFab => "1",
      InitValueFe => "1",
    },
  },
  DynamicMappingConf => { #Structure Type: Reg;
    Name => "DynamicMappingConf",
    RegMem => "Reg",
    Address => "10B", # Excel Formula: =calc_reg_address(C64,A64,G64)
    Width => "89", # Excel Formula: =calc_reg_width(E70:E73,F73)
    Type => "Config",
    DynamicMappingTh0 => { #Structure Type: RegField;
      Name => "DynamicMappingTh0",
      RegMem => "RegField",
      Description => "If DynamicMappingProfile == 1 and free_pool_size < DynamicMappingTh0 dont map this VOQ to a context (drop all PDs of this VOQ)",
      Width => "12", # Excel Formula: =calc_field_width_define("CONTEXT_WIDTH")
      Position => "11:0", # Excel Formula: =calc_position(F69,E70,TRUE)
      Type => "Config",
      UsedBy => "CMAP",
      DefaultValue => "d1000",
    },
    DynamicMappingTh1 => { #Structure Type: RegField;
      Name => "DynamicMappingTh1",
      RegMem => "RegField",
      Description => "If DynamicMappingProfile == 2 and free_pool_size < DynamicMappingTh1 dont map this VOQ to a context (drop all PDs of this VOQ)",
      Width => "12", # Excel Formula: =calc_field_width_define("CONTEXT_WIDTH")
      Position => "23:12", # Excel Formula: =calc_position(F70,E71)
      Type => "Config",
      UsedBy => "CMAP",
      DefaultValue => "d500",
    },
    DynamicMappingProfile => { #Structure Type: RegField;
      Name => "DynamicMappingProfile",
      RegMem => "RegField",
      Description => "2 bit per profile 
if DynamicMappingProfile == 0 then drop the PD only if there is no avaliable context
if DynamicMappingProfile == 1 then drop the PD if the used buffer count > Th0
if DynamicMappingProfile == 2 then drop the PD if the used buffer count > Th1",
      Width => "64", # Excel Formula: =2*calc_field_width_define("VOQ_CGM_NUM_OF_PROFILES")
      Position => "87:24", # Excel Formula: =calc_position(F71,E72)
      Type => "Config",
      UsedBy => "CMAP",
      DefaultValue => "d0",
    },
    ChickenContextReleaseEn => { #Structure Type: RegField;
      Name => "ChickenContextReleaseEn",
      RegMem => "RegField",
      Description => "If '1' try to release every context by a counter",
      Width => "1",
      Position => "88", # Excel Formula: =calc_position(F72,E73)
      Type => "Config",
      UsedBy => "CMAP",
      DefaultValue => "d0",
    },
  },
  CpuReturnContext => { #Structure Type: Reg;
    Name => "CpuReturnContext",
    RegMem => "Reg",
    Address => "10C", # Excel Formula: =calc_reg_address(C69,A69,G69)
    Width => "12", # Excel Formula: =calc_reg_width(E75:E75,F75)
    Type => "External",
    UsedBy => "CMAP",
    AdditionalInfo => "ExternalBackdoorWriteEnable",
    ReturnContext => { #Structure Type: RegField;
      Name => "ReturnContext",
      RegMem => "RegField",
      Width => "12", # Excel Formula: =calc_field_width_define("CONTEXT_WIDTH")
      Position => "11:0", # Excel Formula: =calc_position(F74,E75,TRUE)
      Type => "External",
    },
  },
  CpuReturnContextStatus => { #Structure Type: Reg;
    Name => "CpuReturnContextStatus",
    RegMem => "Reg",
    Address => "10D", # Excel Formula: =calc_reg_address(C74,A74,G74)
    Description => "Status",
    Width => "1", # Excel Formula: =calc_reg_width(E77:E77,F77)
    Type => "ReadOnly",
    ReturnReady => { #Structure Type: RegField;
      Name => "ReturnReady",
      RegMem => "RegField",
      Width => "1",
      Position => "0", # Excel Formula: =calc_position(F76,E77,TRUE)
      Type => "Status",
      UsedBy => "CMAP",
    },
  },
  BypassSelectCfg => { #Structure Type: Reg;
    Name => "BypassSelectCfg",
    RegMem => "Reg",
    Address => "10E", # Excel Formula: =calc_reg_address(C76,A76,G76)
    Description => "Configurations for VOQ bypass select",
    Width => "273", # Excel Formula: =calc_reg_width(E79:E81,F81)
    Type => "Config",
    Comments => "VOQ_CGM",
    ContextBypassMsb => { #Structure Type: RegField;
      Name => "ContextBypassMsb",
      RegMem => "RegField",
      Description => "Select VOQ bypass contexts MSBs (range of 256)",
      Width => "16",
      Position => "15:0", # Excel Formula: =calc_position(F78,E79,TRUE)
      Type => "Config",
      UsedBy => "voq_bps",
      DefaultValue => "h0",
    },
    ContextBypassEnable => { #Structure Type: RegField;
      Name => "ContextBypassEnable",
      RegMem => "RegField",
      Description => "Bitmap per VOQ bypass context. If set, bypass is enabled for ContextBypassMsb*256 + offset",
      Width => "256",
      Position => "271:16", # Excel Formula: =calc_position(F79,E80)
      Type => "Config",
      UsedBy => "voq_bps",
      DefaultValue => "h0",
    },
    McPacketsBypassEnable => { #Structure Type: RegField;
      Name => "McPacketsBypassEnable",
      RegMem => "RegField",
      Description => "Enable bypass for packets with UCDV that does not equal zero, i.e. ingress MC packets",
      Width => "1",
      Position => "272", # Excel Formula: =calc_position(F80,E81)
      Type => "Config",
      UsedBy => "voq_bps",
      DefaultValue => "h1",
    },
  },
  DeqReqScrubber => { #Structure Type: Reg;
    Name => "DeqReqScrubber",
    RegMem => "Reg",
    Address => "10F", # Excel Formula: =calc_reg_address(C78,A78,G78)
    Description => "Deq req scrubber machine configuration",
    Width => "50", # Excel Formula: =calc_reg_width(E83:E88,F88)
    Type => "Config",
    DeqReqScrubberEn => { #Structure Type: RegField;
      Name => "DeqReqScrubberEn",
      RegMem => "RegField",
      Description => "1- enable the deq req scrubber machine ; 
0 - deq req scrubber machine disabled",
      Width => "1",
      Position => "0", # Excel Formula: =calc_position(F82,E83,TRUE)
      Type => "Config",
      UsedBy => "dsn",
      DefaultValue => "d0",
      InitValueAllModes => "0",
    },
    DeqReqScrubberOnlyFifo => { #Structure Type: RegField;
      Name => "DeqReqScrubberOnlyFifo",
      RegMem => "RegField",
      Description => "1- Use only the trap fifo as a source of context to the machine
0- source of context is either the trap fifo or the scanner",
      Width => "1",
      Position => "1", # Excel Formula: =calc_position(F83,E84)
      Type => "Config",
      UsedBy => "dsn",
      DefaultValue => "d0",
    },
    DeqReqScrubberMinPeriod => { #Structure Type: RegField;
      Name => "DeqReqScrubberMinPeriod",
      RegMem => "RegField",
      Description => "Min time in clock cycles between each context deq req by the machine",
      Width => "12",
      Position => "13:2", # Excel Formula: =calc_position(F84,E85)
      Type => "Config",
      UsedBy => "dsn",
      DefaultValue => "d10",
    },
    DeqReqScrubberBetweenScansDelay => { #Structure Type: RegField;
      Name => "DeqReqScrubberBetweenScansDelay",
      RegMem => "RegField",
      Description => "Min time in clock cycles between the deq req of the last context by the machine and the deq req of the first context by the machine",
      Width => "12",
      Position => "25:14", # Excel Formula: =calc_position(F85,E86)
      Type => "Config",
      UsedBy => "dsn",
      DefaultValue => "d100",
    },
    DeqReqScrubberMaxContext => { #Structure Type: RegField;
      Name => "DeqReqScrubberMaxContext",
      RegMem => "RegField",
      Width => "12", # Excel Formula: =calc_field_width_define("CONTEXT_WIDTH")
      Position => "37:26", # Excel Formula: =calc_position(F86,E87)
      Type => "Config",
      UsedBy => "dsn",
      DefaultValue => "d4093",
    },
    DeqReqScrubberFreeContextTh => { #Structure Type: RegField;
      Name => "DeqReqScrubberFreeContextTh",
      RegMem => "RegField",
      Description => "if number of free avilable contexts is less than this field then start the scanner machine. 0 means that the scanner is disabled",
      Width => "12", # Excel Formula: =calc_field_width_define("CONTEXT_WIDTH")
      Position => "49:38", # Excel Formula: =calc_position(F87,E88)
      Type => "Config",
      UsedBy => "dsn",
      DefaultValue => "d4093",
    },
  },
  DeleteQueueCounterId => { #Structure Type: Reg;
    Name => "DeleteQueueCounterId",
    RegMem => "Reg",
    Address => "110", # Excel Formula: =calc_reg_address(C82,A82,G82)
    Description => "See field's description",
    Width => "3", # Excel Formula: =calc_reg_width(E90:E90,F90)
    Type => "Config",
    DocName => "DeleteQueueCounterId",
    Comments => "VOQ_CGM",
    DeleteCounterId => { #Structure Type: RegField;
      Name => "DeleteCounterId",
      RegMem => "RegField",
      Description => "PD Counter ID for delete queue.
Selects which PD counter accounts for the delete queue.
Default is to not count delete PDs in any counter.",
      Width => "3", # Excel Formula: =calc_field_width_define("VOQ_CGM_COUNTER_NUM_WIDTH")
      Position => "2:0", # Excel Formula: =calc_position(F89,E90,TRUE)
      Type => "Config",
      UsedBy => "Voq_CGM",
      DefaultValue => "h4",
      DocName => "DeleteCounterId",
    },
  },
  SliceCGMProfile0 => { #Structure Type: Reg; ArrayLength: 32; ArrayIndex: 0; ArrayLocationInName: 16;
    Name => "SliceCGMProfile[32]",
    RegMem => "Reg",
    Address => "111", # Excel Formula: =calc_reg_address(C89,A89,G89)
    Description => "CGM Global Configs",
    Width => "3", # Excel Formula: =calc_reg_width(E92:E92,F92)
    Type => "Config",
    DocName => "SliceCgmProfile",
    AdditionalInfo => "PackArrayToBus",
    Comments => "VOQ_CGM",
    ArrayLength => "32",
    ArrayIndex => "0",
    CounterId0 => { #Structure Type: RegField; ArrayLength: 32; ArrayIndex: 0; ArrayLocationInName: 10;
      Name => "CounterId[n]",
      RegMem => "RegField",
      Description => "Map CGM profile to PD counter.
Values :
0 - 3 : counter ID
4 : Do not count
5-7 : Unused",
      Width => "3", # Excel Formula: =calc_field_width_define("VOQ_CGM_COUNTER_NUM_WIDTH")
      Position => "2:0", # Excel Formula: =calc_position(F91,E92,TRUE)
      Type => "Config",
      UsedBy => "Voq_CGM",
      DefaultValue => "h0",
      DocName => "CounterId",
      Comments => "VOQ_CGM_COUNTER_UC  = d0
VOQ_CGM_COUNTER_MC = d1
VOQ_CGM_COUNTER_MS_UC = d2
VOQ_CGM_COUNTER_MS_MC = d3
VOQ_CGM_COUNTER_IGNORE = d4",
      InitValueSa => "(instance == 0) ? 4 :
(instance == 1) ? 1 : 0",
      InitValueLcNwk => "(instance == 0) ? 4 :
(instance == 1) ? 1 : 0",
      InitValueLcFab => "(instance == 2) ? 2 :
(instance == 3) ? 3 : 4",
      InitValueFe => "(instance == 2) ? 2 :
(instance == 3) ? 3 : 4",
    },
  },
  SliceCGMProfile1 => { #Structure Type: Reg; ArrayLength: 32; ArrayIndex: 1; ArrayLocationInName: 16;
    Name => "SliceCGMProfile[32]",
    RegMem => "Reg",
    Address => "112",
    Description => "CGM Global Configs",
    Width => "3", # Excel Formula: =calc_reg_width(E92:E92,F92)
    Type => "Config",
    DocName => "SliceCgmProfile",
    AdditionalInfo => "PackArrayToBus",
    Comments => "VOQ_CGM",
    ArrayLength => "32",
    ArrayIndex => "1",
    CounterId1 => { #Structure Type: RegField; ArrayLength: 32; ArrayIndex: 1; ArrayLocationInName: 10;
      Name => "CounterId[n]",
      RegMem => "RegField",
      Description => "Map CGM profile to PD counter.
Values :
0 - 3 : counter ID
4 : Do not count
5-7 : Unused",
      Width => "3", # Excel Formula: =calc_field_width_define("VOQ_CGM_COUNTER_NUM_WIDTH")
      Position => "2:0", # Excel Formula: =calc_position(F91,E92,TRUE)
      Type => "Config",
      UsedBy => "Voq_CGM",
      DefaultValue => "h0",
      DocName => "CounterId",
      Comments => "VOQ_CGM_COUNTER_UC  = d0
VOQ_CGM_COUNTER_MC = d1
VOQ_CGM_COUNTER_MS_UC = d2
VOQ_CGM_COUNTER_MS_MC = d3
VOQ_CGM_COUNTER_IGNORE = d4",
      InitValueSa => "(instance == 0) ? 4 :
(instance == 1) ? 1 : 0",
      InitValueLcNwk => "(instance == 0) ? 4 :
(instance == 1) ? 1 : 0",
      InitValueLcFab => "(instance == 2) ? 2 :
(instance == 3) ? 3 : 4",
      InitValueFe => "(instance == 2) ? 2 :
(instance == 3) ? 3 : 4",
    },
  },
  SliceCGMProfile2 => { #Structure Type: Reg; ArrayLength: 32; ArrayIndex: 2; ArrayLocationInName: 16;
    Name => "SliceCGMProfile[32]",
    RegMem => "Reg",
    Address => "113",
    Description => "CGM Global Configs",
    Width => "3", # Excel Formula: =calc_reg_width(E92:E92,F92)
    Type => "Config",
    DocName => "SliceCgmProfile",
    AdditionalInfo => "PackArrayToBus",
    Comments => "VOQ_CGM",
    ArrayLength => "32",
    ArrayIndex => "2",
    CounterId2 => { #Structure Type: RegField; ArrayLength: 32; ArrayIndex: 2; ArrayLocationInName: 10;
      Name => "CounterId[n]",
      RegMem => "RegField",
      Description => "Map CGM profile to PD counter.
Values :
0 - 3 : counter ID
4 : Do not count
5-7 : Unused",
      Width => "3", # Excel Formula: =calc_field_width_define("VOQ_CGM_COUNTER_NUM_WIDTH")
      Position => "2:0", # Excel Formula: =calc_position(F91,E92,TRUE)
      Type => "Config",
      UsedBy => "Voq_CGM",
      DefaultValue => "h0",
      DocName => "CounterId",
      Comments => "VOQ_CGM_COUNTER_UC  = d0
VOQ_CGM_COUNTER_MC = d1
VOQ_CGM_COUNTER_MS_UC = d2
VOQ_CGM_COUNTER_MS_MC = d3
VOQ_CGM_COUNTER_IGNORE = d4",
      InitValueSa => "(instance == 0) ? 4 :
(instance == 1) ? 1 : 0",
      InitValueLcNwk => "(instance == 0) ? 4 :
(instance == 1) ? 1 : 0",
      InitValueLcFab => "(instance == 2) ? 2 :
(instance == 3) ? 3 : 4",
      InitValueFe => "(instance == 2) ? 2 :
(instance == 3) ? 3 : 4",
    },
  },
  SliceCGMProfile3 => { #Structure Type: Reg; ArrayLength: 32; ArrayIndex: 3; ArrayLocationInName: 16;
    Name => "SliceCGMProfile[32]",
    RegMem => "Reg",
    Address => "114",
    Description => "CGM Global Configs",
    Width => "3", # Excel Formula: =calc_reg_width(E92:E92,F92)
    Type => "Config",
    DocName => "SliceCgmProfile",
    AdditionalInfo => "PackArrayToBus",
    Comments => "VOQ_CGM",
    ArrayLength => "32",
    ArrayIndex => "3",
    CounterId3 => { #Structure Type: RegField; ArrayLength: 32; ArrayIndex: 3; ArrayLocationInName: 10;
      Name => "CounterId[n]",
      RegMem => "RegField",
      Description => "Map CGM profile to PD counter.
Values :
0 - 3 : counter ID
4 : Do not count
5-7 : Unused",
      Width => "3", # Excel Formula: =calc_field_width_define("VOQ_CGM_COUNTER_NUM_WIDTH")
      Position => "2:0", # Excel Formula: =calc_position(F91,E92,TRUE)
      Type => "Config",
      UsedBy => "Voq_CGM",
      DefaultValue => "h0",
      DocName => "CounterId",
      Comments => "VOQ_CGM_COUNTER_UC  = d0
VOQ_CGM_COUNTER_MC = d1
VOQ_CGM_COUNTER_MS_UC = d2
VOQ_CGM_COUNTER_MS_MC = d3
VOQ_CGM_COUNTER_IGNORE = d4",
      InitValueSa => "(instance == 0) ? 4 :
(instance == 1) ? 1 : 0",
      InitValueLcNwk => "(instance == 0) ? 4 :
(instance == 1) ? 1 : 0",
      InitValueLcFab => "(instance == 2) ? 2 :
(instance == 3) ? 3 : 4",
      InitValueFe => "(instance == 2) ? 2 :
(instance == 3) ? 3 : 4",
    },
  },
  SliceCGMProfile4 => { #Structure Type: Reg; ArrayLength: 32; ArrayIndex: 4; ArrayLocationInName: 16;
    Name => "SliceCGMProfile[32]",
    RegMem => "Reg",
    Address => "115",
    Description => "CGM Global Configs",
    Width => "3", # Excel Formula: =calc_reg_width(E92:E92,F92)
    Type => "Config",
    DocName => "SliceCgmProfile",
    AdditionalInfo => "PackArrayToBus",
    Comments => "VOQ_CGM",
    ArrayLength => "32",
    ArrayIndex => "4",
    CounterId4 => { #Structure Type: RegField; ArrayLength: 32; ArrayIndex: 4; ArrayLocationInName: 10;
      Name => "CounterId[n]",
      RegMem => "RegField",
      Description => "Map CGM profile to PD counter.
Values :
0 - 3 : counter ID
4 : Do not count
5-7 : Unused",
      Width => "3", # Excel Formula: =calc_field_width_define("VOQ_CGM_COUNTER_NUM_WIDTH")
      Position => "2:0", # Excel Formula: =calc_position(F91,E92,TRUE)
      Type => "Config",
      UsedBy => "Voq_CGM",
      DefaultValue => "h0",
      DocName => "CounterId",
      Comments => "VOQ_CGM_COUNTER_UC  = d0
VOQ_CGM_COUNTER_MC = d1
VOQ_CGM_COUNTER_MS_UC = d2
VOQ_CGM_COUNTER_MS_MC = d3
VOQ_CGM_COUNTER_IGNORE = d4",
      InitValueSa => "(instance == 0) ? 4 :
(instance == 1) ? 1 : 0",
      InitValueLcNwk => "(instance == 0) ? 4 :
(instance == 1) ? 1 : 0",
      InitValueLcFab => "(instance == 2) ? 2 :
(instance == 3) ? 3 : 4",
      InitValueFe => "(instance == 2) ? 2 :
(instance == 3) ? 3 : 4",
    },
  },
  SliceCGMProfile5 => { #Structure Type: Reg; ArrayLength: 32; ArrayIndex: 5; ArrayLocationInName: 16;
    Name => "SliceCGMProfile[32]",
    RegMem => "Reg",
    Address => "116",
    Description => "CGM Global Configs",
    Width => "3", # Excel Formula: =calc_reg_width(E92:E92,F92)
    Type => "Config",
    DocName => "SliceCgmProfile",
    AdditionalInfo => "PackArrayToBus",
    Comments => "VOQ_CGM",
    ArrayLength => "32",
    ArrayIndex => "5",
    CounterId5 => { #Structure Type: RegField; ArrayLength: 32; ArrayIndex: 5; ArrayLocationInName: 10;
      Name => "CounterId[n]",
      RegMem => "RegField",
      Description => "Map CGM profile to PD counter.
Values :
0 - 3 : counter ID
4 : Do not count
5-7 : Unused",
      Width => "3", # Excel Formula: =calc_field_width_define("VOQ_CGM_COUNTER_NUM_WIDTH")
      Position => "2:0", # Excel Formula: =calc_position(F91,E92,TRUE)
      Type => "Config",
      UsedBy => "Voq_CGM",
      DefaultValue => "h0",
      DocName => "CounterId",
      Comments => "VOQ_CGM_COUNTER_UC  = d0
VOQ_CGM_COUNTER_MC = d1
VOQ_CGM_COUNTER_MS_UC = d2
VOQ_CGM_COUNTER_MS_MC = d3
VOQ_CGM_COUNTER_IGNORE = d4",
      InitValueSa => "(instance == 0) ? 4 :
(instance == 1) ? 1 : 0",
      InitValueLcNwk => "(instance == 0) ? 4 :
(instance == 1) ? 1 : 0",
      InitValueLcFab => "(instance == 2) ? 2 :
(instance == 3) ? 3 : 4",
      InitValueFe => "(instance == 2) ? 2 :
(instance == 3) ? 3 : 4",
    },
  },
  SliceCGMProfile6 => { #Structure Type: Reg; ArrayLength: 32; ArrayIndex: 6; ArrayLocationInName: 16;
    Name => "SliceCGMProfile[32]",
    RegMem => "Reg",
    Address => "117",
    Description => "CGM Global Configs",
    Width => "3", # Excel Formula: =calc_reg_width(E92:E92,F92)
    Type => "Config",
    DocName => "SliceCgmProfile",
    AdditionalInfo => "PackArrayToBus",
    Comments => "VOQ_CGM",
    ArrayLength => "32",
    ArrayIndex => "6",
    CounterId6 => { #Structure Type: RegField; ArrayLength: 32; ArrayIndex: 6; ArrayLocationInName: 10;
      Name => "CounterId[n]",
      RegMem => "RegField",
      Description => "Map CGM profile to PD counter.
Values :
0 - 3 : counter ID
4 : Do not count
5-7 : Unused",
      Width => "3", # Excel Formula: =calc_field_width_define("VOQ_CGM_COUNTER_NUM_WIDTH")
      Position => "2:0", # Excel Formula: =calc_position(F91,E92,TRUE)
      Type => "Config",
      UsedBy => "Voq_CGM",
      DefaultValue => "h0",
      DocName => "CounterId",
      Comments => "VOQ_CGM_COUNTER_UC  = d0
VOQ_CGM_COUNTER_MC = d1
VOQ_CGM_COUNTER_MS_UC = d2
VOQ_CGM_COUNTER_MS_MC = d3
VOQ_CGM_COUNTER_IGNORE = d4",
      InitValueSa => "(instance == 0) ? 4 :
(instance == 1) ? 1 : 0",
      InitValueLcNwk => "(instance == 0) ? 4 :
(instance == 1) ? 1 : 0",
      InitValueLcFab => "(instance == 2) ? 2 :
(instance == 3) ? 3 : 4",
      InitValueFe => "(instance == 2) ? 2 :
(instance == 3) ? 3 : 4",
    },
  },
  SliceCGMProfile7 => { #Structure Type: Reg; ArrayLength: 32; ArrayIndex: 7; ArrayLocationInName: 16;
    Name => "SliceCGMProfile[32]",
    RegMem => "Reg",
    Address => "118",
    Description => "CGM Global Configs",
    Width => "3", # Excel Formula: =calc_reg_width(E92:E92,F92)
    Type => "Config",
    DocName => "SliceCgmProfile",
    AdditionalInfo => "PackArrayToBus",
    Comments => "VOQ_CGM",
    ArrayLength => "32",
    ArrayIndex => "7",
    CounterId7 => { #Structure Type: RegField; ArrayLength: 32; ArrayIndex: 7; ArrayLocationInName: 10;
      Name => "CounterId[n]",
      RegMem => "RegField",
      Description => "Map CGM profile to PD counter.
Values :
0 - 3 : counter ID
4 : Do not count
5-7 : Unused",
      Width => "3", # Excel Formula: =calc_field_width_define("VOQ_CGM_COUNTER_NUM_WIDTH")
      Position => "2:0", # Excel Formula: =calc_position(F91,E92,TRUE)
      Type => "Config",
      UsedBy => "Voq_CGM",
      DefaultValue => "h0",
      DocName => "CounterId",
      Comments => "VOQ_CGM_COUNTER_UC  = d0
VOQ_CGM_COUNTER_MC = d1
VOQ_CGM_COUNTER_MS_UC = d2
VOQ_CGM_COUNTER_MS_MC = d3
VOQ_CGM_COUNTER_IGNORE = d4",
      InitValueSa => "(instance == 0) ? 4 :
(instance == 1) ? 1 : 0",
      InitValueLcNwk => "(instance == 0) ? 4 :
(instance == 1) ? 1 : 0",
      InitValueLcFab => "(instance == 2) ? 2 :
(instance == 3) ? 3 : 4",
      InitValueFe => "(instance == 2) ? 2 :
(instance == 3) ? 3 : 4",
    },
  },
  SliceCGMProfile8 => { #Structure Type: Reg; ArrayLength: 32; ArrayIndex: 8; ArrayLocationInName: 16;
    Name => "SliceCGMProfile[32]",
    RegMem => "Reg",
    Address => "119",
    Description => "CGM Global Configs",
    Width => "3", # Excel Formula: =calc_reg_width(E92:E92,F92)
    Type => "Config",
    DocName => "SliceCgmProfile",
    AdditionalInfo => "PackArrayToBus",
    Comments => "VOQ_CGM",
    ArrayLength => "32",
    ArrayIndex => "8",
    CounterId8 => { #Structure Type: RegField; ArrayLength: 32; ArrayIndex: 8; ArrayLocationInName: 10;
      Name => "CounterId[n]",
      RegMem => "RegField",
      Description => "Map CGM profile to PD counter.
Values :
0 - 3 : counter ID
4 : Do not count
5-7 : Unused",
      Width => "3", # Excel Formula: =calc_field_width_define("VOQ_CGM_COUNTER_NUM_WIDTH")
      Position => "2:0", # Excel Formula: =calc_position(F91,E92,TRUE)
      Type => "Config",
      UsedBy => "Voq_CGM",
      DefaultValue => "h0",
      DocName => "CounterId",
      Comments => "VOQ_CGM_COUNTER_UC  = d0
VOQ_CGM_COUNTER_MC = d1
VOQ_CGM_COUNTER_MS_UC = d2
VOQ_CGM_COUNTER_MS_MC = d3
VOQ_CGM_COUNTER_IGNORE = d4",
      InitValueSa => "(instance == 0) ? 4 :
(instance == 1) ? 1 : 0",
      InitValueLcNwk => "(instance == 0) ? 4 :
(instance == 1) ? 1 : 0",
      InitValueLcFab => "(instance == 2) ? 2 :
(instance == 3) ? 3 : 4",
      InitValueFe => "(instance == 2) ? 2 :
(instance == 3) ? 3 : 4",
    },
  },
  SliceCGMProfile9 => { #Structure Type: Reg; ArrayLength: 32; ArrayIndex: 9; ArrayLocationInName: 16;
    Name => "SliceCGMProfile[32]",
    RegMem => "Reg",
    Address => "11A",
    Description => "CGM Global Configs",
    Width => "3", # Excel Formula: =calc_reg_width(E92:E92,F92)
    Type => "Config",
    DocName => "SliceCgmProfile",
    AdditionalInfo => "PackArrayToBus",
    Comments => "VOQ_CGM",
    ArrayLength => "32",
    ArrayIndex => "9",
    CounterId9 => { #Structure Type: RegField; ArrayLength: 32; ArrayIndex: 9; ArrayLocationInName: 10;
      Name => "CounterId[n]",
      RegMem => "RegField",
      Description => "Map CGM profile to PD counter.
Values :
0 - 3 : counter ID
4 : Do not count
5-7 : Unused",
      Width => "3", # Excel Formula: =calc_field_width_define("VOQ_CGM_COUNTER_NUM_WIDTH")
      Position => "2:0", # Excel Formula: =calc_position(F91,E92,TRUE)
      Type => "Config",
      UsedBy => "Voq_CGM",
      DefaultValue => "h0",
      DocName => "CounterId",
      Comments => "VOQ_CGM_COUNTER_UC  = d0
VOQ_CGM_COUNTER_MC = d1
VOQ_CGM_COUNTER_MS_UC = d2
VOQ_CGM_COUNTER_MS_MC = d3
VOQ_CGM_COUNTER_IGNORE = d4",
      InitValueSa => "(instance == 0) ? 4 :
(instance == 1) ? 1 : 0",
      InitValueLcNwk => "(instance == 0) ? 4 :
(instance == 1) ? 1 : 0",
      InitValueLcFab => "(instance == 2) ? 2 :
(instance == 3) ? 3 : 4",
      InitValueFe => "(instance == 2) ? 2 :
(instance == 3) ? 3 : 4",
    },
  },
  SliceCGMProfile10 => { #Structure Type: Reg; ArrayLength: 32; ArrayIndex: 10; ArrayLocationInName: 16;
    Name => "SliceCGMProfile[32]",
    RegMem => "Reg",
    Address => "11B",
    Description => "CGM Global Configs",
    Width => "3", # Excel Formula: =calc_reg_width(E92:E92,F92)
    Type => "Config",
    DocName => "SliceCgmProfile",
    AdditionalInfo => "PackArrayToBus",
    Comments => "VOQ_CGM",
    ArrayLength => "32",
    ArrayIndex => "10",
    CounterId10 => { #Structure Type: RegField; ArrayLength: 32; ArrayIndex: 10; ArrayLocationInName: 10;
      Name => "CounterId[n]",
      RegMem => "RegField",
      Description => "Map CGM profile to PD counter.
Values :
0 - 3 : counter ID
4 : Do not count
5-7 : Unused",
      Width => "3", # Excel Formula: =calc_field_width_define("VOQ_CGM_COUNTER_NUM_WIDTH")
      Position => "2:0", # Excel Formula: =calc_position(F91,E92,TRUE)
      Type => "Config",
      UsedBy => "Voq_CGM",
      DefaultValue => "h0",
      DocName => "CounterId",
      Comments => "VOQ_CGM_COUNTER_UC  = d0
VOQ_CGM_COUNTER_MC = d1
VOQ_CGM_COUNTER_MS_UC = d2
VOQ_CGM_COUNTER_MS_MC = d3
VOQ_CGM_COUNTER_IGNORE = d4",
      InitValueSa => "(instance == 0) ? 4 :
(instance == 1) ? 1 : 0",
      InitValueLcNwk => "(instance == 0) ? 4 :
(instance == 1) ? 1 : 0",
      InitValueLcFab => "(instance == 2) ? 2 :
(instance == 3) ? 3 : 4",
      InitValueFe => "(instance == 2) ? 2 :
(instance == 3) ? 3 : 4",
    },
  },
  SliceCGMProfile11 => { #Structure Type: Reg; ArrayLength: 32; ArrayIndex: 11; ArrayLocationInName: 16;
    Name => "SliceCGMProfile[32]",
    RegMem => "Reg",
    Address => "11C",
    Description => "CGM Global Configs",
    Width => "3", # Excel Formula: =calc_reg_width(E92:E92,F92)
    Type => "Config",
    DocName => "SliceCgmProfile",
    AdditionalInfo => "PackArrayToBus",
    Comments => "VOQ_CGM",
    ArrayLength => "32",
    ArrayIndex => "11",
    CounterId11 => { #Structure Type: RegField; ArrayLength: 32; ArrayIndex: 11; ArrayLocationInName: 10;
      Name => "CounterId[n]",
      RegMem => "RegField",
      Description => "Map CGM profile to PD counter.
Values :
0 - 3 : counter ID
4 : Do not count
5-7 : Unused",
      Width => "3", # Excel Formula: =calc_field_width_define("VOQ_CGM_COUNTER_NUM_WIDTH")
      Position => "2:0", # Excel Formula: =calc_position(F91,E92,TRUE)
      Type => "Config",
      UsedBy => "Voq_CGM",
      DefaultValue => "h0",
      DocName => "CounterId",
      Comments => "VOQ_CGM_COUNTER_UC  = d0
VOQ_CGM_COUNTER_MC = d1
VOQ_CGM_COUNTER_MS_UC = d2
VOQ_CGM_COUNTER_MS_MC = d3
VOQ_CGM_COUNTER_IGNORE = d4",
      InitValueSa => "(instance == 0) ? 4 :
(instance == 1) ? 1 : 0",
      InitValueLcNwk => "(instance == 0) ? 4 :
(instance == 1) ? 1 : 0",
      InitValueLcFab => "(instance == 2) ? 2 :
(instance == 3) ? 3 : 4",
      InitValueFe => "(instance == 2) ? 2 :
(instance == 3) ? 3 : 4",
    },
  },
  SliceCGMProfile12 => { #Structure Type: Reg; ArrayLength: 32; ArrayIndex: 12; ArrayLocationInName: 16;
    Name => "SliceCGMProfile[32]",
    RegMem => "Reg",
    Address => "11D",
    Description => "CGM Global Configs",
    Width => "3", # Excel Formula: =calc_reg_width(E92:E92,F92)
    Type => "Config",
    DocName => "SliceCgmProfile",
    AdditionalInfo => "PackArrayToBus",
    Comments => "VOQ_CGM",
    ArrayLength => "32",
    ArrayIndex => "12",
    CounterId12 => { #Structure Type: RegField; ArrayLength: 32; ArrayIndex: 12; ArrayLocationInName: 10;
      Name => "CounterId[n]",
      RegMem => "RegField",
      Description => "Map CGM profile to PD counter.
Values :
0 - 3 : counter ID
4 : Do not count
5-7 : Unused",
      Width => "3", # Excel Formula: =calc_field_width_define("VOQ_CGM_COUNTER_NUM_WIDTH")
      Position => "2:0", # Excel Formula: =calc_position(F91,E92,TRUE)
      Type => "Config",
      UsedBy => "Voq_CGM",
      DefaultValue => "h0",
      DocName => "CounterId",
      Comments => "VOQ_CGM_COUNTER_UC  = d0
VOQ_CGM_COUNTER_MC = d1
VOQ_CGM_COUNTER_MS_UC = d2
VOQ_CGM_COUNTER_MS_MC = d3
VOQ_CGM_COUNTER_IGNORE = d4",
      InitValueSa => "(instance == 0) ? 4 :
(instance == 1) ? 1 : 0",
      InitValueLcNwk => "(instance == 0) ? 4 :
(instance == 1) ? 1 : 0",
      InitValueLcFab => "(instance == 2) ? 2 :
(instance == 3) ? 3 : 4",
      InitValueFe => "(instance == 2) ? 2 :
(instance == 3) ? 3 : 4",
    },
  },
  SliceCGMProfile13 => { #Structure Type: Reg; ArrayLength: 32; ArrayIndex: 13; ArrayLocationInName: 16;
    Name => "SliceCGMProfile[32]",
    RegMem => "Reg",
    Address => "11E",
    Description => "CGM Global Configs",
    Width => "3", # Excel Formula: =calc_reg_width(E92:E92,F92)
    Type => "Config",
    DocName => "SliceCgmProfile",
    AdditionalInfo => "PackArrayToBus",
    Comments => "VOQ_CGM",
    ArrayLength => "32",
    ArrayIndex => "13",
    CounterId13 => { #Structure Type: RegField; ArrayLength: 32; ArrayIndex: 13; ArrayLocationInName: 10;
      Name => "CounterId[n]",
      RegMem => "RegField",
      Description => "Map CGM profile to PD counter.
Values :
0 - 3 : counter ID
4 : Do not count
5-7 : Unused",
      Width => "3", # Excel Formula: =calc_field_width_define("VOQ_CGM_COUNTER_NUM_WIDTH")
      Position => "2:0", # Excel Formula: =calc_position(F91,E92,TRUE)
      Type => "Config",
      UsedBy => "Voq_CGM",
      DefaultValue => "h0",
      DocName => "CounterId",
      Comments => "VOQ_CGM_COUNTER_UC  = d0
VOQ_CGM_COUNTER_MC = d1
VOQ_CGM_COUNTER_MS_UC = d2
VOQ_CGM_COUNTER_MS_MC = d3
VOQ_CGM_COUNTER_IGNORE = d4",
      InitValueSa => "(instance == 0) ? 4 :
(instance == 1) ? 1 : 0",
      InitValueLcNwk => "(instance == 0) ? 4 :
(instance == 1) ? 1 : 0",
      InitValueLcFab => "(instance == 2) ? 2 :
(instance == 3) ? 3 : 4",
      InitValueFe => "(instance == 2) ? 2 :
(instance == 3) ? 3 : 4",
    },
  },
  SliceCGMProfile14 => { #Structure Type: Reg; ArrayLength: 32; ArrayIndex: 14; ArrayLocationInName: 16;
    Name => "SliceCGMProfile[32]",
    RegMem => "Reg",
    Address => "11F",
    Description => "CGM Global Configs",
    Width => "3", # Excel Formula: =calc_reg_width(E92:E92,F92)
    Type => "Config",
    DocName => "SliceCgmProfile",
    AdditionalInfo => "PackArrayToBus",
    Comments => "VOQ_CGM",
    ArrayLength => "32",
    ArrayIndex => "14",
    CounterId14 => { #Structure Type: RegField; ArrayLength: 32; ArrayIndex: 14; ArrayLocationInName: 10;
      Name => "CounterId[n]",
      RegMem => "RegField",
      Description => "Map CGM profile to PD counter.
Values :
0 - 3 : counter ID
4 : Do not count
5-7 : Unused",
      Width => "3", # Excel Formula: =calc_field_width_define("VOQ_CGM_COUNTER_NUM_WIDTH")
      Position => "2:0", # Excel Formula: =calc_position(F91,E92,TRUE)
      Type => "Config",
      UsedBy => "Voq_CGM",
      DefaultValue => "h0",
      DocName => "CounterId",
      Comments => "VOQ_CGM_COUNTER_UC  = d0
VOQ_CGM_COUNTER_MC = d1
VOQ_CGM_COUNTER_MS_UC = d2
VOQ_CGM_COUNTER_MS_MC = d3
VOQ_CGM_COUNTER_IGNORE = d4",
      InitValueSa => "(instance == 0) ? 4 :
(instance == 1) ? 1 : 0",
      InitValueLcNwk => "(instance == 0) ? 4 :
(instance == 1) ? 1 : 0",
      InitValueLcFab => "(instance == 2) ? 2 :
(instance == 3) ? 3 : 4",
      InitValueFe => "(instance == 2) ? 2 :
(instance == 3) ? 3 : 4",
    },
  },
  SliceCGMProfile15 => { #Structure Type: Reg; ArrayLength: 32; ArrayIndex: 15; ArrayLocationInName: 16;
    Name => "SliceCGMProfile[32]",
    RegMem => "Reg",
    Address => "120",
    Description => "CGM Global Configs",
    Width => "3", # Excel Formula: =calc_reg_width(E92:E92,F92)
    Type => "Config",
    DocName => "SliceCgmProfile",
    AdditionalInfo => "PackArrayToBus",
    Comments => "VOQ_CGM",
    ArrayLength => "32",
    ArrayIndex => "15",
    CounterId15 => { #Structure Type: RegField; ArrayLength: 32; ArrayIndex: 15; ArrayLocationInName: 10;
      Name => "CounterId[n]",
      RegMem => "RegField",
      Description => "Map CGM profile to PD counter.
Values :
0 - 3 : counter ID
4 : Do not count
5-7 : Unused",
      Width => "3", # Excel Formula: =calc_field_width_define("VOQ_CGM_COUNTER_NUM_WIDTH")
      Position => "2:0", # Excel Formula: =calc_position(F91,E92,TRUE)
      Type => "Config",
      UsedBy => "Voq_CGM",
      DefaultValue => "h0",
      DocName => "CounterId",
      Comments => "VOQ_CGM_COUNTER_UC  = d0
VOQ_CGM_COUNTER_MC = d1
VOQ_CGM_COUNTER_MS_UC = d2
VOQ_CGM_COUNTER_MS_MC = d3
VOQ_CGM_COUNTER_IGNORE = d4",
      InitValueSa => "(instance == 0) ? 4 :
(instance == 1) ? 1 : 0",
      InitValueLcNwk => "(instance == 0) ? 4 :
(instance == 1) ? 1 : 0",
      InitValueLcFab => "(instance == 2) ? 2 :
(instance == 3) ? 3 : 4",
      InitValueFe => "(instance == 2) ? 2 :
(instance == 3) ? 3 : 4",
    },
  },
  SliceCGMProfile16 => { #Structure Type: Reg; ArrayLength: 32; ArrayIndex: 16; ArrayLocationInName: 16;
    Name => "SliceCGMProfile[32]",
    RegMem => "Reg",
    Address => "121",
    Description => "CGM Global Configs",
    Width => "3", # Excel Formula: =calc_reg_width(E92:E92,F92)
    Type => "Config",
    DocName => "SliceCgmProfile",
    AdditionalInfo => "PackArrayToBus",
    Comments => "VOQ_CGM",
    ArrayLength => "32",
    ArrayIndex => "16",
    CounterId16 => { #Structure Type: RegField; ArrayLength: 32; ArrayIndex: 16; ArrayLocationInName: 10;
      Name => "CounterId[n]",
      RegMem => "RegField",
      Description => "Map CGM profile to PD counter.
Values :
0 - 3 : counter ID
4 : Do not count
5-7 : Unused",
      Width => "3", # Excel Formula: =calc_field_width_define("VOQ_CGM_COUNTER_NUM_WIDTH")
      Position => "2:0", # Excel Formula: =calc_position(F91,E92,TRUE)
      Type => "Config",
      UsedBy => "Voq_CGM",
      DefaultValue => "h0",
      DocName => "CounterId",
      Comments => "VOQ_CGM_COUNTER_UC  = d0
VOQ_CGM_COUNTER_MC = d1
VOQ_CGM_COUNTER_MS_UC = d2
VOQ_CGM_COUNTER_MS_MC = d3
VOQ_CGM_COUNTER_IGNORE = d4",
      InitValueSa => "(instance == 0) ? 4 :
(instance == 1) ? 1 : 0",
      InitValueLcNwk => "(instance == 0) ? 4 :
(instance == 1) ? 1 : 0",
      InitValueLcFab => "(instance == 2) ? 2 :
(instance == 3) ? 3 : 4",
      InitValueFe => "(instance == 2) ? 2 :
(instance == 3) ? 3 : 4",
    },
  },
  SliceCGMProfile17 => { #Structure Type: Reg; ArrayLength: 32; ArrayIndex: 17; ArrayLocationInName: 16;
    Name => "SliceCGMProfile[32]",
    RegMem => "Reg",
    Address => "122",
    Description => "CGM Global Configs",
    Width => "3", # Excel Formula: =calc_reg_width(E92:E92,F92)
    Type => "Config",
    DocName => "SliceCgmProfile",
    AdditionalInfo => "PackArrayToBus",
    Comments => "VOQ_CGM",
    ArrayLength => "32",
    ArrayIndex => "17",
    CounterId17 => { #Structure Type: RegField; ArrayLength: 32; ArrayIndex: 17; ArrayLocationInName: 10;
      Name => "CounterId[n]",
      RegMem => "RegField",
      Description => "Map CGM profile to PD counter.
Values :
0 - 3 : counter ID
4 : Do not count
5-7 : Unused",
      Width => "3", # Excel Formula: =calc_field_width_define("VOQ_CGM_COUNTER_NUM_WIDTH")
      Position => "2:0", # Excel Formula: =calc_position(F91,E92,TRUE)
      Type => "Config",
      UsedBy => "Voq_CGM",
      DefaultValue => "h0",
      DocName => "CounterId",
      Comments => "VOQ_CGM_COUNTER_UC  = d0
VOQ_CGM_COUNTER_MC = d1
VOQ_CGM_COUNTER_MS_UC = d2
VOQ_CGM_COUNTER_MS_MC = d3
VOQ_CGM_COUNTER_IGNORE = d4",
      InitValueSa => "(instance == 0) ? 4 :
(instance == 1) ? 1 : 0",
      InitValueLcNwk => "(instance == 0) ? 4 :
(instance == 1) ? 1 : 0",
      InitValueLcFab => "(instance == 2) ? 2 :
(instance == 3) ? 3 : 4",
      InitValueFe => "(instance == 2) ? 2 :
(instance == 3) ? 3 : 4",
    },
  },
  SliceCGMProfile18 => { #Structure Type: Reg; ArrayLength: 32; ArrayIndex: 18; ArrayLocationInName: 16;
    Name => "SliceCGMProfile[32]",
    RegMem => "Reg",
    Address => "123",
    Description => "CGM Global Configs",
    Width => "3", # Excel Formula: =calc_reg_width(E92:E92,F92)
    Type => "Config",
    DocName => "SliceCgmProfile",
    AdditionalInfo => "PackArrayToBus",
    Comments => "VOQ_CGM",
    ArrayLength => "32",
    ArrayIndex => "18",
    CounterId18 => { #Structure Type: RegField; ArrayLength: 32; ArrayIndex: 18; ArrayLocationInName: 10;
      Name => "CounterId[n]",
      RegMem => "RegField",
      Description => "Map CGM profile to PD counter.
Values :
0 - 3 : counter ID
4 : Do not count
5-7 : Unused",
      Width => "3", # Excel Formula: =calc_field_width_define("VOQ_CGM_COUNTER_NUM_WIDTH")
      Position => "2:0", # Excel Formula: =calc_position(F91,E92,TRUE)
      Type => "Config",
      UsedBy => "Voq_CGM",
      DefaultValue => "h0",
      DocName => "CounterId",
      Comments => "VOQ_CGM_COUNTER_UC  = d0
VOQ_CGM_COUNTER_MC = d1
VOQ_CGM_COUNTER_MS_UC = d2
VOQ_CGM_COUNTER_MS_MC = d3
VOQ_CGM_COUNTER_IGNORE = d4",
      InitValueSa => "(instance == 0) ? 4 :
(instance == 1) ? 1 : 0",
      InitValueLcNwk => "(instance == 0) ? 4 :
(instance == 1) ? 1 : 0",
      InitValueLcFab => "(instance == 2) ? 2 :
(instance == 3) ? 3 : 4",
      InitValueFe => "(instance == 2) ? 2 :
(instance == 3) ? 3 : 4",
    },
  },
  SliceCGMProfile19 => { #Structure Type: Reg; ArrayLength: 32; ArrayIndex: 19; ArrayLocationInName: 16;
    Name => "SliceCGMProfile[32]",
    RegMem => "Reg",
    Address => "124",
    Description => "CGM Global Configs",
    Width => "3", # Excel Formula: =calc_reg_width(E92:E92,F92)
    Type => "Config",
    DocName => "SliceCgmProfile",
    AdditionalInfo => "PackArrayToBus",
    Comments => "VOQ_CGM",
    ArrayLength => "32",
    ArrayIndex => "19",
    CounterId19 => { #Structure Type: RegField; ArrayLength: 32; ArrayIndex: 19; ArrayLocationInName: 10;
      Name => "CounterId[n]",
      RegMem => "RegField",
      Description => "Map CGM profile to PD counter.
Values :
0 - 3 : counter ID
4 : Do not count
5-7 : Unused",
      Width => "3", # Excel Formula: =calc_field_width_define("VOQ_CGM_COUNTER_NUM_WIDTH")
      Position => "2:0", # Excel Formula: =calc_position(F91,E92,TRUE)
      Type => "Config",
      UsedBy => "Voq_CGM",
      DefaultValue => "h0",
      DocName => "CounterId",
      Comments => "VOQ_CGM_COUNTER_UC  = d0
VOQ_CGM_COUNTER_MC = d1
VOQ_CGM_COUNTER_MS_UC = d2
VOQ_CGM_COUNTER_MS_MC = d3
VOQ_CGM_COUNTER_IGNORE = d4",
      InitValueSa => "(instance == 0) ? 4 :
(instance == 1) ? 1 : 0",
      InitValueLcNwk => "(instance == 0) ? 4 :
(instance == 1) ? 1 : 0",
      InitValueLcFab => "(instance == 2) ? 2 :
(instance == 3) ? 3 : 4",
      InitValueFe => "(instance == 2) ? 2 :
(instance == 3) ? 3 : 4",
    },
  },
  SliceCGMProfile20 => { #Structure Type: Reg; ArrayLength: 32; ArrayIndex: 20; ArrayLocationInName: 16;
    Name => "SliceCGMProfile[32]",
    RegMem => "Reg",
    Address => "125",
    Description => "CGM Global Configs",
    Width => "3", # Excel Formula: =calc_reg_width(E92:E92,F92)
    Type => "Config",
    DocName => "SliceCgmProfile",
    AdditionalInfo => "PackArrayToBus",
    Comments => "VOQ_CGM",
    ArrayLength => "32",
    ArrayIndex => "20",
    CounterId20 => { #Structure Type: RegField; ArrayLength: 32; ArrayIndex: 20; ArrayLocationInName: 10;
      Name => "CounterId[n]",
      RegMem => "RegField",
      Description => "Map CGM profile to PD counter.
Values :
0 - 3 : counter ID
4 : Do not count
5-7 : Unused",
      Width => "3", # Excel Formula: =calc_field_width_define("VOQ_CGM_COUNTER_NUM_WIDTH")
      Position => "2:0", # Excel Formula: =calc_position(F91,E92,TRUE)
      Type => "Config",
      UsedBy => "Voq_CGM",
      DefaultValue => "h0",
      DocName => "CounterId",
      Comments => "VOQ_CGM_COUNTER_UC  = d0
VOQ_CGM_COUNTER_MC = d1
VOQ_CGM_COUNTER_MS_UC = d2
VOQ_CGM_COUNTER_MS_MC = d3
VOQ_CGM_COUNTER_IGNORE = d4",
      InitValueSa => "(instance == 0) ? 4 :
(instance == 1) ? 1 : 0",
      InitValueLcNwk => "(instance == 0) ? 4 :
(instance == 1) ? 1 : 0",
      InitValueLcFab => "(instance == 2) ? 2 :
(instance == 3) ? 3 : 4",
      InitValueFe => "(instance == 2) ? 2 :
(instance == 3) ? 3 : 4",
    },
  },
  SliceCGMProfile21 => { #Structure Type: Reg; ArrayLength: 32; ArrayIndex: 21; ArrayLocationInName: 16;
    Name => "SliceCGMProfile[32]",
    RegMem => "Reg",
    Address => "126",
    Description => "CGM Global Configs",
    Width => "3", # Excel Formula: =calc_reg_width(E92:E92,F92)
    Type => "Config",
    DocName => "SliceCgmProfile",
    AdditionalInfo => "PackArrayToBus",
    Comments => "VOQ_CGM",
    ArrayLength => "32",
    ArrayIndex => "21",
    CounterId21 => { #Structure Type: RegField; ArrayLength: 32; ArrayIndex: 21; ArrayLocationInName: 10;
      Name => "CounterId[n]",
      RegMem => "RegField",
      Description => "Map CGM profile to PD counter.
Values :
0 - 3 : counter ID
4 : Do not count
5-7 : Unused",
      Width => "3", # Excel Formula: =calc_field_width_define("VOQ_CGM_COUNTER_NUM_WIDTH")
      Position => "2:0", # Excel Formula: =calc_position(F91,E92,TRUE)
      Type => "Config",
      UsedBy => "Voq_CGM",
      DefaultValue => "h0",
      DocName => "CounterId",
      Comments => "VOQ_CGM_COUNTER_UC  = d0
VOQ_CGM_COUNTER_MC = d1
VOQ_CGM_COUNTER_MS_UC = d2
VOQ_CGM_COUNTER_MS_MC = d3
VOQ_CGM_COUNTER_IGNORE = d4",
      InitValueSa => "(instance == 0) ? 4 :
(instance == 1) ? 1 : 0",
      InitValueLcNwk => "(instance == 0) ? 4 :
(instance == 1) ? 1 : 0",
      InitValueLcFab => "(instance == 2) ? 2 :
(instance == 3) ? 3 : 4",
      InitValueFe => "(instance == 2) ? 2 :
(instance == 3) ? 3 : 4",
    },
  },
  SliceCGMProfile22 => { #Structure Type: Reg; ArrayLength: 32; ArrayIndex: 22; ArrayLocationInName: 16;
    Name => "SliceCGMProfile[32]",
    RegMem => "Reg",
    Address => "127",
    Description => "CGM Global Configs",
    Width => "3", # Excel Formula: =calc_reg_width(E92:E92,F92)
    Type => "Config",
    DocName => "SliceCgmProfile",
    AdditionalInfo => "PackArrayToBus",
    Comments => "VOQ_CGM",
    ArrayLength => "32",
    ArrayIndex => "22",
    CounterId22 => { #Structure Type: RegField; ArrayLength: 32; ArrayIndex: 22; ArrayLocationInName: 10;
      Name => "CounterId[n]",
      RegMem => "RegField",
      Description => "Map CGM profile to PD counter.
Values :
0 - 3 : counter ID
4 : Do not count
5-7 : Unused",
      Width => "3", # Excel Formula: =calc_field_width_define("VOQ_CGM_COUNTER_NUM_WIDTH")
      Position => "2:0", # Excel Formula: =calc_position(F91,E92,TRUE)
      Type => "Config",
      UsedBy => "Voq_CGM",
      DefaultValue => "h0",
      DocName => "CounterId",
      Comments => "VOQ_CGM_COUNTER_UC  = d0
VOQ_CGM_COUNTER_MC = d1
VOQ_CGM_COUNTER_MS_UC = d2
VOQ_CGM_COUNTER_MS_MC = d3
VOQ_CGM_COUNTER_IGNORE = d4",
      InitValueSa => "(instance == 0) ? 4 :
(instance == 1) ? 1 : 0",
      InitValueLcNwk => "(instance == 0) ? 4 :
(instance == 1) ? 1 : 0",
      InitValueLcFab => "(instance == 2) ? 2 :
(instance == 3) ? 3 : 4",
      InitValueFe => "(instance == 2) ? 2 :
(instance == 3) ? 3 : 4",
    },
  },
  SliceCGMProfile23 => { #Structure Type: Reg; ArrayLength: 32; ArrayIndex: 23; ArrayLocationInName: 16;
    Name => "SliceCGMProfile[32]",
    RegMem => "Reg",
    Address => "128",
    Description => "CGM Global Configs",
    Width => "3", # Excel Formula: =calc_reg_width(E92:E92,F92)
    Type => "Config",
    DocName => "SliceCgmProfile",
    AdditionalInfo => "PackArrayToBus",
    Comments => "VOQ_CGM",
    ArrayLength => "32",
    ArrayIndex => "23",
    CounterId23 => { #Structure Type: RegField; ArrayLength: 32; ArrayIndex: 23; ArrayLocationInName: 10;
      Name => "CounterId[n]",
      RegMem => "RegField",
      Description => "Map CGM profile to PD counter.
Values :
0 - 3 : counter ID
4 : Do not count
5-7 : Unused",
      Width => "3", # Excel Formula: =calc_field_width_define("VOQ_CGM_COUNTER_NUM_WIDTH")
      Position => "2:0", # Excel Formula: =calc_position(F91,E92,TRUE)
      Type => "Config",
      UsedBy => "Voq_CGM",
      DefaultValue => "h0",
      DocName => "CounterId",
      Comments => "VOQ_CGM_COUNTER_UC  = d0
VOQ_CGM_COUNTER_MC = d1
VOQ_CGM_COUNTER_MS_UC = d2
VOQ_CGM_COUNTER_MS_MC = d3
VOQ_CGM_COUNTER_IGNORE = d4",
      InitValueSa => "(instance == 0) ? 4 :
(instance == 1) ? 1 : 0",
      InitValueLcNwk => "(instance == 0) ? 4 :
(instance == 1) ? 1 : 0",
      InitValueLcFab => "(instance == 2) ? 2 :
(instance == 3) ? 3 : 4",
      InitValueFe => "(instance == 2) ? 2 :
(instance == 3) ? 3 : 4",
    },
  },
  SliceCGMProfile24 => { #Structure Type: Reg; ArrayLength: 32; ArrayIndex: 24; ArrayLocationInName: 16;
    Name => "SliceCGMProfile[32]",
    RegMem => "Reg",
    Address => "129",
    Description => "CGM Global Configs",
    Width => "3", # Excel Formula: =calc_reg_width(E92:E92,F92)
    Type => "Config",
    DocName => "SliceCgmProfile",
    AdditionalInfo => "PackArrayToBus",
    Comments => "VOQ_CGM",
    ArrayLength => "32",
    ArrayIndex => "24",
    CounterId24 => { #Structure Type: RegField; ArrayLength: 32; ArrayIndex: 24; ArrayLocationInName: 10;
      Name => "CounterId[n]",
      RegMem => "RegField",
      Description => "Map CGM profile to PD counter.
Values :
0 - 3 : counter ID
4 : Do not count
5-7 : Unused",
      Width => "3", # Excel Formula: =calc_field_width_define("VOQ_CGM_COUNTER_NUM_WIDTH")
      Position => "2:0", # Excel Formula: =calc_position(F91,E92,TRUE)
      Type => "Config",
      UsedBy => "Voq_CGM",
      DefaultValue => "h0",
      DocName => "CounterId",
      Comments => "VOQ_CGM_COUNTER_UC  = d0
VOQ_CGM_COUNTER_MC = d1
VOQ_CGM_COUNTER_MS_UC = d2
VOQ_CGM_COUNTER_MS_MC = d3
VOQ_CGM_COUNTER_IGNORE = d4",
      InitValueSa => "(instance == 0) ? 4 :
(instance == 1) ? 1 : 0",
      InitValueLcNwk => "(instance == 0) ? 4 :
(instance == 1) ? 1 : 0",
      InitValueLcFab => "(instance == 2) ? 2 :
(instance == 3) ? 3 : 4",
      InitValueFe => "(instance == 2) ? 2 :
(instance == 3) ? 3 : 4",
    },
  },
  SliceCGMProfile25 => { #Structure Type: Reg; ArrayLength: 32; ArrayIndex: 25; ArrayLocationInName: 16;
    Name => "SliceCGMProfile[32]",
    RegMem => "Reg",
    Address => "12A",
    Description => "CGM Global Configs",
    Width => "3", # Excel Formula: =calc_reg_width(E92:E92,F92)
    Type => "Config",
    DocName => "SliceCgmProfile",
    AdditionalInfo => "PackArrayToBus",
    Comments => "VOQ_CGM",
    ArrayLength => "32",
    ArrayIndex => "25",
    CounterId25 => { #Structure Type: RegField; ArrayLength: 32; ArrayIndex: 25; ArrayLocationInName: 10;
      Name => "CounterId[n]",
      RegMem => "RegField",
      Description => "Map CGM profile to PD counter.
Values :
0 - 3 : counter ID
4 : Do not count
5-7 : Unused",
      Width => "3", # Excel Formula: =calc_field_width_define("VOQ_CGM_COUNTER_NUM_WIDTH")
      Position => "2:0", # Excel Formula: =calc_position(F91,E92,TRUE)
      Type => "Config",
      UsedBy => "Voq_CGM",
      DefaultValue => "h0",
      DocName => "CounterId",
      Comments => "VOQ_CGM_COUNTER_UC  = d0
VOQ_CGM_COUNTER_MC = d1
VOQ_CGM_COUNTER_MS_UC = d2
VOQ_CGM_COUNTER_MS_MC = d3
VOQ_CGM_COUNTER_IGNORE = d4",
      InitValueSa => "(instance == 0) ? 4 :
(instance == 1) ? 1 : 0",
      InitValueLcNwk => "(instance == 0) ? 4 :
(instance == 1) ? 1 : 0",
      InitValueLcFab => "(instance == 2) ? 2 :
(instance == 3) ? 3 : 4",
      InitValueFe => "(instance == 2) ? 2 :
(instance == 3) ? 3 : 4",
    },
  },
  SliceCGMProfile26 => { #Structure Type: Reg; ArrayLength: 32; ArrayIndex: 26; ArrayLocationInName: 16;
    Name => "SliceCGMProfile[32]",
    RegMem => "Reg",
    Address => "12B",
    Description => "CGM Global Configs",
    Width => "3", # Excel Formula: =calc_reg_width(E92:E92,F92)
    Type => "Config",
    DocName => "SliceCgmProfile",
    AdditionalInfo => "PackArrayToBus",
    Comments => "VOQ_CGM",
    ArrayLength => "32",
    ArrayIndex => "26",
    CounterId26 => { #Structure Type: RegField; ArrayLength: 32; ArrayIndex: 26; ArrayLocationInName: 10;
      Name => "CounterId[n]",
      RegMem => "RegField",
      Description => "Map CGM profile to PD counter.
Values :
0 - 3 : counter ID
4 : Do not count
5-7 : Unused",
      Width => "3", # Excel Formula: =calc_field_width_define("VOQ_CGM_COUNTER_NUM_WIDTH")
      Position => "2:0", # Excel Formula: =calc_position(F91,E92,TRUE)
      Type => "Config",
      UsedBy => "Voq_CGM",
      DefaultValue => "h0",
      DocName => "CounterId",
      Comments => "VOQ_CGM_COUNTER_UC  = d0
VOQ_CGM_COUNTER_MC = d1
VOQ_CGM_COUNTER_MS_UC = d2
VOQ_CGM_COUNTER_MS_MC = d3
VOQ_CGM_COUNTER_IGNORE = d4",
      InitValueSa => "(instance == 0) ? 4 :
(instance == 1) ? 1 : 0",
      InitValueLcNwk => "(instance == 0) ? 4 :
(instance == 1) ? 1 : 0",
      InitValueLcFab => "(instance == 2) ? 2 :
(instance == 3) ? 3 : 4",
      InitValueFe => "(instance == 2) ? 2 :
(instance == 3) ? 3 : 4",
    },
  },
  SliceCGMProfile27 => { #Structure Type: Reg; ArrayLength: 32; ArrayIndex: 27; ArrayLocationInName: 16;
    Name => "SliceCGMProfile[32]",
    RegMem => "Reg",
    Address => "12C",
    Description => "CGM Global Configs",
    Width => "3", # Excel Formula: =calc_reg_width(E92:E92,F92)
    Type => "Config",
    DocName => "SliceCgmProfile",
    AdditionalInfo => "PackArrayToBus",
    Comments => "VOQ_CGM",
    ArrayLength => "32",
    ArrayIndex => "27",
    CounterId27 => { #Structure Type: RegField; ArrayLength: 32; ArrayIndex: 27; ArrayLocationInName: 10;
      Name => "CounterId[n]",
      RegMem => "RegField",
      Description => "Map CGM profile to PD counter.
Values :
0 - 3 : counter ID
4 : Do not count
5-7 : Unused",
      Width => "3", # Excel Formula: =calc_field_width_define("VOQ_CGM_COUNTER_NUM_WIDTH")
      Position => "2:0", # Excel Formula: =calc_position(F91,E92,TRUE)
      Type => "Config",
      UsedBy => "Voq_CGM",
      DefaultValue => "h0",
      DocName => "CounterId",
      Comments => "VOQ_CGM_COUNTER_UC  = d0
VOQ_CGM_COUNTER_MC = d1
VOQ_CGM_COUNTER_MS_UC = d2
VOQ_CGM_COUNTER_MS_MC = d3
VOQ_CGM_COUNTER_IGNORE = d4",
      InitValueSa => "(instance == 0) ? 4 :
(instance == 1) ? 1 : 0",
      InitValueLcNwk => "(instance == 0) ? 4 :
(instance == 1) ? 1 : 0",
      InitValueLcFab => "(instance == 2) ? 2 :
(instance == 3) ? 3 : 4",
      InitValueFe => "(instance == 2) ? 2 :
(instance == 3) ? 3 : 4",
    },
  },
  SliceCGMProfile28 => { #Structure Type: Reg; ArrayLength: 32; ArrayIndex: 28; ArrayLocationInName: 16;
    Name => "SliceCGMProfile[32]",
    RegMem => "Reg",
    Address => "12D",
    Description => "CGM Global Configs",
    Width => "3", # Excel Formula: =calc_reg_width(E92:E92,F92)
    Type => "Config",
    DocName => "SliceCgmProfile",
    AdditionalInfo => "PackArrayToBus",
    Comments => "VOQ_CGM",
    ArrayLength => "32",
    ArrayIndex => "28",
    CounterId28 => { #Structure Type: RegField; ArrayLength: 32; ArrayIndex: 28; ArrayLocationInName: 10;
      Name => "CounterId[n]",
      RegMem => "RegField",
      Description => "Map CGM profile to PD counter.
Values :
0 - 3 : counter ID
4 : Do not count
5-7 : Unused",
      Width => "3", # Excel Formula: =calc_field_width_define("VOQ_CGM_COUNTER_NUM_WIDTH")
      Position => "2:0", # Excel Formula: =calc_position(F91,E92,TRUE)
      Type => "Config",
      UsedBy => "Voq_CGM",
      DefaultValue => "h0",
      DocName => "CounterId",
      Comments => "VOQ_CGM_COUNTER_UC  = d0
VOQ_CGM_COUNTER_MC = d1
VOQ_CGM_COUNTER_MS_UC = d2
VOQ_CGM_COUNTER_MS_MC = d3
VOQ_CGM_COUNTER_IGNORE = d4",
      InitValueSa => "(instance == 0) ? 4 :
(instance == 1) ? 1 : 0",
      InitValueLcNwk => "(instance == 0) ? 4 :
(instance == 1) ? 1 : 0",
      InitValueLcFab => "(instance == 2) ? 2 :
(instance == 3) ? 3 : 4",
      InitValueFe => "(instance == 2) ? 2 :
(instance == 3) ? 3 : 4",
    },
  },
  SliceCGMProfile29 => { #Structure Type: Reg; ArrayLength: 32; ArrayIndex: 29; ArrayLocationInName: 16;
    Name => "SliceCGMProfile[32]",
    RegMem => "Reg",
    Address => "12E",
    Description => "CGM Global Configs",
    Width => "3", # Excel Formula: =calc_reg_width(E92:E92,F92)
    Type => "Config",
    DocName => "SliceCgmProfile",
    AdditionalInfo => "PackArrayToBus",
    Comments => "VOQ_CGM",
    ArrayLength => "32",
    ArrayIndex => "29",
    CounterId29 => { #Structure Type: RegField; ArrayLength: 32; ArrayIndex: 29; ArrayLocationInName: 10;
      Name => "CounterId[n]",
      RegMem => "RegField",
      Description => "Map CGM profile to PD counter.
Values :
0 - 3 : counter ID
4 : Do not count
5-7 : Unused",
      Width => "3", # Excel Formula: =calc_field_width_define("VOQ_CGM_COUNTER_NUM_WIDTH")
      Position => "2:0", # Excel Formula: =calc_position(F91,E92,TRUE)
      Type => "Config",
      UsedBy => "Voq_CGM",
      DefaultValue => "h0",
      DocName => "CounterId",
      Comments => "VOQ_CGM_COUNTER_UC  = d0
VOQ_CGM_COUNTER_MC = d1
VOQ_CGM_COUNTER_MS_UC = d2
VOQ_CGM_COUNTER_MS_MC = d3
VOQ_CGM_COUNTER_IGNORE = d4",
      InitValueSa => "(instance == 0) ? 4 :
(instance == 1) ? 1 : 0",
      InitValueLcNwk => "(instance == 0) ? 4 :
(instance == 1) ? 1 : 0",
      InitValueLcFab => "(instance == 2) ? 2 :
(instance == 3) ? 3 : 4",
      InitValueFe => "(instance == 2) ? 2 :
(instance == 3) ? 3 : 4",
    },
  },
  SliceCGMProfile30 => { #Structure Type: Reg; ArrayLength: 32; ArrayIndex: 30; ArrayLocationInName: 16;
    Name => "SliceCGMProfile[32]",
    RegMem => "Reg",
    Address => "12F",
    Description => "CGM Global Configs",
    Width => "3", # Excel Formula: =calc_reg_width(E92:E92,F92)
    Type => "Config",
    DocName => "SliceCgmProfile",
    AdditionalInfo => "PackArrayToBus",
    Comments => "VOQ_CGM",
    ArrayLength => "32",
    ArrayIndex => "30",
    CounterId30 => { #Structure Type: RegField; ArrayLength: 32; ArrayIndex: 30; ArrayLocationInName: 10;
      Name => "CounterId[n]",
      RegMem => "RegField",
      Description => "Map CGM profile to PD counter.
Values :
0 - 3 : counter ID
4 : Do not count
5-7 : Unused",
      Width => "3", # Excel Formula: =calc_field_width_define("VOQ_CGM_COUNTER_NUM_WIDTH")
      Position => "2:0", # Excel Formula: =calc_position(F91,E92,TRUE)
      Type => "Config",
      UsedBy => "Voq_CGM",
      DefaultValue => "h0",
      DocName => "CounterId",
      Comments => "VOQ_CGM_COUNTER_UC  = d0
VOQ_CGM_COUNTER_MC = d1
VOQ_CGM_COUNTER_MS_UC = d2
VOQ_CGM_COUNTER_MS_MC = d3
VOQ_CGM_COUNTER_IGNORE = d4",
      InitValueSa => "(instance == 0) ? 4 :
(instance == 1) ? 1 : 0",
      InitValueLcNwk => "(instance == 0) ? 4 :
(instance == 1) ? 1 : 0",
      InitValueLcFab => "(instance == 2) ? 2 :
(instance == 3) ? 3 : 4",
      InitValueFe => "(instance == 2) ? 2 :
(instance == 3) ? 3 : 4",
    },
  },
  SliceCGMProfile31 => { #Structure Type: Reg; ArrayLength: 32; ArrayIndex: 31; ArrayLocationInName: 16;
    Name => "SliceCGMProfile[32]",
    RegMem => "Reg",
    Address => "130",
    Description => "CGM Global Configs",
    Width => "3", # Excel Formula: =calc_reg_width(E92:E92,F92)
    Type => "Config",
    DocName => "SliceCgmProfile",
    AdditionalInfo => "PackArrayToBus",
    Comments => "VOQ_CGM",
    ArrayLength => "32",
    ArrayIndex => "31",
    CounterId31 => { #Structure Type: RegField; ArrayLength: 32; ArrayIndex: 31; ArrayLocationInName: 10;
      Name => "CounterId[n]",
      RegMem => "RegField",
      Description => "Map CGM profile to PD counter.
Values :
0 - 3 : counter ID
4 : Do not count
5-7 : Unused",
      Width => "3", # Excel Formula: =calc_field_width_define("VOQ_CGM_COUNTER_NUM_WIDTH")
      Position => "2:0", # Excel Formula: =calc_position(F91,E92,TRUE)
      Type => "Config",
      UsedBy => "Voq_CGM",
      DefaultValue => "h0",
      DocName => "CounterId",
      Comments => "VOQ_CGM_COUNTER_UC  = d0
VOQ_CGM_COUNTER_MC = d1
VOQ_CGM_COUNTER_MS_UC = d2
VOQ_CGM_COUNTER_MS_MC = d3
VOQ_CGM_COUNTER_IGNORE = d4",
      InitValueSa => "(instance == 0) ? 4 :
(instance == 1) ? 1 : 0",
      InitValueLcNwk => "(instance == 0) ? 4 :
(instance == 1) ? 1 : 0",
      InitValueLcFab => "(instance == 2) ? 2 :
(instance == 3) ? 3 : 4",
      InitValueFe => "(instance == 2) ? 2 :
(instance == 3) ? 3 : 4",
    },
  },
  BuffersConsumptionLutForDeq0 => { #Structure Type: Reg; ArrayLength: 128; ArrayIndex: 0; ArrayLocationInName: 28;
    Name => "BuffersConsumptionLutForDeq[128]",
    RegMem => "Reg",
    Address => "131", # Excel Formula: =calc_reg_address(C91,A91,G91)
    Description => "LUT for dequeue marking in VOQ-CGM based on Buffer Consumption.
Index in Array is {Profile,BufferAvailableLevel}
Profile is 5 bits
BufferAvailableLevel is quantized to 2 bits.",
    Width => "8", # Excel Formula: =calc_reg_width(E94:E94,F94)
    Type => "Config",
    AdditionalInfo => "PackArrayToBus",
    Comments => "VOQ_CGM
CGM Deq Marking logic implemented in FF.
Address is {VOQ_PROFILE,Buffer_pool_available_level}
5 + 2 = 7
Buffer_voq_size_level selects offset out of 8.",
    ArrayLength => "128",
    ArrayIndex => "0",
    DeqBufferCongestionMark0 => { #Structure Type: RegField; ArrayLength: 128; ArrayIndex: 0; ArrayLocationInName: 24;
      Name => "DeqBufferCongestionMark[n]",
      RegMem => "RegField",
      Description => "Fill level of VOQ in buffers selects between the 8 values for a given {Profile,BufferAvailableLevel} pair.
The MSB is mark indication in case of most full.
The LSB is mark indication in case of most empty.",
      Width => "8",
      Position => "7:0", # Excel Formula: =calc_position(F93,E94,TRUE)
      Type => "Config",
      UsedBy => "CGM_deq",
      DefaultValue => "h0",
    },
  },
  BuffersConsumptionLutForDeq1 => { #Structure Type: Reg; ArrayLength: 128; ArrayIndex: 1; ArrayLocationInName: 28;
    Name => "BuffersConsumptionLutForDeq[128]",
    RegMem => "Reg",
    Address => "132",
    Description => "LUT for dequeue marking in VOQ-CGM based on Buffer Consumption.
Index in Array is {Profile,BufferAvailableLevel}
Profile is 5 bits
BufferAvailableLevel is quantized to 2 bits.",
    Width => "8", # Excel Formula: =calc_reg_width(E94:E94,F94)
    Type => "Config",
    AdditionalInfo => "PackArrayToBus",
    Comments => "VOQ_CGM
CGM Deq Marking logic implemented in FF.
Address is {VOQ_PROFILE,Buffer_pool_available_level}
5 + 2 = 7
Buffer_voq_size_level selects offset out of 8.",
    ArrayLength => "128",
    ArrayIndex => "1",
    DeqBufferCongestionMark1 => { #Structure Type: RegField; ArrayLength: 128; ArrayIndex: 1; ArrayLocationInName: 24;
      Name => "DeqBufferCongestionMark[n]",
      RegMem => "RegField",
      Description => "Fill level of VOQ in buffers selects between the 8 values for a given {Profile,BufferAvailableLevel} pair.
The MSB is mark indication in case of most full.
The LSB is mark indication in case of most empty.",
      Width => "8",
      Position => "7:0", # Excel Formula: =calc_position(F93,E94,TRUE)
      Type => "Config",
      UsedBy => "CGM_deq",
      DefaultValue => "h0",
    },
  },
  BuffersConsumptionLutForDeq2 => { #Structure Type: Reg; ArrayLength: 128; ArrayIndex: 2; ArrayLocationInName: 28;
    Name => "BuffersConsumptionLutForDeq[128]",
    RegMem => "Reg",
    Address => "133",
    Description => "LUT for dequeue marking in VOQ-CGM based on Buffer Consumption.
Index in Array is {Profile,BufferAvailableLevel}
Profile is 5 bits
BufferAvailableLevel is quantized to 2 bits.",
    Width => "8", # Excel Formula: =calc_reg_width(E94:E94,F94)
    Type => "Config",
    AdditionalInfo => "PackArrayToBus",
    Comments => "VOQ_CGM
CGM Deq Marking logic implemented in FF.
Address is {VOQ_PROFILE,Buffer_pool_available_level}
5 + 2 = 7
Buffer_voq_size_level selects offset out of 8.",
    ArrayLength => "128",
    ArrayIndex => "2",
    DeqBufferCongestionMark2 => { #Structure Type: RegField; ArrayLength: 128; ArrayIndex: 2; ArrayLocationInName: 24;
      Name => "DeqBufferCongestionMark[n]",
      RegMem => "RegField",
      Description => "Fill level of VOQ in buffers selects between the 8 values for a given {Profile,BufferAvailableLevel} pair.
The MSB is mark indication in case of most full.
The LSB is mark indication in case of most empty.",
      Width => "8",
      Position => "7:0", # Excel Formula: =calc_position(F93,E94,TRUE)
      Type => "Config",
      UsedBy => "CGM_deq",
      DefaultValue => "h0",
    },
  },
  BuffersConsumptionLutForDeq3 => { #Structure Type: Reg; ArrayLength: 128; ArrayIndex: 3; ArrayLocationInName: 28;
    Name => "BuffersConsumptionLutForDeq[128]",
    RegMem => "Reg",
    Address => "134",
    Description => "LUT for dequeue marking in VOQ-CGM based on Buffer Consumption.
Index in Array is {Profile,BufferAvailableLevel}
Profile is 5 bits
BufferAvailableLevel is quantized to 2 bits.",
    Width => "8", # Excel Formula: =calc_reg_width(E94:E94,F94)
    Type => "Config",
    AdditionalInfo => "PackArrayToBus",
    Comments => "VOQ_CGM
CGM Deq Marking logic implemented in FF.
Address is {VOQ_PROFILE,Buffer_pool_available_level}
5 + 2 = 7
Buffer_voq_size_level selects offset out of 8.",
    ArrayLength => "128",
    ArrayIndex => "3",
    DeqBufferCongestionMark3 => { #Structure Type: RegField; ArrayLength: 128; ArrayIndex: 3; ArrayLocationInName: 24;
      Name => "DeqBufferCongestionMark[n]",
      RegMem => "RegField",
      Description => "Fill level of VOQ in buffers selects between the 8 values for a given {Profile,BufferAvailableLevel} pair.
The MSB is mark indication in case of most full.
The LSB is mark indication in case of most empty.",
      Width => "8",
      Position => "7:0", # Excel Formula: =calc_position(F93,E94,TRUE)
      Type => "Config",
      UsedBy => "CGM_deq",
      DefaultValue => "h0",
    },
  },
  BuffersConsumptionLutForDeq4 => { #Structure Type: Reg; ArrayLength: 128; ArrayIndex: 4; ArrayLocationInName: 28;
    Name => "BuffersConsumptionLutForDeq[128]",
    RegMem => "Reg",
    Address => "135",
    Description => "LUT for dequeue marking in VOQ-CGM based on Buffer Consumption.
Index in Array is {Profile,BufferAvailableLevel}
Profile is 5 bits
BufferAvailableLevel is quantized to 2 bits.",
    Width => "8", # Excel Formula: =calc_reg_width(E94:E94,F94)
    Type => "Config",
    AdditionalInfo => "PackArrayToBus",
    Comments => "VOQ_CGM
CGM Deq Marking logic implemented in FF.
Address is {VOQ_PROFILE,Buffer_pool_available_level}
5 + 2 = 7
Buffer_voq_size_level selects offset out of 8.",
    ArrayLength => "128",
    ArrayIndex => "4",
    DeqBufferCongestionMark4 => { #Structure Type: RegField; ArrayLength: 128; ArrayIndex: 4; ArrayLocationInName: 24;
      Name => "DeqBufferCongestionMark[n]",
      RegMem => "RegField",
      Description => "Fill level of VOQ in buffers selects between the 8 values for a given {Profile,BufferAvailableLevel} pair.
The MSB is mark indication in case of most full.
The LSB is mark indication in case of most empty.",
      Width => "8",
      Position => "7:0", # Excel Formula: =calc_position(F93,E94,TRUE)
      Type => "Config",
      UsedBy => "CGM_deq",
      DefaultValue => "h0",
    },
  },
  BuffersConsumptionLutForDeq5 => { #Structure Type: Reg; ArrayLength: 128; ArrayIndex: 5; ArrayLocationInName: 28;
    Name => "BuffersConsumptionLutForDeq[128]",
    RegMem => "Reg",
    Address => "136",
    Description => "LUT for dequeue marking in VOQ-CGM based on Buffer Consumption.
Index in Array is {Profile,BufferAvailableLevel}
Profile is 5 bits
BufferAvailableLevel is quantized to 2 bits.",
    Width => "8", # Excel Formula: =calc_reg_width(E94:E94,F94)
    Type => "Config",
    AdditionalInfo => "PackArrayToBus",
    Comments => "VOQ_CGM
CGM Deq Marking logic implemented in FF.
Address is {VOQ_PROFILE,Buffer_pool_available_level}
5 + 2 = 7
Buffer_voq_size_level selects offset out of 8.",
    ArrayLength => "128",
    ArrayIndex => "5",
    DeqBufferCongestionMark5 => { #Structure Type: RegField; ArrayLength: 128; ArrayIndex: 5; ArrayLocationInName: 24;
      Name => "DeqBufferCongestionMark[n]",
      RegMem => "RegField",
      Description => "Fill level of VOQ in buffers selects between the 8 values for a given {Profile,BufferAvailableLevel} pair.
The MSB is mark indication in case of most full.
The LSB is mark indication in case of most empty.",
      Width => "8",
      Position => "7:0", # Excel Formula: =calc_position(F93,E94,TRUE)
      Type => "Config",
      UsedBy => "CGM_deq",
      DefaultValue => "h0",
    },
  },
  BuffersConsumptionLutForDeq6 => { #Structure Type: Reg; ArrayLength: 128; ArrayIndex: 6; ArrayLocationInName: 28;
    Name => "BuffersConsumptionLutForDeq[128]",
    RegMem => "Reg",
    Address => "137",
    Description => "LUT for dequeue marking in VOQ-CGM based on Buffer Consumption.
Index in Array is {Profile,BufferAvailableLevel}
Profile is 5 bits
BufferAvailableLevel is quantized to 2 bits.",
    Width => "8", # Excel Formula: =calc_reg_width(E94:E94,F94)
    Type => "Config",
    AdditionalInfo => "PackArrayToBus",
    Comments => "VOQ_CGM
CGM Deq Marking logic implemented in FF.
Address is {VOQ_PROFILE,Buffer_pool_available_level}
5 + 2 = 7
Buffer_voq_size_level selects offset out of 8.",
    ArrayLength => "128",
    ArrayIndex => "6",
    DeqBufferCongestionMark6 => { #Structure Type: RegField; ArrayLength: 128; ArrayIndex: 6; ArrayLocationInName: 24;
      Name => "DeqBufferCongestionMark[n]",
      RegMem => "RegField",
      Description => "Fill level of VOQ in buffers selects between the 8 values for a given {Profile,BufferAvailableLevel} pair.
The MSB is mark indication in case of most full.
The LSB is mark indication in case of most empty.",
      Width => "8",
      Position => "7:0", # Excel Formula: =calc_position(F93,E94,TRUE)
      Type => "Config",
      UsedBy => "CGM_deq",
      DefaultValue => "h0",
    },
  },
  BuffersConsumptionLutForDeq7 => { #Structure Type: Reg; ArrayLength: 128; ArrayIndex: 7; ArrayLocationInName: 28;
    Name => "BuffersConsumptionLutForDeq[128]",
    RegMem => "Reg",
    Address => "138",
    Description => "LUT for dequeue marking in VOQ-CGM based on Buffer Consumption.
Index in Array is {Profile,BufferAvailableLevel}
Profile is 5 bits
BufferAvailableLevel is quantized to 2 bits.",
    Width => "8", # Excel Formula: =calc_reg_width(E94:E94,F94)
    Type => "Config",
    AdditionalInfo => "PackArrayToBus",
    Comments => "VOQ_CGM
CGM Deq Marking logic implemented in FF.
Address is {VOQ_PROFILE,Buffer_pool_available_level}
5 + 2 = 7
Buffer_voq_size_level selects offset out of 8.",
    ArrayLength => "128",
    ArrayIndex => "7",
    DeqBufferCongestionMark7 => { #Structure Type: RegField; ArrayLength: 128; ArrayIndex: 7; ArrayLocationInName: 24;
      Name => "DeqBufferCongestionMark[n]",
      RegMem => "RegField",
      Description => "Fill level of VOQ in buffers selects between the 8 values for a given {Profile,BufferAvailableLevel} pair.
The MSB is mark indication in case of most full.
The LSB is mark indication in case of most empty.",
      Width => "8",
      Position => "7:0", # Excel Formula: =calc_position(F93,E94,TRUE)
      Type => "Config",
      UsedBy => "CGM_deq",
      DefaultValue => "h0",
    },
  },
  BuffersConsumptionLutForDeq8 => { #Structure Type: Reg; ArrayLength: 128; ArrayIndex: 8; ArrayLocationInName: 28;
    Name => "BuffersConsumptionLutForDeq[128]",
    RegMem => "Reg",
    Address => "139",
    Description => "LUT for dequeue marking in VOQ-CGM based on Buffer Consumption.
Index in Array is {Profile,BufferAvailableLevel}
Profile is 5 bits
BufferAvailableLevel is quantized to 2 bits.",
    Width => "8", # Excel Formula: =calc_reg_width(E94:E94,F94)
    Type => "Config",
    AdditionalInfo => "PackArrayToBus",
    Comments => "VOQ_CGM
CGM Deq Marking logic implemented in FF.
Address is {VOQ_PROFILE,Buffer_pool_available_level}
5 + 2 = 7
Buffer_voq_size_level selects offset out of 8.",
    ArrayLength => "128",
    ArrayIndex => "8",
    DeqBufferCongestionMark8 => { #Structure Type: RegField; ArrayLength: 128; ArrayIndex: 8; ArrayLocationInName: 24;
      Name => "DeqBufferCongestionMark[n]",
      RegMem => "RegField",
      Description => "Fill level of VOQ in buffers selects between the 8 values for a given {Profile,BufferAvailableLevel} pair.
The MSB is mark indication in case of most full.
The LSB is mark indication in case of most empty.",
      Width => "8",
      Position => "7:0", # Excel Formula: =calc_position(F93,E94,TRUE)
      Type => "Config",
      UsedBy => "CGM_deq",
      DefaultValue => "h0",
    },
  },
  BuffersConsumptionLutForDeq9 => { #Structure Type: Reg; ArrayLength: 128; ArrayIndex: 9; ArrayLocationInName: 28;
    Name => "BuffersConsumptionLutForDeq[128]",
    RegMem => "Reg",
    Address => "13A",
    Description => "LUT for dequeue marking in VOQ-CGM based on Buffer Consumption.
Index in Array is {Profile,BufferAvailableLevel}
Profile is 5 bits
BufferAvailableLevel is quantized to 2 bits.",
    Width => "8", # Excel Formula: =calc_reg_width(E94:E94,F94)
    Type => "Config",
    AdditionalInfo => "PackArrayToBus",
    Comments => "VOQ_CGM
CGM Deq Marking logic implemented in FF.
Address is {VOQ_PROFILE,Buffer_pool_available_level}
5 + 2 = 7
Buffer_voq_size_level selects offset out of 8.",
    ArrayLength => "128",
    ArrayIndex => "9",
    DeqBufferCongestionMark9 => { #Structure Type: RegField; ArrayLength: 128; ArrayIndex: 9; ArrayLocationInName: 24;
      Name => "DeqBufferCongestionMark[n]",
      RegMem => "RegField",
      Description => "Fill level of VOQ in buffers selects between the 8 values for a given {Profile,BufferAvailableLevel} pair.
The MSB is mark indication in case of most full.
The LSB is mark indication in case of most empty.",
      Width => "8",
      Position => "7:0", # Excel Formula: =calc_position(F93,E94,TRUE)
      Type => "Config",
      UsedBy => "CGM_deq",
      DefaultValue => "h0",
    },
  },
  BuffersConsumptionLutForDeq10 => { #Structure Type: Reg; ArrayLength: 128; ArrayIndex: 10; ArrayLocationInName: 28;
    Name => "BuffersConsumptionLutForDeq[128]",
    RegMem => "Reg",
    Address => "13B",
    Description => "LUT for dequeue marking in VOQ-CGM based on Buffer Consumption.
Index in Array is {Profile,BufferAvailableLevel}
Profile is 5 bits
BufferAvailableLevel is quantized to 2 bits.",
    Width => "8", # Excel Formula: =calc_reg_width(E94:E94,F94)
    Type => "Config",
    AdditionalInfo => "PackArrayToBus",
    Comments => "VOQ_CGM
CGM Deq Marking logic implemented in FF.
Address is {VOQ_PROFILE,Buffer_pool_available_level}
5 + 2 = 7
Buffer_voq_size_level selects offset out of 8.",
    ArrayLength => "128",
    ArrayIndex => "10",
    DeqBufferCongestionMark10 => { #Structure Type: RegField; ArrayLength: 128; ArrayIndex: 10; ArrayLocationInName: 24;
      Name => "DeqBufferCongestionMark[n]",
      RegMem => "RegField",
      Description => "Fill level of VOQ in buffers selects between the 8 values for a given {Profile,BufferAvailableLevel} pair.
The MSB is mark indication in case of most full.
The LSB is mark indication in case of most empty.",
      Width => "8",
      Position => "7:0", # Excel Formula: =calc_position(F93,E94,TRUE)
      Type => "Config",
      UsedBy => "CGM_deq",
      DefaultValue => "h0",
    },
  },
  BuffersConsumptionLutForDeq11 => { #Structure Type: Reg; ArrayLength: 128; ArrayIndex: 11; ArrayLocationInName: 28;
    Name => "BuffersConsumptionLutForDeq[128]",
    RegMem => "Reg",
    Address => "13C",
    Description => "LUT for dequeue marking in VOQ-CGM based on Buffer Consumption.
Index in Array is {Profile,BufferAvailableLevel}
Profile is 5 bits
BufferAvailableLevel is quantized to 2 bits.",
    Width => "8", # Excel Formula: =calc_reg_width(E94:E94,F94)
    Type => "Config",
    AdditionalInfo => "PackArrayToBus",
    Comments => "VOQ_CGM
CGM Deq Marking logic implemented in FF.
Address is {VOQ_PROFILE,Buffer_pool_available_level}
5 + 2 = 7
Buffer_voq_size_level selects offset out of 8.",
    ArrayLength => "128",
    ArrayIndex => "11",
    DeqBufferCongestionMark11 => { #Structure Type: RegField; ArrayLength: 128; ArrayIndex: 11; ArrayLocationInName: 24;
      Name => "DeqBufferCongestionMark[n]",
      RegMem => "RegField",
      Description => "Fill level of VOQ in buffers selects between the 8 values for a given {Profile,BufferAvailableLevel} pair.
The MSB is mark indication in case of most full.
The LSB is mark indication in case of most empty.",
      Width => "8",
      Position => "7:0", # Excel Formula: =calc_position(F93,E94,TRUE)
      Type => "Config",
      UsedBy => "CGM_deq",
      DefaultValue => "h0",
    },
  },
  BuffersConsumptionLutForDeq12 => { #Structure Type: Reg; ArrayLength: 128; ArrayIndex: 12; ArrayLocationInName: 28;
    Name => "BuffersConsumptionLutForDeq[128]",
    RegMem => "Reg",
    Address => "13D",
    Description => "LUT for dequeue marking in VOQ-CGM based on Buffer Consumption.
Index in Array is {Profile,BufferAvailableLevel}
Profile is 5 bits
BufferAvailableLevel is quantized to 2 bits.",
    Width => "8", # Excel Formula: =calc_reg_width(E94:E94,F94)
    Type => "Config",
    AdditionalInfo => "PackArrayToBus",
    Comments => "VOQ_CGM
CGM Deq Marking logic implemented in FF.
Address is {VOQ_PROFILE,Buffer_pool_available_level}
5 + 2 = 7
Buffer_voq_size_level selects offset out of 8.",
    ArrayLength => "128",
    ArrayIndex => "12",
    DeqBufferCongestionMark12 => { #Structure Type: RegField; ArrayLength: 128; ArrayIndex: 12; ArrayLocationInName: 24;
      Name => "DeqBufferCongestionMark[n]",
      RegMem => "RegField",
      Description => "Fill level of VOQ in buffers selects between the 8 values for a given {Profile,BufferAvailableLevel} pair.
The MSB is mark indication in case of most full.
The LSB is mark indication in case of most empty.",
      Width => "8",
      Position => "7:0", # Excel Formula: =calc_position(F93,E94,TRUE)
      Type => "Config",
      UsedBy => "CGM_deq",
      DefaultValue => "h0",
    },
  },
  BuffersConsumptionLutForDeq13 => { #Structure Type: Reg; ArrayLength: 128; ArrayIndex: 13; ArrayLocationInName: 28;
    Name => "BuffersConsumptionLutForDeq[128]",
    RegMem => "Reg",
    Address => "13E",
    Description => "LUT for dequeue marking in VOQ-CGM based on Buffer Consumption.
Index in Array is {Profile,BufferAvailableLevel}
Profile is 5 bits
BufferAvailableLevel is quantized to 2 bits.",
    Width => "8", # Excel Formula: =calc_reg_width(E94:E94,F94)
    Type => "Config",
    AdditionalInfo => "PackArrayToBus",
    Comments => "VOQ_CGM
CGM Deq Marking logic implemented in FF.
Address is {VOQ_PROFILE,Buffer_pool_available_level}
5 + 2 = 7
Buffer_voq_size_level selects offset out of 8.",
    ArrayLength => "128",
    ArrayIndex => "13",
    DeqBufferCongestionMark13 => { #Structure Type: RegField; ArrayLength: 128; ArrayIndex: 13; ArrayLocationInName: 24;
      Name => "DeqBufferCongestionMark[n]",
      RegMem => "RegField",
      Description => "Fill level of VOQ in buffers selects between the 8 values for a given {Profile,BufferAvailableLevel} pair.
The MSB is mark indication in case of most full.
The LSB is mark indication in case of most empty.",
      Width => "8",
      Position => "7:0", # Excel Formula: =calc_position(F93,E94,TRUE)
      Type => "Config",
      UsedBy => "CGM_deq",
      DefaultValue => "h0",
    },
  },
  BuffersConsumptionLutForDeq14 => { #Structure Type: Reg; ArrayLength: 128; ArrayIndex: 14; ArrayLocationInName: 28;
    Name => "BuffersConsumptionLutForDeq[128]",
    RegMem => "Reg",
    Address => "13F",
    Description => "LUT for dequeue marking in VOQ-CGM based on Buffer Consumption.
Index in Array is {Profile,BufferAvailableLevel}
Profile is 5 bits
BufferAvailableLevel is quantized to 2 bits.",
    Width => "8", # Excel Formula: =calc_reg_width(E94:E94,F94)
    Type => "Config",
    AdditionalInfo => "PackArrayToBus",
    Comments => "VOQ_CGM
CGM Deq Marking logic implemented in FF.
Address is {VOQ_PROFILE,Buffer_pool_available_level}
5 + 2 = 7
Buffer_voq_size_level selects offset out of 8.",
    ArrayLength => "128",
    ArrayIndex => "14",
    DeqBufferCongestionMark14 => { #Structure Type: RegField; ArrayLength: 128; ArrayIndex: 14; ArrayLocationInName: 24;
      Name => "DeqBufferCongestionMark[n]",
      RegMem => "RegField",
      Description => "Fill level of VOQ in buffers selects between the 8 values for a given {Profile,BufferAvailableLevel} pair.
The MSB is mark indication in case of most full.
The LSB is mark indication in case of most empty.",
      Width => "8",
      Position => "7:0", # Excel Formula: =calc_position(F93,E94,TRUE)
      Type => "Config",
      UsedBy => "CGM_deq",
      DefaultValue => "h0",
    },
  },
  BuffersConsumptionLutForDeq15 => { #Structure Type: Reg; ArrayLength: 128; ArrayIndex: 15; ArrayLocationInName: 28;
    Name => "BuffersConsumptionLutForDeq[128]",
    RegMem => "Reg",
    Address => "140",
    Description => "LUT for dequeue marking in VOQ-CGM based on Buffer Consumption.
Index in Array is {Profile,BufferAvailableLevel}
Profile is 5 bits
BufferAvailableLevel is quantized to 2 bits.",
    Width => "8", # Excel Formula: =calc_reg_width(E94:E94,F94)
    Type => "Config",
    AdditionalInfo => "PackArrayToBus",
    Comments => "VOQ_CGM
CGM Deq Marking logic implemented in FF.
Address is {VOQ_PROFILE,Buffer_pool_available_level}
5 + 2 = 7
Buffer_voq_size_level selects offset out of 8.",
    ArrayLength => "128",
    ArrayIndex => "15",
    DeqBufferCongestionMark15 => { #Structure Type: RegField; ArrayLength: 128; ArrayIndex: 15; ArrayLocationInName: 24;
      Name => "DeqBufferCongestionMark[n]",
      RegMem => "RegField",
      Description => "Fill level of VOQ in buffers selects between the 8 values for a given {Profile,BufferAvailableLevel} pair.
The MSB is mark indication in case of most full.
The LSB is mark indication in case of most empty.",
      Width => "8",
      Position => "7:0", # Excel Formula: =calc_position(F93,E94,TRUE)
      Type => "Config",
      UsedBy => "CGM_deq",
      DefaultValue => "h0",
    },
  },
  BuffersConsumptionLutForDeq16 => { #Structure Type: Reg; ArrayLength: 128; ArrayIndex: 16; ArrayLocationInName: 28;
    Name => "BuffersConsumptionLutForDeq[128]",
    RegMem => "Reg",
    Address => "141",
    Description => "LUT for dequeue marking in VOQ-CGM based on Buffer Consumption.
Index in Array is {Profile,BufferAvailableLevel}
Profile is 5 bits
BufferAvailableLevel is quantized to 2 bits.",
    Width => "8", # Excel Formula: =calc_reg_width(E94:E94,F94)
    Type => "Config",
    AdditionalInfo => "PackArrayToBus",
    Comments => "VOQ_CGM
CGM Deq Marking logic implemented in FF.
Address is {VOQ_PROFILE,Buffer_pool_available_level}
5 + 2 = 7
Buffer_voq_size_level selects offset out of 8.",
    ArrayLength => "128",
    ArrayIndex => "16",
    DeqBufferCongestionMark16 => { #Structure Type: RegField; ArrayLength: 128; ArrayIndex: 16; ArrayLocationInName: 24;
      Name => "DeqBufferCongestionMark[n]",
      RegMem => "RegField",
      Description => "Fill level of VOQ in buffers selects between the 8 values for a given {Profile,BufferAvailableLevel} pair.
The MSB is mark indication in case of most full.
The LSB is mark indication in case of most empty.",
      Width => "8",
      Position => "7:0", # Excel Formula: =calc_position(F93,E94,TRUE)
      Type => "Config",
      UsedBy => "CGM_deq",
      DefaultValue => "h0",
    },
  },
  BuffersConsumptionLutForDeq17 => { #Structure Type: Reg; ArrayLength: 128; ArrayIndex: 17; ArrayLocationInName: 28;
    Name => "BuffersConsumptionLutForDeq[128]",
    RegMem => "Reg",
    Address => "142",
    Description => "LUT for dequeue marking in VOQ-CGM based on Buffer Consumption.
Index in Array is {Profile,BufferAvailableLevel}
Profile is 5 bits
BufferAvailableLevel is quantized to 2 bits.",
    Width => "8", # Excel Formula: =calc_reg_width(E94:E94,F94)
    Type => "Config",
    AdditionalInfo => "PackArrayToBus",
    Comments => "VOQ_CGM
CGM Deq Marking logic implemented in FF.
Address is {VOQ_PROFILE,Buffer_pool_available_level}
5 + 2 = 7
Buffer_voq_size_level selects offset out of 8.",
    ArrayLength => "128",
    ArrayIndex => "17",
    DeqBufferCongestionMark17 => { #Structure Type: RegField; ArrayLength: 128; ArrayIndex: 17; ArrayLocationInName: 24;
      Name => "DeqBufferCongestionMark[n]",
      RegMem => "RegField",
      Description => "Fill level of VOQ in buffers selects between the 8 values for a given {Profile,BufferAvailableLevel} pair.
The MSB is mark indication in case of most full.
The LSB is mark indication in case of most empty.",
      Width => "8",
      Position => "7:0", # Excel Formula: =calc_position(F93,E94,TRUE)
      Type => "Config",
      UsedBy => "CGM_deq",
      DefaultValue => "h0",
    },
  },
  BuffersConsumptionLutForDeq18 => { #Structure Type: Reg; ArrayLength: 128; ArrayIndex: 18; ArrayLocationInName: 28;
    Name => "BuffersConsumptionLutForDeq[128]",
    RegMem => "Reg",
    Address => "143",
    Description => "LUT for dequeue marking in VOQ-CGM based on Buffer Consumption.
Index in Array is {Profile,BufferAvailableLevel}
Profile is 5 bits
BufferAvailableLevel is quantized to 2 bits.",
    Width => "8", # Excel Formula: =calc_reg_width(E94:E94,F94)
    Type => "Config",
    AdditionalInfo => "PackArrayToBus",
    Comments => "VOQ_CGM
CGM Deq Marking logic implemented in FF.
Address is {VOQ_PROFILE,Buffer_pool_available_level}
5 + 2 = 7
Buffer_voq_size_level selects offset out of 8.",
    ArrayLength => "128",
    ArrayIndex => "18",
    DeqBufferCongestionMark18 => { #Structure Type: RegField; ArrayLength: 128; ArrayIndex: 18; ArrayLocationInName: 24;
      Name => "DeqBufferCongestionMark[n]",
      RegMem => "RegField",
      Description => "Fill level of VOQ in buffers selects between the 8 values for a given {Profile,BufferAvailableLevel} pair.
The MSB is mark indication in case of most full.
The LSB is mark indication in case of most empty.",
      Width => "8",
      Position => "7:0", # Excel Formula: =calc_position(F93,E94,TRUE)
      Type => "Config",
      UsedBy => "CGM_deq",
      DefaultValue => "h0",
    },
  },
  BuffersConsumptionLutForDeq19 => { #Structure Type: Reg; ArrayLength: 128; ArrayIndex: 19; ArrayLocationInName: 28;
    Name => "BuffersConsumptionLutForDeq[128]",
    RegMem => "Reg",
    Address => "144",
    Description => "LUT for dequeue marking in VOQ-CGM based on Buffer Consumption.
Index in Array is {Profile,BufferAvailableLevel}
Profile is 5 bits
BufferAvailableLevel is quantized to 2 bits.",
    Width => "8", # Excel Formula: =calc_reg_width(E94:E94,F94)
    Type => "Config",
    AdditionalInfo => "PackArrayToBus",
    Comments => "VOQ_CGM
CGM Deq Marking logic implemented in FF.
Address is {VOQ_PROFILE,Buffer_pool_available_level}
5 + 2 = 7
Buffer_voq_size_level selects offset out of 8.",
    ArrayLength => "128",
    ArrayIndex => "19",
    DeqBufferCongestionMark19 => { #Structure Type: RegField; ArrayLength: 128; ArrayIndex: 19; ArrayLocationInName: 24;
      Name => "DeqBufferCongestionMark[n]",
      RegMem => "RegField",
      Description => "Fill level of VOQ in buffers selects between the 8 values for a given {Profile,BufferAvailableLevel} pair.
The MSB is mark indication in case of most full.
The LSB is mark indication in case of most empty.",
      Width => "8",
      Position => "7:0", # Excel Formula: =calc_position(F93,E94,TRUE)
      Type => "Config",
      UsedBy => "CGM_deq",
      DefaultValue => "h0",
    },
  },
  BuffersConsumptionLutForDeq20 => { #Structure Type: Reg; ArrayLength: 128; ArrayIndex: 20; ArrayLocationInName: 28;
    Name => "BuffersConsumptionLutForDeq[128]",
    RegMem => "Reg",
    Address => "145",
    Description => "LUT for dequeue marking in VOQ-CGM based on Buffer Consumption.
Index in Array is {Profile,BufferAvailableLevel}
Profile is 5 bits
BufferAvailableLevel is quantized to 2 bits.",
    Width => "8", # Excel Formula: =calc_reg_width(E94:E94,F94)
    Type => "Config",
    AdditionalInfo => "PackArrayToBus",
    Comments => "VOQ_CGM
CGM Deq Marking logic implemented in FF.
Address is {VOQ_PROFILE,Buffer_pool_available_level}
5 + 2 = 7
Buffer_voq_size_level selects offset out of 8.",
    ArrayLength => "128",
    ArrayIndex => "20",
    DeqBufferCongestionMark20 => { #Structure Type: RegField; ArrayLength: 128; ArrayIndex: 20; ArrayLocationInName: 24;
      Name => "DeqBufferCongestionMark[n]",
      RegMem => "RegField",
      Description => "Fill level of VOQ in buffers selects between the 8 values for a given {Profile,BufferAvailableLevel} pair.
The MSB is mark indication in case of most full.
The LSB is mark indication in case of most empty.",
      Width => "8",
      Position => "7:0", # Excel Formula: =calc_position(F93,E94,TRUE)
      Type => "Config",
      UsedBy => "CGM_deq",
      DefaultValue => "h0",
    },
  },
  BuffersConsumptionLutForDeq21 => { #Structure Type: Reg; ArrayLength: 128; ArrayIndex: 21; ArrayLocationInName: 28;
    Name => "BuffersConsumptionLutForDeq[128]",
    RegMem => "Reg",
    Address => "146",
    Description => "LUT for dequeue marking in VOQ-CGM based on Buffer Consumption.
Index in Array is {Profile,BufferAvailableLevel}
Profile is 5 bits
BufferAvailableLevel is quantized to 2 bits.",
    Width => "8", # Excel Formula: =calc_reg_width(E94:E94,F94)
    Type => "Config",
    AdditionalInfo => "PackArrayToBus",
    Comments => "VOQ_CGM
CGM Deq Marking logic implemented in FF.
Address is {VOQ_PROFILE,Buffer_pool_available_level}
5 + 2 = 7
Buffer_voq_size_level selects offset out of 8.",
    ArrayLength => "128",
    ArrayIndex => "21",
    DeqBufferCongestionMark21 => { #Structure Type: RegField; ArrayLength: 128; ArrayIndex: 21; ArrayLocationInName: 24;
      Name => "DeqBufferCongestionMark[n]",
      RegMem => "RegField",
      Description => "Fill level of VOQ in buffers selects between the 8 values for a given {Profile,BufferAvailableLevel} pair.
The MSB is mark indication in case of most full.
The LSB is mark indication in case of most empty.",
      Width => "8",
      Position => "7:0", # Excel Formula: =calc_position(F93,E94,TRUE)
      Type => "Config",
      UsedBy => "CGM_deq",
      DefaultValue => "h0",
    },
  },
  BuffersConsumptionLutForDeq22 => { #Structure Type: Reg; ArrayLength: 128; ArrayIndex: 22; ArrayLocationInName: 28;
    Name => "BuffersConsumptionLutForDeq[128]",
    RegMem => "Reg",
    Address => "147",
    Description => "LUT for dequeue marking in VOQ-CGM based on Buffer Consumption.
Index in Array is {Profile,BufferAvailableLevel}
Profile is 5 bits
BufferAvailableLevel is quantized to 2 bits.",
    Width => "8", # Excel Formula: =calc_reg_width(E94:E94,F94)
    Type => "Config",
    AdditionalInfo => "PackArrayToBus",
    Comments => "VOQ_CGM
CGM Deq Marking logic implemented in FF.
Address is {VOQ_PROFILE,Buffer_pool_available_level}
5 + 2 = 7
Buffer_voq_size_level selects offset out of 8.",
    ArrayLength => "128",
    ArrayIndex => "22",
    DeqBufferCongestionMark22 => { #Structure Type: RegField; ArrayLength: 128; ArrayIndex: 22; ArrayLocationInName: 24;
      Name => "DeqBufferCongestionMark[n]",
      RegMem => "RegField",
      Description => "Fill level of VOQ in buffers selects between the 8 values for a given {Profile,BufferAvailableLevel} pair.
The MSB is mark indication in case of most full.
The LSB is mark indication in case of most empty.",
      Width => "8",
      Position => "7:0", # Excel Formula: =calc_position(F93,E94,TRUE)
      Type => "Config",
      UsedBy => "CGM_deq",
      DefaultValue => "h0",
    },
  },
  BuffersConsumptionLutForDeq23 => { #Structure Type: Reg; ArrayLength: 128; ArrayIndex: 23; ArrayLocationInName: 28;
    Name => "BuffersConsumptionLutForDeq[128]",
    RegMem => "Reg",
    Address => "148",
    Description => "LUT for dequeue marking in VOQ-CGM based on Buffer Consumption.
Index in Array is {Profile,BufferAvailableLevel}
Profile is 5 bits
BufferAvailableLevel is quantized to 2 bits.",
    Width => "8", # Excel Formula: =calc_reg_width(E94:E94,F94)
    Type => "Config",
    AdditionalInfo => "PackArrayToBus",
    Comments => "VOQ_CGM
CGM Deq Marking logic implemented in FF.
Address is {VOQ_PROFILE,Buffer_pool_available_level}
5 + 2 = 7
Buffer_voq_size_level selects offset out of 8.",
    ArrayLength => "128",
    ArrayIndex => "23",
    DeqBufferCongestionMark23 => { #Structure Type: RegField; ArrayLength: 128; ArrayIndex: 23; ArrayLocationInName: 24;
      Name => "DeqBufferCongestionMark[n]",
      RegMem => "RegField",
      Description => "Fill level of VOQ in buffers selects between the 8 values for a given {Profile,BufferAvailableLevel} pair.
The MSB is mark indication in case of most full.
The LSB is mark indication in case of most empty.",
      Width => "8",
      Position => "7:0", # Excel Formula: =calc_position(F93,E94,TRUE)
      Type => "Config",
      UsedBy => "CGM_deq",
      DefaultValue => "h0",
    },
  },
  BuffersConsumptionLutForDeq24 => { #Structure Type: Reg; ArrayLength: 128; ArrayIndex: 24; ArrayLocationInName: 28;
    Name => "BuffersConsumptionLutForDeq[128]",
    RegMem => "Reg",
    Address => "149",
    Description => "LUT for dequeue marking in VOQ-CGM based on Buffer Consumption.
Index in Array is {Profile,BufferAvailableLevel}
Profile is 5 bits
BufferAvailableLevel is quantized to 2 bits.",
    Width => "8", # Excel Formula: =calc_reg_width(E94:E94,F94)
    Type => "Config",
    AdditionalInfo => "PackArrayToBus",
    Comments => "VOQ_CGM
CGM Deq Marking logic implemented in FF.
Address is {VOQ_PROFILE,Buffer_pool_available_level}
5 + 2 = 7
Buffer_voq_size_level selects offset out of 8.",
    ArrayLength => "128",
    ArrayIndex => "24",
    DeqBufferCongestionMark24 => { #Structure Type: RegField; ArrayLength: 128; ArrayIndex: 24; ArrayLocationInName: 24;
      Name => "DeqBufferCongestionMark[n]",
      RegMem => "RegField",
      Description => "Fill level of VOQ in buffers selects between the 8 values for a given {Profile,BufferAvailableLevel} pair.
The MSB is mark indication in case of most full.
The LSB is mark indication in case of most empty.",
      Width => "8",
      Position => "7:0", # Excel Formula: =calc_position(F93,E94,TRUE)
      Type => "Config",
      UsedBy => "CGM_deq",
      DefaultValue => "h0",
    },
  },
  BuffersConsumptionLutForDeq25 => { #Structure Type: Reg; ArrayLength: 128; ArrayIndex: 25; ArrayLocationInName: 28;
    Name => "BuffersConsumptionLutForDeq[128]",
    RegMem => "Reg",
    Address => "14A",
    Description => "LUT for dequeue marking in VOQ-CGM based on Buffer Consumption.
Index in Array is {Profile,BufferAvailableLevel}
Profile is 5 bits
BufferAvailableLevel is quantized to 2 bits.",
    Width => "8", # Excel Formula: =calc_reg_width(E94:E94,F94)
    Type => "Config",
    AdditionalInfo => "PackArrayToBus",
    Comments => "VOQ_CGM
CGM Deq Marking logic implemented in FF.
Address is {VOQ_PROFILE,Buffer_pool_available_level}
5 + 2 = 7
Buffer_voq_size_level selects offset out of 8.",
    ArrayLength => "128",
    ArrayIndex => "25",
    DeqBufferCongestionMark25 => { #Structure Type: RegField; ArrayLength: 128; ArrayIndex: 25; ArrayLocationInName: 24;
      Name => "DeqBufferCongestionMark[n]",
      RegMem => "RegField",
      Description => "Fill level of VOQ in buffers selects between the 8 values for a given {Profile,BufferAvailableLevel} pair.
The MSB is mark indication in case of most full.
The LSB is mark indication in case of most empty.",
      Width => "8",
      Position => "7:0", # Excel Formula: =calc_position(F93,E94,TRUE)
      Type => "Config",
      UsedBy => "CGM_deq",
      DefaultValue => "h0",
    },
  },
  BuffersConsumptionLutForDeq26 => { #Structure Type: Reg; ArrayLength: 128; ArrayIndex: 26; ArrayLocationInName: 28;
    Name => "BuffersConsumptionLutForDeq[128]",
    RegMem => "Reg",
    Address => "14B",
    Description => "LUT for dequeue marking in VOQ-CGM based on Buffer Consumption.
Index in Array is {Profile,BufferAvailableLevel}
Profile is 5 bits
BufferAvailableLevel is quantized to 2 bits.",
    Width => "8", # Excel Formula: =calc_reg_width(E94:E94,F94)
    Type => "Config",
    AdditionalInfo => "PackArrayToBus",
    Comments => "VOQ_CGM
CGM Deq Marking logic implemented in FF.
Address is {VOQ_PROFILE,Buffer_pool_available_level}
5 + 2 = 7
Buffer_voq_size_level selects offset out of 8.",
    ArrayLength => "128",
    ArrayIndex => "26",
    DeqBufferCongestionMark26 => { #Structure Type: RegField; ArrayLength: 128; ArrayIndex: 26; ArrayLocationInName: 24;
      Name => "DeqBufferCongestionMark[n]",
      RegMem => "RegField",
      Description => "Fill level of VOQ in buffers selects between the 8 values for a given {Profile,BufferAvailableLevel} pair.
The MSB is mark indication in case of most full.
The LSB is mark indication in case of most empty.",
      Width => "8",
      Position => "7:0", # Excel Formula: =calc_position(F93,E94,TRUE)
      Type => "Config",
      UsedBy => "CGM_deq",
      DefaultValue => "h0",
    },
  },
  BuffersConsumptionLutForDeq27 => { #Structure Type: Reg; ArrayLength: 128; ArrayIndex: 27; ArrayLocationInName: 28;
    Name => "BuffersConsumptionLutForDeq[128]",
    RegMem => "Reg",
    Address => "14C",
    Description => "LUT for dequeue marking in VOQ-CGM based on Buffer Consumption.
Index in Array is {Profile,BufferAvailableLevel}
Profile is 5 bits
BufferAvailableLevel is quantized to 2 bits.",
    Width => "8", # Excel Formula: =calc_reg_width(E94:E94,F94)
    Type => "Config",
    AdditionalInfo => "PackArrayToBus",
    Comments => "VOQ_CGM
CGM Deq Marking logic implemented in FF.
Address is {VOQ_PROFILE,Buffer_pool_available_level}
5 + 2 = 7
Buffer_voq_size_level selects offset out of 8.",
    ArrayLength => "128",
    ArrayIndex => "27",
    DeqBufferCongestionMark27 => { #Structure Type: RegField; ArrayLength: 128; ArrayIndex: 27; ArrayLocationInName: 24;
      Name => "DeqBufferCongestionMark[n]",
      RegMem => "RegField",
      Description => "Fill level of VOQ in buffers selects between the 8 values for a given {Profile,BufferAvailableLevel} pair.
The MSB is mark indication in case of most full.
The LSB is mark indication in case of most empty.",
      Width => "8",
      Position => "7:0", # Excel Formula: =calc_position(F93,E94,TRUE)
      Type => "Config",
      UsedBy => "CGM_deq",
      DefaultValue => "h0",
    },
  },
  BuffersConsumptionLutForDeq28 => { #Structure Type: Reg; ArrayLength: 128; ArrayIndex: 28; ArrayLocationInName: 28;
    Name => "BuffersConsumptionLutForDeq[128]",
    RegMem => "Reg",
    Address => "14D",
    Description => "LUT for dequeue marking in VOQ-CGM based on Buffer Consumption.
Index in Array is {Profile,BufferAvailableLevel}
Profile is 5 bits
BufferAvailableLevel is quantized to 2 bits.",
    Width => "8", # Excel Formula: =calc_reg_width(E94:E94,F94)
    Type => "Config",
    AdditionalInfo => "PackArrayToBus",
    Comments => "VOQ_CGM
CGM Deq Marking logic implemented in FF.
Address is {VOQ_PROFILE,Buffer_pool_available_level}
5 + 2 = 7
Buffer_voq_size_level selects offset out of 8.",
    ArrayLength => "128",
    ArrayIndex => "28",
    DeqBufferCongestionMark28 => { #Structure Type: RegField; ArrayLength: 128; ArrayIndex: 28; ArrayLocationInName: 24;
      Name => "DeqBufferCongestionMark[n]",
      RegMem => "RegField",
      Description => "Fill level of VOQ in buffers selects between the 8 values for a given {Profile,BufferAvailableLevel} pair.
The MSB is mark indication in case of most full.
The LSB is mark indication in case of most empty.",
      Width => "8",
      Position => "7:0", # Excel Formula: =calc_position(F93,E94,TRUE)
      Type => "Config",
      UsedBy => "CGM_deq",
      DefaultValue => "h0",
    },
  },
  BuffersConsumptionLutForDeq29 => { #Structure Type: Reg; ArrayLength: 128; ArrayIndex: 29; ArrayLocationInName: 28;
    Name => "BuffersConsumptionLutForDeq[128]",
    RegMem => "Reg",
    Address => "14E",
    Description => "LUT for dequeue marking in VOQ-CGM based on Buffer Consumption.
Index in Array is {Profile,BufferAvailableLevel}
Profile is 5 bits
BufferAvailableLevel is quantized to 2 bits.",
    Width => "8", # Excel Formula: =calc_reg_width(E94:E94,F94)
    Type => "Config",
    AdditionalInfo => "PackArrayToBus",
    Comments => "VOQ_CGM
CGM Deq Marking logic implemented in FF.
Address is {VOQ_PROFILE,Buffer_pool_available_level}
5 + 2 = 7
Buffer_voq_size_level selects offset out of 8.",
    ArrayLength => "128",
    ArrayIndex => "29",
    DeqBufferCongestionMark29 => { #Structure Type: RegField; ArrayLength: 128; ArrayIndex: 29; ArrayLocationInName: 24;
      Name => "DeqBufferCongestionMark[n]",
      RegMem => "RegField",
      Description => "Fill level of VOQ in buffers selects between the 8 values for a given {Profile,BufferAvailableLevel} pair.
The MSB is mark indication in case of most full.
The LSB is mark indication in case of most empty.",
      Width => "8",
      Position => "7:0", # Excel Formula: =calc_position(F93,E94,TRUE)
      Type => "Config",
      UsedBy => "CGM_deq",
      DefaultValue => "h0",
    },
  },
  BuffersConsumptionLutForDeq30 => { #Structure Type: Reg; ArrayLength: 128; ArrayIndex: 30; ArrayLocationInName: 28;
    Name => "BuffersConsumptionLutForDeq[128]",
    RegMem => "Reg",
    Address => "14F",
    Description => "LUT for dequeue marking in VOQ-CGM based on Buffer Consumption.
Index in Array is {Profile,BufferAvailableLevel}
Profile is 5 bits
BufferAvailableLevel is quantized to 2 bits.",
    Width => "8", # Excel Formula: =calc_reg_width(E94:E94,F94)
    Type => "Config",
    AdditionalInfo => "PackArrayToBus",
    Comments => "VOQ_CGM
CGM Deq Marking logic implemented in FF.
Address is {VOQ_PROFILE,Buffer_pool_available_level}
5 + 2 = 7
Buffer_voq_size_level selects offset out of 8.",
    ArrayLength => "128",
    ArrayIndex => "30",
    DeqBufferCongestionMark30 => { #Structure Type: RegField; ArrayLength: 128; ArrayIndex: 30; ArrayLocationInName: 24;
      Name => "DeqBufferCongestionMark[n]",
      RegMem => "RegField",
      Description => "Fill level of VOQ in buffers selects between the 8 values for a given {Profile,BufferAvailableLevel} pair.
The MSB is mark indication in case of most full.
The LSB is mark indication in case of most empty.",
      Width => "8",
      Position => "7:0", # Excel Formula: =calc_position(F93,E94,TRUE)
      Type => "Config",
      UsedBy => "CGM_deq",
      DefaultValue => "h0",
    },
  },
  BuffersConsumptionLutForDeq31 => { #Structure Type: Reg; ArrayLength: 128; ArrayIndex: 31; ArrayLocationInName: 28;
    Name => "BuffersConsumptionLutForDeq[128]",
    RegMem => "Reg",
    Address => "150",
    Description => "LUT for dequeue marking in VOQ-CGM based on Buffer Consumption.
Index in Array is {Profile,BufferAvailableLevel}
Profile is 5 bits
BufferAvailableLevel is quantized to 2 bits.",
    Width => "8", # Excel Formula: =calc_reg_width(E94:E94,F94)
    Type => "Config",
    AdditionalInfo => "PackArrayToBus",
    Comments => "VOQ_CGM
CGM Deq Marking logic implemented in FF.
Address is {VOQ_PROFILE,Buffer_pool_available_level}
5 + 2 = 7
Buffer_voq_size_level selects offset out of 8.",
    ArrayLength => "128",
    ArrayIndex => "31",
    DeqBufferCongestionMark31 => { #Structure Type: RegField; ArrayLength: 128; ArrayIndex: 31; ArrayLocationInName: 24;
      Name => "DeqBufferCongestionMark[n]",
      RegMem => "RegField",
      Description => "Fill level of VOQ in buffers selects between the 8 values for a given {Profile,BufferAvailableLevel} pair.
The MSB is mark indication in case of most full.
The LSB is mark indication in case of most empty.",
      Width => "8",
      Position => "7:0", # Excel Formula: =calc_position(F93,E94,TRUE)
      Type => "Config",
      UsedBy => "CGM_deq",
      DefaultValue => "h0",
    },
  },
  BuffersConsumptionLutForDeq32 => { #Structure Type: Reg; ArrayLength: 128; ArrayIndex: 32; ArrayLocationInName: 28;
    Name => "BuffersConsumptionLutForDeq[128]",
    RegMem => "Reg",
    Address => "151",
    Description => "LUT for dequeue marking in VOQ-CGM based on Buffer Consumption.
Index in Array is {Profile,BufferAvailableLevel}
Profile is 5 bits
BufferAvailableLevel is quantized to 2 bits.",
    Width => "8", # Excel Formula: =calc_reg_width(E94:E94,F94)
    Type => "Config",
    AdditionalInfo => "PackArrayToBus",
    Comments => "VOQ_CGM
CGM Deq Marking logic implemented in FF.
Address is {VOQ_PROFILE,Buffer_pool_available_level}
5 + 2 = 7
Buffer_voq_size_level selects offset out of 8.",
    ArrayLength => "128",
    ArrayIndex => "32",
    DeqBufferCongestionMark32 => { #Structure Type: RegField; ArrayLength: 128; ArrayIndex: 32; ArrayLocationInName: 24;
      Name => "DeqBufferCongestionMark[n]",
      RegMem => "RegField",
      Description => "Fill level of VOQ in buffers selects between the 8 values for a given {Profile,BufferAvailableLevel} pair.
The MSB is mark indication in case of most full.
The LSB is mark indication in case of most empty.",
      Width => "8",
      Position => "7:0", # Excel Formula: =calc_position(F93,E94,TRUE)
      Type => "Config",
      UsedBy => "CGM_deq",
      DefaultValue => "h0",
    },
  },
  BuffersConsumptionLutForDeq33 => { #Structure Type: Reg; ArrayLength: 128; ArrayIndex: 33; ArrayLocationInName: 28;
    Name => "BuffersConsumptionLutForDeq[128]",
    RegMem => "Reg",
    Address => "152",
    Description => "LUT for dequeue marking in VOQ-CGM based on Buffer Consumption.
Index in Array is {Profile,BufferAvailableLevel}
Profile is 5 bits
BufferAvailableLevel is quantized to 2 bits.",
    Width => "8", # Excel Formula: =calc_reg_width(E94:E94,F94)
    Type => "Config",
    AdditionalInfo => "PackArrayToBus",
    Comments => "VOQ_CGM
CGM Deq Marking logic implemented in FF.
Address is {VOQ_PROFILE,Buffer_pool_available_level}
5 + 2 = 7
Buffer_voq_size_level selects offset out of 8.",
    ArrayLength => "128",
    ArrayIndex => "33",
    DeqBufferCongestionMark33 => { #Structure Type: RegField; ArrayLength: 128; ArrayIndex: 33; ArrayLocationInName: 24;
      Name => "DeqBufferCongestionMark[n]",
      RegMem => "RegField",
      Description => "Fill level of VOQ in buffers selects between the 8 values for a given {Profile,BufferAvailableLevel} pair.
The MSB is mark indication in case of most full.
The LSB is mark indication in case of most empty.",
      Width => "8",
      Position => "7:0", # Excel Formula: =calc_position(F93,E94,TRUE)
      Type => "Config",
      UsedBy => "CGM_deq",
      DefaultValue => "h0",
    },
  },
  BuffersConsumptionLutForDeq34 => { #Structure Type: Reg; ArrayLength: 128; ArrayIndex: 34; ArrayLocationInName: 28;
    Name => "BuffersConsumptionLutForDeq[128]",
    RegMem => "Reg",
    Address => "153",
    Description => "LUT for dequeue marking in VOQ-CGM based on Buffer Consumption.
Index in Array is {Profile,BufferAvailableLevel}
Profile is 5 bits
BufferAvailableLevel is quantized to 2 bits.",
    Width => "8", # Excel Formula: =calc_reg_width(E94:E94,F94)
    Type => "Config",
    AdditionalInfo => "PackArrayToBus",
    Comments => "VOQ_CGM
CGM Deq Marking logic implemented in FF.
Address is {VOQ_PROFILE,Buffer_pool_available_level}
5 + 2 = 7
Buffer_voq_size_level selects offset out of 8.",
    ArrayLength => "128",
    ArrayIndex => "34",
    DeqBufferCongestionMark34 => { #Structure Type: RegField; ArrayLength: 128; ArrayIndex: 34; ArrayLocationInName: 24;
      Name => "DeqBufferCongestionMark[n]",
      RegMem => "RegField",
      Description => "Fill level of VOQ in buffers selects between the 8 values for a given {Profile,BufferAvailableLevel} pair.
The MSB is mark indication in case of most full.
The LSB is mark indication in case of most empty.",
      Width => "8",
      Position => "7:0", # Excel Formula: =calc_position(F93,E94,TRUE)
      Type => "Config",
      UsedBy => "CGM_deq",
      DefaultValue => "h0",
    },
  },
  BuffersConsumptionLutForDeq35 => { #Structure Type: Reg; ArrayLength: 128; ArrayIndex: 35; ArrayLocationInName: 28;
    Name => "BuffersConsumptionLutForDeq[128]",
    RegMem => "Reg",
    Address => "154",
    Description => "LUT for dequeue marking in VOQ-CGM based on Buffer Consumption.
Index in Array is {Profile,BufferAvailableLevel}
Profile is 5 bits
BufferAvailableLevel is quantized to 2 bits.",
    Width => "8", # Excel Formula: =calc_reg_width(E94:E94,F94)
    Type => "Config",
    AdditionalInfo => "PackArrayToBus",
    Comments => "VOQ_CGM
CGM Deq Marking logic implemented in FF.
Address is {VOQ_PROFILE,Buffer_pool_available_level}
5 + 2 = 7
Buffer_voq_size_level selects offset out of 8.",
    ArrayLength => "128",
    ArrayIndex => "35",
    DeqBufferCongestionMark35 => { #Structure Type: RegField; ArrayLength: 128; ArrayIndex: 35; ArrayLocationInName: 24;
      Name => "DeqBufferCongestionMark[n]",
      RegMem => "RegField",
      Description => "Fill level of VOQ in buffers selects between the 8 values for a given {Profile,BufferAvailableLevel} pair.
The MSB is mark indication in case of most full.
The LSB is mark indication in case of most empty.",
      Width => "8",
      Position => "7:0", # Excel Formula: =calc_position(F93,E94,TRUE)
      Type => "Config",
      UsedBy => "CGM_deq",
      DefaultValue => "h0",
    },
  },
  BuffersConsumptionLutForDeq36 => { #Structure Type: Reg; ArrayLength: 128; ArrayIndex: 36; ArrayLocationInName: 28;
    Name => "BuffersConsumptionLutForDeq[128]",
    RegMem => "Reg",
    Address => "155",
    Description => "LUT for dequeue marking in VOQ-CGM based on Buffer Consumption.
Index in Array is {Profile,BufferAvailableLevel}
Profile is 5 bits
BufferAvailableLevel is quantized to 2 bits.",
    Width => "8", # Excel Formula: =calc_reg_width(E94:E94,F94)
    Type => "Config",
    AdditionalInfo => "PackArrayToBus",
    Comments => "VOQ_CGM
CGM Deq Marking logic implemented in FF.
Address is {VOQ_PROFILE,Buffer_pool_available_level}
5 + 2 = 7
Buffer_voq_size_level selects offset out of 8.",
    ArrayLength => "128",
    ArrayIndex => "36",
    DeqBufferCongestionMark36 => { #Structure Type: RegField; ArrayLength: 128; ArrayIndex: 36; ArrayLocationInName: 24;
      Name => "DeqBufferCongestionMark[n]",
      RegMem => "RegField",
      Description => "Fill level of VOQ in buffers selects between the 8 values for a given {Profile,BufferAvailableLevel} pair.
The MSB is mark indication in case of most full.
The LSB is mark indication in case of most empty.",
      Width => "8",
      Position => "7:0", # Excel Formula: =calc_position(F93,E94,TRUE)
      Type => "Config",
      UsedBy => "CGM_deq",
      DefaultValue => "h0",
    },
  },
  BuffersConsumptionLutForDeq37 => { #Structure Type: Reg; ArrayLength: 128; ArrayIndex: 37; ArrayLocationInName: 28;
    Name => "BuffersConsumptionLutForDeq[128]",
    RegMem => "Reg",
    Address => "156",
    Description => "LUT for dequeue marking in VOQ-CGM based on Buffer Consumption.
Index in Array is {Profile,BufferAvailableLevel}
Profile is 5 bits
BufferAvailableLevel is quantized to 2 bits.",
    Width => "8", # Excel Formula: =calc_reg_width(E94:E94,F94)
    Type => "Config",
    AdditionalInfo => "PackArrayToBus",
    Comments => "VOQ_CGM
CGM Deq Marking logic implemented in FF.
Address is {VOQ_PROFILE,Buffer_pool_available_level}
5 + 2 = 7
Buffer_voq_size_level selects offset out of 8.",
    ArrayLength => "128",
    ArrayIndex => "37",
    DeqBufferCongestionMark37 => { #Structure Type: RegField; ArrayLength: 128; ArrayIndex: 37; ArrayLocationInName: 24;
      Name => "DeqBufferCongestionMark[n]",
      RegMem => "RegField",
      Description => "Fill level of VOQ in buffers selects between the 8 values for a given {Profile,BufferAvailableLevel} pair.
The MSB is mark indication in case of most full.
The LSB is mark indication in case of most empty.",
      Width => "8",
      Position => "7:0", # Excel Formula: =calc_position(F93,E94,TRUE)
      Type => "Config",
      UsedBy => "CGM_deq",
      DefaultValue => "h0",
    },
  },
  BuffersConsumptionLutForDeq38 => { #Structure Type: Reg; ArrayLength: 128; ArrayIndex: 38; ArrayLocationInName: 28;
    Name => "BuffersConsumptionLutForDeq[128]",
    RegMem => "Reg",
    Address => "157",
    Description => "LUT for dequeue marking in VOQ-CGM based on Buffer Consumption.
Index in Array is {Profile,BufferAvailableLevel}
Profile is 5 bits
BufferAvailableLevel is quantized to 2 bits.",
    Width => "8", # Excel Formula: =calc_reg_width(E94:E94,F94)
    Type => "Config",
    AdditionalInfo => "PackArrayToBus",
    Comments => "VOQ_CGM
CGM Deq Marking logic implemented in FF.
Address is {VOQ_PROFILE,Buffer_pool_available_level}
5 + 2 = 7
Buffer_voq_size_level selects offset out of 8.",
    ArrayLength => "128",
    ArrayIndex => "38",
    DeqBufferCongestionMark38 => { #Structure Type: RegField; ArrayLength: 128; ArrayIndex: 38; ArrayLocationInName: 24;
      Name => "DeqBufferCongestionMark[n]",
      RegMem => "RegField",
      Description => "Fill level of VOQ in buffers selects between the 8 values for a given {Profile,BufferAvailableLevel} pair.
The MSB is mark indication in case of most full.
The LSB is mark indication in case of most empty.",
      Width => "8",
      Position => "7:0", # Excel Formula: =calc_position(F93,E94,TRUE)
      Type => "Config",
      UsedBy => "CGM_deq",
      DefaultValue => "h0",
    },
  },
  BuffersConsumptionLutForDeq39 => { #Structure Type: Reg; ArrayLength: 128; ArrayIndex: 39; ArrayLocationInName: 28;
    Name => "BuffersConsumptionLutForDeq[128]",
    RegMem => "Reg",
    Address => "158",
    Description => "LUT for dequeue marking in VOQ-CGM based on Buffer Consumption.
Index in Array is {Profile,BufferAvailableLevel}
Profile is 5 bits
BufferAvailableLevel is quantized to 2 bits.",
    Width => "8", # Excel Formula: =calc_reg_width(E94:E94,F94)
    Type => "Config",
    AdditionalInfo => "PackArrayToBus",
    Comments => "VOQ_CGM
CGM Deq Marking logic implemented in FF.
Address is {VOQ_PROFILE,Buffer_pool_available_level}
5 + 2 = 7
Buffer_voq_size_level selects offset out of 8.",
    ArrayLength => "128",
    ArrayIndex => "39",
    DeqBufferCongestionMark39 => { #Structure Type: RegField; ArrayLength: 128; ArrayIndex: 39; ArrayLocationInName: 24;
      Name => "DeqBufferCongestionMark[n]",
      RegMem => "RegField",
      Description => "Fill level of VOQ in buffers selects between the 8 values for a given {Profile,BufferAvailableLevel} pair.
The MSB is mark indication in case of most full.
The LSB is mark indication in case of most empty.",
      Width => "8",
      Position => "7:0", # Excel Formula: =calc_position(F93,E94,TRUE)
      Type => "Config",
      UsedBy => "CGM_deq",
      DefaultValue => "h0",
    },
  },
  BuffersConsumptionLutForDeq40 => { #Structure Type: Reg; ArrayLength: 128; ArrayIndex: 40; ArrayLocationInName: 28;
    Name => "BuffersConsumptionLutForDeq[128]",
    RegMem => "Reg",
    Address => "159",
    Description => "LUT for dequeue marking in VOQ-CGM based on Buffer Consumption.
Index in Array is {Profile,BufferAvailableLevel}
Profile is 5 bits
BufferAvailableLevel is quantized to 2 bits.",
    Width => "8", # Excel Formula: =calc_reg_width(E94:E94,F94)
    Type => "Config",
    AdditionalInfo => "PackArrayToBus",
    Comments => "VOQ_CGM
CGM Deq Marking logic implemented in FF.
Address is {VOQ_PROFILE,Buffer_pool_available_level}
5 + 2 = 7
Buffer_voq_size_level selects offset out of 8.",
    ArrayLength => "128",
    ArrayIndex => "40",
    DeqBufferCongestionMark40 => { #Structure Type: RegField; ArrayLength: 128; ArrayIndex: 40; ArrayLocationInName: 24;
      Name => "DeqBufferCongestionMark[n]",
      RegMem => "RegField",
      Description => "Fill level of VOQ in buffers selects between the 8 values for a given {Profile,BufferAvailableLevel} pair.
The MSB is mark indication in case of most full.
The LSB is mark indication in case of most empty.",
      Width => "8",
      Position => "7:0", # Excel Formula: =calc_position(F93,E94,TRUE)
      Type => "Config",
      UsedBy => "CGM_deq",
      DefaultValue => "h0",
    },
  },
  BuffersConsumptionLutForDeq41 => { #Structure Type: Reg; ArrayLength: 128; ArrayIndex: 41; ArrayLocationInName: 28;
    Name => "BuffersConsumptionLutForDeq[128]",
    RegMem => "Reg",
    Address => "15A",
    Description => "LUT for dequeue marking in VOQ-CGM based on Buffer Consumption.
Index in Array is {Profile,BufferAvailableLevel}
Profile is 5 bits
BufferAvailableLevel is quantized to 2 bits.",
    Width => "8", # Excel Formula: =calc_reg_width(E94:E94,F94)
    Type => "Config",
    AdditionalInfo => "PackArrayToBus",
    Comments => "VOQ_CGM
CGM Deq Marking logic implemented in FF.
Address is {VOQ_PROFILE,Buffer_pool_available_level}
5 + 2 = 7
Buffer_voq_size_level selects offset out of 8.",
    ArrayLength => "128",
    ArrayIndex => "41",
    DeqBufferCongestionMark41 => { #Structure Type: RegField; ArrayLength: 128; ArrayIndex: 41; ArrayLocationInName: 24;
      Name => "DeqBufferCongestionMark[n]",
      RegMem => "RegField",
      Description => "Fill level of VOQ in buffers selects between the 8 values for a given {Profile,BufferAvailableLevel} pair.
The MSB is mark indication in case of most full.
The LSB is mark indication in case of most empty.",
      Width => "8",
      Position => "7:0", # Excel Formula: =calc_position(F93,E94,TRUE)
      Type => "Config",
      UsedBy => "CGM_deq",
      DefaultValue => "h0",
    },
  },
  BuffersConsumptionLutForDeq42 => { #Structure Type: Reg; ArrayLength: 128; ArrayIndex: 42; ArrayLocationInName: 28;
    Name => "BuffersConsumptionLutForDeq[128]",
    RegMem => "Reg",
    Address => "15B",
    Description => "LUT for dequeue marking in VOQ-CGM based on Buffer Consumption.
Index in Array is {Profile,BufferAvailableLevel}
Profile is 5 bits
BufferAvailableLevel is quantized to 2 bits.",
    Width => "8", # Excel Formula: =calc_reg_width(E94:E94,F94)
    Type => "Config",
    AdditionalInfo => "PackArrayToBus",
    Comments => "VOQ_CGM
CGM Deq Marking logic implemented in FF.
Address is {VOQ_PROFILE,Buffer_pool_available_level}
5 + 2 = 7
Buffer_voq_size_level selects offset out of 8.",
    ArrayLength => "128",
    ArrayIndex => "42",
    DeqBufferCongestionMark42 => { #Structure Type: RegField; ArrayLength: 128; ArrayIndex: 42; ArrayLocationInName: 24;
      Name => "DeqBufferCongestionMark[n]",
      RegMem => "RegField",
      Description => "Fill level of VOQ in buffers selects between the 8 values for a given {Profile,BufferAvailableLevel} pair.
The MSB is mark indication in case of most full.
The LSB is mark indication in case of most empty.",
      Width => "8",
      Position => "7:0", # Excel Formula: =calc_position(F93,E94,TRUE)
      Type => "Config",
      UsedBy => "CGM_deq",
      DefaultValue => "h0",
    },
  },
  BuffersConsumptionLutForDeq43 => { #Structure Type: Reg; ArrayLength: 128; ArrayIndex: 43; ArrayLocationInName: 28;
    Name => "BuffersConsumptionLutForDeq[128]",
    RegMem => "Reg",
    Address => "15C",
    Description => "LUT for dequeue marking in VOQ-CGM based on Buffer Consumption.
Index in Array is {Profile,BufferAvailableLevel}
Profile is 5 bits
BufferAvailableLevel is quantized to 2 bits.",
    Width => "8", # Excel Formula: =calc_reg_width(E94:E94,F94)
    Type => "Config",
    AdditionalInfo => "PackArrayToBus",
    Comments => "VOQ_CGM
CGM Deq Marking logic implemented in FF.
Address is {VOQ_PROFILE,Buffer_pool_available_level}
5 + 2 = 7
Buffer_voq_size_level selects offset out of 8.",
    ArrayLength => "128",
    ArrayIndex => "43",
    DeqBufferCongestionMark43 => { #Structure Type: RegField; ArrayLength: 128; ArrayIndex: 43; ArrayLocationInName: 24;
      Name => "DeqBufferCongestionMark[n]",
      RegMem => "RegField",
      Description => "Fill level of VOQ in buffers selects between the 8 values for a given {Profile,BufferAvailableLevel} pair.
The MSB is mark indication in case of most full.
The LSB is mark indication in case of most empty.",
      Width => "8",
      Position => "7:0", # Excel Formula: =calc_position(F93,E94,TRUE)
      Type => "Config",
      UsedBy => "CGM_deq",
      DefaultValue => "h0",
    },
  },
  BuffersConsumptionLutForDeq44 => { #Structure Type: Reg; ArrayLength: 128; ArrayIndex: 44; ArrayLocationInName: 28;
    Name => "BuffersConsumptionLutForDeq[128]",
    RegMem => "Reg",
    Address => "15D",
    Description => "LUT for dequeue marking in VOQ-CGM based on Buffer Consumption.
Index in Array is {Profile,BufferAvailableLevel}
Profile is 5 bits
BufferAvailableLevel is quantized to 2 bits.",
    Width => "8", # Excel Formula: =calc_reg_width(E94:E94,F94)
    Type => "Config",
    AdditionalInfo => "PackArrayToBus",
    Comments => "VOQ_CGM
CGM Deq Marking logic implemented in FF.
Address is {VOQ_PROFILE,Buffer_pool_available_level}
5 + 2 = 7
Buffer_voq_size_level selects offset out of 8.",
    ArrayLength => "128",
    ArrayIndex => "44",
    DeqBufferCongestionMark44 => { #Structure Type: RegField; ArrayLength: 128; ArrayIndex: 44; ArrayLocationInName: 24;
      Name => "DeqBufferCongestionMark[n]",
      RegMem => "RegField",
      Description => "Fill level of VOQ in buffers selects between the 8 values for a given {Profile,BufferAvailableLevel} pair.
The MSB is mark indication in case of most full.
The LSB is mark indication in case of most empty.",
      Width => "8",
      Position => "7:0", # Excel Formula: =calc_position(F93,E94,TRUE)
      Type => "Config",
      UsedBy => "CGM_deq",
      DefaultValue => "h0",
    },
  },
  BuffersConsumptionLutForDeq45 => { #Structure Type: Reg; ArrayLength: 128; ArrayIndex: 45; ArrayLocationInName: 28;
    Name => "BuffersConsumptionLutForDeq[128]",
    RegMem => "Reg",
    Address => "15E",
    Description => "LUT for dequeue marking in VOQ-CGM based on Buffer Consumption.
Index in Array is {Profile,BufferAvailableLevel}
Profile is 5 bits
BufferAvailableLevel is quantized to 2 bits.",
    Width => "8", # Excel Formula: =calc_reg_width(E94:E94,F94)
    Type => "Config",
    AdditionalInfo => "PackArrayToBus",
    Comments => "VOQ_CGM
CGM Deq Marking logic implemented in FF.
Address is {VOQ_PROFILE,Buffer_pool_available_level}
5 + 2 = 7
Buffer_voq_size_level selects offset out of 8.",
    ArrayLength => "128",
    ArrayIndex => "45",
    DeqBufferCongestionMark45 => { #Structure Type: RegField; ArrayLength: 128; ArrayIndex: 45; ArrayLocationInName: 24;
      Name => "DeqBufferCongestionMark[n]",
      RegMem => "RegField",
      Description => "Fill level of VOQ in buffers selects between the 8 values for a given {Profile,BufferAvailableLevel} pair.
The MSB is mark indication in case of most full.
The LSB is mark indication in case of most empty.",
      Width => "8",
      Position => "7:0", # Excel Formula: =calc_position(F93,E94,TRUE)
      Type => "Config",
      UsedBy => "CGM_deq",
      DefaultValue => "h0",
    },
  },
  BuffersConsumptionLutForDeq46 => { #Structure Type: Reg; ArrayLength: 128; ArrayIndex: 46; ArrayLocationInName: 28;
    Name => "BuffersConsumptionLutForDeq[128]",
    RegMem => "Reg",
    Address => "15F",
    Description => "LUT for dequeue marking in VOQ-CGM based on Buffer Consumption.
Index in Array is {Profile,BufferAvailableLevel}
Profile is 5 bits
BufferAvailableLevel is quantized to 2 bits.",
    Width => "8", # Excel Formula: =calc_reg_width(E94:E94,F94)
    Type => "Config",
    AdditionalInfo => "PackArrayToBus",
    Comments => "VOQ_CGM
CGM Deq Marking logic implemented in FF.
Address is {VOQ_PROFILE,Buffer_pool_available_level}
5 + 2 = 7
Buffer_voq_size_level selects offset out of 8.",
    ArrayLength => "128",
    ArrayIndex => "46",
    DeqBufferCongestionMark46 => { #Structure Type: RegField; ArrayLength: 128; ArrayIndex: 46; ArrayLocationInName: 24;
      Name => "DeqBufferCongestionMark[n]",
      RegMem => "RegField",
      Description => "Fill level of VOQ in buffers selects between the 8 values for a given {Profile,BufferAvailableLevel} pair.
The MSB is mark indication in case of most full.
The LSB is mark indication in case of most empty.",
      Width => "8",
      Position => "7:0", # Excel Formula: =calc_position(F93,E94,TRUE)
      Type => "Config",
      UsedBy => "CGM_deq",
      DefaultValue => "h0",
    },
  },
  BuffersConsumptionLutForDeq47 => { #Structure Type: Reg; ArrayLength: 128; ArrayIndex: 47; ArrayLocationInName: 28;
    Name => "BuffersConsumptionLutForDeq[128]",
    RegMem => "Reg",
    Address => "160",
    Description => "LUT for dequeue marking in VOQ-CGM based on Buffer Consumption.
Index in Array is {Profile,BufferAvailableLevel}
Profile is 5 bits
BufferAvailableLevel is quantized to 2 bits.",
    Width => "8", # Excel Formula: =calc_reg_width(E94:E94,F94)
    Type => "Config",
    AdditionalInfo => "PackArrayToBus",
    Comments => "VOQ_CGM
CGM Deq Marking logic implemented in FF.
Address is {VOQ_PROFILE,Buffer_pool_available_level}
5 + 2 = 7
Buffer_voq_size_level selects offset out of 8.",
    ArrayLength => "128",
    ArrayIndex => "47",
    DeqBufferCongestionMark47 => { #Structure Type: RegField; ArrayLength: 128; ArrayIndex: 47; ArrayLocationInName: 24;
      Name => "DeqBufferCongestionMark[n]",
      RegMem => "RegField",
      Description => "Fill level of VOQ in buffers selects between the 8 values for a given {Profile,BufferAvailableLevel} pair.
The MSB is mark indication in case of most full.
The LSB is mark indication in case of most empty.",
      Width => "8",
      Position => "7:0", # Excel Formula: =calc_position(F93,E94,TRUE)
      Type => "Config",
      UsedBy => "CGM_deq",
      DefaultValue => "h0",
    },
  },
  BuffersConsumptionLutForDeq48 => { #Structure Type: Reg; ArrayLength: 128; ArrayIndex: 48; ArrayLocationInName: 28;
    Name => "BuffersConsumptionLutForDeq[128]",
    RegMem => "Reg",
    Address => "161",
    Description => "LUT for dequeue marking in VOQ-CGM based on Buffer Consumption.
Index in Array is {Profile,BufferAvailableLevel}
Profile is 5 bits
BufferAvailableLevel is quantized to 2 bits.",
    Width => "8", # Excel Formula: =calc_reg_width(E94:E94,F94)
    Type => "Config",
    AdditionalInfo => "PackArrayToBus",
    Comments => "VOQ_CGM
CGM Deq Marking logic implemented in FF.
Address is {VOQ_PROFILE,Buffer_pool_available_level}
5 + 2 = 7
Buffer_voq_size_level selects offset out of 8.",
    ArrayLength => "128",
    ArrayIndex => "48",
    DeqBufferCongestionMark48 => { #Structure Type: RegField; ArrayLength: 128; ArrayIndex: 48; ArrayLocationInName: 24;
      Name => "DeqBufferCongestionMark[n]",
      RegMem => "RegField",
      Description => "Fill level of VOQ in buffers selects between the 8 values for a given {Profile,BufferAvailableLevel} pair.
The MSB is mark indication in case of most full.
The LSB is mark indication in case of most empty.",
      Width => "8",
      Position => "7:0", # Excel Formula: =calc_position(F93,E94,TRUE)
      Type => "Config",
      UsedBy => "CGM_deq",
      DefaultValue => "h0",
    },
  },
  BuffersConsumptionLutForDeq49 => { #Structure Type: Reg; ArrayLength: 128; ArrayIndex: 49; ArrayLocationInName: 28;
    Name => "BuffersConsumptionLutForDeq[128]",
    RegMem => "Reg",
    Address => "162",
    Description => "LUT for dequeue marking in VOQ-CGM based on Buffer Consumption.
Index in Array is {Profile,BufferAvailableLevel}
Profile is 5 bits
BufferAvailableLevel is quantized to 2 bits.",
    Width => "8", # Excel Formula: =calc_reg_width(E94:E94,F94)
    Type => "Config",
    AdditionalInfo => "PackArrayToBus",
    Comments => "VOQ_CGM
CGM Deq Marking logic implemented in FF.
Address is {VOQ_PROFILE,Buffer_pool_available_level}
5 + 2 = 7
Buffer_voq_size_level selects offset out of 8.",
    ArrayLength => "128",
    ArrayIndex => "49",
    DeqBufferCongestionMark49 => { #Structure Type: RegField; ArrayLength: 128; ArrayIndex: 49; ArrayLocationInName: 24;
      Name => "DeqBufferCongestionMark[n]",
      RegMem => "RegField",
      Description => "Fill level of VOQ in buffers selects between the 8 values for a given {Profile,BufferAvailableLevel} pair.
The MSB is mark indication in case of most full.
The LSB is mark indication in case of most empty.",
      Width => "8",
      Position => "7:0", # Excel Formula: =calc_position(F93,E94,TRUE)
      Type => "Config",
      UsedBy => "CGM_deq",
      DefaultValue => "h0",
    },
  },
  BuffersConsumptionLutForDeq50 => { #Structure Type: Reg; ArrayLength: 128; ArrayIndex: 50; ArrayLocationInName: 28;
    Name => "BuffersConsumptionLutForDeq[128]",
    RegMem => "Reg",
    Address => "163",
    Description => "LUT for dequeue marking in VOQ-CGM based on Buffer Consumption.
Index in Array is {Profile,BufferAvailableLevel}
Profile is 5 bits
BufferAvailableLevel is quantized to 2 bits.",
    Width => "8", # Excel Formula: =calc_reg_width(E94:E94,F94)
    Type => "Config",
    AdditionalInfo => "PackArrayToBus",
    Comments => "VOQ_CGM
CGM Deq Marking logic implemented in FF.
Address is {VOQ_PROFILE,Buffer_pool_available_level}
5 + 2 = 7
Buffer_voq_size_level selects offset out of 8.",
    ArrayLength => "128",
    ArrayIndex => "50",
    DeqBufferCongestionMark50 => { #Structure Type: RegField; ArrayLength: 128; ArrayIndex: 50; ArrayLocationInName: 24;
      Name => "DeqBufferCongestionMark[n]",
      RegMem => "RegField",
      Description => "Fill level of VOQ in buffers selects between the 8 values for a given {Profile,BufferAvailableLevel} pair.
The MSB is mark indication in case of most full.
The LSB is mark indication in case of most empty.",
      Width => "8",
      Position => "7:0", # Excel Formula: =calc_position(F93,E94,TRUE)
      Type => "Config",
      UsedBy => "CGM_deq",
      DefaultValue => "h0",
    },
  },
  BuffersConsumptionLutForDeq51 => { #Structure Type: Reg; ArrayLength: 128; ArrayIndex: 51; ArrayLocationInName: 28;
    Name => "BuffersConsumptionLutForDeq[128]",
    RegMem => "Reg",
    Address => "164",
    Description => "LUT for dequeue marking in VOQ-CGM based on Buffer Consumption.
Index in Array is {Profile,BufferAvailableLevel}
Profile is 5 bits
BufferAvailableLevel is quantized to 2 bits.",
    Width => "8", # Excel Formula: =calc_reg_width(E94:E94,F94)
    Type => "Config",
    AdditionalInfo => "PackArrayToBus",
    Comments => "VOQ_CGM
CGM Deq Marking logic implemented in FF.
Address is {VOQ_PROFILE,Buffer_pool_available_level}
5 + 2 = 7
Buffer_voq_size_level selects offset out of 8.",
    ArrayLength => "128",
    ArrayIndex => "51",
    DeqBufferCongestionMark51 => { #Structure Type: RegField; ArrayLength: 128; ArrayIndex: 51; ArrayLocationInName: 24;
      Name => "DeqBufferCongestionMark[n]",
      RegMem => "RegField",
      Description => "Fill level of VOQ in buffers selects between the 8 values for a given {Profile,BufferAvailableLevel} pair.
The MSB is mark indication in case of most full.
The LSB is mark indication in case of most empty.",
      Width => "8",
      Position => "7:0", # Excel Formula: =calc_position(F93,E94,TRUE)
      Type => "Config",
      UsedBy => "CGM_deq",
      DefaultValue => "h0",
    },
  },
  BuffersConsumptionLutForDeq52 => { #Structure Type: Reg; ArrayLength: 128; ArrayIndex: 52; ArrayLocationInName: 28;
    Name => "BuffersConsumptionLutForDeq[128]",
    RegMem => "Reg",
    Address => "165",
    Description => "LUT for dequeue marking in VOQ-CGM based on Buffer Consumption.
Index in Array is {Profile,BufferAvailableLevel}
Profile is 5 bits
BufferAvailableLevel is quantized to 2 bits.",
    Width => "8", # Excel Formula: =calc_reg_width(E94:E94,F94)
    Type => "Config",
    AdditionalInfo => "PackArrayToBus",
    Comments => "VOQ_CGM
CGM Deq Marking logic implemented in FF.
Address is {VOQ_PROFILE,Buffer_pool_available_level}
5 + 2 = 7
Buffer_voq_size_level selects offset out of 8.",
    ArrayLength => "128",
    ArrayIndex => "52",
    DeqBufferCongestionMark52 => { #Structure Type: RegField; ArrayLength: 128; ArrayIndex: 52; ArrayLocationInName: 24;
      Name => "DeqBufferCongestionMark[n]",
      RegMem => "RegField",
      Description => "Fill level of VOQ in buffers selects between the 8 values for a given {Profile,BufferAvailableLevel} pair.
The MSB is mark indication in case of most full.
The LSB is mark indication in case of most empty.",
      Width => "8",
      Position => "7:0", # Excel Formula: =calc_position(F93,E94,TRUE)
      Type => "Config",
      UsedBy => "CGM_deq",
      DefaultValue => "h0",
    },
  },
  BuffersConsumptionLutForDeq53 => { #Structure Type: Reg; ArrayLength: 128; ArrayIndex: 53; ArrayLocationInName: 28;
    Name => "BuffersConsumptionLutForDeq[128]",
    RegMem => "Reg",
    Address => "166",
    Description => "LUT for dequeue marking in VOQ-CGM based on Buffer Consumption.
Index in Array is {Profile,BufferAvailableLevel}
Profile is 5 bits
BufferAvailableLevel is quantized to 2 bits.",
    Width => "8", # Excel Formula: =calc_reg_width(E94:E94,F94)
    Type => "Config",
    AdditionalInfo => "PackArrayToBus",
    Comments => "VOQ_CGM
CGM Deq Marking logic implemented in FF.
Address is {VOQ_PROFILE,Buffer_pool_available_level}
5 + 2 = 7
Buffer_voq_size_level selects offset out of 8.",
    ArrayLength => "128",
    ArrayIndex => "53",
    DeqBufferCongestionMark53 => { #Structure Type: RegField; ArrayLength: 128; ArrayIndex: 53; ArrayLocationInName: 24;
      Name => "DeqBufferCongestionMark[n]",
      RegMem => "RegField",
      Description => "Fill level of VOQ in buffers selects between the 8 values for a given {Profile,BufferAvailableLevel} pair.
The MSB is mark indication in case of most full.
The LSB is mark indication in case of most empty.",
      Width => "8",
      Position => "7:0", # Excel Formula: =calc_position(F93,E94,TRUE)
      Type => "Config",
      UsedBy => "CGM_deq",
      DefaultValue => "h0",
    },
  },
  BuffersConsumptionLutForDeq54 => { #Structure Type: Reg; ArrayLength: 128; ArrayIndex: 54; ArrayLocationInName: 28;
    Name => "BuffersConsumptionLutForDeq[128]",
    RegMem => "Reg",
    Address => "167",
    Description => "LUT for dequeue marking in VOQ-CGM based on Buffer Consumption.
Index in Array is {Profile,BufferAvailableLevel}
Profile is 5 bits
BufferAvailableLevel is quantized to 2 bits.",
    Width => "8", # Excel Formula: =calc_reg_width(E94:E94,F94)
    Type => "Config",
    AdditionalInfo => "PackArrayToBus",
    Comments => "VOQ_CGM
CGM Deq Marking logic implemented in FF.
Address is {VOQ_PROFILE,Buffer_pool_available_level}
5 + 2 = 7
Buffer_voq_size_level selects offset out of 8.",
    ArrayLength => "128",
    ArrayIndex => "54",
    DeqBufferCongestionMark54 => { #Structure Type: RegField; ArrayLength: 128; ArrayIndex: 54; ArrayLocationInName: 24;
      Name => "DeqBufferCongestionMark[n]",
      RegMem => "RegField",
      Description => "Fill level of VOQ in buffers selects between the 8 values for a given {Profile,BufferAvailableLevel} pair.
The MSB is mark indication in case of most full.
The LSB is mark indication in case of most empty.",
      Width => "8",
      Position => "7:0", # Excel Formula: =calc_position(F93,E94,TRUE)
      Type => "Config",
      UsedBy => "CGM_deq",
      DefaultValue => "h0",
    },
  },
  BuffersConsumptionLutForDeq55 => { #Structure Type: Reg; ArrayLength: 128; ArrayIndex: 55; ArrayLocationInName: 28;
    Name => "BuffersConsumptionLutForDeq[128]",
    RegMem => "Reg",
    Address => "168",
    Description => "LUT for dequeue marking in VOQ-CGM based on Buffer Consumption.
Index in Array is {Profile,BufferAvailableLevel}
Profile is 5 bits
BufferAvailableLevel is quantized to 2 bits.",
    Width => "8", # Excel Formula: =calc_reg_width(E94:E94,F94)
    Type => "Config",
    AdditionalInfo => "PackArrayToBus",
    Comments => "VOQ_CGM
CGM Deq Marking logic implemented in FF.
Address is {VOQ_PROFILE,Buffer_pool_available_level}
5 + 2 = 7
Buffer_voq_size_level selects offset out of 8.",
    ArrayLength => "128",
    ArrayIndex => "55",
    DeqBufferCongestionMark55 => { #Structure Type: RegField; ArrayLength: 128; ArrayIndex: 55; ArrayLocationInName: 24;
      Name => "DeqBufferCongestionMark[n]",
      RegMem => "RegField",
      Description => "Fill level of VOQ in buffers selects between the 8 values for a given {Profile,BufferAvailableLevel} pair.
The MSB is mark indication in case of most full.
The LSB is mark indication in case of most empty.",
      Width => "8",
      Position => "7:0", # Excel Formula: =calc_position(F93,E94,TRUE)
      Type => "Config",
      UsedBy => "CGM_deq",
      DefaultValue => "h0",
    },
  },
  BuffersConsumptionLutForDeq56 => { #Structure Type: Reg; ArrayLength: 128; ArrayIndex: 56; ArrayLocationInName: 28;
    Name => "BuffersConsumptionLutForDeq[128]",
    RegMem => "Reg",
    Address => "169",
    Description => "LUT for dequeue marking in VOQ-CGM based on Buffer Consumption.
Index in Array is {Profile,BufferAvailableLevel}
Profile is 5 bits
BufferAvailableLevel is quantized to 2 bits.",
    Width => "8", # Excel Formula: =calc_reg_width(E94:E94,F94)
    Type => "Config",
    AdditionalInfo => "PackArrayToBus",
    Comments => "VOQ_CGM
CGM Deq Marking logic implemented in FF.
Address is {VOQ_PROFILE,Buffer_pool_available_level}
5 + 2 = 7
Buffer_voq_size_level selects offset out of 8.",
    ArrayLength => "128",
    ArrayIndex => "56",
    DeqBufferCongestionMark56 => { #Structure Type: RegField; ArrayLength: 128; ArrayIndex: 56; ArrayLocationInName: 24;
      Name => "DeqBufferCongestionMark[n]",
      RegMem => "RegField",
      Description => "Fill level of VOQ in buffers selects between the 8 values for a given {Profile,BufferAvailableLevel} pair.
The MSB is mark indication in case of most full.
The LSB is mark indication in case of most empty.",
      Width => "8",
      Position => "7:0", # Excel Formula: =calc_position(F93,E94,TRUE)
      Type => "Config",
      UsedBy => "CGM_deq",
      DefaultValue => "h0",
    },
  },
  BuffersConsumptionLutForDeq57 => { #Structure Type: Reg; ArrayLength: 128; ArrayIndex: 57; ArrayLocationInName: 28;
    Name => "BuffersConsumptionLutForDeq[128]",
    RegMem => "Reg",
    Address => "16A",
    Description => "LUT for dequeue marking in VOQ-CGM based on Buffer Consumption.
Index in Array is {Profile,BufferAvailableLevel}
Profile is 5 bits
BufferAvailableLevel is quantized to 2 bits.",
    Width => "8", # Excel Formula: =calc_reg_width(E94:E94,F94)
    Type => "Config",
    AdditionalInfo => "PackArrayToBus",
    Comments => "VOQ_CGM
CGM Deq Marking logic implemented in FF.
Address is {VOQ_PROFILE,Buffer_pool_available_level}
5 + 2 = 7
Buffer_voq_size_level selects offset out of 8.",
    ArrayLength => "128",
    ArrayIndex => "57",
    DeqBufferCongestionMark57 => { #Structure Type: RegField; ArrayLength: 128; ArrayIndex: 57; ArrayLocationInName: 24;
      Name => "DeqBufferCongestionMark[n]",
      RegMem => "RegField",
      Description => "Fill level of VOQ in buffers selects between the 8 values for a given {Profile,BufferAvailableLevel} pair.
The MSB is mark indication in case of most full.
The LSB is mark indication in case of most empty.",
      Width => "8",
      Position => "7:0", # Excel Formula: =calc_position(F93,E94,TRUE)
      Type => "Config",
      UsedBy => "CGM_deq",
      DefaultValue => "h0",
    },
  },
  BuffersConsumptionLutForDeq58 => { #Structure Type: Reg; ArrayLength: 128; ArrayIndex: 58; ArrayLocationInName: 28;
    Name => "BuffersConsumptionLutForDeq[128]",
    RegMem => "Reg",
    Address => "16B",
    Description => "LUT for dequeue marking in VOQ-CGM based on Buffer Consumption.
Index in Array is {Profile,BufferAvailableLevel}
Profile is 5 bits
BufferAvailableLevel is quantized to 2 bits.",
    Width => "8", # Excel Formula: =calc_reg_width(E94:E94,F94)
    Type => "Config",
    AdditionalInfo => "PackArrayToBus",
    Comments => "VOQ_CGM
CGM Deq Marking logic implemented in FF.
Address is {VOQ_PROFILE,Buffer_pool_available_level}
5 + 2 = 7
Buffer_voq_size_level selects offset out of 8.",
    ArrayLength => "128",
    ArrayIndex => "58",
    DeqBufferCongestionMark58 => { #Structure Type: RegField; ArrayLength: 128; ArrayIndex: 58; ArrayLocationInName: 24;
      Name => "DeqBufferCongestionMark[n]",
      RegMem => "RegField",
      Description => "Fill level of VOQ in buffers selects between the 8 values for a given {Profile,BufferAvailableLevel} pair.
The MSB is mark indication in case of most full.
The LSB is mark indication in case of most empty.",
      Width => "8",
      Position => "7:0", # Excel Formula: =calc_position(F93,E94,TRUE)
      Type => "Config",
      UsedBy => "CGM_deq",
      DefaultValue => "h0",
    },
  },
  BuffersConsumptionLutForDeq59 => { #Structure Type: Reg; ArrayLength: 128; ArrayIndex: 59; ArrayLocationInName: 28;
    Name => "BuffersConsumptionLutForDeq[128]",
    RegMem => "Reg",
    Address => "16C",
    Description => "LUT for dequeue marking in VOQ-CGM based on Buffer Consumption.
Index in Array is {Profile,BufferAvailableLevel}
Profile is 5 bits
BufferAvailableLevel is quantized to 2 bits.",
    Width => "8", # Excel Formula: =calc_reg_width(E94:E94,F94)
    Type => "Config",
    AdditionalInfo => "PackArrayToBus",
    Comments => "VOQ_CGM
CGM Deq Marking logic implemented in FF.
Address is {VOQ_PROFILE,Buffer_pool_available_level}
5 + 2 = 7
Buffer_voq_size_level selects offset out of 8.",
    ArrayLength => "128",
    ArrayIndex => "59",
    DeqBufferCongestionMark59 => { #Structure Type: RegField; ArrayLength: 128; ArrayIndex: 59; ArrayLocationInName: 24;
      Name => "DeqBufferCongestionMark[n]",
      RegMem => "RegField",
      Description => "Fill level of VOQ in buffers selects between the 8 values for a given {Profile,BufferAvailableLevel} pair.
The MSB is mark indication in case of most full.
The LSB is mark indication in case of most empty.",
      Width => "8",
      Position => "7:0", # Excel Formula: =calc_position(F93,E94,TRUE)
      Type => "Config",
      UsedBy => "CGM_deq",
      DefaultValue => "h0",
    },
  },
  BuffersConsumptionLutForDeq60 => { #Structure Type: Reg; ArrayLength: 128; ArrayIndex: 60; ArrayLocationInName: 28;
    Name => "BuffersConsumptionLutForDeq[128]",
    RegMem => "Reg",
    Address => "16D",
    Description => "LUT for dequeue marking in VOQ-CGM based on Buffer Consumption.
Index in Array is {Profile,BufferAvailableLevel}
Profile is 5 bits
BufferAvailableLevel is quantized to 2 bits.",
    Width => "8", # Excel Formula: =calc_reg_width(E94:E94,F94)
    Type => "Config",
    AdditionalInfo => "PackArrayToBus",
    Comments => "VOQ_CGM
CGM Deq Marking logic implemented in FF.
Address is {VOQ_PROFILE,Buffer_pool_available_level}
5 + 2 = 7
Buffer_voq_size_level selects offset out of 8.",
    ArrayLength => "128",
    ArrayIndex => "60",
    DeqBufferCongestionMark60 => { #Structure Type: RegField; ArrayLength: 128; ArrayIndex: 60; ArrayLocationInName: 24;
      Name => "DeqBufferCongestionMark[n]",
      RegMem => "RegField",
      Description => "Fill level of VOQ in buffers selects between the 8 values for a given {Profile,BufferAvailableLevel} pair.
The MSB is mark indication in case of most full.
The LSB is mark indication in case of most empty.",
      Width => "8",
      Position => "7:0", # Excel Formula: =calc_position(F93,E94,TRUE)
      Type => "Config",
      UsedBy => "CGM_deq",
      DefaultValue => "h0",
    },
  },
  BuffersConsumptionLutForDeq61 => { #Structure Type: Reg; ArrayLength: 128; ArrayIndex: 61; ArrayLocationInName: 28;
    Name => "BuffersConsumptionLutForDeq[128]",
    RegMem => "Reg",
    Address => "16E",
    Description => "LUT for dequeue marking in VOQ-CGM based on Buffer Consumption.
Index in Array is {Profile,BufferAvailableLevel}
Profile is 5 bits
BufferAvailableLevel is quantized to 2 bits.",
    Width => "8", # Excel Formula: =calc_reg_width(E94:E94,F94)
    Type => "Config",
    AdditionalInfo => "PackArrayToBus",
    Comments => "VOQ_CGM
CGM Deq Marking logic implemented in FF.
Address is {VOQ_PROFILE,Buffer_pool_available_level}
5 + 2 = 7
Buffer_voq_size_level selects offset out of 8.",
    ArrayLength => "128",
    ArrayIndex => "61",
    DeqBufferCongestionMark61 => { #Structure Type: RegField; ArrayLength: 128; ArrayIndex: 61; ArrayLocationInName: 24;
      Name => "DeqBufferCongestionMark[n]",
      RegMem => "RegField",
      Description => "Fill level of VOQ in buffers selects between the 8 values for a given {Profile,BufferAvailableLevel} pair.
The MSB is mark indication in case of most full.
The LSB is mark indication in case of most empty.",
      Width => "8",
      Position => "7:0", # Excel Formula: =calc_position(F93,E94,TRUE)
      Type => "Config",
      UsedBy => "CGM_deq",
      DefaultValue => "h0",
    },
  },
  BuffersConsumptionLutForDeq62 => { #Structure Type: Reg; ArrayLength: 128; ArrayIndex: 62; ArrayLocationInName: 28;
    Name => "BuffersConsumptionLutForDeq[128]",
    RegMem => "Reg",
    Address => "16F",
    Description => "LUT for dequeue marking in VOQ-CGM based on Buffer Consumption.
Index in Array is {Profile,BufferAvailableLevel}
Profile is 5 bits
BufferAvailableLevel is quantized to 2 bits.",
    Width => "8", # Excel Formula: =calc_reg_width(E94:E94,F94)
    Type => "Config",
    AdditionalInfo => "PackArrayToBus",
    Comments => "VOQ_CGM
CGM Deq Marking logic implemented in FF.
Address is {VOQ_PROFILE,Buffer_pool_available_level}
5 + 2 = 7
Buffer_voq_size_level selects offset out of 8.",
    ArrayLength => "128",
    ArrayIndex => "62",
    DeqBufferCongestionMark62 => { #Structure Type: RegField; ArrayLength: 128; ArrayIndex: 62; ArrayLocationInName: 24;
      Name => "DeqBufferCongestionMark[n]",
      RegMem => "RegField",
      Description => "Fill level of VOQ in buffers selects between the 8 values for a given {Profile,BufferAvailableLevel} pair.
The MSB is mark indication in case of most full.
The LSB is mark indication in case of most empty.",
      Width => "8",
      Position => "7:0", # Excel Formula: =calc_position(F93,E94,TRUE)
      Type => "Config",
      UsedBy => "CGM_deq",
      DefaultValue => "h0",
    },
  },
  BuffersConsumptionLutForDeq63 => { #Structure Type: Reg; ArrayLength: 128; ArrayIndex: 63; ArrayLocationInName: 28;
    Name => "BuffersConsumptionLutForDeq[128]",
    RegMem => "Reg",
    Address => "170",
    Description => "LUT for dequeue marking in VOQ-CGM based on Buffer Consumption.
Index in Array is {Profile,BufferAvailableLevel}
Profile is 5 bits
BufferAvailableLevel is quantized to 2 bits.",
    Width => "8", # Excel Formula: =calc_reg_width(E94:E94,F94)
    Type => "Config",
    AdditionalInfo => "PackArrayToBus",
    Comments => "VOQ_CGM
CGM Deq Marking logic implemented in FF.
Address is {VOQ_PROFILE,Buffer_pool_available_level}
5 + 2 = 7
Buffer_voq_size_level selects offset out of 8.",
    ArrayLength => "128",
    ArrayIndex => "63",
    DeqBufferCongestionMark63 => { #Structure Type: RegField; ArrayLength: 128; ArrayIndex: 63; ArrayLocationInName: 24;
      Name => "DeqBufferCongestionMark[n]",
      RegMem => "RegField",
      Description => "Fill level of VOQ in buffers selects between the 8 values for a given {Profile,BufferAvailableLevel} pair.
The MSB is mark indication in case of most full.
The LSB is mark indication in case of most empty.",
      Width => "8",
      Position => "7:0", # Excel Formula: =calc_position(F93,E94,TRUE)
      Type => "Config",
      UsedBy => "CGM_deq",
      DefaultValue => "h0",
    },
  },
  BuffersConsumptionLutForDeq64 => { #Structure Type: Reg; ArrayLength: 128; ArrayIndex: 64; ArrayLocationInName: 28;
    Name => "BuffersConsumptionLutForDeq[128]",
    RegMem => "Reg",
    Address => "171",
    Description => "LUT for dequeue marking in VOQ-CGM based on Buffer Consumption.
Index in Array is {Profile,BufferAvailableLevel}
Profile is 5 bits
BufferAvailableLevel is quantized to 2 bits.",
    Width => "8", # Excel Formula: =calc_reg_width(E94:E94,F94)
    Type => "Config",
    AdditionalInfo => "PackArrayToBus",
    Comments => "VOQ_CGM
CGM Deq Marking logic implemented in FF.
Address is {VOQ_PROFILE,Buffer_pool_available_level}
5 + 2 = 7
Buffer_voq_size_level selects offset out of 8.",
    ArrayLength => "128",
    ArrayIndex => "64",
    DeqBufferCongestionMark64 => { #Structure Type: RegField; ArrayLength: 128; ArrayIndex: 64; ArrayLocationInName: 24;
      Name => "DeqBufferCongestionMark[n]",
      RegMem => "RegField",
      Description => "Fill level of VOQ in buffers selects between the 8 values for a given {Profile,BufferAvailableLevel} pair.
The MSB is mark indication in case of most full.
The LSB is mark indication in case of most empty.",
      Width => "8",
      Position => "7:0", # Excel Formula: =calc_position(F93,E94,TRUE)
      Type => "Config",
      UsedBy => "CGM_deq",
      DefaultValue => "h0",
    },
  },
  BuffersConsumptionLutForDeq65 => { #Structure Type: Reg; ArrayLength: 128; ArrayIndex: 65; ArrayLocationInName: 28;
    Name => "BuffersConsumptionLutForDeq[128]",
    RegMem => "Reg",
    Address => "172",
    Description => "LUT for dequeue marking in VOQ-CGM based on Buffer Consumption.
Index in Array is {Profile,BufferAvailableLevel}
Profile is 5 bits
BufferAvailableLevel is quantized to 2 bits.",
    Width => "8", # Excel Formula: =calc_reg_width(E94:E94,F94)
    Type => "Config",
    AdditionalInfo => "PackArrayToBus",
    Comments => "VOQ_CGM
CGM Deq Marking logic implemented in FF.
Address is {VOQ_PROFILE,Buffer_pool_available_level}
5 + 2 = 7
Buffer_voq_size_level selects offset out of 8.",
    ArrayLength => "128",
    ArrayIndex => "65",
    DeqBufferCongestionMark65 => { #Structure Type: RegField; ArrayLength: 128; ArrayIndex: 65; ArrayLocationInName: 24;
      Name => "DeqBufferCongestionMark[n]",
      RegMem => "RegField",
      Description => "Fill level of VOQ in buffers selects between the 8 values for a given {Profile,BufferAvailableLevel} pair.
The MSB is mark indication in case of most full.
The LSB is mark indication in case of most empty.",
      Width => "8",
      Position => "7:0", # Excel Formula: =calc_position(F93,E94,TRUE)
      Type => "Config",
      UsedBy => "CGM_deq",
      DefaultValue => "h0",
    },
  },
  BuffersConsumptionLutForDeq66 => { #Structure Type: Reg; ArrayLength: 128; ArrayIndex: 66; ArrayLocationInName: 28;
    Name => "BuffersConsumptionLutForDeq[128]",
    RegMem => "Reg",
    Address => "173",
    Description => "LUT for dequeue marking in VOQ-CGM based on Buffer Consumption.
Index in Array is {Profile,BufferAvailableLevel}
Profile is 5 bits
BufferAvailableLevel is quantized to 2 bits.",
    Width => "8", # Excel Formula: =calc_reg_width(E94:E94,F94)
    Type => "Config",
    AdditionalInfo => "PackArrayToBus",
    Comments => "VOQ_CGM
CGM Deq Marking logic implemented in FF.
Address is {VOQ_PROFILE,Buffer_pool_available_level}
5 + 2 = 7
Buffer_voq_size_level selects offset out of 8.",
    ArrayLength => "128",
    ArrayIndex => "66",
    DeqBufferCongestionMark66 => { #Structure Type: RegField; ArrayLength: 128; ArrayIndex: 66; ArrayLocationInName: 24;
      Name => "DeqBufferCongestionMark[n]",
      RegMem => "RegField",
      Description => "Fill level of VOQ in buffers selects between the 8 values for a given {Profile,BufferAvailableLevel} pair.
The MSB is mark indication in case of most full.
The LSB is mark indication in case of most empty.",
      Width => "8",
      Position => "7:0", # Excel Formula: =calc_position(F93,E94,TRUE)
      Type => "Config",
      UsedBy => "CGM_deq",
      DefaultValue => "h0",
    },
  },
  BuffersConsumptionLutForDeq67 => { #Structure Type: Reg; ArrayLength: 128; ArrayIndex: 67; ArrayLocationInName: 28;
    Name => "BuffersConsumptionLutForDeq[128]",
    RegMem => "Reg",
    Address => "174",
    Description => "LUT for dequeue marking in VOQ-CGM based on Buffer Consumption.
Index in Array is {Profile,BufferAvailableLevel}
Profile is 5 bits
BufferAvailableLevel is quantized to 2 bits.",
    Width => "8", # Excel Formula: =calc_reg_width(E94:E94,F94)
    Type => "Config",
    AdditionalInfo => "PackArrayToBus",
    Comments => "VOQ_CGM
CGM Deq Marking logic implemented in FF.
Address is {VOQ_PROFILE,Buffer_pool_available_level}
5 + 2 = 7
Buffer_voq_size_level selects offset out of 8.",
    ArrayLength => "128",
    ArrayIndex => "67",
    DeqBufferCongestionMark67 => { #Structure Type: RegField; ArrayLength: 128; ArrayIndex: 67; ArrayLocationInName: 24;
      Name => "DeqBufferCongestionMark[n]",
      RegMem => "RegField",
      Description => "Fill level of VOQ in buffers selects between the 8 values for a given {Profile,BufferAvailableLevel} pair.
The MSB is mark indication in case of most full.
The LSB is mark indication in case of most empty.",
      Width => "8",
      Position => "7:0", # Excel Formula: =calc_position(F93,E94,TRUE)
      Type => "Config",
      UsedBy => "CGM_deq",
      DefaultValue => "h0",
    },
  },
  BuffersConsumptionLutForDeq68 => { #Structure Type: Reg; ArrayLength: 128; ArrayIndex: 68; ArrayLocationInName: 28;
    Name => "BuffersConsumptionLutForDeq[128]",
    RegMem => "Reg",
    Address => "175",
    Description => "LUT for dequeue marking in VOQ-CGM based on Buffer Consumption.
Index in Array is {Profile,BufferAvailableLevel}
Profile is 5 bits
BufferAvailableLevel is quantized to 2 bits.",
    Width => "8", # Excel Formula: =calc_reg_width(E94:E94,F94)
    Type => "Config",
    AdditionalInfo => "PackArrayToBus",
    Comments => "VOQ_CGM
CGM Deq Marking logic implemented in FF.
Address is {VOQ_PROFILE,Buffer_pool_available_level}
5 + 2 = 7
Buffer_voq_size_level selects offset out of 8.",
    ArrayLength => "128",
    ArrayIndex => "68",
    DeqBufferCongestionMark68 => { #Structure Type: RegField; ArrayLength: 128; ArrayIndex: 68; ArrayLocationInName: 24;
      Name => "DeqBufferCongestionMark[n]",
      RegMem => "RegField",
      Description => "Fill level of VOQ in buffers selects between the 8 values for a given {Profile,BufferAvailableLevel} pair.
The MSB is mark indication in case of most full.
The LSB is mark indication in case of most empty.",
      Width => "8",
      Position => "7:0", # Excel Formula: =calc_position(F93,E94,TRUE)
      Type => "Config",
      UsedBy => "CGM_deq",
      DefaultValue => "h0",
    },
  },
  BuffersConsumptionLutForDeq69 => { #Structure Type: Reg; ArrayLength: 128; ArrayIndex: 69; ArrayLocationInName: 28;
    Name => "BuffersConsumptionLutForDeq[128]",
    RegMem => "Reg",
    Address => "176",
    Description => "LUT for dequeue marking in VOQ-CGM based on Buffer Consumption.
Index in Array is {Profile,BufferAvailableLevel}
Profile is 5 bits
BufferAvailableLevel is quantized to 2 bits.",
    Width => "8", # Excel Formula: =calc_reg_width(E94:E94,F94)
    Type => "Config",
    AdditionalInfo => "PackArrayToBus",
    Comments => "VOQ_CGM
CGM Deq Marking logic implemented in FF.
Address is {VOQ_PROFILE,Buffer_pool_available_level}
5 + 2 = 7
Buffer_voq_size_level selects offset out of 8.",
    ArrayLength => "128",
    ArrayIndex => "69",
    DeqBufferCongestionMark69 => { #Structure Type: RegField; ArrayLength: 128; ArrayIndex: 69; ArrayLocationInName: 24;
      Name => "DeqBufferCongestionMark[n]",
      RegMem => "RegField",
      Description => "Fill level of VOQ in buffers selects between the 8 values for a given {Profile,BufferAvailableLevel} pair.
The MSB is mark indication in case of most full.
The LSB is mark indication in case of most empty.",
      Width => "8",
      Position => "7:0", # Excel Formula: =calc_position(F93,E94,TRUE)
      Type => "Config",
      UsedBy => "CGM_deq",
      DefaultValue => "h0",
    },
  },
  BuffersConsumptionLutForDeq70 => { #Structure Type: Reg; ArrayLength: 128; ArrayIndex: 70; ArrayLocationInName: 28;
    Name => "BuffersConsumptionLutForDeq[128]",
    RegMem => "Reg",
    Address => "177",
    Description => "LUT for dequeue marking in VOQ-CGM based on Buffer Consumption.
Index in Array is {Profile,BufferAvailableLevel}
Profile is 5 bits
BufferAvailableLevel is quantized to 2 bits.",
    Width => "8", # Excel Formula: =calc_reg_width(E94:E94,F94)
    Type => "Config",
    AdditionalInfo => "PackArrayToBus",
    Comments => "VOQ_CGM
CGM Deq Marking logic implemented in FF.
Address is {VOQ_PROFILE,Buffer_pool_available_level}
5 + 2 = 7
Buffer_voq_size_level selects offset out of 8.",
    ArrayLength => "128",
    ArrayIndex => "70",
    DeqBufferCongestionMark70 => { #Structure Type: RegField; ArrayLength: 128; ArrayIndex: 70; ArrayLocationInName: 24;
      Name => "DeqBufferCongestionMark[n]",
      RegMem => "RegField",
      Description => "Fill level of VOQ in buffers selects between the 8 values for a given {Profile,BufferAvailableLevel} pair.
The MSB is mark indication in case of most full.
The LSB is mark indication in case of most empty.",
      Width => "8",
      Position => "7:0", # Excel Formula: =calc_position(F93,E94,TRUE)
      Type => "Config",
      UsedBy => "CGM_deq",
      DefaultValue => "h0",
    },
  },
  BuffersConsumptionLutForDeq71 => { #Structure Type: Reg; ArrayLength: 128; ArrayIndex: 71; ArrayLocationInName: 28;
    Name => "BuffersConsumptionLutForDeq[128]",
    RegMem => "Reg",
    Address => "178",
    Description => "LUT for dequeue marking in VOQ-CGM based on Buffer Consumption.
Index in Array is {Profile,BufferAvailableLevel}
Profile is 5 bits
BufferAvailableLevel is quantized to 2 bits.",
    Width => "8", # Excel Formula: =calc_reg_width(E94:E94,F94)
    Type => "Config",
    AdditionalInfo => "PackArrayToBus",
    Comments => "VOQ_CGM
CGM Deq Marking logic implemented in FF.
Address is {VOQ_PROFILE,Buffer_pool_available_level}
5 + 2 = 7
Buffer_voq_size_level selects offset out of 8.",
    ArrayLength => "128",
    ArrayIndex => "71",
    DeqBufferCongestionMark71 => { #Structure Type: RegField; ArrayLength: 128; ArrayIndex: 71; ArrayLocationInName: 24;
      Name => "DeqBufferCongestionMark[n]",
      RegMem => "RegField",
      Description => "Fill level of VOQ in buffers selects between the 8 values for a given {Profile,BufferAvailableLevel} pair.
The MSB is mark indication in case of most full.
The LSB is mark indication in case of most empty.",
      Width => "8",
      Position => "7:0", # Excel Formula: =calc_position(F93,E94,TRUE)
      Type => "Config",
      UsedBy => "CGM_deq",
      DefaultValue => "h0",
    },
  },
  BuffersConsumptionLutForDeq72 => { #Structure Type: Reg; ArrayLength: 128; ArrayIndex: 72; ArrayLocationInName: 28;
    Name => "BuffersConsumptionLutForDeq[128]",
    RegMem => "Reg",
    Address => "179",
    Description => "LUT for dequeue marking in VOQ-CGM based on Buffer Consumption.
Index in Array is {Profile,BufferAvailableLevel}
Profile is 5 bits
BufferAvailableLevel is quantized to 2 bits.",
    Width => "8", # Excel Formula: =calc_reg_width(E94:E94,F94)
    Type => "Config",
    AdditionalInfo => "PackArrayToBus",
    Comments => "VOQ_CGM
CGM Deq Marking logic implemented in FF.
Address is {VOQ_PROFILE,Buffer_pool_available_level}
5 + 2 = 7
Buffer_voq_size_level selects offset out of 8.",
    ArrayLength => "128",
    ArrayIndex => "72",
    DeqBufferCongestionMark72 => { #Structure Type: RegField; ArrayLength: 128; ArrayIndex: 72; ArrayLocationInName: 24;
      Name => "DeqBufferCongestionMark[n]",
      RegMem => "RegField",
      Description => "Fill level of VOQ in buffers selects between the 8 values for a given {Profile,BufferAvailableLevel} pair.
The MSB is mark indication in case of most full.
The LSB is mark indication in case of most empty.",
      Width => "8",
      Position => "7:0", # Excel Formula: =calc_position(F93,E94,TRUE)
      Type => "Config",
      UsedBy => "CGM_deq",
      DefaultValue => "h0",
    },
  },
  BuffersConsumptionLutForDeq73 => { #Structure Type: Reg; ArrayLength: 128; ArrayIndex: 73; ArrayLocationInName: 28;
    Name => "BuffersConsumptionLutForDeq[128]",
    RegMem => "Reg",
    Address => "17A",
    Description => "LUT for dequeue marking in VOQ-CGM based on Buffer Consumption.
Index in Array is {Profile,BufferAvailableLevel}
Profile is 5 bits
BufferAvailableLevel is quantized to 2 bits.",
    Width => "8", # Excel Formula: =calc_reg_width(E94:E94,F94)
    Type => "Config",
    AdditionalInfo => "PackArrayToBus",
    Comments => "VOQ_CGM
CGM Deq Marking logic implemented in FF.
Address is {VOQ_PROFILE,Buffer_pool_available_level}
5 + 2 = 7
Buffer_voq_size_level selects offset out of 8.",
    ArrayLength => "128",
    ArrayIndex => "73",
    DeqBufferCongestionMark73 => { #Structure Type: RegField; ArrayLength: 128; ArrayIndex: 73; ArrayLocationInName: 24;
      Name => "DeqBufferCongestionMark[n]",
      RegMem => "RegField",
      Description => "Fill level of VOQ in buffers selects between the 8 values for a given {Profile,BufferAvailableLevel} pair.
The MSB is mark indication in case of most full.
The LSB is mark indication in case of most empty.",
      Width => "8",
      Position => "7:0", # Excel Formula: =calc_position(F93,E94,TRUE)
      Type => "Config",
      UsedBy => "CGM_deq",
      DefaultValue => "h0",
    },
  },
  BuffersConsumptionLutForDeq74 => { #Structure Type: Reg; ArrayLength: 128; ArrayIndex: 74; ArrayLocationInName: 28;
    Name => "BuffersConsumptionLutForDeq[128]",
    RegMem => "Reg",
    Address => "17B",
    Description => "LUT for dequeue marking in VOQ-CGM based on Buffer Consumption.
Index in Array is {Profile,BufferAvailableLevel}
Profile is 5 bits
BufferAvailableLevel is quantized to 2 bits.",
    Width => "8", # Excel Formula: =calc_reg_width(E94:E94,F94)
    Type => "Config",
    AdditionalInfo => "PackArrayToBus",
    Comments => "VOQ_CGM
CGM Deq Marking logic implemented in FF.
Address is {VOQ_PROFILE,Buffer_pool_available_level}
5 + 2 = 7
Buffer_voq_size_level selects offset out of 8.",
    ArrayLength => "128",
    ArrayIndex => "74",
    DeqBufferCongestionMark74 => { #Structure Type: RegField; ArrayLength: 128; ArrayIndex: 74; ArrayLocationInName: 24;
      Name => "DeqBufferCongestionMark[n]",
      RegMem => "RegField",
      Description => "Fill level of VOQ in buffers selects between the 8 values for a given {Profile,BufferAvailableLevel} pair.
The MSB is mark indication in case of most full.
The LSB is mark indication in case of most empty.",
      Width => "8",
      Position => "7:0", # Excel Formula: =calc_position(F93,E94,TRUE)
      Type => "Config",
      UsedBy => "CGM_deq",
      DefaultValue => "h0",
    },
  },
  BuffersConsumptionLutForDeq75 => { #Structure Type: Reg; ArrayLength: 128; ArrayIndex: 75; ArrayLocationInName: 28;
    Name => "BuffersConsumptionLutForDeq[128]",
    RegMem => "Reg",
    Address => "17C",
    Description => "LUT for dequeue marking in VOQ-CGM based on Buffer Consumption.
Index in Array is {Profile,BufferAvailableLevel}
Profile is 5 bits
BufferAvailableLevel is quantized to 2 bits.",
    Width => "8", # Excel Formula: =calc_reg_width(E94:E94,F94)
    Type => "Config",
    AdditionalInfo => "PackArrayToBus",
    Comments => "VOQ_CGM
CGM Deq Marking logic implemented in FF.
Address is {VOQ_PROFILE,Buffer_pool_available_level}
5 + 2 = 7
Buffer_voq_size_level selects offset out of 8.",
    ArrayLength => "128",
    ArrayIndex => "75",
    DeqBufferCongestionMark75 => { #Structure Type: RegField; ArrayLength: 128; ArrayIndex: 75; ArrayLocationInName: 24;
      Name => "DeqBufferCongestionMark[n]",
      RegMem => "RegField",
      Description => "Fill level of VOQ in buffers selects between the 8 values for a given {Profile,BufferAvailableLevel} pair.
The MSB is mark indication in case of most full.
The LSB is mark indication in case of most empty.",
      Width => "8",
      Position => "7:0", # Excel Formula: =calc_position(F93,E94,TRUE)
      Type => "Config",
      UsedBy => "CGM_deq",
      DefaultValue => "h0",
    },
  },
  BuffersConsumptionLutForDeq76 => { #Structure Type: Reg; ArrayLength: 128; ArrayIndex: 76; ArrayLocationInName: 28;
    Name => "BuffersConsumptionLutForDeq[128]",
    RegMem => "Reg",
    Address => "17D",
    Description => "LUT for dequeue marking in VOQ-CGM based on Buffer Consumption.
Index in Array is {Profile,BufferAvailableLevel}
Profile is 5 bits
BufferAvailableLevel is quantized to 2 bits.",
    Width => "8", # Excel Formula: =calc_reg_width(E94:E94,F94)
    Type => "Config",
    AdditionalInfo => "PackArrayToBus",
    Comments => "VOQ_CGM
CGM Deq Marking logic implemented in FF.
Address is {VOQ_PROFILE,Buffer_pool_available_level}
5 + 2 = 7
Buffer_voq_size_level selects offset out of 8.",
    ArrayLength => "128",
    ArrayIndex => "76",
    DeqBufferCongestionMark76 => { #Structure Type: RegField; ArrayLength: 128; ArrayIndex: 76; ArrayLocationInName: 24;
      Name => "DeqBufferCongestionMark[n]",
      RegMem => "RegField",
      Description => "Fill level of VOQ in buffers selects between the 8 values for a given {Profile,BufferAvailableLevel} pair.
The MSB is mark indication in case of most full.
The LSB is mark indication in case of most empty.",
      Width => "8",
      Position => "7:0", # Excel Formula: =calc_position(F93,E94,TRUE)
      Type => "Config",
      UsedBy => "CGM_deq",
      DefaultValue => "h0",
    },
  },
  BuffersConsumptionLutForDeq77 => { #Structure Type: Reg; ArrayLength: 128; ArrayIndex: 77; ArrayLocationInName: 28;
    Name => "BuffersConsumptionLutForDeq[128]",
    RegMem => "Reg",
    Address => "17E",
    Description => "LUT for dequeue marking in VOQ-CGM based on Buffer Consumption.
Index in Array is {Profile,BufferAvailableLevel}
Profile is 5 bits
BufferAvailableLevel is quantized to 2 bits.",
    Width => "8", # Excel Formula: =calc_reg_width(E94:E94,F94)
    Type => "Config",
    AdditionalInfo => "PackArrayToBus",
    Comments => "VOQ_CGM
CGM Deq Marking logic implemented in FF.
Address is {VOQ_PROFILE,Buffer_pool_available_level}
5 + 2 = 7
Buffer_voq_size_level selects offset out of 8.",
    ArrayLength => "128",
    ArrayIndex => "77",
    DeqBufferCongestionMark77 => { #Structure Type: RegField; ArrayLength: 128; ArrayIndex: 77; ArrayLocationInName: 24;
      Name => "DeqBufferCongestionMark[n]",
      RegMem => "RegField",
      Description => "Fill level of VOQ in buffers selects between the 8 values for a given {Profile,BufferAvailableLevel} pair.
The MSB is mark indication in case of most full.
The LSB is mark indication in case of most empty.",
      Width => "8",
      Position => "7:0", # Excel Formula: =calc_position(F93,E94,TRUE)
      Type => "Config",
      UsedBy => "CGM_deq",
      DefaultValue => "h0",
    },
  },
  BuffersConsumptionLutForDeq78 => { #Structure Type: Reg; ArrayLength: 128; ArrayIndex: 78; ArrayLocationInName: 28;
    Name => "BuffersConsumptionLutForDeq[128]",
    RegMem => "Reg",
    Address => "17F",
    Description => "LUT for dequeue marking in VOQ-CGM based on Buffer Consumption.
Index in Array is {Profile,BufferAvailableLevel}
Profile is 5 bits
BufferAvailableLevel is quantized to 2 bits.",
    Width => "8", # Excel Formula: =calc_reg_width(E94:E94,F94)
    Type => "Config",
    AdditionalInfo => "PackArrayToBus",
    Comments => "VOQ_CGM
CGM Deq Marking logic implemented in FF.
Address is {VOQ_PROFILE,Buffer_pool_available_level}
5 + 2 = 7
Buffer_voq_size_level selects offset out of 8.",
    ArrayLength => "128",
    ArrayIndex => "78",
    DeqBufferCongestionMark78 => { #Structure Type: RegField; ArrayLength: 128; ArrayIndex: 78; ArrayLocationInName: 24;
      Name => "DeqBufferCongestionMark[n]",
      RegMem => "RegField",
      Description => "Fill level of VOQ in buffers selects between the 8 values for a given {Profile,BufferAvailableLevel} pair.
The MSB is mark indication in case of most full.
The LSB is mark indication in case of most empty.",
      Width => "8",
      Position => "7:0", # Excel Formula: =calc_position(F93,E94,TRUE)
      Type => "Config",
      UsedBy => "CGM_deq",
      DefaultValue => "h0",
    },
  },
  BuffersConsumptionLutForDeq79 => { #Structure Type: Reg; ArrayLength: 128; ArrayIndex: 79; ArrayLocationInName: 28;
    Name => "BuffersConsumptionLutForDeq[128]",
    RegMem => "Reg",
    Address => "180",
    Description => "LUT for dequeue marking in VOQ-CGM based on Buffer Consumption.
Index in Array is {Profile,BufferAvailableLevel}
Profile is 5 bits
BufferAvailableLevel is quantized to 2 bits.",
    Width => "8", # Excel Formula: =calc_reg_width(E94:E94,F94)
    Type => "Config",
    AdditionalInfo => "PackArrayToBus",
    Comments => "VOQ_CGM
CGM Deq Marking logic implemented in FF.
Address is {VOQ_PROFILE,Buffer_pool_available_level}
5 + 2 = 7
Buffer_voq_size_level selects offset out of 8.",
    ArrayLength => "128",
    ArrayIndex => "79",
    DeqBufferCongestionMark79 => { #Structure Type: RegField; ArrayLength: 128; ArrayIndex: 79; ArrayLocationInName: 24;
      Name => "DeqBufferCongestionMark[n]",
      RegMem => "RegField",
      Description => "Fill level of VOQ in buffers selects between the 8 values for a given {Profile,BufferAvailableLevel} pair.
The MSB is mark indication in case of most full.
The LSB is mark indication in case of most empty.",
      Width => "8",
      Position => "7:0", # Excel Formula: =calc_position(F93,E94,TRUE)
      Type => "Config",
      UsedBy => "CGM_deq",
      DefaultValue => "h0",
    },
  },
  BuffersConsumptionLutForDeq80 => { #Structure Type: Reg; ArrayLength: 128; ArrayIndex: 80; ArrayLocationInName: 28;
    Name => "BuffersConsumptionLutForDeq[128]",
    RegMem => "Reg",
    Address => "181",
    Description => "LUT for dequeue marking in VOQ-CGM based on Buffer Consumption.
Index in Array is {Profile,BufferAvailableLevel}
Profile is 5 bits
BufferAvailableLevel is quantized to 2 bits.",
    Width => "8", # Excel Formula: =calc_reg_width(E94:E94,F94)
    Type => "Config",
    AdditionalInfo => "PackArrayToBus",
    Comments => "VOQ_CGM
CGM Deq Marking logic implemented in FF.
Address is {VOQ_PROFILE,Buffer_pool_available_level}
5 + 2 = 7
Buffer_voq_size_level selects offset out of 8.",
    ArrayLength => "128",
    ArrayIndex => "80",
    DeqBufferCongestionMark80 => { #Structure Type: RegField; ArrayLength: 128; ArrayIndex: 80; ArrayLocationInName: 24;
      Name => "DeqBufferCongestionMark[n]",
      RegMem => "RegField",
      Description => "Fill level of VOQ in buffers selects between the 8 values for a given {Profile,BufferAvailableLevel} pair.
The MSB is mark indication in case of most full.
The LSB is mark indication in case of most empty.",
      Width => "8",
      Position => "7:0", # Excel Formula: =calc_position(F93,E94,TRUE)
      Type => "Config",
      UsedBy => "CGM_deq",
      DefaultValue => "h0",
    },
  },
  BuffersConsumptionLutForDeq81 => { #Structure Type: Reg; ArrayLength: 128; ArrayIndex: 81; ArrayLocationInName: 28;
    Name => "BuffersConsumptionLutForDeq[128]",
    RegMem => "Reg",
    Address => "182",
    Description => "LUT for dequeue marking in VOQ-CGM based on Buffer Consumption.
Index in Array is {Profile,BufferAvailableLevel}
Profile is 5 bits
BufferAvailableLevel is quantized to 2 bits.",
    Width => "8", # Excel Formula: =calc_reg_width(E94:E94,F94)
    Type => "Config",
    AdditionalInfo => "PackArrayToBus",
    Comments => "VOQ_CGM
CGM Deq Marking logic implemented in FF.
Address is {VOQ_PROFILE,Buffer_pool_available_level}
5 + 2 = 7
Buffer_voq_size_level selects offset out of 8.",
    ArrayLength => "128",
    ArrayIndex => "81",
    DeqBufferCongestionMark81 => { #Structure Type: RegField; ArrayLength: 128; ArrayIndex: 81; ArrayLocationInName: 24;
      Name => "DeqBufferCongestionMark[n]",
      RegMem => "RegField",
      Description => "Fill level of VOQ in buffers selects between the 8 values for a given {Profile,BufferAvailableLevel} pair.
The MSB is mark indication in case of most full.
The LSB is mark indication in case of most empty.",
      Width => "8",
      Position => "7:0", # Excel Formula: =calc_position(F93,E94,TRUE)
      Type => "Config",
      UsedBy => "CGM_deq",
      DefaultValue => "h0",
    },
  },
  BuffersConsumptionLutForDeq82 => { #Structure Type: Reg; ArrayLength: 128; ArrayIndex: 82; ArrayLocationInName: 28;
    Name => "BuffersConsumptionLutForDeq[128]",
    RegMem => "Reg",
    Address => "183",
    Description => "LUT for dequeue marking in VOQ-CGM based on Buffer Consumption.
Index in Array is {Profile,BufferAvailableLevel}
Profile is 5 bits
BufferAvailableLevel is quantized to 2 bits.",
    Width => "8", # Excel Formula: =calc_reg_width(E94:E94,F94)
    Type => "Config",
    AdditionalInfo => "PackArrayToBus",
    Comments => "VOQ_CGM
CGM Deq Marking logic implemented in FF.
Address is {VOQ_PROFILE,Buffer_pool_available_level}
5 + 2 = 7
Buffer_voq_size_level selects offset out of 8.",
    ArrayLength => "128",
    ArrayIndex => "82",
    DeqBufferCongestionMark82 => { #Structure Type: RegField; ArrayLength: 128; ArrayIndex: 82; ArrayLocationInName: 24;
      Name => "DeqBufferCongestionMark[n]",
      RegMem => "RegField",
      Description => "Fill level of VOQ in buffers selects between the 8 values for a given {Profile,BufferAvailableLevel} pair.
The MSB is mark indication in case of most full.
The LSB is mark indication in case of most empty.",
      Width => "8",
      Position => "7:0", # Excel Formula: =calc_position(F93,E94,TRUE)
      Type => "Config",
      UsedBy => "CGM_deq",
      DefaultValue => "h0",
    },
  },
  BuffersConsumptionLutForDeq83 => { #Structure Type: Reg; ArrayLength: 128; ArrayIndex: 83; ArrayLocationInName: 28;
    Name => "BuffersConsumptionLutForDeq[128]",
    RegMem => "Reg",
    Address => "184",
    Description => "LUT for dequeue marking in VOQ-CGM based on Buffer Consumption.
Index in Array is {Profile,BufferAvailableLevel}
Profile is 5 bits
BufferAvailableLevel is quantized to 2 bits.",
    Width => "8", # Excel Formula: =calc_reg_width(E94:E94,F94)
    Type => "Config",
    AdditionalInfo => "PackArrayToBus",
    Comments => "VOQ_CGM
CGM Deq Marking logic implemented in FF.
Address is {VOQ_PROFILE,Buffer_pool_available_level}
5 + 2 = 7
Buffer_voq_size_level selects offset out of 8.",
    ArrayLength => "128",
    ArrayIndex => "83",
    DeqBufferCongestionMark83 => { #Structure Type: RegField; ArrayLength: 128; ArrayIndex: 83; ArrayLocationInName: 24;
      Name => "DeqBufferCongestionMark[n]",
      RegMem => "RegField",
      Description => "Fill level of VOQ in buffers selects between the 8 values for a given {Profile,BufferAvailableLevel} pair.
The MSB is mark indication in case of most full.
The LSB is mark indication in case of most empty.",
      Width => "8",
      Position => "7:0", # Excel Formula: =calc_position(F93,E94,TRUE)
      Type => "Config",
      UsedBy => "CGM_deq",
      DefaultValue => "h0",
    },
  },
  BuffersConsumptionLutForDeq84 => { #Structure Type: Reg; ArrayLength: 128; ArrayIndex: 84; ArrayLocationInName: 28;
    Name => "BuffersConsumptionLutForDeq[128]",
    RegMem => "Reg",
    Address => "185",
    Description => "LUT for dequeue marking in VOQ-CGM based on Buffer Consumption.
Index in Array is {Profile,BufferAvailableLevel}
Profile is 5 bits
BufferAvailableLevel is quantized to 2 bits.",
    Width => "8", # Excel Formula: =calc_reg_width(E94:E94,F94)
    Type => "Config",
    AdditionalInfo => "PackArrayToBus",
    Comments => "VOQ_CGM
CGM Deq Marking logic implemented in FF.
Address is {VOQ_PROFILE,Buffer_pool_available_level}
5 + 2 = 7
Buffer_voq_size_level selects offset out of 8.",
    ArrayLength => "128",
    ArrayIndex => "84",
    DeqBufferCongestionMark84 => { #Structure Type: RegField; ArrayLength: 128; ArrayIndex: 84; ArrayLocationInName: 24;
      Name => "DeqBufferCongestionMark[n]",
      RegMem => "RegField",
      Description => "Fill level of VOQ in buffers selects between the 8 values for a given {Profile,BufferAvailableLevel} pair.
The MSB is mark indication in case of most full.
The LSB is mark indication in case of most empty.",
      Width => "8",
      Position => "7:0", # Excel Formula: =calc_position(F93,E94,TRUE)
      Type => "Config",
      UsedBy => "CGM_deq",
      DefaultValue => "h0",
    },
  },
  BuffersConsumptionLutForDeq85 => { #Structure Type: Reg; ArrayLength: 128; ArrayIndex: 85; ArrayLocationInName: 28;
    Name => "BuffersConsumptionLutForDeq[128]",
    RegMem => "Reg",
    Address => "186",
    Description => "LUT for dequeue marking in VOQ-CGM based on Buffer Consumption.
Index in Array is {Profile,BufferAvailableLevel}
Profile is 5 bits
BufferAvailableLevel is quantized to 2 bits.",
    Width => "8", # Excel Formula: =calc_reg_width(E94:E94,F94)
    Type => "Config",
    AdditionalInfo => "PackArrayToBus",
    Comments => "VOQ_CGM
CGM Deq Marking logic implemented in FF.
Address is {VOQ_PROFILE,Buffer_pool_available_level}
5 + 2 = 7
Buffer_voq_size_level selects offset out of 8.",
    ArrayLength => "128",
    ArrayIndex => "85",
    DeqBufferCongestionMark85 => { #Structure Type: RegField; ArrayLength: 128; ArrayIndex: 85; ArrayLocationInName: 24;
      Name => "DeqBufferCongestionMark[n]",
      RegMem => "RegField",
      Description => "Fill level of VOQ in buffers selects between the 8 values for a given {Profile,BufferAvailableLevel} pair.
The MSB is mark indication in case of most full.
The LSB is mark indication in case of most empty.",
      Width => "8",
      Position => "7:0", # Excel Formula: =calc_position(F93,E94,TRUE)
      Type => "Config",
      UsedBy => "CGM_deq",
      DefaultValue => "h0",
    },
  },
  BuffersConsumptionLutForDeq86 => { #Structure Type: Reg; ArrayLength: 128; ArrayIndex: 86; ArrayLocationInName: 28;
    Name => "BuffersConsumptionLutForDeq[128]",
    RegMem => "Reg",
    Address => "187",
    Description => "LUT for dequeue marking in VOQ-CGM based on Buffer Consumption.
Index in Array is {Profile,BufferAvailableLevel}
Profile is 5 bits
BufferAvailableLevel is quantized to 2 bits.",
    Width => "8", # Excel Formula: =calc_reg_width(E94:E94,F94)
    Type => "Config",
    AdditionalInfo => "PackArrayToBus",
    Comments => "VOQ_CGM
CGM Deq Marking logic implemented in FF.
Address is {VOQ_PROFILE,Buffer_pool_available_level}
5 + 2 = 7
Buffer_voq_size_level selects offset out of 8.",
    ArrayLength => "128",
    ArrayIndex => "86",
    DeqBufferCongestionMark86 => { #Structure Type: RegField; ArrayLength: 128; ArrayIndex: 86; ArrayLocationInName: 24;
      Name => "DeqBufferCongestionMark[n]",
      RegMem => "RegField",
      Description => "Fill level of VOQ in buffers selects between the 8 values for a given {Profile,BufferAvailableLevel} pair.
The MSB is mark indication in case of most full.
The LSB is mark indication in case of most empty.",
      Width => "8",
      Position => "7:0", # Excel Formula: =calc_position(F93,E94,TRUE)
      Type => "Config",
      UsedBy => "CGM_deq",
      DefaultValue => "h0",
    },
  },
  BuffersConsumptionLutForDeq87 => { #Structure Type: Reg; ArrayLength: 128; ArrayIndex: 87; ArrayLocationInName: 28;
    Name => "BuffersConsumptionLutForDeq[128]",
    RegMem => "Reg",
    Address => "188",
    Description => "LUT for dequeue marking in VOQ-CGM based on Buffer Consumption.
Index in Array is {Profile,BufferAvailableLevel}
Profile is 5 bits
BufferAvailableLevel is quantized to 2 bits.",
    Width => "8", # Excel Formula: =calc_reg_width(E94:E94,F94)
    Type => "Config",
    AdditionalInfo => "PackArrayToBus",
    Comments => "VOQ_CGM
CGM Deq Marking logic implemented in FF.
Address is {VOQ_PROFILE,Buffer_pool_available_level}
5 + 2 = 7
Buffer_voq_size_level selects offset out of 8.",
    ArrayLength => "128",
    ArrayIndex => "87",
    DeqBufferCongestionMark87 => { #Structure Type: RegField; ArrayLength: 128; ArrayIndex: 87; ArrayLocationInName: 24;
      Name => "DeqBufferCongestionMark[n]",
      RegMem => "RegField",
      Description => "Fill level of VOQ in buffers selects between the 8 values for a given {Profile,BufferAvailableLevel} pair.
The MSB is mark indication in case of most full.
The LSB is mark indication in case of most empty.",
      Width => "8",
      Position => "7:0", # Excel Formula: =calc_position(F93,E94,TRUE)
      Type => "Config",
      UsedBy => "CGM_deq",
      DefaultValue => "h0",
    },
  },
  BuffersConsumptionLutForDeq88 => { #Structure Type: Reg; ArrayLength: 128; ArrayIndex: 88; ArrayLocationInName: 28;
    Name => "BuffersConsumptionLutForDeq[128]",
    RegMem => "Reg",
    Address => "189",
    Description => "LUT for dequeue marking in VOQ-CGM based on Buffer Consumption.
Index in Array is {Profile,BufferAvailableLevel}
Profile is 5 bits
BufferAvailableLevel is quantized to 2 bits.",
    Width => "8", # Excel Formula: =calc_reg_width(E94:E94,F94)
    Type => "Config",
    AdditionalInfo => "PackArrayToBus",
    Comments => "VOQ_CGM
CGM Deq Marking logic implemented in FF.
Address is {VOQ_PROFILE,Buffer_pool_available_level}
5 + 2 = 7
Buffer_voq_size_level selects offset out of 8.",
    ArrayLength => "128",
    ArrayIndex => "88",
    DeqBufferCongestionMark88 => { #Structure Type: RegField; ArrayLength: 128; ArrayIndex: 88; ArrayLocationInName: 24;
      Name => "DeqBufferCongestionMark[n]",
      RegMem => "RegField",
      Description => "Fill level of VOQ in buffers selects between the 8 values for a given {Profile,BufferAvailableLevel} pair.
The MSB is mark indication in case of most full.
The LSB is mark indication in case of most empty.",
      Width => "8",
      Position => "7:0", # Excel Formula: =calc_position(F93,E94,TRUE)
      Type => "Config",
      UsedBy => "CGM_deq",
      DefaultValue => "h0",
    },
  },
  BuffersConsumptionLutForDeq89 => { #Structure Type: Reg; ArrayLength: 128; ArrayIndex: 89; ArrayLocationInName: 28;
    Name => "BuffersConsumptionLutForDeq[128]",
    RegMem => "Reg",
    Address => "18A",
    Description => "LUT for dequeue marking in VOQ-CGM based on Buffer Consumption.
Index in Array is {Profile,BufferAvailableLevel}
Profile is 5 bits
BufferAvailableLevel is quantized to 2 bits.",
    Width => "8", # Excel Formula: =calc_reg_width(E94:E94,F94)
    Type => "Config",
    AdditionalInfo => "PackArrayToBus",
    Comments => "VOQ_CGM
CGM Deq Marking logic implemented in FF.
Address is {VOQ_PROFILE,Buffer_pool_available_level}
5 + 2 = 7
Buffer_voq_size_level selects offset out of 8.",
    ArrayLength => "128",
    ArrayIndex => "89",
    DeqBufferCongestionMark89 => { #Structure Type: RegField; ArrayLength: 128; ArrayIndex: 89; ArrayLocationInName: 24;
      Name => "DeqBufferCongestionMark[n]",
      RegMem => "RegField",
      Description => "Fill level of VOQ in buffers selects between the 8 values for a given {Profile,BufferAvailableLevel} pair.
The MSB is mark indication in case of most full.
The LSB is mark indication in case of most empty.",
      Width => "8",
      Position => "7:0", # Excel Formula: =calc_position(F93,E94,TRUE)
      Type => "Config",
      UsedBy => "CGM_deq",
      DefaultValue => "h0",
    },
  },
  BuffersConsumptionLutForDeq90 => { #Structure Type: Reg; ArrayLength: 128; ArrayIndex: 90; ArrayLocationInName: 28;
    Name => "BuffersConsumptionLutForDeq[128]",
    RegMem => "Reg",
    Address => "18B",
    Description => "LUT for dequeue marking in VOQ-CGM based on Buffer Consumption.
Index in Array is {Profile,BufferAvailableLevel}
Profile is 5 bits
BufferAvailableLevel is quantized to 2 bits.",
    Width => "8", # Excel Formula: =calc_reg_width(E94:E94,F94)
    Type => "Config",
    AdditionalInfo => "PackArrayToBus",
    Comments => "VOQ_CGM
CGM Deq Marking logic implemented in FF.
Address is {VOQ_PROFILE,Buffer_pool_available_level}
5 + 2 = 7
Buffer_voq_size_level selects offset out of 8.",
    ArrayLength => "128",
    ArrayIndex => "90",
    DeqBufferCongestionMark90 => { #Structure Type: RegField; ArrayLength: 128; ArrayIndex: 90; ArrayLocationInName: 24;
      Name => "DeqBufferCongestionMark[n]",
      RegMem => "RegField",
      Description => "Fill level of VOQ in buffers selects between the 8 values for a given {Profile,BufferAvailableLevel} pair.
The MSB is mark indication in case of most full.
The LSB is mark indication in case of most empty.",
      Width => "8",
      Position => "7:0", # Excel Formula: =calc_position(F93,E94,TRUE)
      Type => "Config",
      UsedBy => "CGM_deq",
      DefaultValue => "h0",
    },
  },
  BuffersConsumptionLutForDeq91 => { #Structure Type: Reg; ArrayLength: 128; ArrayIndex: 91; ArrayLocationInName: 28;
    Name => "BuffersConsumptionLutForDeq[128]",
    RegMem => "Reg",
    Address => "18C",
    Description => "LUT for dequeue marking in VOQ-CGM based on Buffer Consumption.
Index in Array is {Profile,BufferAvailableLevel}
Profile is 5 bits
BufferAvailableLevel is quantized to 2 bits.",
    Width => "8", # Excel Formula: =calc_reg_width(E94:E94,F94)
    Type => "Config",
    AdditionalInfo => "PackArrayToBus",
    Comments => "VOQ_CGM
CGM Deq Marking logic implemented in FF.
Address is {VOQ_PROFILE,Buffer_pool_available_level}
5 + 2 = 7
Buffer_voq_size_level selects offset out of 8.",
    ArrayLength => "128",
    ArrayIndex => "91",
    DeqBufferCongestionMark91 => { #Structure Type: RegField; ArrayLength: 128; ArrayIndex: 91; ArrayLocationInName: 24;
      Name => "DeqBufferCongestionMark[n]",
      RegMem => "RegField",
      Description => "Fill level of VOQ in buffers selects between the 8 values for a given {Profile,BufferAvailableLevel} pair.
The MSB is mark indication in case of most full.
The LSB is mark indication in case of most empty.",
      Width => "8",
      Position => "7:0", # Excel Formula: =calc_position(F93,E94,TRUE)
      Type => "Config",
      UsedBy => "CGM_deq",
      DefaultValue => "h0",
    },
  },
  BuffersConsumptionLutForDeq92 => { #Structure Type: Reg; ArrayLength: 128; ArrayIndex: 92; ArrayLocationInName: 28;
    Name => "BuffersConsumptionLutForDeq[128]",
    RegMem => "Reg",
    Address => "18D",
    Description => "LUT for dequeue marking in VOQ-CGM based on Buffer Consumption.
Index in Array is {Profile,BufferAvailableLevel}
Profile is 5 bits
BufferAvailableLevel is quantized to 2 bits.",
    Width => "8", # Excel Formula: =calc_reg_width(E94:E94,F94)
    Type => "Config",
    AdditionalInfo => "PackArrayToBus",
    Comments => "VOQ_CGM
CGM Deq Marking logic implemented in FF.
Address is {VOQ_PROFILE,Buffer_pool_available_level}
5 + 2 = 7
Buffer_voq_size_level selects offset out of 8.",
    ArrayLength => "128",
    ArrayIndex => "92",
    DeqBufferCongestionMark92 => { #Structure Type: RegField; ArrayLength: 128; ArrayIndex: 92; ArrayLocationInName: 24;
      Name => "DeqBufferCongestionMark[n]",
      RegMem => "RegField",
      Description => "Fill level of VOQ in buffers selects between the 8 values for a given {Profile,BufferAvailableLevel} pair.
The MSB is mark indication in case of most full.
The LSB is mark indication in case of most empty.",
      Width => "8",
      Position => "7:0", # Excel Formula: =calc_position(F93,E94,TRUE)
      Type => "Config",
      UsedBy => "CGM_deq",
      DefaultValue => "h0",
    },
  },
  BuffersConsumptionLutForDeq93 => { #Structure Type: Reg; ArrayLength: 128; ArrayIndex: 93; ArrayLocationInName: 28;
    Name => "BuffersConsumptionLutForDeq[128]",
    RegMem => "Reg",
    Address => "18E",
    Description => "LUT for dequeue marking in VOQ-CGM based on Buffer Consumption.
Index in Array is {Profile,BufferAvailableLevel}
Profile is 5 bits
BufferAvailableLevel is quantized to 2 bits.",
    Width => "8", # Excel Formula: =calc_reg_width(E94:E94,F94)
    Type => "Config",
    AdditionalInfo => "PackArrayToBus",
    Comments => "VOQ_CGM
CGM Deq Marking logic implemented in FF.
Address is {VOQ_PROFILE,Buffer_pool_available_level}
5 + 2 = 7
Buffer_voq_size_level selects offset out of 8.",
    ArrayLength => "128",
    ArrayIndex => "93",
    DeqBufferCongestionMark93 => { #Structure Type: RegField; ArrayLength: 128; ArrayIndex: 93; ArrayLocationInName: 24;
      Name => "DeqBufferCongestionMark[n]",
      RegMem => "RegField",
      Description => "Fill level of VOQ in buffers selects between the 8 values for a given {Profile,BufferAvailableLevel} pair.
The MSB is mark indication in case of most full.
The LSB is mark indication in case of most empty.",
      Width => "8",
      Position => "7:0", # Excel Formula: =calc_position(F93,E94,TRUE)
      Type => "Config",
      UsedBy => "CGM_deq",
      DefaultValue => "h0",
    },
  },
  BuffersConsumptionLutForDeq94 => { #Structure Type: Reg; ArrayLength: 128; ArrayIndex: 94; ArrayLocationInName: 28;
    Name => "BuffersConsumptionLutForDeq[128]",
    RegMem => "Reg",
    Address => "18F",
    Description => "LUT for dequeue marking in VOQ-CGM based on Buffer Consumption.
Index in Array is {Profile,BufferAvailableLevel}
Profile is 5 bits
BufferAvailableLevel is quantized to 2 bits.",
    Width => "8", # Excel Formula: =calc_reg_width(E94:E94,F94)
    Type => "Config",
    AdditionalInfo => "PackArrayToBus",
    Comments => "VOQ_CGM
CGM Deq Marking logic implemented in FF.
Address is {VOQ_PROFILE,Buffer_pool_available_level}
5 + 2 = 7
Buffer_voq_size_level selects offset out of 8.",
    ArrayLength => "128",
    ArrayIndex => "94",
    DeqBufferCongestionMark94 => { #Structure Type: RegField; ArrayLength: 128; ArrayIndex: 94; ArrayLocationInName: 24;
      Name => "DeqBufferCongestionMark[n]",
      RegMem => "RegField",
      Description => "Fill level of VOQ in buffers selects between the 8 values for a given {Profile,BufferAvailableLevel} pair.
The MSB is mark indication in case of most full.
The LSB is mark indication in case of most empty.",
      Width => "8",
      Position => "7:0", # Excel Formula: =calc_position(F93,E94,TRUE)
      Type => "Config",
      UsedBy => "CGM_deq",
      DefaultValue => "h0",
    },
  },
  BuffersConsumptionLutForDeq95 => { #Structure Type: Reg; ArrayLength: 128; ArrayIndex: 95; ArrayLocationInName: 28;
    Name => "BuffersConsumptionLutForDeq[128]",
    RegMem => "Reg",
    Address => "190",
    Description => "LUT for dequeue marking in VOQ-CGM based on Buffer Consumption.
Index in Array is {Profile,BufferAvailableLevel}
Profile is 5 bits
BufferAvailableLevel is quantized to 2 bits.",
    Width => "8", # Excel Formula: =calc_reg_width(E94:E94,F94)
    Type => "Config",
    AdditionalInfo => "PackArrayToBus",
    Comments => "VOQ_CGM
CGM Deq Marking logic implemented in FF.
Address is {VOQ_PROFILE,Buffer_pool_available_level}
5 + 2 = 7
Buffer_voq_size_level selects offset out of 8.",
    ArrayLength => "128",
    ArrayIndex => "95",
    DeqBufferCongestionMark95 => { #Structure Type: RegField; ArrayLength: 128; ArrayIndex: 95; ArrayLocationInName: 24;
      Name => "DeqBufferCongestionMark[n]",
      RegMem => "RegField",
      Description => "Fill level of VOQ in buffers selects between the 8 values for a given {Profile,BufferAvailableLevel} pair.
The MSB is mark indication in case of most full.
The LSB is mark indication in case of most empty.",
      Width => "8",
      Position => "7:0", # Excel Formula: =calc_position(F93,E94,TRUE)
      Type => "Config",
      UsedBy => "CGM_deq",
      DefaultValue => "h0",
    },
  },
  BuffersConsumptionLutForDeq96 => { #Structure Type: Reg; ArrayLength: 128; ArrayIndex: 96; ArrayLocationInName: 28;
    Name => "BuffersConsumptionLutForDeq[128]",
    RegMem => "Reg",
    Address => "191",
    Description => "LUT for dequeue marking in VOQ-CGM based on Buffer Consumption.
Index in Array is {Profile,BufferAvailableLevel}
Profile is 5 bits
BufferAvailableLevel is quantized to 2 bits.",
    Width => "8", # Excel Formula: =calc_reg_width(E94:E94,F94)
    Type => "Config",
    AdditionalInfo => "PackArrayToBus",
    Comments => "VOQ_CGM
CGM Deq Marking logic implemented in FF.
Address is {VOQ_PROFILE,Buffer_pool_available_level}
5 + 2 = 7
Buffer_voq_size_level selects offset out of 8.",
    ArrayLength => "128",
    ArrayIndex => "96",
    DeqBufferCongestionMark96 => { #Structure Type: RegField; ArrayLength: 128; ArrayIndex: 96; ArrayLocationInName: 24;
      Name => "DeqBufferCongestionMark[n]",
      RegMem => "RegField",
      Description => "Fill level of VOQ in buffers selects between the 8 values for a given {Profile,BufferAvailableLevel} pair.
The MSB is mark indication in case of most full.
The LSB is mark indication in case of most empty.",
      Width => "8",
      Position => "7:0", # Excel Formula: =calc_position(F93,E94,TRUE)
      Type => "Config",
      UsedBy => "CGM_deq",
      DefaultValue => "h0",
    },
  },
  BuffersConsumptionLutForDeq97 => { #Structure Type: Reg; ArrayLength: 128; ArrayIndex: 97; ArrayLocationInName: 28;
    Name => "BuffersConsumptionLutForDeq[128]",
    RegMem => "Reg",
    Address => "192",
    Description => "LUT for dequeue marking in VOQ-CGM based on Buffer Consumption.
Index in Array is {Profile,BufferAvailableLevel}
Profile is 5 bits
BufferAvailableLevel is quantized to 2 bits.",
    Width => "8", # Excel Formula: =calc_reg_width(E94:E94,F94)
    Type => "Config",
    AdditionalInfo => "PackArrayToBus",
    Comments => "VOQ_CGM
CGM Deq Marking logic implemented in FF.
Address is {VOQ_PROFILE,Buffer_pool_available_level}
5 + 2 = 7
Buffer_voq_size_level selects offset out of 8.",
    ArrayLength => "128",
    ArrayIndex => "97",
    DeqBufferCongestionMark97 => { #Structure Type: RegField; ArrayLength: 128; ArrayIndex: 97; ArrayLocationInName: 24;
      Name => "DeqBufferCongestionMark[n]",
      RegMem => "RegField",
      Description => "Fill level of VOQ in buffers selects between the 8 values for a given {Profile,BufferAvailableLevel} pair.
The MSB is mark indication in case of most full.
The LSB is mark indication in case of most empty.",
      Width => "8",
      Position => "7:0", # Excel Formula: =calc_position(F93,E94,TRUE)
      Type => "Config",
      UsedBy => "CGM_deq",
      DefaultValue => "h0",
    },
  },
  BuffersConsumptionLutForDeq98 => { #Structure Type: Reg; ArrayLength: 128; ArrayIndex: 98; ArrayLocationInName: 28;
    Name => "BuffersConsumptionLutForDeq[128]",
    RegMem => "Reg",
    Address => "193",
    Description => "LUT for dequeue marking in VOQ-CGM based on Buffer Consumption.
Index in Array is {Profile,BufferAvailableLevel}
Profile is 5 bits
BufferAvailableLevel is quantized to 2 bits.",
    Width => "8", # Excel Formula: =calc_reg_width(E94:E94,F94)
    Type => "Config",
    AdditionalInfo => "PackArrayToBus",
    Comments => "VOQ_CGM
CGM Deq Marking logic implemented in FF.
Address is {VOQ_PROFILE,Buffer_pool_available_level}
5 + 2 = 7
Buffer_voq_size_level selects offset out of 8.",
    ArrayLength => "128",
    ArrayIndex => "98",
    DeqBufferCongestionMark98 => { #Structure Type: RegField; ArrayLength: 128; ArrayIndex: 98; ArrayLocationInName: 24;
      Name => "DeqBufferCongestionMark[n]",
      RegMem => "RegField",
      Description => "Fill level of VOQ in buffers selects between the 8 values for a given {Profile,BufferAvailableLevel} pair.
The MSB is mark indication in case of most full.
The LSB is mark indication in case of most empty.",
      Width => "8",
      Position => "7:0", # Excel Formula: =calc_position(F93,E94,TRUE)
      Type => "Config",
      UsedBy => "CGM_deq",
      DefaultValue => "h0",
    },
  },
  BuffersConsumptionLutForDeq99 => { #Structure Type: Reg; ArrayLength: 128; ArrayIndex: 99; ArrayLocationInName: 28;
    Name => "BuffersConsumptionLutForDeq[128]",
    RegMem => "Reg",
    Address => "194",
    Description => "LUT for dequeue marking in VOQ-CGM based on Buffer Consumption.
Index in Array is {Profile,BufferAvailableLevel}
Profile is 5 bits
BufferAvailableLevel is quantized to 2 bits.",
    Width => "8", # Excel Formula: =calc_reg_width(E94:E94,F94)
    Type => "Config",
    AdditionalInfo => "PackArrayToBus",
    Comments => "VOQ_CGM
CGM Deq Marking logic implemented in FF.
Address is {VOQ_PROFILE,Buffer_pool_available_level}
5 + 2 = 7
Buffer_voq_size_level selects offset out of 8.",
    ArrayLength => "128",
    ArrayIndex => "99",
    DeqBufferCongestionMark99 => { #Structure Type: RegField; ArrayLength: 128; ArrayIndex: 99; ArrayLocationInName: 24;
      Name => "DeqBufferCongestionMark[n]",
      RegMem => "RegField",
      Description => "Fill level of VOQ in buffers selects between the 8 values for a given {Profile,BufferAvailableLevel} pair.
The MSB is mark indication in case of most full.
The LSB is mark indication in case of most empty.",
      Width => "8",
      Position => "7:0", # Excel Formula: =calc_position(F93,E94,TRUE)
      Type => "Config",
      UsedBy => "CGM_deq",
      DefaultValue => "h0",
    },
  },
  BuffersConsumptionLutForDeq100 => { #Structure Type: Reg; ArrayLength: 128; ArrayIndex: 100; ArrayLocationInName: 28;
    Name => "BuffersConsumptionLutForDeq[128]",
    RegMem => "Reg",
    Address => "195",
    Description => "LUT for dequeue marking in VOQ-CGM based on Buffer Consumption.
Index in Array is {Profile,BufferAvailableLevel}
Profile is 5 bits
BufferAvailableLevel is quantized to 2 bits.",
    Width => "8", # Excel Formula: =calc_reg_width(E94:E94,F94)
    Type => "Config",
    AdditionalInfo => "PackArrayToBus",
    Comments => "VOQ_CGM
CGM Deq Marking logic implemented in FF.
Address is {VOQ_PROFILE,Buffer_pool_available_level}
5 + 2 = 7
Buffer_voq_size_level selects offset out of 8.",
    ArrayLength => "128",
    ArrayIndex => "100",
    DeqBufferCongestionMark100 => { #Structure Type: RegField; ArrayLength: 128; ArrayIndex: 100; ArrayLocationInName: 24;
      Name => "DeqBufferCongestionMark[n]",
      RegMem => "RegField",
      Description => "Fill level of VOQ in buffers selects between the 8 values for a given {Profile,BufferAvailableLevel} pair.
The MSB is mark indication in case of most full.
The LSB is mark indication in case of most empty.",
      Width => "8",
      Position => "7:0", # Excel Formula: =calc_position(F93,E94,TRUE)
      Type => "Config",
      UsedBy => "CGM_deq",
      DefaultValue => "h0",
    },
  },
  BuffersConsumptionLutForDeq101 => { #Structure Type: Reg; ArrayLength: 128; ArrayIndex: 101; ArrayLocationInName: 28;
    Name => "BuffersConsumptionLutForDeq[128]",
    RegMem => "Reg",
    Address => "196",
    Description => "LUT for dequeue marking in VOQ-CGM based on Buffer Consumption.
Index in Array is {Profile,BufferAvailableLevel}
Profile is 5 bits
BufferAvailableLevel is quantized to 2 bits.",
    Width => "8", # Excel Formula: =calc_reg_width(E94:E94,F94)
    Type => "Config",
    AdditionalInfo => "PackArrayToBus",
    Comments => "VOQ_CGM
CGM Deq Marking logic implemented in FF.
Address is {VOQ_PROFILE,Buffer_pool_available_level}
5 + 2 = 7
Buffer_voq_size_level selects offset out of 8.",
    ArrayLength => "128",
    ArrayIndex => "101",
    DeqBufferCongestionMark101 => { #Structure Type: RegField; ArrayLength: 128; ArrayIndex: 101; ArrayLocationInName: 24;
      Name => "DeqBufferCongestionMark[n]",
      RegMem => "RegField",
      Description => "Fill level of VOQ in buffers selects between the 8 values for a given {Profile,BufferAvailableLevel} pair.
The MSB is mark indication in case of most full.
The LSB is mark indication in case of most empty.",
      Width => "8",
      Position => "7:0", # Excel Formula: =calc_position(F93,E94,TRUE)
      Type => "Config",
      UsedBy => "CGM_deq",
      DefaultValue => "h0",
    },
  },
  BuffersConsumptionLutForDeq102 => { #Structure Type: Reg; ArrayLength: 128; ArrayIndex: 102; ArrayLocationInName: 28;
    Name => "BuffersConsumptionLutForDeq[128]",
    RegMem => "Reg",
    Address => "197",
    Description => "LUT for dequeue marking in VOQ-CGM based on Buffer Consumption.
Index in Array is {Profile,BufferAvailableLevel}
Profile is 5 bits
BufferAvailableLevel is quantized to 2 bits.",
    Width => "8", # Excel Formula: =calc_reg_width(E94:E94,F94)
    Type => "Config",
    AdditionalInfo => "PackArrayToBus",
    Comments => "VOQ_CGM
CGM Deq Marking logic implemented in FF.
Address is {VOQ_PROFILE,Buffer_pool_available_level}
5 + 2 = 7
Buffer_voq_size_level selects offset out of 8.",
    ArrayLength => "128",
    ArrayIndex => "102",
    DeqBufferCongestionMark102 => { #Structure Type: RegField; ArrayLength: 128; ArrayIndex: 102; ArrayLocationInName: 24;
      Name => "DeqBufferCongestionMark[n]",
      RegMem => "RegField",
      Description => "Fill level of VOQ in buffers selects between the 8 values for a given {Profile,BufferAvailableLevel} pair.
The MSB is mark indication in case of most full.
The LSB is mark indication in case of most empty.",
      Width => "8",
      Position => "7:0", # Excel Formula: =calc_position(F93,E94,TRUE)
      Type => "Config",
      UsedBy => "CGM_deq",
      DefaultValue => "h0",
    },
  },
  BuffersConsumptionLutForDeq103 => { #Structure Type: Reg; ArrayLength: 128; ArrayIndex: 103; ArrayLocationInName: 28;
    Name => "BuffersConsumptionLutForDeq[128]",
    RegMem => "Reg",
    Address => "198",
    Description => "LUT for dequeue marking in VOQ-CGM based on Buffer Consumption.
Index in Array is {Profile,BufferAvailableLevel}
Profile is 5 bits
BufferAvailableLevel is quantized to 2 bits.",
    Width => "8", # Excel Formula: =calc_reg_width(E94:E94,F94)
    Type => "Config",
    AdditionalInfo => "PackArrayToBus",
    Comments => "VOQ_CGM
CGM Deq Marking logic implemented in FF.
Address is {VOQ_PROFILE,Buffer_pool_available_level}
5 + 2 = 7
Buffer_voq_size_level selects offset out of 8.",
    ArrayLength => "128",
    ArrayIndex => "103",
    DeqBufferCongestionMark103 => { #Structure Type: RegField; ArrayLength: 128; ArrayIndex: 103; ArrayLocationInName: 24;
      Name => "DeqBufferCongestionMark[n]",
      RegMem => "RegField",
      Description => "Fill level of VOQ in buffers selects between the 8 values for a given {Profile,BufferAvailableLevel} pair.
The MSB is mark indication in case of most full.
The LSB is mark indication in case of most empty.",
      Width => "8",
      Position => "7:0", # Excel Formula: =calc_position(F93,E94,TRUE)
      Type => "Config",
      UsedBy => "CGM_deq",
      DefaultValue => "h0",
    },
  },
  BuffersConsumptionLutForDeq104 => { #Structure Type: Reg; ArrayLength: 128; ArrayIndex: 104; ArrayLocationInName: 28;
    Name => "BuffersConsumptionLutForDeq[128]",
    RegMem => "Reg",
    Address => "199",
    Description => "LUT for dequeue marking in VOQ-CGM based on Buffer Consumption.
Index in Array is {Profile,BufferAvailableLevel}
Profile is 5 bits
BufferAvailableLevel is quantized to 2 bits.",
    Width => "8", # Excel Formula: =calc_reg_width(E94:E94,F94)
    Type => "Config",
    AdditionalInfo => "PackArrayToBus",
    Comments => "VOQ_CGM
CGM Deq Marking logic implemented in FF.
Address is {VOQ_PROFILE,Buffer_pool_available_level}
5 + 2 = 7
Buffer_voq_size_level selects offset out of 8.",
    ArrayLength => "128",
    ArrayIndex => "104",
    DeqBufferCongestionMark104 => { #Structure Type: RegField; ArrayLength: 128; ArrayIndex: 104; ArrayLocationInName: 24;
      Name => "DeqBufferCongestionMark[n]",
      RegMem => "RegField",
      Description => "Fill level of VOQ in buffers selects between the 8 values for a given {Profile,BufferAvailableLevel} pair.
The MSB is mark indication in case of most full.
The LSB is mark indication in case of most empty.",
      Width => "8",
      Position => "7:0", # Excel Formula: =calc_position(F93,E94,TRUE)
      Type => "Config",
      UsedBy => "CGM_deq",
      DefaultValue => "h0",
    },
  },
  BuffersConsumptionLutForDeq105 => { #Structure Type: Reg; ArrayLength: 128; ArrayIndex: 105; ArrayLocationInName: 28;
    Name => "BuffersConsumptionLutForDeq[128]",
    RegMem => "Reg",
    Address => "19A",
    Description => "LUT for dequeue marking in VOQ-CGM based on Buffer Consumption.
Index in Array is {Profile,BufferAvailableLevel}
Profile is 5 bits
BufferAvailableLevel is quantized to 2 bits.",
    Width => "8", # Excel Formula: =calc_reg_width(E94:E94,F94)
    Type => "Config",
    AdditionalInfo => "PackArrayToBus",
    Comments => "VOQ_CGM
CGM Deq Marking logic implemented in FF.
Address is {VOQ_PROFILE,Buffer_pool_available_level}
5 + 2 = 7
Buffer_voq_size_level selects offset out of 8.",
    ArrayLength => "128",
    ArrayIndex => "105",
    DeqBufferCongestionMark105 => { #Structure Type: RegField; ArrayLength: 128; ArrayIndex: 105; ArrayLocationInName: 24;
      Name => "DeqBufferCongestionMark[n]",
      RegMem => "RegField",
      Description => "Fill level of VOQ in buffers selects between the 8 values for a given {Profile,BufferAvailableLevel} pair.
The MSB is mark indication in case of most full.
The LSB is mark indication in case of most empty.",
      Width => "8",
      Position => "7:0", # Excel Formula: =calc_position(F93,E94,TRUE)
      Type => "Config",
      UsedBy => "CGM_deq",
      DefaultValue => "h0",
    },
  },
  BuffersConsumptionLutForDeq106 => { #Structure Type: Reg; ArrayLength: 128; ArrayIndex: 106; ArrayLocationInName: 28;
    Name => "BuffersConsumptionLutForDeq[128]",
    RegMem => "Reg",
    Address => "19B",
    Description => "LUT for dequeue marking in VOQ-CGM based on Buffer Consumption.
Index in Array is {Profile,BufferAvailableLevel}
Profile is 5 bits
BufferAvailableLevel is quantized to 2 bits.",
    Width => "8", # Excel Formula: =calc_reg_width(E94:E94,F94)
    Type => "Config",
    AdditionalInfo => "PackArrayToBus",
    Comments => "VOQ_CGM
CGM Deq Marking logic implemented in FF.
Address is {VOQ_PROFILE,Buffer_pool_available_level}
5 + 2 = 7
Buffer_voq_size_level selects offset out of 8.",
    ArrayLength => "128",
    ArrayIndex => "106",
    DeqBufferCongestionMark106 => { #Structure Type: RegField; ArrayLength: 128; ArrayIndex: 106; ArrayLocationInName: 24;
      Name => "DeqBufferCongestionMark[n]",
      RegMem => "RegField",
      Description => "Fill level of VOQ in buffers selects between the 8 values for a given {Profile,BufferAvailableLevel} pair.
The MSB is mark indication in case of most full.
The LSB is mark indication in case of most empty.",
      Width => "8",
      Position => "7:0", # Excel Formula: =calc_position(F93,E94,TRUE)
      Type => "Config",
      UsedBy => "CGM_deq",
      DefaultValue => "h0",
    },
  },
  BuffersConsumptionLutForDeq107 => { #Structure Type: Reg; ArrayLength: 128; ArrayIndex: 107; ArrayLocationInName: 28;
    Name => "BuffersConsumptionLutForDeq[128]",
    RegMem => "Reg",
    Address => "19C",
    Description => "LUT for dequeue marking in VOQ-CGM based on Buffer Consumption.
Index in Array is {Profile,BufferAvailableLevel}
Profile is 5 bits
BufferAvailableLevel is quantized to 2 bits.",
    Width => "8", # Excel Formula: =calc_reg_width(E94:E94,F94)
    Type => "Config",
    AdditionalInfo => "PackArrayToBus",
    Comments => "VOQ_CGM
CGM Deq Marking logic implemented in FF.
Address is {VOQ_PROFILE,Buffer_pool_available_level}
5 + 2 = 7
Buffer_voq_size_level selects offset out of 8.",
    ArrayLength => "128",
    ArrayIndex => "107",
    DeqBufferCongestionMark107 => { #Structure Type: RegField; ArrayLength: 128; ArrayIndex: 107; ArrayLocationInName: 24;
      Name => "DeqBufferCongestionMark[n]",
      RegMem => "RegField",
      Description => "Fill level of VOQ in buffers selects between the 8 values for a given {Profile,BufferAvailableLevel} pair.
The MSB is mark indication in case of most full.
The LSB is mark indication in case of most empty.",
      Width => "8",
      Position => "7:0", # Excel Formula: =calc_position(F93,E94,TRUE)
      Type => "Config",
      UsedBy => "CGM_deq",
      DefaultValue => "h0",
    },
  },
  BuffersConsumptionLutForDeq108 => { #Structure Type: Reg; ArrayLength: 128; ArrayIndex: 108; ArrayLocationInName: 28;
    Name => "BuffersConsumptionLutForDeq[128]",
    RegMem => "Reg",
    Address => "19D",
    Description => "LUT for dequeue marking in VOQ-CGM based on Buffer Consumption.
Index in Array is {Profile,BufferAvailableLevel}
Profile is 5 bits
BufferAvailableLevel is quantized to 2 bits.",
    Width => "8", # Excel Formula: =calc_reg_width(E94:E94,F94)
    Type => "Config",
    AdditionalInfo => "PackArrayToBus",
    Comments => "VOQ_CGM
CGM Deq Marking logic implemented in FF.
Address is {VOQ_PROFILE,Buffer_pool_available_level}
5 + 2 = 7
Buffer_voq_size_level selects offset out of 8.",
    ArrayLength => "128",
    ArrayIndex => "108",
    DeqBufferCongestionMark108 => { #Structure Type: RegField; ArrayLength: 128; ArrayIndex: 108; ArrayLocationInName: 24;
      Name => "DeqBufferCongestionMark[n]",
      RegMem => "RegField",
      Description => "Fill level of VOQ in buffers selects between the 8 values for a given {Profile,BufferAvailableLevel} pair.
The MSB is mark indication in case of most full.
The LSB is mark indication in case of most empty.",
      Width => "8",
      Position => "7:0", # Excel Formula: =calc_position(F93,E94,TRUE)
      Type => "Config",
      UsedBy => "CGM_deq",
      DefaultValue => "h0",
    },
  },
  BuffersConsumptionLutForDeq109 => { #Structure Type: Reg; ArrayLength: 128; ArrayIndex: 109; ArrayLocationInName: 28;
    Name => "BuffersConsumptionLutForDeq[128]",
    RegMem => "Reg",
    Address => "19E",
    Description => "LUT for dequeue marking in VOQ-CGM based on Buffer Consumption.
Index in Array is {Profile,BufferAvailableLevel}
Profile is 5 bits
BufferAvailableLevel is quantized to 2 bits.",
    Width => "8", # Excel Formula: =calc_reg_width(E94:E94,F94)
    Type => "Config",
    AdditionalInfo => "PackArrayToBus",
    Comments => "VOQ_CGM
CGM Deq Marking logic implemented in FF.
Address is {VOQ_PROFILE,Buffer_pool_available_level}
5 + 2 = 7
Buffer_voq_size_level selects offset out of 8.",
    ArrayLength => "128",
    ArrayIndex => "109",
    DeqBufferCongestionMark109 => { #Structure Type: RegField; ArrayLength: 128; ArrayIndex: 109; ArrayLocationInName: 24;
      Name => "DeqBufferCongestionMark[n]",
      RegMem => "RegField",
      Description => "Fill level of VOQ in buffers selects between the 8 values for a given {Profile,BufferAvailableLevel} pair.
The MSB is mark indication in case of most full.
The LSB is mark indication in case of most empty.",
      Width => "8",
      Position => "7:0", # Excel Formula: =calc_position(F93,E94,TRUE)
      Type => "Config",
      UsedBy => "CGM_deq",
      DefaultValue => "h0",
    },
  },
  BuffersConsumptionLutForDeq110 => { #Structure Type: Reg; ArrayLength: 128; ArrayIndex: 110; ArrayLocationInName: 28;
    Name => "BuffersConsumptionLutForDeq[128]",
    RegMem => "Reg",
    Address => "19F",
    Description => "LUT for dequeue marking in VOQ-CGM based on Buffer Consumption.
Index in Array is {Profile,BufferAvailableLevel}
Profile is 5 bits
BufferAvailableLevel is quantized to 2 bits.",
    Width => "8", # Excel Formula: =calc_reg_width(E94:E94,F94)
    Type => "Config",
    AdditionalInfo => "PackArrayToBus",
    Comments => "VOQ_CGM
CGM Deq Marking logic implemented in FF.
Address is {VOQ_PROFILE,Buffer_pool_available_level}
5 + 2 = 7
Buffer_voq_size_level selects offset out of 8.",
    ArrayLength => "128",
    ArrayIndex => "110",
    DeqBufferCongestionMark110 => { #Structure Type: RegField; ArrayLength: 128; ArrayIndex: 110; ArrayLocationInName: 24;
      Name => "DeqBufferCongestionMark[n]",
      RegMem => "RegField",
      Description => "Fill level of VOQ in buffers selects between the 8 values for a given {Profile,BufferAvailableLevel} pair.
The MSB is mark indication in case of most full.
The LSB is mark indication in case of most empty.",
      Width => "8",
      Position => "7:0", # Excel Formula: =calc_position(F93,E94,TRUE)
      Type => "Config",
      UsedBy => "CGM_deq",
      DefaultValue => "h0",
    },
  },
  BuffersConsumptionLutForDeq111 => { #Structure Type: Reg; ArrayLength: 128; ArrayIndex: 111; ArrayLocationInName: 28;
    Name => "BuffersConsumptionLutForDeq[128]",
    RegMem => "Reg",
    Address => "1A0",
    Description => "LUT for dequeue marking in VOQ-CGM based on Buffer Consumption.
Index in Array is {Profile,BufferAvailableLevel}
Profile is 5 bits
BufferAvailableLevel is quantized to 2 bits.",
    Width => "8", # Excel Formula: =calc_reg_width(E94:E94,F94)
    Type => "Config",
    AdditionalInfo => "PackArrayToBus",
    Comments => "VOQ_CGM
CGM Deq Marking logic implemented in FF.
Address is {VOQ_PROFILE,Buffer_pool_available_level}
5 + 2 = 7
Buffer_voq_size_level selects offset out of 8.",
    ArrayLength => "128",
    ArrayIndex => "111",
    DeqBufferCongestionMark111 => { #Structure Type: RegField; ArrayLength: 128; ArrayIndex: 111; ArrayLocationInName: 24;
      Name => "DeqBufferCongestionMark[n]",
      RegMem => "RegField",
      Description => "Fill level of VOQ in buffers selects between the 8 values for a given {Profile,BufferAvailableLevel} pair.
The MSB is mark indication in case of most full.
The LSB is mark indication in case of most empty.",
      Width => "8",
      Position => "7:0", # Excel Formula: =calc_position(F93,E94,TRUE)
      Type => "Config",
      UsedBy => "CGM_deq",
      DefaultValue => "h0",
    },
  },
  BuffersConsumptionLutForDeq112 => { #Structure Type: Reg; ArrayLength: 128; ArrayIndex: 112; ArrayLocationInName: 28;
    Name => "BuffersConsumptionLutForDeq[128]",
    RegMem => "Reg",
    Address => "1A1",
    Description => "LUT for dequeue marking in VOQ-CGM based on Buffer Consumption.
Index in Array is {Profile,BufferAvailableLevel}
Profile is 5 bits
BufferAvailableLevel is quantized to 2 bits.",
    Width => "8", # Excel Formula: =calc_reg_width(E94:E94,F94)
    Type => "Config",
    AdditionalInfo => "PackArrayToBus",
    Comments => "VOQ_CGM
CGM Deq Marking logic implemented in FF.
Address is {VOQ_PROFILE,Buffer_pool_available_level}
5 + 2 = 7
Buffer_voq_size_level selects offset out of 8.",
    ArrayLength => "128",
    ArrayIndex => "112",
    DeqBufferCongestionMark112 => { #Structure Type: RegField; ArrayLength: 128; ArrayIndex: 112; ArrayLocationInName: 24;
      Name => "DeqBufferCongestionMark[n]",
      RegMem => "RegField",
      Description => "Fill level of VOQ in buffers selects between the 8 values for a given {Profile,BufferAvailableLevel} pair.
The MSB is mark indication in case of most full.
The LSB is mark indication in case of most empty.",
      Width => "8",
      Position => "7:0", # Excel Formula: =calc_position(F93,E94,TRUE)
      Type => "Config",
      UsedBy => "CGM_deq",
      DefaultValue => "h0",
    },
  },
  BuffersConsumptionLutForDeq113 => { #Structure Type: Reg; ArrayLength: 128; ArrayIndex: 113; ArrayLocationInName: 28;
    Name => "BuffersConsumptionLutForDeq[128]",
    RegMem => "Reg",
    Address => "1A2",
    Description => "LUT for dequeue marking in VOQ-CGM based on Buffer Consumption.
Index in Array is {Profile,BufferAvailableLevel}
Profile is 5 bits
BufferAvailableLevel is quantized to 2 bits.",
    Width => "8", # Excel Formula: =calc_reg_width(E94:E94,F94)
    Type => "Config",
    AdditionalInfo => "PackArrayToBus",
    Comments => "VOQ_CGM
CGM Deq Marking logic implemented in FF.
Address is {VOQ_PROFILE,Buffer_pool_available_level}
5 + 2 = 7
Buffer_voq_size_level selects offset out of 8.",
    ArrayLength => "128",
    ArrayIndex => "113",
    DeqBufferCongestionMark113 => { #Structure Type: RegField; ArrayLength: 128; ArrayIndex: 113; ArrayLocationInName: 24;
      Name => "DeqBufferCongestionMark[n]",
      RegMem => "RegField",
      Description => "Fill level of VOQ in buffers selects between the 8 values for a given {Profile,BufferAvailableLevel} pair.
The MSB is mark indication in case of most full.
The LSB is mark indication in case of most empty.",
      Width => "8",
      Position => "7:0", # Excel Formula: =calc_position(F93,E94,TRUE)
      Type => "Config",
      UsedBy => "CGM_deq",
      DefaultValue => "h0",
    },
  },
  BuffersConsumptionLutForDeq114 => { #Structure Type: Reg; ArrayLength: 128; ArrayIndex: 114; ArrayLocationInName: 28;
    Name => "BuffersConsumptionLutForDeq[128]",
    RegMem => "Reg",
    Address => "1A3",
    Description => "LUT for dequeue marking in VOQ-CGM based on Buffer Consumption.
Index in Array is {Profile,BufferAvailableLevel}
Profile is 5 bits
BufferAvailableLevel is quantized to 2 bits.",
    Width => "8", # Excel Formula: =calc_reg_width(E94:E94,F94)
    Type => "Config",
    AdditionalInfo => "PackArrayToBus",
    Comments => "VOQ_CGM
CGM Deq Marking logic implemented in FF.
Address is {VOQ_PROFILE,Buffer_pool_available_level}
5 + 2 = 7
Buffer_voq_size_level selects offset out of 8.",
    ArrayLength => "128",
    ArrayIndex => "114",
    DeqBufferCongestionMark114 => { #Structure Type: RegField; ArrayLength: 128; ArrayIndex: 114; ArrayLocationInName: 24;
      Name => "DeqBufferCongestionMark[n]",
      RegMem => "RegField",
      Description => "Fill level of VOQ in buffers selects between the 8 values for a given {Profile,BufferAvailableLevel} pair.
The MSB is mark indication in case of most full.
The LSB is mark indication in case of most empty.",
      Width => "8",
      Position => "7:0", # Excel Formula: =calc_position(F93,E94,TRUE)
      Type => "Config",
      UsedBy => "CGM_deq",
      DefaultValue => "h0",
    },
  },
  BuffersConsumptionLutForDeq115 => { #Structure Type: Reg; ArrayLength: 128; ArrayIndex: 115; ArrayLocationInName: 28;
    Name => "BuffersConsumptionLutForDeq[128]",
    RegMem => "Reg",
    Address => "1A4",
    Description => "LUT for dequeue marking in VOQ-CGM based on Buffer Consumption.
Index in Array is {Profile,BufferAvailableLevel}
Profile is 5 bits
BufferAvailableLevel is quantized to 2 bits.",
    Width => "8", # Excel Formula: =calc_reg_width(E94:E94,F94)
    Type => "Config",
    AdditionalInfo => "PackArrayToBus",
    Comments => "VOQ_CGM
CGM Deq Marking logic implemented in FF.
Address is {VOQ_PROFILE,Buffer_pool_available_level}
5 + 2 = 7
Buffer_voq_size_level selects offset out of 8.",
    ArrayLength => "128",
    ArrayIndex => "115",
    DeqBufferCongestionMark115 => { #Structure Type: RegField; ArrayLength: 128; ArrayIndex: 115; ArrayLocationInName: 24;
      Name => "DeqBufferCongestionMark[n]",
      RegMem => "RegField",
      Description => "Fill level of VOQ in buffers selects between the 8 values for a given {Profile,BufferAvailableLevel} pair.
The MSB is mark indication in case of most full.
The LSB is mark indication in case of most empty.",
      Width => "8",
      Position => "7:0", # Excel Formula: =calc_position(F93,E94,TRUE)
      Type => "Config",
      UsedBy => "CGM_deq",
      DefaultValue => "h0",
    },
  },
  BuffersConsumptionLutForDeq116 => { #Structure Type: Reg; ArrayLength: 128; ArrayIndex: 116; ArrayLocationInName: 28;
    Name => "BuffersConsumptionLutForDeq[128]",
    RegMem => "Reg",
    Address => "1A5",
    Description => "LUT for dequeue marking in VOQ-CGM based on Buffer Consumption.
Index in Array is {Profile,BufferAvailableLevel}
Profile is 5 bits
BufferAvailableLevel is quantized to 2 bits.",
    Width => "8", # Excel Formula: =calc_reg_width(E94:E94,F94)
    Type => "Config",
    AdditionalInfo => "PackArrayToBus",
    Comments => "VOQ_CGM
CGM Deq Marking logic implemented in FF.
Address is {VOQ_PROFILE,Buffer_pool_available_level}
5 + 2 = 7
Buffer_voq_size_level selects offset out of 8.",
    ArrayLength => "128",
    ArrayIndex => "116",
    DeqBufferCongestionMark116 => { #Structure Type: RegField; ArrayLength: 128; ArrayIndex: 116; ArrayLocationInName: 24;
      Name => "DeqBufferCongestionMark[n]",
      RegMem => "RegField",
      Description => "Fill level of VOQ in buffers selects between the 8 values for a given {Profile,BufferAvailableLevel} pair.
The MSB is mark indication in case of most full.
The LSB is mark indication in case of most empty.",
      Width => "8",
      Position => "7:0", # Excel Formula: =calc_position(F93,E94,TRUE)
      Type => "Config",
      UsedBy => "CGM_deq",
      DefaultValue => "h0",
    },
  },
  BuffersConsumptionLutForDeq117 => { #Structure Type: Reg; ArrayLength: 128; ArrayIndex: 117; ArrayLocationInName: 28;
    Name => "BuffersConsumptionLutForDeq[128]",
    RegMem => "Reg",
    Address => "1A6",
    Description => "LUT for dequeue marking in VOQ-CGM based on Buffer Consumption.
Index in Array is {Profile,BufferAvailableLevel}
Profile is 5 bits
BufferAvailableLevel is quantized to 2 bits.",
    Width => "8", # Excel Formula: =calc_reg_width(E94:E94,F94)
    Type => "Config",
    AdditionalInfo => "PackArrayToBus",
    Comments => "VOQ_CGM
CGM Deq Marking logic implemented in FF.
Address is {VOQ_PROFILE,Buffer_pool_available_level}
5 + 2 = 7
Buffer_voq_size_level selects offset out of 8.",
    ArrayLength => "128",
    ArrayIndex => "117",
    DeqBufferCongestionMark117 => { #Structure Type: RegField; ArrayLength: 128; ArrayIndex: 117; ArrayLocationInName: 24;
      Name => "DeqBufferCongestionMark[n]",
      RegMem => "RegField",
      Description => "Fill level of VOQ in buffers selects between the 8 values for a given {Profile,BufferAvailableLevel} pair.
The MSB is mark indication in case of most full.
The LSB is mark indication in case of most empty.",
      Width => "8",
      Position => "7:0", # Excel Formula: =calc_position(F93,E94,TRUE)
      Type => "Config",
      UsedBy => "CGM_deq",
      DefaultValue => "h0",
    },
  },
  BuffersConsumptionLutForDeq118 => { #Structure Type: Reg; ArrayLength: 128; ArrayIndex: 118; ArrayLocationInName: 28;
    Name => "BuffersConsumptionLutForDeq[128]",
    RegMem => "Reg",
    Address => "1A7",
    Description => "LUT for dequeue marking in VOQ-CGM based on Buffer Consumption.
Index in Array is {Profile,BufferAvailableLevel}
Profile is 5 bits
BufferAvailableLevel is quantized to 2 bits.",
    Width => "8", # Excel Formula: =calc_reg_width(E94:E94,F94)
    Type => "Config",
    AdditionalInfo => "PackArrayToBus",
    Comments => "VOQ_CGM
CGM Deq Marking logic implemented in FF.
Address is {VOQ_PROFILE,Buffer_pool_available_level}
5 + 2 = 7
Buffer_voq_size_level selects offset out of 8.",
    ArrayLength => "128",
    ArrayIndex => "118",
    DeqBufferCongestionMark118 => { #Structure Type: RegField; ArrayLength: 128; ArrayIndex: 118; ArrayLocationInName: 24;
      Name => "DeqBufferCongestionMark[n]",
      RegMem => "RegField",
      Description => "Fill level of VOQ in buffers selects between the 8 values for a given {Profile,BufferAvailableLevel} pair.
The MSB is mark indication in case of most full.
The LSB is mark indication in case of most empty.",
      Width => "8",
      Position => "7:0", # Excel Formula: =calc_position(F93,E94,TRUE)
      Type => "Config",
      UsedBy => "CGM_deq",
      DefaultValue => "h0",
    },
  },
  BuffersConsumptionLutForDeq119 => { #Structure Type: Reg; ArrayLength: 128; ArrayIndex: 119; ArrayLocationInName: 28;
    Name => "BuffersConsumptionLutForDeq[128]",
    RegMem => "Reg",
    Address => "1A8",
    Description => "LUT for dequeue marking in VOQ-CGM based on Buffer Consumption.
Index in Array is {Profile,BufferAvailableLevel}
Profile is 5 bits
BufferAvailableLevel is quantized to 2 bits.",
    Width => "8", # Excel Formula: =calc_reg_width(E94:E94,F94)
    Type => "Config",
    AdditionalInfo => "PackArrayToBus",
    Comments => "VOQ_CGM
CGM Deq Marking logic implemented in FF.
Address is {VOQ_PROFILE,Buffer_pool_available_level}
5 + 2 = 7
Buffer_voq_size_level selects offset out of 8.",
    ArrayLength => "128",
    ArrayIndex => "119",
    DeqBufferCongestionMark119 => { #Structure Type: RegField; ArrayLength: 128; ArrayIndex: 119; ArrayLocationInName: 24;
      Name => "DeqBufferCongestionMark[n]",
      RegMem => "RegField",
      Description => "Fill level of VOQ in buffers selects between the 8 values for a given {Profile,BufferAvailableLevel} pair.
The MSB is mark indication in case of most full.
The LSB is mark indication in case of most empty.",
      Width => "8",
      Position => "7:0", # Excel Formula: =calc_position(F93,E94,TRUE)
      Type => "Config",
      UsedBy => "CGM_deq",
      DefaultValue => "h0",
    },
  },
  BuffersConsumptionLutForDeq120 => { #Structure Type: Reg; ArrayLength: 128; ArrayIndex: 120; ArrayLocationInName: 28;
    Name => "BuffersConsumptionLutForDeq[128]",
    RegMem => "Reg",
    Address => "1A9",
    Description => "LUT for dequeue marking in VOQ-CGM based on Buffer Consumption.
Index in Array is {Profile,BufferAvailableLevel}
Profile is 5 bits
BufferAvailableLevel is quantized to 2 bits.",
    Width => "8", # Excel Formula: =calc_reg_width(E94:E94,F94)
    Type => "Config",
    AdditionalInfo => "PackArrayToBus",
    Comments => "VOQ_CGM
CGM Deq Marking logic implemented in FF.
Address is {VOQ_PROFILE,Buffer_pool_available_level}
5 + 2 = 7
Buffer_voq_size_level selects offset out of 8.",
    ArrayLength => "128",
    ArrayIndex => "120",
    DeqBufferCongestionMark120 => { #Structure Type: RegField; ArrayLength: 128; ArrayIndex: 120; ArrayLocationInName: 24;
      Name => "DeqBufferCongestionMark[n]",
      RegMem => "RegField",
      Description => "Fill level of VOQ in buffers selects between the 8 values for a given {Profile,BufferAvailableLevel} pair.
The MSB is mark indication in case of most full.
The LSB is mark indication in case of most empty.",
      Width => "8",
      Position => "7:0", # Excel Formula: =calc_position(F93,E94,TRUE)
      Type => "Config",
      UsedBy => "CGM_deq",
      DefaultValue => "h0",
    },
  },
  BuffersConsumptionLutForDeq121 => { #Structure Type: Reg; ArrayLength: 128; ArrayIndex: 121; ArrayLocationInName: 28;
    Name => "BuffersConsumptionLutForDeq[128]",
    RegMem => "Reg",
    Address => "1AA",
    Description => "LUT for dequeue marking in VOQ-CGM based on Buffer Consumption.
Index in Array is {Profile,BufferAvailableLevel}
Profile is 5 bits
BufferAvailableLevel is quantized to 2 bits.",
    Width => "8", # Excel Formula: =calc_reg_width(E94:E94,F94)
    Type => "Config",
    AdditionalInfo => "PackArrayToBus",
    Comments => "VOQ_CGM
CGM Deq Marking logic implemented in FF.
Address is {VOQ_PROFILE,Buffer_pool_available_level}
5 + 2 = 7
Buffer_voq_size_level selects offset out of 8.",
    ArrayLength => "128",
    ArrayIndex => "121",
    DeqBufferCongestionMark121 => { #Structure Type: RegField; ArrayLength: 128; ArrayIndex: 121; ArrayLocationInName: 24;
      Name => "DeqBufferCongestionMark[n]",
      RegMem => "RegField",
      Description => "Fill level of VOQ in buffers selects between the 8 values for a given {Profile,BufferAvailableLevel} pair.
The MSB is mark indication in case of most full.
The LSB is mark indication in case of most empty.",
      Width => "8",
      Position => "7:0", # Excel Formula: =calc_position(F93,E94,TRUE)
      Type => "Config",
      UsedBy => "CGM_deq",
      DefaultValue => "h0",
    },
  },
  BuffersConsumptionLutForDeq122 => { #Structure Type: Reg; ArrayLength: 128; ArrayIndex: 122; ArrayLocationInName: 28;
    Name => "BuffersConsumptionLutForDeq[128]",
    RegMem => "Reg",
    Address => "1AB",
    Description => "LUT for dequeue marking in VOQ-CGM based on Buffer Consumption.
Index in Array is {Profile,BufferAvailableLevel}
Profile is 5 bits
BufferAvailableLevel is quantized to 2 bits.",
    Width => "8", # Excel Formula: =calc_reg_width(E94:E94,F94)
    Type => "Config",
    AdditionalInfo => "PackArrayToBus",
    Comments => "VOQ_CGM
CGM Deq Marking logic implemented in FF.
Address is {VOQ_PROFILE,Buffer_pool_available_level}
5 + 2 = 7
Buffer_voq_size_level selects offset out of 8.",
    ArrayLength => "128",
    ArrayIndex => "122",
    DeqBufferCongestionMark122 => { #Structure Type: RegField; ArrayLength: 128; ArrayIndex: 122; ArrayLocationInName: 24;
      Name => "DeqBufferCongestionMark[n]",
      RegMem => "RegField",
      Description => "Fill level of VOQ in buffers selects between the 8 values for a given {Profile,BufferAvailableLevel} pair.
The MSB is mark indication in case of most full.
The LSB is mark indication in case of most empty.",
      Width => "8",
      Position => "7:0", # Excel Formula: =calc_position(F93,E94,TRUE)
      Type => "Config",
      UsedBy => "CGM_deq",
      DefaultValue => "h0",
    },
  },
  BuffersConsumptionLutForDeq123 => { #Structure Type: Reg; ArrayLength: 128; ArrayIndex: 123; ArrayLocationInName: 28;
    Name => "BuffersConsumptionLutForDeq[128]",
    RegMem => "Reg",
    Address => "1AC",
    Description => "LUT for dequeue marking in VOQ-CGM based on Buffer Consumption.
Index in Array is {Profile,BufferAvailableLevel}
Profile is 5 bits
BufferAvailableLevel is quantized to 2 bits.",
    Width => "8", # Excel Formula: =calc_reg_width(E94:E94,F94)
    Type => "Config",
    AdditionalInfo => "PackArrayToBus",
    Comments => "VOQ_CGM
CGM Deq Marking logic implemented in FF.
Address is {VOQ_PROFILE,Buffer_pool_available_level}
5 + 2 = 7
Buffer_voq_size_level selects offset out of 8.",
    ArrayLength => "128",
    ArrayIndex => "123",
    DeqBufferCongestionMark123 => { #Structure Type: RegField; ArrayLength: 128; ArrayIndex: 123; ArrayLocationInName: 24;
      Name => "DeqBufferCongestionMark[n]",
      RegMem => "RegField",
      Description => "Fill level of VOQ in buffers selects between the 8 values for a given {Profile,BufferAvailableLevel} pair.
The MSB is mark indication in case of most full.
The LSB is mark indication in case of most empty.",
      Width => "8",
      Position => "7:0", # Excel Formula: =calc_position(F93,E94,TRUE)
      Type => "Config",
      UsedBy => "CGM_deq",
      DefaultValue => "h0",
    },
  },
  BuffersConsumptionLutForDeq124 => { #Structure Type: Reg; ArrayLength: 128; ArrayIndex: 124; ArrayLocationInName: 28;
    Name => "BuffersConsumptionLutForDeq[128]",
    RegMem => "Reg",
    Address => "1AD",
    Description => "LUT for dequeue marking in VOQ-CGM based on Buffer Consumption.
Index in Array is {Profile,BufferAvailableLevel}
Profile is 5 bits
BufferAvailableLevel is quantized to 2 bits.",
    Width => "8", # Excel Formula: =calc_reg_width(E94:E94,F94)
    Type => "Config",
    AdditionalInfo => "PackArrayToBus",
    Comments => "VOQ_CGM
CGM Deq Marking logic implemented in FF.
Address is {VOQ_PROFILE,Buffer_pool_available_level}
5 + 2 = 7
Buffer_voq_size_level selects offset out of 8.",
    ArrayLength => "128",
    ArrayIndex => "124",
    DeqBufferCongestionMark124 => { #Structure Type: RegField; ArrayLength: 128; ArrayIndex: 124; ArrayLocationInName: 24;
      Name => "DeqBufferCongestionMark[n]",
      RegMem => "RegField",
      Description => "Fill level of VOQ in buffers selects between the 8 values for a given {Profile,BufferAvailableLevel} pair.
The MSB is mark indication in case of most full.
The LSB is mark indication in case of most empty.",
      Width => "8",
      Position => "7:0", # Excel Formula: =calc_position(F93,E94,TRUE)
      Type => "Config",
      UsedBy => "CGM_deq",
      DefaultValue => "h0",
    },
  },
  BuffersConsumptionLutForDeq125 => { #Structure Type: Reg; ArrayLength: 128; ArrayIndex: 125; ArrayLocationInName: 28;
    Name => "BuffersConsumptionLutForDeq[128]",
    RegMem => "Reg",
    Address => "1AE",
    Description => "LUT for dequeue marking in VOQ-CGM based on Buffer Consumption.
Index in Array is {Profile,BufferAvailableLevel}
Profile is 5 bits
BufferAvailableLevel is quantized to 2 bits.",
    Width => "8", # Excel Formula: =calc_reg_width(E94:E94,F94)
    Type => "Config",
    AdditionalInfo => "PackArrayToBus",
    Comments => "VOQ_CGM
CGM Deq Marking logic implemented in FF.
Address is {VOQ_PROFILE,Buffer_pool_available_level}
5 + 2 = 7
Buffer_voq_size_level selects offset out of 8.",
    ArrayLength => "128",
    ArrayIndex => "125",
    DeqBufferCongestionMark125 => { #Structure Type: RegField; ArrayLength: 128; ArrayIndex: 125; ArrayLocationInName: 24;
      Name => "DeqBufferCongestionMark[n]",
      RegMem => "RegField",
      Description => "Fill level of VOQ in buffers selects between the 8 values for a given {Profile,BufferAvailableLevel} pair.
The MSB is mark indication in case of most full.
The LSB is mark indication in case of most empty.",
      Width => "8",
      Position => "7:0", # Excel Formula: =calc_position(F93,E94,TRUE)
      Type => "Config",
      UsedBy => "CGM_deq",
      DefaultValue => "h0",
    },
  },
  BuffersConsumptionLutForDeq126 => { #Structure Type: Reg; ArrayLength: 128; ArrayIndex: 126; ArrayLocationInName: 28;
    Name => "BuffersConsumptionLutForDeq[128]",
    RegMem => "Reg",
    Address => "1AF",
    Description => "LUT for dequeue marking in VOQ-CGM based on Buffer Consumption.
Index in Array is {Profile,BufferAvailableLevel}
Profile is 5 bits
BufferAvailableLevel is quantized to 2 bits.",
    Width => "8", # Excel Formula: =calc_reg_width(E94:E94,F94)
    Type => "Config",
    AdditionalInfo => "PackArrayToBus",
    Comments => "VOQ_CGM
CGM Deq Marking logic implemented in FF.
Address is {VOQ_PROFILE,Buffer_pool_available_level}
5 + 2 = 7
Buffer_voq_size_level selects offset out of 8.",
    ArrayLength => "128",
    ArrayIndex => "126",
    DeqBufferCongestionMark126 => { #Structure Type: RegField; ArrayLength: 128; ArrayIndex: 126; ArrayLocationInName: 24;
      Name => "DeqBufferCongestionMark[n]",
      RegMem => "RegField",
      Description => "Fill level of VOQ in buffers selects between the 8 values for a given {Profile,BufferAvailableLevel} pair.
The MSB is mark indication in case of most full.
The LSB is mark indication in case of most empty.",
      Width => "8",
      Position => "7:0", # Excel Formula: =calc_position(F93,E94,TRUE)
      Type => "Config",
      UsedBy => "CGM_deq",
      DefaultValue => "h0",
    },
  },
  BuffersConsumptionLutForDeq127 => { #Structure Type: Reg; ArrayLength: 128; ArrayIndex: 127; ArrayLocationInName: 28;
    Name => "BuffersConsumptionLutForDeq[128]",
    RegMem => "Reg",
    Address => "1B0",
    Description => "LUT for dequeue marking in VOQ-CGM based on Buffer Consumption.
Index in Array is {Profile,BufferAvailableLevel}
Profile is 5 bits
BufferAvailableLevel is quantized to 2 bits.",
    Width => "8", # Excel Formula: =calc_reg_width(E94:E94,F94)
    Type => "Config",
    AdditionalInfo => "PackArrayToBus",
    Comments => "VOQ_CGM
CGM Deq Marking logic implemented in FF.
Address is {VOQ_PROFILE,Buffer_pool_available_level}
5 + 2 = 7
Buffer_voq_size_level selects offset out of 8.",
    ArrayLength => "128",
    ArrayIndex => "127",
    DeqBufferCongestionMark127 => { #Structure Type: RegField; ArrayLength: 128; ArrayIndex: 127; ArrayLocationInName: 24;
      Name => "DeqBufferCongestionMark[n]",
      RegMem => "RegField",
      Description => "Fill level of VOQ in buffers selects between the 8 values for a given {Profile,BufferAvailableLevel} pair.
The MSB is mark indication in case of most full.
The LSB is mark indication in case of most empty.",
      Width => "8",
      Position => "7:0", # Excel Formula: =calc_position(F93,E94,TRUE)
      Type => "Config",
      UsedBy => "CGM_deq",
      DefaultValue => "h0",
    },
  },
  PdConsumptionLutForDeq => { #Structure Type: Reg;
    Name => "PdConsumptionLutForDeq",
    RegMem => "Reg",
    Address => "1B1", # Excel Formula: =calc_reg_address(C93,A93,G93)
    Description => "LUT for dequeue marking in VOQ-CGM based on Pd Consumption.
Decision is taken from offset {Profile,PktAvailableLevel}
Profile is 5 bits
PktAvailableLevel is quantized to 2 bits.",
    Width => "128", # Excel Formula: =calc_reg_width(E96:E96,F96)
    Type => "Config",
    Comments => "VOQ_CGM",
    DeqPktCongestionMark => { #Structure Type: RegField;
      Name => "DeqPktCongestionMark",
      RegMem => "RegField",
      Description => "Mark decision is taken from offset {Profile,PktAvailableLevel} ",
      Width => "128", # Excel Formula: =calc_field_width_define("VOQ_CGM_NUM_OF_PROFILES")*4
      Position => "127:0", # Excel Formula: =calc_position(F95,E96,TRUE)
      Type => "Config",
      UsedBy => "CGM_deq",
      DefaultValue => "h0",
    },
  },
  VoqCgmAgingMachineCnf => { #Structure Type: Reg;
    Name => "VoqCgmAgingMachineCnf",
    RegMem => "Reg",
    Address => "1B2", # Excel Formula: =calc_reg_address(C95,A95,G95)
    Description => "ConfigRegisters for aging machine",
    Width => "7", # Excel Formula: =calc_reg_width(E98:E99,F99)
    Type => "Config",
    Comments => "VOQ_CGM",
    VoqCgmAgingStartOffset => { #Structure Type: RegField;
      Name => "VoqCgmAgingStartOffset",
      RegMem => "RegField",
      Description => "Triggers the aging machine scan when local time matches this value.
Local time is in 1us or 2us depending on PDVOQ configuration
The Scan takes ~4us.
This value must allow the scan to finish before the local time wraps around.",
      Width => "6", # Excel Formula: =calc_field_width_define("VOQ_CGM_ENQ_TIME_WIDTH")-2
      Position => "5:0", # Excel Formula: =calc_position(F97,E98,TRUE)
      Type => "Config",
      UsedBy => "cgm_aging",
      DefaultValue => "d50",
    },
    VoqCgmAgingDisable => { #Structure Type: RegField;
      Name => "VoqCgmAgingDisable",
      RegMem => "RegField",
      Description => "Disable aging machine altogether",
      Width => "1",
      Position => "6", # Excel Formula: =calc_position(F98,E99)
      Type => "Config",
      UsedBy => "cgm_aging",
      DefaultValue => "h0",
    },
  },
  VoqCgmEnqTimeFifoCfg => { #Structure Type: Reg;
    Name => "VoqCgmEnqTimeFifoCfg",
    RegMem => "Reg",
    Address => "1B3", # Excel Formula: =calc_reg_address(C97,A97,G97)
    Description => "Config Register for fifo that stores the enq time of a PD between read report and Deq Cmd ",
    Width => "1", # Excel Formula: =calc_reg_width(E101:E101,F101)
    Type => "Config",
    Comments => "VOQ_CGM",
    BypassEnqTimeFifo => { #Structure Type: RegField;
      Name => "BypassEnqTimeFifo",
      RegMem => "RegField",
      Description => "Bypass Fifo",
      Width => "1",
      Position => "0", # Excel Formula: =calc_position(F100,E101,TRUE)
      Type => "Config",
      UsedBy => "voq_cgm",
      DefaultValue => "b0",
      Comments => "Chicken Bit",
    },
  },
  VoqCgmChickenReg => { #Structure Type: Reg;
    Name => "VoqCgmChickenReg",
    RegMem => "Reg",
    Address => "1B4", # Excel Formula: =calc_reg_address(C100,A100,G100)
    Width => "3", # Excel Formula: =calc_reg_width(E103:E105,F105)
    Type => "Config",
    Comments => "VOQ_CGM",
    ChickenDramCgmUpdatesArb => { #Structure Type: RegField;
      Name => "ChickenDramCgmUpdatesArb",
      RegMem => "RegField",
      Description => "Only dram_cgm updates AdmissionResultDram table - that is no arbitration with dram context return",
      Width => "1",
      Position => "0", # Excel Formula: =calc_position(F102,E103,TRUE)
      Type => "Config",
      UsedBy => "voq_cgm",
      DefaultValue => "b0",
      Comments => "Chicken Bit",
    },
    ChickenQueueIsEvictedDis => { #Structure Type: RegField;
      Name => "ChickenQueueIsEvictedDis",
      RegMem => "RegField",
      Description => "Disable the coding of queue-is-evicted ",
      Width => "1",
      Position => "1", # Excel Formula: =calc_position(F103,E104)
      Type => "Config",
      UsedBy => "voq_cgm",
      DefaultValue => "b0",
      Comments => "Chicken Bit",
    },
    ChickenEnWredOnEvicted => { #Structure Type: RegField;
      Name => "ChickenEnWredOnEvicted",
      RegMem => "RegField",
      Description => "Enablw SMS Wred although the queue is evicted",
      Width => "1",
      Position => "2", # Excel Formula: =calc_position(F104,E105)
      Type => "Config",
      UsedBy => "voq_cgm",
      DefaultValue => "b0",
      Comments => "Chicken Bit",
    },
  },
  CgmProfile2EvictedProfile => { #Structure Type: Reg;
    Name => "CgmProfile2EvictedProfile",
    RegMem => "Reg",
    Address => "1B5", # Excel Formula: =calc_reg_address(C102,A102,G102)
    Description => "Reduce bit usage by mapping 5 bit CGM Profile to 2 bit Evicted Profile",
    Width => "64", # Excel Formula: =calc_reg_width(E107:E107,F107)
    Type => "Config",
    Comments => "VOQ_CGM",
    EvictedProfile => { #Structure Type: RegField;
      Name => "EvictedProfile",
      RegMem => "RegField",
      Description => "mapped profile from CGM profile",
      Width => "64", # Excel Formula: =2*32
      Position => "63:0", # Excel Formula: =calc_position(F106,E107,TRUE)
      Type => "Config",
      UsedBy => "voq_cgm",
      DefaultValue => "d0",
      ArrayItemWidth => "2",
    },
  },
  CongExpControl => { #Structure Type: Reg;
    Name => "CongExpControl",
    RegMem => "Reg",
    Address => "1B6", # Excel Formula: =calc_reg_address(C106,A106,G106)
    Description => "Congestion experienced control register",
    Width => "128", # Excel Formula: =calc_reg_width(E109:E109,F109)
    Type => "Config",
    CongExpPerProfileTh => { #Structure Type: RegField;
      Name => "CongExpPerProfileTh",
      RegMem => "RegField",
      Description => "Threshold (4-bit) per profile to set the congestion experienced bit based on the value of the congestion level",
      Width => "128", # Excel Formula: =32*4
      Position => "127:0", # Excel Formula: =calc_position(F108,E109,TRUE)
      Type => "Config",
      UsedBy => "voq_cgm",
      DefaultValue => "h8888_8888_8888_8888_8888_8888_8888_8888",
      ArrayItemWidth => "4",
    },
  },
  VoqCgmCfg => { #Structure Type: Reg;
    Name => "VoqCgmCfg",
    RegMem => "Reg",
    Address => "1B7", # Excel Formula: =calc_reg_address(C108,A108,G108)
    Width => "1", # Excel Formula: =calc_reg_width(E111:E111,F111)
    Type => "Config",
    UseTcInLut => { #Structure Type: RegField;
      Name => "UseTcInLut",
      RegMem => "RegField",
      Description => "Use 3 bit PD.TC instead of the 3 MSB of the Profile so that the value used is: {PD.TC[2:0], VOQ.Profile[1:0]}
This is done when accessing the below LUTs:
BuffersConsumptionLutForEnq
PdConsumptionLutForEnq
Disabled by default",
      Width => "1",
      Position => "0", # Excel Formula: =calc_position(F110,E111,TRUE)
      Type => "Config",
      UsedBy => "voq_cgm",
      DefaultValue => "h0",
      InitValueSa => "0",
      InitValueLcNwk => "0",
      InitValueLcFab => "1",
      InitValueFe => "1",
    },
  },
  TrapCfg => { #Structure Type: Reg;
    Name => "TrapCfg",
    RegMem => "Reg",
    Address => "1B8", # Excel Formula: =calc_reg_address(C110,A110,G110)
    Description => "Trap feature configuration register",
    Width => "344", # Excel Formula: =calc_reg_width(E113:E131,F131)
    Type => "Config",
    Comments => "VOQ_CGM",
    TrapContextNum => { #Structure Type: RegField;
      Name => "TrapContextNum",
      RegMem => "RegField",
      Description => "Statically mapped context for TRAP",
      Width => "12",
      Position => "11:0", # Excel Formula: =calc_position(F112,E113,TRUE)
      Type => "Config",
      UsedBy => "voq_cgm",
      DefaultValue => "hFFE",
    },
    TrapContextProfile => { #Structure Type: RegField;
      Name => "TrapContextProfile",
      RegMem => "RegField",
      Description => "Statically mapped profile for TRAP",
      Width => "5",
      Position => "16:12", # Excel Formula: =calc_position(F113,E114)
      Type => "Config",
      UsedBy => "voq_cgm",
      DefaultValue => "h1F",
    },
    TrapContextBufTh => { #Structure Type: RegField;
      Name => "TrapContextBufTh",
      RegMem => "RegField",
      Description => "Tail drop threshold in buffers for trap queue",
      Width => "14",
      Position => "30:17", # Excel Formula: =calc_position(F114,E115)
      Type => "Config",
      UsedBy => "voq_cgm",
      DefaultValue => "hFFE",
    },
    TrapContextPktTh => { #Structure Type: RegField;
      Name => "TrapContextPktTh",
      RegMem => "RegField",
      Description => "Tail drop threshold in packets for trap queue",
      Width => "14",
      Position => "44:31", # Excel Formula: =calc_position(F115,E116)
      Type => "Config",
      UsedBy => "voq_cgm",
      DefaultValue => "hFFE",
    },
    TrapBucketMode => { #Structure Type: RegField;
      Name => "TrapBucketMode",
      RegMem => "RegField",
      Description => "Select between packet rate limit and byte rate limit
0 - packet rate
1 - byte rate",
      Width => "1",
      Position => "45", # Excel Formula: =calc_position(F116,E117)
      Type => "Config",
      UsedBy => "voq_cgm",
      DefaultValue => "h0",
    },
    TrapBucketRate => { #Structure Type: RegField;
      Name => "TrapBucketRate",
      RegMem => "RegField",
      Description => "Trap token bucket increment rate ",
      Width => "24",
      Position => "69:46", # Excel Formula: =calc_position(F117,E118)
      Type => "Config",
      UsedBy => "voq_cgm",
      DefaultValue => "h00FFE",
    },
    TrapBucketMaxSize => { #Structure Type: RegField;
      Name => "TrapBucketMaxSize",
      RegMem => "RegField",
      Description => "Trap token bucket max size",
      Width => "24",
      Position => "93:70", # Excel Formula: =calc_position(F118,E119)
      Type => "Config",
      UsedBy => "voq_cgm",
      DefaultValue => "h200",
    },
    TrapBucketHighTh => { #Structure Type: RegField;
      Name => "TrapBucketHighTh",
      RegMem => "RegField",
      Description => "Trap token bucket high threshold",
      Width => "24",
      Position => "117:94", # Excel Formula: =calc_position(F119,E120)
      Type => "Config",
      UsedBy => "voq_cgm",
      DefaultValue => "h100",
    },
    TrapBucketTokenSize => { #Structure Type: RegField;
      Name => "TrapBucketTokenSize",
      RegMem => "RegField",
      Description => "Trap token bucket increment size
In case of packets should be 1
In case of bytes should be calculated from desired rate",
      Width => "14",
      Position => "131:118", # Excel Formula: =calc_position(F120,E121)
      Type => "Config",
      UsedBy => "voq_cgm",
      DefaultValue => "h1",
    },
    TrapProbabilityTh => { #Structure Type: RegField;
      Name => "TrapProbabilityTh",
      RegMem => "RegField",
      Description => "Probability threshold to enable trap in case of trap token bucket below threshold",
      Width => "16",
      Position => "147:132", # Excel Formula: =calc_position(F121,E122)
      Type => "Config",
      UsedBy => "voq_cgm",
      DefaultValue => "h00FF",
    },
    TrapProbabilityPdSize0Th => { #Structure Type: RegField;
      Name => "TrapProbabilityPdSize0Th",
      RegMem => "RegField",
      Description => "pkt mode prob when pd size < 128",
      Width => "16",
      Position => "163:148", # Excel Formula: =calc_position(F122,E123)
      Type => "Config",
      UsedBy => "voq_cgm",
      DefaultValue => "d100",
    },
    TrapProbabilityPdSize1Th => { #Structure Type: RegField;
      Name => "TrapProbabilityPdSize1Th",
      RegMem => "RegField",
      Description => "pkt mode prob when pd size > 127 & size < 256",
      Width => "16",
      Position => "179:164", # Excel Formula: =calc_position(F123,E124)
      Type => "Config",
      UsedBy => "voq_cgm",
      DefaultValue => "d200",
    },
    TrapProbabilityPdSize2Th => { #Structure Type: RegField;
      Name => "TrapProbabilityPdSize2Th",
      RegMem => "RegField",
      Description => "pkt mode prob when pd size > 255 & size < 512",
      Width => "16",
      Position => "195:180", # Excel Formula: =calc_position(F124,E125)
      Type => "Config",
      UsedBy => "voq_cgm",
      DefaultValue => "d300",
    },
    TrapProbabilityPdSize3Th => { #Structure Type: RegField;
      Name => "TrapProbabilityPdSize3Th",
      RegMem => "RegField",
      Description => "pkt mode prob when pd size > 511 & size < 1024",
      Width => "16",
      Position => "211:196", # Excel Formula: =calc_position(F125,E126)
      Type => "Config",
      UsedBy => "voq_cgm",
      DefaultValue => "d400",
    },
    TrapProbabilityPdSize4Th => { #Structure Type: RegField;
      Name => "TrapProbabilityPdSize4Th",
      RegMem => "RegField",
      Description => "pkt mode prob when pd size > 1023 size < 2K",
      Width => "16",
      Position => "227:212", # Excel Formula: =calc_position(F126,E127)
      Type => "Config",
      UsedBy => "voq_cgm",
      DefaultValue => "d500",
    },
    TrapProbabilityPdSize5Th => { #Structure Type: RegField;
      Name => "TrapProbabilityPdSize5Th",
      RegMem => "RegField",
      Description => "pkt mode prob when pd size >= 2K",
      Width => "16",
      Position => "243:228", # Excel Formula: =calc_position(F127,E128)
      Type => "Config",
      UsedBy => "voq_cgm",
      DefaultValue => "d600",
    },
    TrapVoqRange => { #Structure Type: RegField;
      Name => "TrapVoqRange",
      RegMem => "RegField",
      Description => "VOQ Range for trap on VOQ CGM drop 
{VoqMax0,VoqMin0,VoqMax1,VoqMin1}",
      Width => "64", # Excel Formula: =calc_field_width_define("QUEUE_WIDTH")*4
      Position => "307:244", # Excel Formula: =calc_position(F128,E129)
      Type => "Config",
      UsedBy => "voq_cgm",
      DefaultValue => "hFFFE_0000_FFFF_FFFF",
      ArrayItemWidth => "16",
    },
    TrapEnPerDropCode => { #Structure Type: RegField;
      Name => "TrapEnPerDropCode",
      RegMem => "RegField",
      Description => "Bitmaps to enable trap of each individual drop code

DROP_TRAP_CODE_NO_DROP                      5'd0
DROP_TRAP_CODE_EXACT_METER_DROP             5'd1
DROP_TRAP_CODE_STAT_METER_DROP              5'd2
DROP_TRAP_CODE_RATE_LIMITER_DROP            5'd3
DROP_TRAP_CODE_COUNTER_A_DSP_OVERFLOW       5'd4
DROP_TRAP_CODE_COUNTER_A_VN_OVERFLOW        5'd5
DROP_TRAP_CODE_COUNTER_A_MCID_OVERFLOW      5'd6
DROP_TRAP_CODE_COUNTER_B_OVERFLOW           5'd7
DROP_TRAP_CODE_COUNTER_E_OVERFLOW           5'd8
DROP_TRAP_CODE_RXRQ1_DSP_OVERFLOW           5'd9
DROP_TRAP_CODE_RXRQ1_VN_OVERFLOW            5'd10
DROP_TRAP_CODE_RXRQ2_OVERFLOW               5'd11
DROP_TRAP_CODE_RXRQ3_OVERFLOW               5'd12
DROP_TRAP_CODE_RX_CGM_SQ_SQG                5'd13
DROP_TRAP_CODE_RX_CGM_CTC_CTCG              5'd14
DROP_TRAP_CODE_RX_CGM_HEADROOM              5'd15
DROP_TRAP_CODE_TOTAL_EVICTED_BUFFERS_YELLOW 5'd16
DROP_TRAP_CODE_TOTAL_EVICTED_BUFFERS_GREEN  5'd17
DROP_TRAP_CODE_SMS_WRED_BUFFERS_GREEN       5'd18
DROP_TRAP_CODE_SMS_WRED_BUFFERS_YELLOW      5'd19
DROP_TRAP_CODE_SMS_PDS_YELLOW               5'd20
DROP_TRAP_CODE_SMS_PDS_GREEN                5'd21
DROP_TRAP_CODE_DRAM_BUFFERS_YELLOW          5'd22
DROP_TRAP_CODE_DRAM_BUFFERS_GREEN           5'd23
DROP_TRAP_CODE_DRAM_WRED_YELLOW             5'd24
DROP_TRAP_CODE_DRAM_WRED_GREEN              5'd25
DROP_TRAP_CODE_PD_COUNTERS_OVERFLOW         5'd26
DROP_TRAP_CODE_CANT_EVICT_TO_DRAM           5'd27",
      Width => "32",
      Position => "339:308", # Excel Formula: =calc_position(F129,E130)
      Type => "Config",
      UsedBy => "voq_cgm",
      DefaultValue => "h3FFFFE",
      InitValueAllModes => "0",
    },
    TrapLfsrSeed => { #Structure Type: RegField;
      Name => "TrapLfsrSeed",
      RegMem => "RegField",
      Description => "Seed for random sampling LFSR",
      Width => "4",
      Position => "343:340", # Excel Formula: =calc_position(F130,E131)
      Type => "Config",
      UsedBy => "voq_cgm",
      DefaultValue => "h4",
    },
  },
  rdrqsn => { #Structure Type: Mem;
    Name => "rdrqsn",
    RegMem => "Mem",
    Address => "100000",
    Description => "Read request sequence number, entry per queue, each entry is initialized to the entry number. The sequence number is incremented (RMW) every read-request command and written to an old sequence number value in case the ICS asks for retransmit (on dequeue-command).",
    Width => "20", # Excel Formula: =calc_mem_width(E133:E133,M132,F133,-1)
    Type => "Dynamic",
    UsedBy => "rqm: Write ,rqm: Read",
    MemEntries => "4096", # Excel Formula: =calc_field_width_define("NUM_OF_CONTEXTS")
    MemWrapper => "1R1W",
    MemProtect => "ECC",
    AdditionalInfo => "SampleReadBeforeProt=2,SampleReadAfterProt=1,SampleWriteAfterProt=1,CpuReadAccess=Enabled,CpuWriteAccess=Enabled,DisableSameAddressErr=Enabled,WriteActivityFactor=100,ReadActivityFactor=100,PortErrPropagate=Disabled",
    MemLogicalWidth => "14",
    rdrqsndata => { #Structure Type: MemField;
      Name => "rdrqsndata",
      RegMem => "MemField",
      Width => "14", # Excel Formula: =calc_field_width_define("QSIZE_PKT_WIDTH")
      Position => "13:0", # Excel Formula: =calc_position(F132,E133,TRUE)
    },
  },
  rdsn => { #Structure Type: Mem;
    Name => "rdsn",
    RegMem => "Mem",
    Address => "200000", # Excel Formula: =calc_mem_address(C132,A132,G134,L134)
    Description => "Read sequence number, entry per queue, each entry is initialized to the entry number. 
The sequence number is incremented every dequeue-command from the ICS and read every enqueue-command by the write-queue-manager. ",
    Width => "20", # Excel Formula: =calc_mem_width(E135:E135,M134,F135,-1)
    Type => "Dynamic",
    UsedBy => "rqm: Write,rqm: Read0 ,wqm: Read1",
    MemEntries => "4096", # Excel Formula: =calc_field_width_define("NUM_OF_CONTEXTS")
    MemWrapper => "2R1W Fast Write",
    MemProtect => "ECC",
    AdditionalInfo => "SampleReadBeforeProt=2,SampleReadAfterProt=1,SampleWriteAfterProt=1,CpuReadAccess=Enabled,CpuWriteAccess=Enabled,DisableSameAddressErr=Enabled,WriteActivityFactor=100,ReadActivityFactor=100,PortErrPropagate=Disabled",
    MemLogicalWidth => "14",
    rdsndata => { #Structure Type: MemField;
      Name => "rdsndata",
      RegMem => "MemField",
      Width => "14", # Excel Formula: =calc_field_width_define("QSIZE_PKT_WIDTH")
      Position => "13:0", # Excel Formula: =calc_position(F134,E135,TRUE)
    },
  },
  rdbc => { #Structure Type: Mem;
    Name => "rdbc",
    RegMem => "Mem",
    Address => "300000", # Excel Formula: =calc_mem_address(C134,A134,G136,L136)
    Description => "Read bytes count, entry per queue, initialized to 0. The read bytes count is incremented (RMW) with the packet size every dequeue-command from the ICS, and read every enqueue-command, 2R+W memory.",
    Width => "29", # Excel Formula: =calc_mem_width(E137:E137,M136,F137,-1)
    Type => "Dynamic",
    UsedBy => "rqm: Write,rqm: Read0 ,wqm: Read1",
    MemEntries => "4096", # Excel Formula: =calc_field_width_define("NUM_OF_CONTEXTS")
    MemWrapper => "2R1W Fast Write",
    MemProtect => "ECC",
    AdditionalInfo => "SampleReadBeforeProt=2,SampleReadAfterProt=1,SampleWriteAfterProt=1,CpuReadAccess=Enabled,CpuWriteAccess=Enabled,DisableSameAddressErr=Enabled,WriteActivityFactor=100,ReadActivityFactor=100,PortErrPropagate=Disabled",
    MemLogicalWidth => "23",
    rdbcdata => { #Structure Type: MemField;
      Name => "rdbcdata",
      RegMem => "MemField",
      Width => "23", # Excel Formula: =calc_field_width_define("QSIZE_BYT_WIDTH")
      Position => "22:0", # Excel Formula: =calc_position(F136,E137,TRUE)
    },
  },
  rdbufcnt => { #Structure Type: Mem;
    Name => "rdbufcnt",
    RegMem => "Mem",
    Address => "400000", # Excel Formula: =calc_mem_address(C136,A136,G138,L138)
    Description => "Similar to rdbc but in SMS buffers.
CGM need to know the queue size in SMS buffer units.
SMS buffer is 384B.",
    Width => "20", # Excel Formula: =calc_mem_width(E139:E139,M138,F139,-1)
    Type => "Dynamic",
    UsedBy => "rqm: Write,rqm: Read0 ,wqm: Read1",
    MemEntries => "4096", # Excel Formula: =calc_field_width_define("NUM_OF_CONTEXTS")
    MemWrapper => "2R1W Fast Write",
    MemProtect => "ECC",
    AdditionalInfo => "SampleReadBeforeProt=2,SampleReadAfterProt=1,SampleWriteAfterProt=1,CpuReadAccess=Enabled,CpuWriteAccess=Enabled,DisableSameAddressErr=Enabled,WriteActivityFactor=100,ReadActivityFactor=100,PortErrPropagate=Disabled",
    MemLogicalWidth => "14",
    rdbufcntdata => { #Structure Type: MemField;
      Name => "rdbufcntdata",
      RegMem => "MemField",
      Width => "14", # Excel Formula: =calc_field_width_define("QSIZE_BUF_WIDTH")
      Position => "13:0", # Excel Formula: =calc_position(F138,E139,TRUE)
    },
  },
  wrrqsn => { #Structure Type: Mem;
    Name => "wrrqsn",
    RegMem => "Mem",
    Address => "500000", # Excel Formula: =calc_mem_address(C138,A138,G140,L140)
    Description => "Write request sequence number, entry per queue. Each entry is initialized to the entry number (in order to prevent pressure on the first exact-match core).

The sequence number is incremented by the write-queue-manager (RMW) every enqueue-command, R+W (Two ports) memory.",
    Width => "20", # Excel Formula: =calc_mem_width(E141:E141,M140,F141,-1)
    Type => "Dynamic",
    UsedBy => "wqm: Write,wqm: Read0 ,rqm: Read1",
    MemEntries => "4096", # Excel Formula: =calc_field_width_define("NUM_OF_CONTEXTS")
    MemWrapper => "2R1W Fast Write",
    MemProtect => "ECC",
    AdditionalInfo => "SampleReadBeforeProt=2,SampleReadAfterProt=1,SampleWriteAfterProt=1,CpuReadAccess=Enabled,CpuWriteAccess=Enabled,DisableSameAddressErr=Enabled,WriteActivityFactor=100,ReadActivityFactor=100,PortErrPropagate=Disabled",
    MemLogicalWidth => "14",
    wrrqsndata => { #Structure Type: MemField;
      Name => "wrrqsndata",
      RegMem => "MemField",
      Width => "14", # Excel Formula: =calc_field_width_define("QSIZE_PKT_WIDTH")
      Position => "13:0", # Excel Formula: =calc_position(F140,E141,TRUE)
    },
  },
  wrsn => { #Structure Type: Mem;
    Name => "wrsn",
    RegMem => "Mem",
    Address => "600000", # Excel Formula: =calc_mem_address(C140,A140,G142,L142)
    Description => "Write sequence number, entry per queue, each entry is initialized to the entry number. 
The sequence number increments every write report (read-increment-write) and read every De-queue command, 2R+W memory.
",
    Width => "20", # Excel Formula: =calc_mem_width(E143:E143,M142,F143,-1)
    Type => "Dynamic",
    UsedBy => "wqm: Write ,wqm: Read",
    MemEntries => "4096", # Excel Formula: =calc_field_width_define("NUM_OF_CONTEXTS")
    MemWrapper => "1R1W",
    MemProtect => "ECC",
    AdditionalInfo => "SampleReadBeforeProt=2,SampleReadAfterProt=1,SampleWriteAfterProt=1,CpuReadAccess=Enabled,CpuWriteAccess=Enabled,DisableSameAddressErr=Enabled,WriteActivityFactor=100,ReadActivityFactor=100,PortErrPropagate=Disabled",
    MemLogicalWidth => "14",
    wrsndata => { #Structure Type: MemField;
      Name => "wrsndata",
      RegMem => "MemField",
      Width => "14", # Excel Formula: =calc_field_width_define("QSIZE_PKT_WIDTH")
      Position => "13:0", # Excel Formula: =calc_position(F142,E143,TRUE)
    },
  },
  wrbc => { #Structure Type: Mem;
    Name => "wrbc",
    RegMem => "Mem",
    Address => "700000", # Excel Formula: =calc_mem_address(C142,A142,G144,L144)
    Description => "Write bytes count, entry per queue, initialized to 0. 
The write bytes count is incremented (RMW) in packet size every write-report and read every dequeue-command, 2R+W memory.",
    Width => "29", # Excel Formula: =calc_mem_width(E145:E145,M144,F145,-1)
    Type => "Dynamic",
    UsedBy => "wqm: Write,wqm: Read0 ,rqm: Read1",
    MemEntries => "4096", # Excel Formula: =calc_field_width_define("NUM_OF_CONTEXTS")
    MemWrapper => "2R1W Fast Write",
    MemProtect => "ECC",
    AdditionalInfo => "SampleReadBeforeProt=2,SampleReadAfterProt=1,SampleWriteAfterProt=1,CpuReadAccess=Enabled,CpuWriteAccess=Enabled,DisableSameAddressErr=Enabled,WriteActivityFactor=100,ReadActivityFactor=100,PortErrPropagate=Disabled",
    MemLogicalWidth => "23",
    wrbcdata => { #Structure Type: MemField;
      Name => "wrbcdata",
      RegMem => "MemField",
      Width => "23", # Excel Formula: =calc_field_width_define("QSIZE_BYT_WIDTH")
      Position => "22:0", # Excel Formula: =calc_position(F144,E145,TRUE)
    },
  },
  wrbufcnt => { #Structure Type: Mem;
    Name => "wrbufcnt",
    RegMem => "Mem",
    Address => "800000", # Excel Formula: =calc_mem_address(C144,A144,G146,L146)
    Description => "Similar to wrbc but in SMS buffers.
CGM need to know the queue size in SMS buffer units.
SMS buffer is 384B.",
    Width => "20", # Excel Formula: =calc_mem_width(E147:E147,M146,F147,-1)
    Type => "Dynamic",
    UsedBy => "wqm: Write,wqm: Read0 ,rqm: Read1",
    MemEntries => "4096", # Excel Formula: =calc_field_width_define("NUM_OF_CONTEXTS")
    MemWrapper => "2R1W Fast Write",
    MemProtect => "ECC",
    AdditionalInfo => "SampleReadBeforeProt=2,SampleReadAfterProt=1,SampleWriteAfterProt=1,CpuReadAccess=Enabled,CpuWriteAccess=Enabled,DisableSameAddressErr=Enabled,WriteActivityFactor=100,ReadActivityFactor=100,PortErrPropagate=Disabled",
    MemLogicalWidth => "14",
    wrbufcntdata => { #Structure Type: MemField;
      Name => "wrbufcntdata",
      RegMem => "MemField",
      Width => "14", # Excel Formula: =calc_field_width_define("QSIZE_BUF_WIDTH")
      Position => "13:0", # Excel Formula: =calc_position(F146,E147,TRUE)
    },
  },
  voq2context => { #Structure Type: Mem;
    Name => "voq2context",
    RegMem => "Mem",
    Address => "900000", # Excel Formula: =calc_mem_address(C146,A146,G148,L148)
    Description => "context per voq. Managed by the context mapper. 
Read by ICS when it receives credit-grant and need to translate the VOQ# to context.",
    Width => "18", # Excel Formula: =calc_mem_width(E149:E149,M148,F149,-1)
    Type => "Dynamic",
    UsedBy => "CMAP: Write,CMAP: Read0 ,ICS: Read1",
    MemEntries => "65535", # Excel Formula: =calc_field_width_define("NUM_QUEUES_PER_SLICE")
    MemWrapper => "2R1W Fast Write",
    MemProtect => "ECC",
    AdditionalInfo => "SampleReadAccess=1,SampleReadBeforeProt=2,SampleReadAfterProt=1,SampleWriteAfterProt=1,CpuReadAccess=Enabled,CpuWriteAccess=Enabled,DisableSameAddressErr=Enabled,WriteActivityFactor=10,ReadActivityFactor=75,PortErrPropagate=Disabled",
    MemLogicalWidth => "12",
    voq2contextData => { #Structure Type: MemField;
      Name => "voq2contextData",
      RegMem => "MemField",
      Description => "8k context - 13 bit
Valud of 13'h1FFF mean unused
",
      Width => "12", # Excel Formula: =calc_field_width_define("CONTEXT_WIDTH")
      Position => "11:0", # Excel Formula: =calc_position(F148,E149,TRUE)
      InitValueSa => "4095",
      InitValueLcNwk => "4095",
      InitValueLcFab => "(line < 432) ? line : 4095",
      InitValueFe => "(line < 432) ? line : 4095",
    },
  },
  CandRelFifo => { #Structure Type: Mem;
    Name => "CandRelFifo",
    RegMem => "Mem",
    Address => "A00000", # Excel Formula: =calc_mem_address(C148,A148,G150,L150)
    Description => "Fifo to hold context# released by the ICS",
    Width => "18", # Excel Formula: =calc_mem_width(E151:E151,M150,F151,-1)
    Type => "Dynamic",
    UsedBy => "CMAP",
    MemEntries => "2048", # Excel Formula: =2048
    MemWrapper => "Fifo",
    MemProtect => "ECC",
    AdditionalInfo => "SampleReadAccess=1,SampleReadBeforeProt=1,SampleReadAfterProt=1,SampleWriteAfterProt=1,DisableSameAddressErr=Enabled,WriteActivityFactor=10,ReadActivityFactor=10,PortErrPropagate=Disabled,CpuReadAccess=Disabled,CpuWriteAccess=Disabled",
    MemLogicalWidth => "12",
    ContextToRelease => { #Structure Type: MemField;
      Name => "ContextToRelease",
      RegMem => "MemField",
      Width => "12", # Excel Formula: =calc_field_width_define("CONTEXT_WIDTH")
      Position => "11:0", # Excel Formula: =calc_position(F150,E151,TRUE)
    },
  },
  InCandRelFifoSet => { #Structure Type: Mem;
    Name => "InCandRelFifoSet",
    RegMem => "Mem",
    Address => "B00000", # Excel Formula: =calc_mem_address(C150,A150,G152,L152)
    Description => "The context resides in the CandRelFifo - set-clear-read to prevent double entries in the fifo",
    Width => "72", # Excel Formula: =calc_mem_width(E153:E153,M152,F153,-1)
    Type => "Dynamic",
    UsedBy => "CMAP",
    MemEntries => "64", # Excel Formula: =calc_field_width_define("NUM_OF_CONTEXTS")/E153
    MemWrapper => "2R1W Fast Write",
    MemProtect => "ECC",
    AdditionalInfo => "SampleReadBeforeProt=1,SampleReadAfterProt=1,SampleWriteAfterProt=1,DisableSameAddressErr=Enabled,WriteActivityFactor=10,ReadActivityFactor=10,PortErrPropagate=Disabled,CpuReadAccess=Disabled,CpuWriteAccess=Disabled",
    Comments => "s+c+r imp",
    MemLogicalWidth => "64",
    ctxRelSet => { #Structure Type: MemField;
      Name => "ctxRelSet",
      RegMem => "MemField",
      Width => "64",
      Position => "63:0", # Excel Formula: =calc_position(F152,E153,TRUE)
    },
  },
  InCandRelFifoClr => { #Structure Type: Mem;
    Name => "InCandRelFifoClr",
    RegMem => "Mem",
    Address => "C00000", # Excel Formula: =calc_mem_address(C152,A152,G154,L154)
    Description => "The context resides in the CandRelFifo - set-clear-read to prevent double entries in the fifo",
    Width => "72", # Excel Formula: =calc_mem_width(E155:E155,M154,F155,-1)
    Type => "Dynamic",
    UsedBy => "CMAP",
    MemEntries => "64", # Excel Formula: =calc_field_width_define("NUM_OF_CONTEXTS")/E155
    MemWrapper => "2R1W Fast Write",
    MemProtect => "ECC",
    AdditionalInfo => "SampleReadBeforeProt=1,SampleReadAfterProt=1,SampleWriteAfterProt=1,DisableSameAddressErr=Enabled,WriteActivityFactor=10,ReadActivityFactor=10,PortErrPropagate=Disabled,CpuReadAccess=Disabled,CpuWriteAccess=Disabled",
    Comments => "s+c+r imp",
    MemLogicalWidth => "64",
    ctxRelClr => { #Structure Type: MemField;
      Name => "ctxRelClr",
      RegMem => "MemField",
      Width => "64",
      Position => "63:0", # Excel Formula: =calc_position(F154,E155,TRUE)
    },
  },
  ContextReleaseEligibleSet => { #Structure Type: Mem;
    Name => "ContextReleaseEligibleSet",
    RegMem => "Mem",
    Address => "D00000", # Excel Formula: =calc_mem_address(C154,A154,G156,L156)
    Description => "The context is empty and thus ready for release SCRP",
    Width => "72", # Excel Formula: =calc_mem_width(E157:E157,M156,F157,-1)
    Type => "Dynamic",
    UsedBy => "CMAP",
    MemEntries => "64", # Excel Formula: =calc_field_width_define("NUM_OF_CONTEXTS")/E157
    MemWrapper => "3R1W Fast Write",
    MemProtect => "ECC",
    AdditionalInfo => "SampleReadBeforeProt=1,SampleReadAfterProt=1,SampleWriteAfterProt=1,DisableSameAddressErr=Enabled,WriteActivityFactor=100,ReadActivityFactor=10,PortErrPropagate=Disabled,CpuReadAccess=Disabled,CpuWriteAccess=Disabled",
    Comments => "s+c+r imp",
    MemLogicalWidth => "64",
    ctxRelElgblSet => { #Structure Type: MemField;
      Name => "ctxRelElgblSet",
      RegMem => "MemField",
      Width => "64",
      Position => "63:0", # Excel Formula: =calc_position(F156,E157,TRUE)
    },
  },
  ContextReleaseEligibleClr => { #Structure Type: Mem;
    Name => "ContextReleaseEligibleClr",
    RegMem => "Mem",
    Address => "E00000", # Excel Formula: =calc_mem_address(C156,A156,G158,L158)
    Description => "The context is empty and thus ready for release SCRP",
    Width => "72", # Excel Formula: =calc_mem_width(E159:E159,M158,F159,-1)
    Type => "Dynamic",
    UsedBy => "CMAP",
    MemEntries => "64", # Excel Formula: =calc_field_width_define("NUM_OF_CONTEXTS")/E159
    MemWrapper => "3R1W Fast Write",
    MemProtect => "ECC",
    AdditionalInfo => "SampleReadBeforeProt=1,SampleReadAfterProt=1,SampleWriteAfterProt=1,DisableSameAddressErr=Enabled,WriteActivityFactor=100,ReadActivityFactor=10,PortErrPropagate=Disabled,CpuReadAccess=Disabled,CpuWriteAccess=Disabled",
    Comments => "s+c+r imp",
    MemLogicalWidth => "64",
    ctxRelElgblClr => { #Structure Type: MemField;
      Name => "ctxRelElgblClr",
      RegMem => "MemField",
      Width => "64",
      Position => "63:0", # Excel Formula: =calc_position(F158,E159,TRUE)
    },
  },
  ContextInDramSet => { #Structure Type: Mem;
    Name => "ContextInDramSet",
    RegMem => "Mem",
    Address => "F00000", # Excel Formula: =calc_mem_address(C158,A158,G160,L160)
    Description => "The context is in the DRAM and thus it is not ready for release SCR",
    Width => "72", # Excel Formula: =calc_mem_width(E161:E161,M160,F161,-1)
    Type => "Dynamic",
    UsedBy => "CMAP",
    MemEntries => "64", # Excel Formula: =calc_field_width_define("NUM_OF_CONTEXTS")/E161
    MemWrapper => "2R1W Fast Write",
    MemProtect => "ECC",
    AdditionalInfo => "SampleReadBeforeProt=1,SampleReadAfterProt=1,SampleWriteAfterProt=1,DisableSameAddressErr=Enabled,WriteActivityFactor=10,ReadActivityFactor=10,PortErrPropagate=Disabled,CpuReadAccess=Disabled,CpuWriteAccess=Disabled",
    Comments => "s+c+r imp",
    MemLogicalWidth => "64",
    ctxInDramSet => { #Structure Type: MemField;
      Name => "ctxInDramSet",
      RegMem => "MemField",
      Width => "64",
      Position => "63:0", # Excel Formula: =calc_position(F160,E161,TRUE)
    },
  },
  ContextInDramClr => { #Structure Type: Mem;
    Name => "ContextInDramClr",
    RegMem => "Mem",
    Address => "1000000", # Excel Formula: =calc_mem_address(C160,A160,G162,L162)
    Description => "The context is in the DRAM and thus it is not ready for release SCR",
    Width => "72", # Excel Formula: =calc_mem_width(E163:E163,M162,F163,-1)
    Type => "Dynamic",
    UsedBy => "CMAP",
    MemEntries => "64", # Excel Formula: =calc_field_width_define("NUM_OF_CONTEXTS")/E163
    MemWrapper => "2R1W Fast Write",
    MemProtect => "ECC",
    AdditionalInfo => "SampleReadBeforeProt=1,SampleReadAfterProt=1,SampleWriteAfterProt=1,DisableSameAddressErr=Enabled,WriteActivityFactor=10,ReadActivityFactor=10,PortErrPropagate=Disabled,CpuReadAccess=Disabled,CpuWriteAccess=Disabled",
    Comments => "s+c+r imp",
    MemLogicalWidth => "64",
    ctxInDramClr => { #Structure Type: MemField;
      Name => "ctxInDramClr",
      RegMem => "MemField",
      Width => "64",
      Position => "63:0", # Excel Formula: =calc_position(F162,E163,TRUE)
    },
  },
  ContextMapValidSet => { #Structure Type: Mem;
    Name => "ContextMapValidSet",
    RegMem => "Mem",
    Address => "1100000", # Excel Formula: =calc_mem_address(C162,A162,G164,L164)
    Description => "The context is mapped to VOQ (SCR)",
    Width => "72", # Excel Formula: =calc_mem_width(E165:E165,M164,F165,-1)
    Type => "Dynamic",
    UsedBy => "CMAP",
    MemEntries => "64", # Excel Formula: =calc_field_width_define("NUM_OF_CONTEXTS")/E165
    MemWrapper => "2R1W Fast Write",
    MemProtect => "ECC",
    AdditionalInfo => "SampleReadBeforeProt=1,SampleReadAfterProt=1,SampleWriteAfterProt=1,DisableSameAddressErr=Enabled,WriteActivityFactor=10,ReadActivityFactor=10,PortErrPropagate=Disabled,CpuReadAccess=Disabled,CpuWriteAccess=Disabled",
    Comments => "s+c+r imp",
    MemLogicalWidth => "64",
    ctxMapValidSet => { #Structure Type: MemField;
      Name => "ctxMapValidSet",
      RegMem => "MemField",
      Width => "64",
      Position => "63:0", # Excel Formula: =calc_position(F164,E165,TRUE)
    },
  },
  ContextMapValidClr => { #Structure Type: Mem;
    Name => "ContextMapValidClr",
    RegMem => "Mem",
    Address => "1200000", # Excel Formula: =calc_mem_address(C164,A164,G166,L166)
    Description => "The context is mapped to VOQ (SCR)",
    Width => "72", # Excel Formula: =calc_mem_width(E167:E167,M166,F167,-1)
    Type => "Dynamic",
    UsedBy => "CMAP",
    MemEntries => "64", # Excel Formula: =calc_field_width_define("NUM_OF_CONTEXTS")/E167
    MemWrapper => "2R1W Fast Write",
    MemProtect => "ECC",
    AdditionalInfo => "SampleReadBeforeProt=1,SampleReadAfterProt=1,SampleWriteAfterProt=1,DisableSameAddressErr=Enabled,WriteActivityFactor=10,ReadActivityFactor=10,PortErrPropagate=Disabled,CpuReadAccess=Disabled,CpuWriteAccess=Disabled",
    Comments => "s+c+r imp",
    MemLogicalWidth => "64",
    ctxMapValidClr => { #Structure Type: MemField;
      Name => "ctxMapValidClr",
      RegMem => "MemField",
      Width => "64",
      Position => "63:0", # Excel Formula: =calc_position(F166,E167,TRUE)
    },
  },
  contextfbmBmp => { #Structure Type: Mem;
    Name => "contextfbmBmp",
    RegMem => "Mem",
    Address => "1300000", # Excel Formula: =calc_mem_address(C166,A166,G168,L168)
    Description => "bitmap memory for the free buffer manager",
    Width => "72", # Excel Formula: =calc_mem_width(E169:E169,M168,F169,-1)
    Type => "Dynamic",
    UsedBy => "CMAP: Read,CMAP: Write",
    MemEntries => "64", # Excel Formula: =calc_field_width_define("NUM_OF_CONTEXTS")/E169
    MemWrapper => "1R1W",
    MemProtect => "ECC",
    AdditionalInfo => "SampleReadAccess=1,SampleReadBeforeProt=1,SampleWriteAfterProt=1,CpuReadAccess=Enabled,CpuWriteAccess=Enabled,DisableSameAddressErr=Enabled,WriteActivityFactor=10,ReadActivityFactor=10,PortErrPropagate=Disabled",
    Comments => "Note that FBM memory must be eq3 ",
    MemLogicalWidth => "64",
    contextfbmBmpdata => { #Structure Type: MemField;
      Name => "contextfbmBmpdata",
      RegMem => "MemField",
      Description => "bitmap",
      Width => "64",
      Position => "63:0", # Excel Formula: =calc_position(F168,E169,TRUE)
      InitValueSa => "(line < 63) ? 'hFFFF_FFFF_FFFF_FFFF : 'h7FFF_FFFF_FFFF_FFFF",
      InitValueLcNwk => "(line < 63) ? 'hFFFF_FFFF_FFFF_FFFF : 'h7FFF_FFFF_FFFF_FFFF",
      InitValueLcFab => "(line < 6) ? 0 :
(line < 7) ? 'hFFFF << 48 :
(line < 63) ? 'hFFFF_FFFF_FFFF_FFFF : 'h7FFF_FFFF_FFFF_FFFF",
      InitValueFe => "(line < 6) ? 0 :
(line < 7) ? 'hFFFF << 48 :
(line < 63) ? 'hFFFF_FFFF_FFFF_FFFF : 'h7FFF_FFFF_FFFF_FFFF",
    },
  },
  NewVoqSet => { #Structure Type: Mem;
    Name => "NewVoqSet",
    RegMem => "Mem",
    Address => "1400000", # Excel Formula: =calc_mem_address(C168,A168,G170,L170)
    Width => "72", # Excel Formula: =calc_mem_width(E171:E171,M170,F171,-1)
    Type => "Dynamic",
    UsedBy => "NEWVOQ",
    MemEntries => "64", # Excel Formula: =calc_field_width_define("NUM_OF_CONTEXTS")/E171
    MemWrapper => "3R1W Fast Write",
    MemProtect => "ECC",
    AdditionalInfo => "SampleReadBeforeProt=2,SampleReadAfterProt=1,SampleWriteAfterProt=1,DisableSameAddressErr=Enabled,WriteActivityFactor=0,ReadActivityFactor=100,PortErrPropagate=Disabled,CpuReadAccess=Disabled,CpuWriteAccess=Disabled",
    Comments => "s+c+r imp",
    MemLogicalWidth => "64",
    NewVoqSetBits => { #Structure Type: MemField;
      Name => "NewVoqSetBits",
      RegMem => "MemField",
      Width => "64",
      Position => "63:0", # Excel Formula: =calc_position(F170,E171,TRUE)
    },
  },
  NewVoqClr => { #Structure Type: Mem;
    Name => "NewVoqClr",
    RegMem => "Mem",
    Address => "1500000", # Excel Formula: =calc_mem_address(C170,A170,G172,L172)
    Width => "72", # Excel Formula: =calc_mem_width(E173:E173,M172,F173,-1)
    Type => "Dynamic",
    UsedBy => "NEWVOQ",
    MemEntries => "64", # Excel Formula: =calc_field_width_define("NUM_OF_CONTEXTS")/E173
    MemWrapper => "3R1W Fast Write",
    MemProtect => "ECC",
    AdditionalInfo => "SampleReadBeforeProt=2,SampleReadAfterProt=1,SampleWriteAfterProt=1,DisableSameAddressErr=Enabled,WriteActivityFactor=0,ReadActivityFactor=100,PortErrPropagate=Disabled,CpuReadAccess=Disabled,CpuWriteAccess=Disabled",
    Comments => "s+c+r imp",
    MemLogicalWidth => "64",
    NewVoqClrBits => { #Structure Type: MemField;
      Name => "NewVoqClrBits",
      RegMem => "MemField",
      Width => "64",
      Position => "63:0", # Excel Formula: =calc_position(F172,E173,TRUE)
    },
  },
  voqProperties => { #Structure Type: Mem;
    Name => "voqProperties",
    RegMem => "Mem",
    Address => "1600000", # Excel Formula: =calc_mem_address(C172,A172,G174,L174)
    Description => "context per voq. Managed by the context mapper. 
Read by ICS when it receives credit-grant and need to translate the VOQ# to context.",
    Width => "137", # Excel Formula: =calc_mem_width(E175:E175,M174,F175,-1)
    Type => "Config",
    UsedBy => "CMAP",
    MemEntries => "4096", # Excel Formula: =(1+calc_field_width_define("NUM_QUEUES_PER_SLICE"))/16
    MemWrapper => "1P",
    MemProtect => "ECC",
    AdditionalInfo => "SampleReadBeforeProt=2,SampleReadAfterProt=1,SampleWriteAfterProt=1,CpuReadAccess=Enabled,CpuWriteAccess=Enabled,WriteActivityFactor=0,ReadActivityFactor=10,PortErrPropagate=Disabled",
    MemLogicalWidth => "128",
    Profile => { #Structure Type: MemField;
      Name => "Profile",
      RegMem => "MemField",
      Description => "16 entries of 8 bit {Type[2:0],Profile[4:0]}
Type code RLB / FLB - HP/LP MC",
      Width => "128", # Excel Formula: =16*(calc_field_width_define("ICS_TYPE_WIDTH") + calc_field_width_define("PDVOQ_QUEUE_PROFILE_WIDTH"))
      Position => "127:0", # Excel Formula: =calc_position(F174,E175,TRUE)
      Comments => "5 LSBs = prfofile, 3 MSBs = type
FE mode - UCH drop, UCL and MC use 18 VOQs per dest slice, drop others
LC fab moe - UCH drop, UCL, MC use 20 or 24 VOQs per slice 0,1,2, drop others",
      ArrayItemWidth => "8",
      InitValueSa => "INIT_AFTER_SOFT_RESET (line < 6) ? 3*32+1 : 3*32 + 0",
      InitValueLcNwk => "INIT_AFTER_SOFT_RESET (line < 3) ? 3*32+1 : (line == 3) ? 2*32+1 : 3*32 + 0",
      InitValueLcFab => "INIT_AFTER_SOFT_RESET 
(is_100g_fabric || item % 2 == 0) &&
(((slice == 3 || slice == 4) && (line ==  9 || line == 12 || (line == 10 && (item < 4 || item >= 8)) || (line == 11 && item < 12) || (line == 13 && item < 4))) ||
((slice == 5) && ((line >=  9 && line < 13) || (line == 13 && item < 8)))) ? 1*32+2 : 
(is_100g_fabric || item % 2 == 0) &&
(((slice == 3 || slice == 4) && (line == 18 || line == 21 || (line == 19 && (item < 4 || item >= 8)) || (line == 20 && item < 12) || (line == 22 && item < 4))) ||
((slice == 5) && ((line >= 18 && line < 22) || (line == 22 && item < 8)))) ? 2*32+3 : 3*32 + 0",
      InitValueFe => "INIT_AFTER_SOFT_RESET 
(is_100g_fabric || item % 2 == 0) && (line ==  9 || line == 12 || line == 15 || ((line == 10 || line == 13 || line == 16) && (item < 2 || item >= 8)) || ((line == 11 || line == 14 || line == 17) && (item < 10))) ? 1*32+2 : 
(is_100g_fabric || item % 2 == 0) && (line == 18 || line == 21 || line == 24 || ((line == 19 || line == 22 || line == 25) && (item < 2 || item >= 8)) || ((line == 20 || line == 23 || line == 26) && (item < 10))) ? 2*32+3 : 3*32 + 0",
    },
  },
  staticMapping => { #Structure Type: Mem;
    Name => "staticMapping",
    RegMem => "Mem",
    Address => "1700000", # Excel Formula: =calc_mem_address(C174,A174,G176,L176)
    Description => "Mark the static context so they want be reused - returned to the pool",
    Width => "72", # Excel Formula: =calc_mem_width(E177:E177,M176,F177,-1)
    Type => "Config",
    UsedBy => "CMAP",
    MemEntries => "64", # Excel Formula: =calc_field_width_define("NUM_OF_CONTEXTS")/64
    MemWrapper => "1P",
    MemProtect => "ECC",
    AdditionalInfo => "SampleReadAccess=1,SampleReadBeforeProt=1,SampleReadAfterProt=1,SampleWriteAfterProt=1,CpuReadAccess=Enabled,CpuWriteAccess=Enabled,WriteActivityFactor=0,ReadActivityFactor=10,PortErrPropagate=Disabled",
    MemLogicalWidth => "64",
    staticMappingBitmap => { #Structure Type: MemField;
      Name => "staticMappingBitmap",
      RegMem => "MemField",
      Description => "bitmap per 64 contexts.
'1' the context mapping is static - dont return it to the context pool
'0' the context mapping is dynamic - return the context when possible",
      Width => "64",
      Position => "63:0", # Excel Formula: =calc_position(F176,E177,TRUE)
      InitValueSa => "(line == 63) ? 1<<63 : 0",
      InitValueLcNwk => "(line == 63) ? 1<<63 : 0",
      InitValueLcFab => "(line == 63) ? 1<<63 : 
(line < 6) ? 'hFFFF_FFFF_FFFF_FFFF : 
(line == 6) ? 'hFFFF_FFFF_FFFF : 0",
      InitValueFe => "(line == 63) ? 1<<63 : 
(line < 6) ? 'hFFFF_FFFF_FFFF_FFFF : 
(line == 6) ? 'hFFFF_FFFF_FFFF : 0",
    },
  },
  context_allocate_set_master => { #Structure Type: Mem;
    Name => "context_allocate_set_master",
    RegMem => "Mem",
    Address => "1800000", # Excel Formula: =calc_mem_address(C176,A176,G178,L178)
    Description => "Some desc for mem0",
    Width => "39", # Excel Formula: =calc_mem_width(E179:E179,M178,F179,-1)
    Type => "Dynamic",
    UsedBy => "CMAP: Read,CMAP: Write",
    MemEntries => "2048", # Excel Formula: =(1+calc_field_width_define("NUM_QUEUES_PER_SLICE"))/32
    MemWrapper => "1R1W",
    MemProtect => "ECC",
    AdditionalInfo => "SampleReadAccess=1,SampleReadBeforeProt=2,SampleWriteAfterProt=1,CpuReadAccess=Enabled,CpuWriteAccess=Enabled,DisableSameAddressErr=Enabled,WriteActivityFactor=10,ReadActivityFactor=10,PortErrPropagate=Disabled",
    MemLogicalWidth => "32",
    bitmap_a => { #Structure Type: MemField;
      Name => "bitmap_a",
      RegMem => "MemField",
      Description => "Some desc for mem0 field0",
      Width => "32",
      Position => "31:0", # Excel Formula: =calc_position(F178,E179,TRUE)
      InitValueSa => "INIT_AFTER_SOFT_RESET 0",
      InitValueLcNwk => "INIT_AFTER_SOFT_RESET 0",
      InitValueLcFab => "INIT_AFTER_SOFT_RESET (line < 13) ? 'hFFFF_FFFF : (line == 13) ? 'hFFFF : 0",
      InitValueFe => "INIT_AFTER_SOFT_RESET (line < 13) ? 'hFFFF_FFFF : (line == 13) ? 'hFFFF : 0",
    },
  },
  context_allocate_set_slave => { #Structure Type: Mem;
    Name => "context_allocate_set_slave",
    RegMem => "Mem",
    Address => "1900000", # Excel Formula: =calc_mem_address(C178,A178,G180,L180)
    Description => "Some desc for mem0",
    Width => "39", # Excel Formula: =calc_mem_width(E181:E181,M180,F181,-1)
    Type => "Dynamic",
    UsedBy => "CMAP: Read,CMAP: Write",
    MemEntries => "2048", # Excel Formula: =(1+calc_field_width_define("NUM_QUEUES_PER_SLICE"))/32
    MemWrapper => "1R1W",
    MemProtect => "ECC",
    AdditionalInfo => "SampleReadAccess=1,SampleReadBeforeProt=2,SampleWriteAfterProt=1,CpuReadAccess=Enabled,CpuWriteAccess=Enabled,DisableSameAddressErr=Enabled,WriteActivityFactor=10,ReadActivityFactor=10,PortErrPropagate=Disabled",
    MemLogicalWidth => "32",
    bitmap_b => { #Structure Type: MemField;
      Name => "bitmap_b",
      RegMem => "MemField",
      Description => "Some desc for mem0 field0",
      Width => "32",
      Position => "31:0", # Excel Formula: =calc_position(F180,E181,TRUE)
      InitValueSa => "INIT_AFTER_SOFT_RESET 0",
      InitValueLcNwk => "INIT_AFTER_SOFT_RESET 0",
      InitValueLcFab => "INIT_AFTER_SOFT_RESET (line < 13) ? 'hFFFF_FFFF : (line == 13) ? 'hFFFF : 0",
      InitValueFe => "INIT_AFTER_SOFT_RESET (line < 13) ? 'hFFFF_FFFF : (line == 13) ? 'hFFFF : 0",
    },
  },
  context_allocate_clr_master => { #Structure Type: Mem;
    Name => "context_allocate_clr_master",
    RegMem => "Mem",
    Address => "1A00000", # Excel Formula: =calc_mem_address(C180,A180,G182,L182)
    Description => "Some desc for mem0",
    Width => "39", # Excel Formula: =calc_mem_width(E183:E183,M182,F183,-1)
    Type => "Dynamic",
    UsedBy => "CMAP: Read,CMAP: Write",
    MemEntries => "2048", # Excel Formula: =(1+calc_field_width_define("NUM_QUEUES_PER_SLICE"))/32
    MemWrapper => "1R1W",
    MemProtect => "ECC",
    AdditionalInfo => "SampleReadAccess=1,SampleReadBeforeProt=2,SampleWriteAfterProt=1,CpuReadAccess=Enabled,CpuWriteAccess=Enabled,DisableSameAddressErr=Enabled,WriteActivityFactor=10,ReadActivityFactor=10,PortErrPropagate=Disabled",
    MemLogicalWidth => "32",
    bitmap_c => { #Structure Type: MemField;
      Name => "bitmap_c",
      RegMem => "MemField",
      Description => "Some desc for mem0 field0",
      Width => "32",
      Position => "31:0", # Excel Formula: =calc_position(F182,E183,TRUE)
    },
  },
  context_allocate_clr_slave => { #Structure Type: Mem;
    Name => "context_allocate_clr_slave",
    RegMem => "Mem",
    Address => "1B00000", # Excel Formula: =calc_mem_address(C182,A182,G184,L184)
    Description => "Some desc for mem0",
    Width => "39", # Excel Formula: =calc_mem_width(E185:E185,M184,F185,-1)
    Type => "Dynamic",
    UsedBy => "CMAP: Read,CMAP: Write",
    MemEntries => "2048", # Excel Formula: =(1+calc_field_width_define("NUM_QUEUES_PER_SLICE"))/32
    MemWrapper => "1R1W",
    MemProtect => "ECC",
    AdditionalInfo => "SampleReadAccess=1,SampleReadBeforeProt=2,SampleWriteAfterProt=1,CpuReadAccess=Enabled,CpuWriteAccess=Enabled,DisableSameAddressErr=Enabled,WriteActivityFactor=10,ReadActivityFactor=10,PortErrPropagate=Disabled",
    MemLogicalWidth => "32",
    bitmap_d => { #Structure Type: MemField;
      Name => "bitmap_d",
      RegMem => "MemField",
      Description => "Some desc for mem0 field0",
      Width => "32",
      Position => "31:0", # Excel Formula: =calc_position(F184,E185,TRUE)
    },
  },
  context_allocate_grant_set => { #Structure Type: Mem;
    Name => "context_allocate_grant_set",
    RegMem => "Mem",
    Address => "1C00000", # Excel Formula: =calc_mem_address(C184,A184,G186,L186)
    Description => "credit allocate read port for credit grant",
    Width => "39", # Excel Formula: =calc_mem_width(E187:E187,M186,F187,-1)
    Type => "Dynamic",
    UsedBy => "CMAP: Read,CMAP: Write",
    MemEntries => "2048", # Excel Formula: =(1+calc_field_width_define("NUM_QUEUES_PER_SLICE"))/32
    MemWrapper => "1R1W",
    MemProtect => "ECC",
    AdditionalInfo => "SampleReadAccess=1,SampleReadBeforeProt=2,SampleWriteAfterProt=1,CpuReadAccess=Enabled,CpuWriteAccess=Enabled,DisableSameAddressErr=Enabled,WriteActivityFactor=10,ReadActivityFactor=10,PortErrPropagate=Disabled",
    MemLogicalWidth => "32",
    bitmap_e => { #Structure Type: MemField;
      Name => "bitmap_e",
      RegMem => "MemField",
      Description => "Some desc for mem0 field0",
      Width => "32",
      Position => "31:0", # Excel Formula: =calc_position(F186,E187,TRUE)
      InitValueSa => "INIT_AFTER_SOFT_RESET 0",
      InitValueLcNwk => "INIT_AFTER_SOFT_RESET 0",
      InitValueLcFab => "INIT_AFTER_SOFT_RESET (line < 13) ? 'hFFFF_FFFF : (line == 13) ? 'hFFFF : 0",
      InitValueFe => "INIT_AFTER_SOFT_RESET (line < 13) ? 'hFFFF_FFFF : (line == 13) ? 'hFFFF : 0",
    },
  },
  context_allocate_grant_clr => { #Structure Type: Mem;
    Name => "context_allocate_grant_clr",
    RegMem => "Mem",
    Address => "1D00000", # Excel Formula: =calc_mem_address(C186,A186,G188,L188)
    Description => "credit allocate read port for credit grant",
    Width => "39", # Excel Formula: =calc_mem_width(E189:E189,M188,F189,-1)
    Type => "Dynamic",
    UsedBy => "CMAP: Read,CMAP: Write",
    MemEntries => "2048", # Excel Formula: =(1+calc_field_width_define("NUM_QUEUES_PER_SLICE"))/32
    MemWrapper => "1R1W",
    MemProtect => "ECC",
    AdditionalInfo => "SampleReadAccess=1,SampleReadBeforeProt=2,SampleWriteAfterProt=1,CpuReadAccess=Enabled,CpuWriteAccess=Enabled,DisableSameAddressErr=Enabled,WriteActivityFactor=10,ReadActivityFactor=10,PortErrPropagate=Disabled",
    MemLogicalWidth => "32",
    bitmap_f => { #Structure Type: MemField;
      Name => "bitmap_f",
      RegMem => "MemField",
      Description => "Some desc for mem0 field0",
      Width => "32",
      Position => "31:0", # Excel Formula: =calc_position(F188,E189,TRUE)
    },
  },
  Context2voq => { #Structure Type: Mem;
    Name => "Context2voq",
    RegMem => "Mem",
    Address => "1E00000", # Excel Formula: =calc_mem_address(C188,A188,G190,L190)
    Description => "credit allocate read port for credit grant",
    Width => "22", # Excel Formula: =calc_mem_width(E191:E191,M190,F191,-1)
    Type => "Dynamic",
    UsedBy => "CMAP: Read,CMAP: Write",
    MemEntries => "4096", # Excel Formula: =calc_field_width_define("NUM_OF_CONTEXTS")
    MemWrapper => "1R1W",
    MemProtect => "ECC",
    AdditionalInfo => "SampleReadAccess=1,SampleReadBeforeProt=1,SampleReadAfterProt=1,SampleWriteAfterProt=1,CpuReadAccess=Enabled,CpuWriteAccess=Enabled,DisableSameAddressErr=Enabled,WriteActivityFactor=0,ReadActivityFactor=50,PortErrPropagate=Disabled",
    MemLogicalWidth => "16",
    Context2voqBits => { #Structure Type: MemField;
      Name => "Context2voqBits",
      RegMem => "MemField",
      Description => "Some desc for mem0 field0",
      Width => "16", # Excel Formula: =calc_field_width_define("VOQ_NUMBER_WIDTH")
      Position => "15:0", # Excel Formula: =calc_position(F190,E191,TRUE)
      InitValueAllModes => "0",
    },
  },
  RqmFreeFifo => { #Structure Type: Mem;
    Name => "RqmFreeFifo",
    RegMem => "Mem",
    Address => "1F00000", # Excel Formula: =calc_mem_address(C190,A190,G192,L192)
    Description => "fifo for dequeue between RQM and the EMCs",
    Width => "40", # Excel Formula: =calc_mem_width(E193:E195,M192,F195,-1)
    Type => "Dynamic",
    UsedBy => "RQM",
    MemEntries => "128", # Excel Formula: =128
    MemWrapper => "Fifo",
    MemProtect => "ECC",
    AdditionalInfo => "SampleReadAccess=1,SampleReadBeforeProt=2,SampleWriteAfterProt=1,DisableSameAddressErr=Enabled,WriteActivityFactor=100,ReadActivityFactor=100,PortErrPropagate=Disabled,CpuReadAccess=Disabled,CpuWriteAccess=Disabled",
    MemLogicalWidth => "33",
    RqmFifoDatBank => { #Structure Type: MemField;
      Name => "RqmFifoDatBank",
      RegMem => "MemField",
      Description => "Some desc for mem0 field0",
      Width => "4",
      Position => "3:0", # Excel Formula: =calc_position(F192,E193,TRUE)
    },
    RqmFifoDatIdx => { #Structure Type: MemField;
      Name => "RqmFifoDatIdx",
      RegMem => "MemField",
      Description => "Some desc for mem0 field0",
      Width => "15", # Excel Formula: =calc_field_width_define("PDVOQ_EM_IDX_WIDTH")
      Position => "18:4", # Excel Formula: =calc_position(F193,E194)
    },
    RqmFifoDatBuf => { #Structure Type: MemField;
      Name => "RqmFifoDatBuf",
      RegMem => "MemField",
      Description => "Some desc for mem0 field0",
      Width => "14", # Excel Formula: =calc_field_width_define("PDVOQ_BUF_WIDTH")
      Position => "32:19", # Excel Formula: =calc_position(F194,E195)
    },
  },
  voqcgmProfile => { #Structure Type: Mem;
    Name => "voqcgmProfile",
    RegMem => "Mem",
    Address => "2000000", # Excel Formula: =calc_mem_address(C192,A192,G196,L196)
    Description => "CGM profile per context used by voq_cgm",
    Width => "10", # Excel Formula: =calc_mem_width(E197:E197,M196,F197,-1)
    Type => "Dynamic",
    UsedBy => "CMAP: Write,RQM: Read0,RQM: Read1",
    MemEntries => "4096", # Excel Formula: =calc_field_width_define("NUM_OF_CONTEXTS")
    MemWrapper => "2R1W Fast Write",
    MemProtect => "ECC",
    AdditionalInfo => "SampleReadAccess=1,SampleReadBeforeProt=2,SampleWriteAfterProt=1,CpuReadAccess=Enabled,CpuWriteAccess=Enabled,DisableSameAddressErr=Enabled,WriteActivityFactor=10,ReadActivityFactor=100,PortErrPropagate=Disabled",
    MemLogicalWidth => "5",
    cgmProfile => { #Structure Type: MemField;
      Name => "cgmProfile",
      RegMem => "MemField",
      Width => "5", # Excel Formula: =calc_field_width_define("VOQ_CGM_PROFILE_NUM_WIDTH")
      Position => "4:0", # Excel Formula: =calc_position(F196,E197,TRUE)
      InitValueSa => "0",
      InitValueLcNwk => "0",
      InitValueLcFab => "(is_100g_fabric || line % 2 == 0) && (slice == 3 || slice == 4 ) &&
((line >= 1*144 + 24*0 && line < 1*144 + 24*0 + 20) ||
 (line >= 1*144 + 24*1 && line < 1*144 + 24*1 + 20) ||
 (line >= 1*144 + 24*2 && line < 1*144 + 24*2 + 20)) ? 2 :
(is_100g_fabric || line % 2 == 0) && (slice == 5) &&
 (line >= 1*144 + 24*0 && line < 1*144 + 24*3) ? 2 :
(is_100g_fabric || line % 2 == 0) && (slice == 3 || slice == 4 ) &&
((line >= 2*144 + 24*0 && line < 2*144 + 24*0 + 20) ||
 (line >= 2*144 + 24*1 && line < 2*144 + 24*1 + 20) ||
 (line >= 2*144 + 24*2 && line < 2*144 + 24*2 + 20)) ? 3 :
(is_100g_fabric || line % 2 == 0) && (slice == 5) &&
 (line >= 2*144 + 24*0 && line < 2*144 + 24*3) ? 3 : 0",
      InitValueFe => "(is_100g_fabric || line % 2 == 0) &&
((line >= 1*144 + 24*0 && line < 1*144 + 24*0 + 18) ||
 (line >= 1*144 + 24*1 && line < 1*144 + 24*1 + 18) ||
 (line >= 1*144 + 24*2 && line < 1*144 + 24*2 + 18) ||
 (line >= 1*144 + 24*3 && line < 1*144 + 24*3 + 18) ||
 (line >= 1*144 + 24*4 && line < 1*144 + 24*4 + 18) ||
 (line >= 1*144 + 24*5 && line < 1*144 + 24*5 + 18)) ? 2 :
(is_100g_fabric || line % 2 == 0) &&
((line >= 2*144 + 24*0 && line < 2*144 + 24*0 + 18) ||
 (line >= 2*144 + 24*1 && line < 2*144 + 24*1 + 18) ||
 (line >= 2*144 + 24*2 && line < 2*144 + 24*2 + 18) ||
 (line >= 2*144 + 24*3 && line < 2*144 + 24*3 + 18) ||
 (line >= 2*144 + 24*4 && line < 2*144 + 24*4 + 18) ||
 (line >= 2*144 + 24*5 && line < 2*144 + 24*5 + 18)) ? 3 : 0",
    },
  },
  ProfileBuffRegionThresholds => { #Structure Type: Mem;
    Name => "ProfileBuffRegionThresholds",
    RegMem => "Mem",
    Address => "2100000", # Excel Formula: =calc_mem_address(C196,A196,G198,L198)
    Description => "Per Profile Thresholds for max queue size in buffers to be included in Region X.
i.e. if QsizeBuffRegion0 < QsizeBuff <= QsizeBuffRegion1 then the region is 1.
If QsizeBuffRegion14 < QsizeBuff the region is 5",
    Width => "210", # Excel Formula: =calc_mem_width(E199:E199,M198,F199,-1)
    Type => "Config",
    UsedBy => "CgmEnqRpt: Read0,CgmDeqRpt: Read1",
    MemEntries => "32", # Excel Formula: =calc_field_width_define("VOQ_CGM_NUM_OF_PROFILES")
    MemWrapper => "2R1W Fast Write",
    MemProtect => "None",
    AdditionalInfo => "CpuReadAccess=Enabled,CpuWriteAccess=Enabled,FfBased=Enabled,DisableSameAddressErr=Enabled,WriteActivityFactor=0,ReadActivityFactor=100,PortErrPropagate=Disabled",
    Comments => "VOQ_CGM",
    MemLogicalWidth => "210",
    QsizeBuffRegion => { #Structure Type: MemField;
      Name => "QsizeBuffRegion",
      RegMem => "MemField",
      Description => "

Packed as:
{QsizeBuffRegion15,,QsizeBuffRegion0}
There are 16 Regions so 15 Thresholds
Each Threshold is 14 bits",
      Width => "210", # Excel Formula: =calc_field_width_define("QSIZE_BUF_WIDTH")*15
      Position => "209:0", # Excel Formula: =calc_position(F198,E199,TRUE)
      ArrayItemWidth => "14",
      InitValueSa => "item == 0 ? 50 :
item == 1 ? 256 :
item == 2 ? 512 :
item == 3 ? 1024 :
item == 4 ? 2048 :
item == 5 ? 3000 :
item == 6 ? 6000 :
item == 7 ? 7000 :
item == 8 ? 8000 :
item == 9 ? 9000 :
item == 10 ? 10000 :
item == 11 ? 12000 :
item == 12 ? 14000 :
item == 13 ? 15000 : 16000",
      InitValueLcNwk => "item == 0 ? 50 :
item == 1 ? 256 :
item == 2 ? 512 :
item == 3 ? 1024 :
item == 4 ? 2048 :
item == 5 ? 3000 :
item == 6 ? 6000 :
item == 7 ? 7000 :
item == 8 ? 8000 :
item == 9 ? 9000 :
item == 10 ? 10000 :
item == 11 ? 12000 :
item == 12 ? 14000 :
item == 13 ? 15000 : 16000",
      InitValueLcFab => "item == 0 ? 50 :
item == 1 ? 300 :
item == 2 ? 400 :
item == 3 ? 1000 :
item == 4 ? 1500 :
item == 5 ? 3000 :
item == 6 ? 6000 :
item == 7 ? 7000 :
item == 8 ? 8000 :
item == 9 ? 9000 :
item == 10 ? 10000 :
item == 11 ? 12000 :
item == 12 ? 14000 :
item == 13 ? 15000 : 16000",
      InitValueFe => "item == 0 ? 50 :
item == 1 ? 300 :
item == 2 ? 400 :
item == 3 ? 1000 :
item == 4 ? 1500 :
item == 5 ? 3000 :
item == 6 ? 4000 :
item == 7 ? 7000 :
item == 8 ? 8000 :
item == 9 ? 9000 :
item == 10 ? 10000 :
item == 11 ? 12000 :
item == 12 ? 14000 :
item == 13 ? 15000 : 16000",
    },
  },
  ProfilePktRegionThresholds => { #Structure Type: Mem;
    Name => "ProfilePktRegionThresholds",
    RegMem => "Mem",
    Address => "2200000", # Excel Formula: =calc_mem_address(C198,A198,G200,L200)
    Description => "Per Profile Thresholds for max queue size in PDs to be included in Region X.
i.e. if QsizePktRegion0 < QsizePkts <= QsizePktRegion1 then the region is 1.
If QsizePktRegion6 < QsizePkts the region is 7",
    Width => "98", # Excel Formula: =calc_mem_width(E201:E201,M200,F201,-1)
    Type => "Config",
    UsedBy => "CgmEnqRpt: Read0,CgmDeqRpt: Read1",
    MemEntries => "32", # Excel Formula: =calc_field_width_define("VOQ_CGM_NUM_OF_PROFILES")
    MemWrapper => "2R1W Fast Write",
    MemProtect => "None",
    AdditionalInfo => "CpuReadAccess=Enabled,CpuWriteAccess=Enabled,FfBased=Enabled,DisableSameAddressErr=Enabled,WriteActivityFactor=0,ReadActivityFactor=100,PortErrPropagate=Disabled",
    Comments => "VOQ_CGM",
    MemLogicalWidth => "98",
    QsizePktRegion => { #Structure Type: MemField;
      Name => "QsizePktRegion",
      RegMem => "MemField",
      Description => "
Packed as:
{QsizePktRegion6,,QsizePktRegion0}
There are 8 Regions so 7 Thresholds
Each Threshold is 14 bits",
      Width => "98", # Excel Formula: =calc_field_width_define("QSIZE_PKT_WIDTH")*7
      Position => "97:0", # Excel Formula: =calc_position(F200,E201,TRUE)
      ArrayItemWidth => "14",
      InitValueAllModes => "item == 0 ? 50 :
item == 1 ? 1500 :
item == 2 ? 12000 :
item == 3 ? 13000 :
item == 4 ? 14000 :
item == 5 ? 15000 : 16100",
    },
  },
  ProfilePktEnqTimeRegionThresholds => { #Structure Type: Mem;
    Name => "ProfilePktEnqTimeRegionThresholds",
    RegMem => "Mem",
    Address => "2300000", # Excel Formula: =calc_mem_address(C200,A200,G202,L202)
    Description => "Per Profile Thresholds for Voq-Delay to be in Region X.
i.e. if PdEnqTimeRegion0 < Qdelay <= PdEnqTimeRegion1 then region is 1.
If PdEnqTimeRegion14 < Qdelay region is 15",
    Width => "120", # Excel Formula: =calc_mem_width(E203:E203,M202,F203,-1)
    Type => "Config",
    UsedBy => "cgm_enq_req: Read",
    MemEntries => "32", # Excel Formula: =calc_field_width_define("VOQ_CGM_NUM_OF_PROFILES")
    MemWrapper => "1R1W",
    MemProtect => "None",
    AdditionalInfo => "CpuReadAccess=Enabled,CpuWriteAccess=Enabled,FfBased=Enabled,DisableSameAddressErr=Enabled,WriteActivityFactor=0,ReadActivityFactor=100,PortErrPropagate=Disabled",
    Comments => "VOQ_CGM",
    MemLogicalWidth => "120",
    PktEnqTimeRegion => { #Structure Type: MemField;
      Name => "PktEnqTimeRegion",
      RegMem => "MemField",
      Description => "
Packed as:
{PdEnqTimeRegion14,,QsizeBuffRegion0}
There are 16 Regions so 15 Thresholds
Each Threshold is 8 bits",
      Width => "120", # Excel Formula: =calc_field_width_define("VOQ_CGM_ENQ_TIME_WIDTH")*15
      Position => "119:0", # Excel Formula: =calc_position(F202,E203,TRUE)
      ArrayItemWidth => "8",
      InitValueAllModes => "(item < 14)  ? (item+1)*16 : 255",
    },
  },
  BuffersConsumptionLutForEnq => { #Structure Type: Mem;
    Name => "BuffersConsumptionLutForEnq",
    RegMem => "Mem",
    Address => "2400000", # Excel Formula: =calc_mem_address(C202,A202,G204,L204)
    Description => "CGM Enqueue test LUT for queue size in buffers.
The result of the test is a 3 bit decision for each of DropGreen, DropYellow, a 2 bit decision for CongestionMark, the decision is mapped to a probability threshold and then tested against a randomly generated value to decide if the relevant action is performed.
In addition there is a 1 bit decision for EvictToDram.
For drop green and drop yellow, the value 0 means no drop, and 7 means always drop, on all other values the relevant probablity LUT is accessed and the probability threshold for drop is calculated.
For congestion marking, the value 0 means no marking, on 1,2 and 3 the relevant probability LUT is accessed and the probability threshold for marking is calculated.
Every entry in memory holds 16 values for each decision type and the final decision is selected based on the 4 bit quantized queue delay level.
Address in memory is:
{Profile,RxpdrIngressCounterRegion,VoqSizeBuffersLevel}
Profile is 5 bits.
RxpdrIngressCounterRegion is 2 bits of Rxpdr's CounterA Utilization level.
VoqSizeBuffersLevel is 4 bits and is the quantized queue size in buffers based on ProfileBuffRegionThresholds Memory.",
    Width => "185", # Excel Formula: =calc_mem_width(E205:E209,M204,F209,-1)
    Type => "Config",
    UsedBy => "CGM_enq",
    MemEntries => "2048",
    MemWrapper => "1P",
    MemProtect => "ECC",
    AdditionalInfo => "SampleReadBeforeProt=2,SampleReadAfterProt=1,SampleWriteAfterProt=1,CpuReadAccess=Enabled,CpuWriteAccess=Enabled,DisableSameAddressErr=Enabled,WriteActivityFactor=0,ReadActivityFactor=100,PortErrPropagate=Disabled",
    Comments => "VOQ_CGM",
    MemLogicalWidth => "176",
    DropGreen => { #Structure Type: MemField;
      Name => "DropGreen",
      RegMem => "MemField",
      Description => "VoqDelayLevel selects offset out of 16.",
      Width => "48", # Excel Formula: =3*16
      Position => "47:0", # Excel Formula: =calc_position(F204,E205,TRUE)
      ArrayItemWidth => "3",
      InitValueSa => "(round_down(line/64) == 0) ? 7 :
((round_down(line/64) == 1) && (line%16 >= 6)) ? 7 :
((round_down(line/64) == 1) && (line%16 < 6)) ? 0 :
(line%16 == 15) ? 7 :
(is_hbm && (((round_down(line/16))%4 == 0 && line%16 >= 4 && item >= 12) ||
((round_down(line/16))%4 == 1 && line%16 >= 1 && item >= 12) ||
((round_down(line/16))%4 == 2 && line%16 >= 1 && item >= 12) ||
((round_down(line/16))%4 == 3 && line%16 >= 1 && item >= 1))) ? 7 :
(!is_hbm && (round_down(line/16))%4 == 0 && line%16 >= 12 && line%16 < 13) ? 1 :
(!is_hbm && (round_down(line/16))%4 == 0 && line%16 >= 13 && line%16 < 14) ? 2 :
(!is_hbm && (round_down(line/16))%4 == 0 && line%16 >= 14 && line%16 < 15) ? 3 :
(!is_hbm && (round_down(line/16))%4 == 1 && line%16 >   0 && line%16 < 12 && item == 15) ? 1 :
(!is_hbm && (round_down(line/16))%4 == 1 && line%16 >= 12 && line%16 < 13) ? 1 :
(!is_hbm && (round_down(line/16))%4 == 1 && line%16 >= 13 && line%16 < 14) ? 2 :
(!is_hbm && (round_down(line/16))%4 == 1 && line%16 >= 14 && line%16 < 15) ? 3 :
(!is_hbm && (round_down(line/16))%4 == 2 && line%16 >   0 && line%16 < 13 && item >  8) ? 2 :
(!is_hbm && (round_down(line/16))%4 == 2 && line%16 >= 12 && line%16 < 13 && item <= 8) ? 1 :
(!is_hbm && (round_down(line/16))%4 == 2 && line%16 >= 13 && line%16 < 14) ? 2 :
(!is_hbm && (round_down(line/16))%4 == 2 && line%16 >= 14 && line%16 < 15) ? 3 :
(!is_hbm && (round_down(line/16))%4 == 3 && line%16 >=  1 && line%16 < 15 && item >=  1) ? 7 : 0",
      InitValueLcNwk => "(round_down(line/64) == 0) ? 7 :
((round_down(line/64) == 1) && (line%16 >= 6)) ? 7 :
((round_down(line/64) == 1) && (line%16 < 6)) ? 0 :
(line%16 == 15) ? 7 :
(is_hbm && (((round_down(line/16))%4 == 0 && line%16 >= 4 && item >= 12) ||
((round_down(line/16))%4 == 1 && line%16 >= 1 && item >= 12) ||
((round_down(line/16))%4 == 2 && line%16 >= 1 && item >= 12) ||
((round_down(line/16))%4 == 3 && line%16 >= 1 && item >= 1))) ? 7 :
(!is_hbm && (round_down(line/16))%4 == 0 && line%16 >= 12 && line%16 < 13) ? 1 :
(!is_hbm && (round_down(line/16))%4 == 0 && line%16 >= 13 && line%16 < 14) ? 2 :
(!is_hbm && (round_down(line/16))%4 == 0 && line%16 >= 14 && line%16 < 15) ? 3 :
(!is_hbm && (round_down(line/16))%4 == 1 && line%16 >   0 && line%16 < 12 && item == 15) ? 1 :
(!is_hbm && (round_down(line/16))%4 == 1 && line%16 >= 12 && line%16 < 13) ? 1 :
(!is_hbm && (round_down(line/16))%4 == 1 && line%16 >= 13 && line%16 < 14) ? 2 :
(!is_hbm && (round_down(line/16))%4 == 1 && line%16 >= 14 && line%16 < 15) ? 3 :
(!is_hbm && (round_down(line/16))%4 == 2 && line%16 >   0 && line%16 < 13 && item >  8) ? 2 :
(!is_hbm && (round_down(line/16))%4 == 2 && line%16 >= 12 && line%16 < 13 && item <= 8) ? 1 :
(!is_hbm && (round_down(line/16))%4 == 2 && line%16 >= 13 && line%16 < 14) ? 2 :
(!is_hbm && (round_down(line/16))%4 == 2 && line%16 >= 14 && line%16 < 15) ? 3 :
(!is_hbm && (round_down(line/16))%4 == 3 && line%16 >=  1 && line%16 < 15 && item >=  1) ? 7 : 0",
      InitValueLcFab => "(round_down(line/64))%4 == 2 && round_down(line/256)   < 6 && line%16 >= 4 ? 7 :
(round_down(line/64))%4 == 3 && round_down(line/256)   < 6 && line%16 >= 2 ? 7 :
(round_down(line/64))%4 == 2 && round_down(line/256) >= 6 && line%16 >= 5 ? 7 :
(round_down(line/64))%4 == 3 && round_down(line/256) >= 6 && line%16 >= 3 ? 7 :
(round_down(line/64) == 0) ? 7 :
((round_down(line/64))%4 == 1) ? 7 : 0",
      InitValueFe => "(round_down(line/64))%4 == 2 && round_down(line/256)   < 6 && line%16 >= 6 ? 7 :
(round_down(line/64))%4 == 3 && round_down(line/256)   < 6 && line%16 >= 2 ? 7 :
(round_down(line/64))%4 == 2 && round_down(line/256) >= 6 && line%16 >= 7 ? 7 :
(round_down(line/64))%4 == 3 && round_down(line/256) >= 6 && line%16 >= 3 ? 7 :
(round_down(line/64) == 0) ? 7 :
((round_down(line/64))%4 == 1) ? 7 : 0",
    },
    DropYellow => { #Structure Type: MemField;
      Name => "DropYellow",
      RegMem => "MemField",
      Description => "VoqDelayLevel selects offset out of 16.",
      Width => "48", # Excel Formula: =3*16
      Position => "95:48", # Excel Formula: =calc_position(F205,E206)
      ArrayItemWidth => "3",
      InitValueSa => "(round_down(line/64) == 0) ? 7 :
((round_down(line/64) == 1) && (line%16 >= 6)) ? 7 :
((round_down(line/64) == 1) && (line%16 < 6)) ? 0 :
(line%16 == 15) ? 7 :
(is_hbm && (((round_down(line/16))%4 == 0 && line%16 >= 4 && item >= 12) ||
((round_down(line/16))%4 == 1 && line%16 >= 1 && item >= 12) ||
((round_down(line/16))%4 == 2 && line%16 >= 1 && item >= 12) ||
((round_down(line/16))%4 == 3 && line%16 >= 1 && item >= 1))) ? 7 :
(!is_hbm && (round_down(line/16))%4 == 0 && line%16 >= 12 && line%16 < 13) ? 1 :
(!is_hbm && (round_down(line/16))%4 == 0 && line%16 >= 13 && line%16 < 14) ? 2 :
(!is_hbm && (round_down(line/16))%4 == 0 && line%16 >= 14 && line%16 < 15) ? 3 :
(!is_hbm && (round_down(line/16))%4 == 1 && line%16 >   0 && line%16 < 12 && item == 15) ? 2 :
(!is_hbm && (round_down(line/16))%4 == 1 && line%16 >= 12 && line%16 < 13) ? 1 :
(!is_hbm && (round_down(line/16))%4 == 1 && line%16 >= 13 && line%16 < 14) ? 2 :
(!is_hbm && (round_down(line/16))%4 == 1 && line%16 >= 14 && line%16 < 15) ? 3 :
(!is_hbm && (round_down(line/16))%4 == 2 && line%16 >   0 && line%16 < 13 && item >  8) ? 3 :
(!is_hbm && (round_down(line/16))%4 == 2 && line%16 >= 12 && line%16 < 13 && item <= 8) ? 1 :
(!is_hbm && (round_down(line/16))%4 == 2 && line%16 >= 13 && line%16 < 14) ? 2 :
(!is_hbm && (round_down(line/16))%4 == 2 && line%16 >= 14 && line%16 < 15) ? 3 :
(!is_hbm && (round_down(line/16))%4 == 3 && line%16 >=  1 && line%16 < 15 && item >=  1) ? 7 : 0",
      InitValueLcNwk => "(round_down(line/64) == 0) ? 7 :
((round_down(line/64) == 1) && (line%16 >= 6)) ? 7 :
((round_down(line/64) == 1) && (line%16 < 6)) ? 0 :
(line%16 == 15) ? 7 :
(is_hbm && (((round_down(line/16))%4 == 0 && line%16 >= 4 && item >= 12) ||
((round_down(line/16))%4 == 1 && line%16 >= 1 && item >= 12) ||
((round_down(line/16))%4 == 2 && line%16 >= 1 && item >= 12) ||
((round_down(line/16))%4 == 3 && line%16 >= 1 && item >= 1))) ? 7 :
(!is_hbm && (round_down(line/16))%4 == 0 && line%16 >= 12 && line%16 < 13) ? 1 :
(!is_hbm && (round_down(line/16))%4 == 0 && line%16 >= 13 && line%16 < 14) ? 2 :
(!is_hbm && (round_down(line/16))%4 == 0 && line%16 >= 14 && line%16 < 15) ? 3 :
(!is_hbm && (round_down(line/16))%4 == 1 && line%16 >   0 && line%16 < 12 && item == 15) ? 2 :
(!is_hbm && (round_down(line/16))%4 == 1 && line%16 >= 12 && line%16 < 13) ? 1 :
(!is_hbm && (round_down(line/16))%4 == 1 && line%16 >= 13 && line%16 < 14) ? 2 :
(!is_hbm && (round_down(line/16))%4 == 1 && line%16 >= 14 && line%16 < 15) ? 3 :
(!is_hbm && (round_down(line/16))%4 == 2 && line%16 >   0 && line%16 < 13 && item >  8) ? 3 :
(!is_hbm && (round_down(line/16))%4 == 2 && line%16 >= 12 && line%16 < 13 && item <= 8) ? 1 :
(!is_hbm && (round_down(line/16))%4 == 2 && line%16 >= 13 && line%16 < 14) ? 2 :
(!is_hbm && (round_down(line/16))%4 == 2 && line%16 >= 14 && line%16 < 15) ? 3 :
(!is_hbm && (round_down(line/16))%4 == 3 && line%16 >=  1 && line%16 < 15 && item >=  1) ? 7 : 0",
      InitValueLcFab => "(round_down(line/64))%4 == 2 && round_down(line/256)   < 6 && line%16 >= 4 ? 7 :
(round_down(line/64))%4 == 3 && round_down(line/256)   < 6 && line%16 >= 2 ? 7 :
(round_down(line/64))%4 == 2 && round_down(line/256) >= 6 && line%16 >= 5 ? 7 :
(round_down(line/64))%4 == 3 && round_down(line/256) >= 6 && line%16 >= 3 ? 7 :
(round_down(line/64) == 0) ? 7 :
((round_down(line/64))%4 == 1) ? 7 : 0",
      InitValueFe => "(round_down(line/64))%4 == 2 && round_down(line/256)   < 6 && line%16 >= 6 ? 7 :
(round_down(line/64))%4 == 3 && round_down(line/256)   < 6 && line%16 >= 2 ? 7 :
(round_down(line/64))%4 == 2 && round_down(line/256) >= 6 && line%16 >= 7 ? 7 :
(round_down(line/64))%4 == 3 && round_down(line/256) >= 6 && line%16 >= 3 ? 7 :
(round_down(line/64) == 0) ? 7 :
((round_down(line/64))%4 == 1) ? 7 : 0",
    },
    EvictToDram => { #Structure Type: MemField;
      Name => "EvictToDram",
      RegMem => "MemField",
      Description => "VoqDelayLevel selects offset out of 16.",
      Width => "16",
      Position => "111:96", # Excel Formula: =calc_position(F206,E207)
      ArrayItemWidth => "1",
      InitValueSa => "(round_down(line/64) <= 1) ? 0 :
(line%16 == 15) ? 0 :
!is_hbm ? 0 :
((round_down(line/16))%4 == 0 && line%16 >= 2 &&  line%16 < 4   && item >=   8) ||
((round_down(line/16))%4 == 0 && line%16 >= 4 && item >=   8 && item < 12) ||
((round_down(line/16))%4 == 1 && line%16 >= 1 &&  item >=   8 && item < 12) ||
((round_down(line/16))%4 == 2 && line%16 >= 1 &&  item >=   8 && item < 12) ? 1 : 0",
      InitValueLcNwk => "(round_down(line/64) <= 1) ? 0 :
(line%16 == 15) ? 0 :
!is_hbm ? 0 :
((round_down(line/16))%4 == 0 && line%16 >= 2 &&  line%16 < 4   && item >=   8) ||
((round_down(line/16))%4 == 0 && line%16 >= 4 && item >=   8 && item < 12) ||
((round_down(line/16))%4 == 1 && line%16 >= 1 &&  item >=   8 && item < 12) ||
((round_down(line/16))%4 == 2 && line%16 >= 1 &&  item >=   8 && item < 12) ? 1 : 0",
      InitValueLcFab => "0",
      InitValueFe => "0",
    },
    MarkGreen => { #Structure Type: MemField;
      Name => "MarkGreen",
      RegMem => "MemField",
      Description => "VoqDelayLevel selects offset out of 16.",
      Width => "32", # Excel Formula: =2*16
      Position => "143:112", # Excel Formula: =calc_position(F207,E208)
      ArrayItemWidth => "2",
      InitValueSa => "(round_down(line/64) == 0) ? 0 :
(round_down(line/64) == 1) ? 0 :
(line%16 == 15) ? 0 :
is_hbm ? 0 :
((round_down(line/16))%4 == 0 && line%16 >= 12 && line%16 < 13) ? 1 :
((round_down(line/16))%4 == 0 && line%16 >= 13 && line%16 < 14) ? 2 :
((round_down(line/16))%4 == 0 && line%16 >= 14 && line%16 < 15) ? 3 :
((round_down(line/16))%4 == 1 && line%16 >   0 && line%16 < 12 && item == 15) ? 1 :
((round_down(line/16))%4 == 1 && line%16 >= 12 && line%16 < 13) ? 1 :
((round_down(line/16))%4 == 1 && line%16 >= 13 && line%16 < 14) ? 2 :
((round_down(line/16))%4 == 1 && line%16 >= 14 && line%16 < 15) ? 3 :
((round_down(line/16))%4 == 2 && line%16 >   0 && line%16 < 13 && item >  8) ? 2 :
((round_down(line/16))%4 == 2 && line%16 >= 12 && line%16 < 13 && item <= 8) ? 1 :
((round_down(line/16))%4 == 2 && line%16 >= 13 && line%16 < 14) ? 2 :
((round_down(line/16))%4 == 2 && line%16 >= 14 && line%16 < 15) ? 3 :
((round_down(line/16))%4 == 3 && line%16 >   0 && line%16 < 15 && item >  0) ? 0 : 0",
      InitValueLcNwk => "(round_down(line/64) == 0) ? 0 :
(round_down(line/64) == 1) ? 0 :
(line%16 == 15) ? 0 :
is_hbm ? 0 :
((round_down(line/16))%4 == 0 && line%16 >= 12 && line%16 < 13) ? 1 :
((round_down(line/16))%4 == 0 && line%16 >= 13 && line%16 < 14) ? 2 :
((round_down(line/16))%4 == 0 && line%16 >= 14 && line%16 < 15) ? 3 :
((round_down(line/16))%4 == 1 && line%16 >   0 && line%16 < 12 && item == 15) ? 1 :
((round_down(line/16))%4 == 1 && line%16 >= 12 && line%16 < 13) ? 1 :
((round_down(line/16))%4 == 1 && line%16 >= 13 && line%16 < 14) ? 2 :
((round_down(line/16))%4 == 1 && line%16 >= 14 && line%16 < 15) ? 3 :
((round_down(line/16))%4 == 2 && line%16 >   0 && line%16 < 13 && item >  8) ? 2 :
((round_down(line/16))%4 == 2 && line%16 >= 12 && line%16 < 13 && item <= 8) ? 1 :
((round_down(line/16))%4 == 2 && line%16 >= 13 && line%16 < 14) ? 2 :
((round_down(line/16))%4 == 2 && line%16 >= 14 && line%16 < 15) ? 3 :
((round_down(line/16))%4 == 3 && line%16 >   0 && line%16 < 15 && item >  0) ? 0 : 0",
      InitValueLcFab => "0",
      InitValueFe => "0",
    },
    MarkYellow => { #Structure Type: MemField;
      Name => "MarkYellow",
      RegMem => "MemField",
      Description => "VoqDelayLevel selects offset out of 16.",
      Width => "32", # Excel Formula: =2*16
      Position => "175:144", # Excel Formula: =calc_position(F208,E209)
      ArrayItemWidth => "2",
      InitValueSa => "(round_down(line/64) == 0) ? 0 :
(round_down(line/64) == 1) ? 0 :
(line%16 == 15) ? 0 :
is_hbm ? 0 :
((round_down(line/16))%4 == 0 && line%16 >= 12 && line%16 < 13) ? 1 :
((round_down(line/16))%4 == 0 && line%16 >= 13 && line%16 < 14) ? 2 :
((round_down(line/16))%4 == 0 && line%16 >= 14 && line%16 < 15) ? 3 :
((round_down(line/16))%4 == 1 && line%16 >   0 && line%16 < 12 && item == 15) ? 2 :
((round_down(line/16))%4 == 1 && line%16 >= 12 && line%16 < 13) ? 1 :
((round_down(line/16))%4 == 1 && line%16 >= 13 && line%16 < 14) ? 2 :
((round_down(line/16))%4 == 1 && line%16 >= 14 && line%16 < 15) ? 3 :
((round_down(line/16))%4 == 2 && line%16 >   0 && line%16 < 13 && item >  8) ? 3 :
((round_down(line/16))%4 == 2 && line%16 >= 12 && line%16 < 13 && item <= 8) ? 1 :
((round_down(line/16))%4 == 2 && line%16 >= 13 && line%16 < 14) ? 2 :
((round_down(line/16))%4 == 2 && line%16 >= 14 && line%16 < 15) ? 3 :
((round_down(line/16))%4 == 3 && line%16 >   0 && line%16 < 15 && item >  0) ? 0 : 0",
      InitValueLcNwk => "(round_down(line/64) == 0) ? 0 :
(round_down(line/64) == 1) ? 0 :
(line%16 == 15) ? 0 :
is_hbm ? 0 :
((round_down(line/16))%4 == 0 && line%16 >= 12 && line%16 < 13) ? 1 :
((round_down(line/16))%4 == 0 && line%16 >= 13 && line%16 < 14) ? 2 :
((round_down(line/16))%4 == 0 && line%16 >= 14 && line%16 < 15) ? 3 :
((round_down(line/16))%4 == 1 && line%16 >   0 && line%16 < 12 && item == 15) ? 2 :
((round_down(line/16))%4 == 1 && line%16 >= 12 && line%16 < 13) ? 1 :
((round_down(line/16))%4 == 1 && line%16 >= 13 && line%16 < 14) ? 2 :
((round_down(line/16))%4 == 1 && line%16 >= 14 && line%16 < 15) ? 3 :
((round_down(line/16))%4 == 2 && line%16 >   0 && line%16 < 13 && item >  8) ? 3 :
((round_down(line/16))%4 == 2 && line%16 >= 12 && line%16 < 13 && item <= 8) ? 1 :
((round_down(line/16))%4 == 2 && line%16 >= 13 && line%16 < 14) ? 2 :
((round_down(line/16))%4 == 2 && line%16 >= 14 && line%16 < 15) ? 3 :
((round_down(line/16))%4 == 3 && line%16 >   0 && line%16 < 15 && item >  0) ? 0 : 0",
      InitValueLcFab => "0",
      InitValueFe => "0",
    },
  },
  PdConsumptionLutForEnq => { #Structure Type: Mem;
    Name => "PdConsumptionLutForEnq",
    RegMem => "Mem",
    Address => "2500000", # Excel Formula: =calc_mem_address(C204,A204,G210,L210)
    Description => "CGM Enqueue test LUT for queue size in PDs.
The result of the test is a decision for DropGreen, DropYellow and CongestionMark.
Every entry in memory holds 16 bits for each decision type and the final decision is selected based on the 4 bit quantized queue delay level.
Address in memory is:
{Profile,PdvoqPdCounter0Level,VoqSizePdsLevel}
CGM logic implemented in memory.

Profile is 5 bits.
PdvoqPdCounter0Level is 2 bits of PDVOQ's PD Counter 0  Utilization level.
VoqSizePdsLevel is 3 bits and is the quantized queue size in PDs based on ProfilePktRegionThresholds Memory.",
    Width => "88", # Excel Formula: =calc_mem_width(E211:E215,M210,F215,-1)
    Type => "Config",
    UsedBy => "CGM_enq",
    MemEntries => "1024",
    MemWrapper => "1P",
    MemProtect => "ECC",
    AdditionalInfo => "SampleReadBeforeProt=2,SampleReadAfterProt=1,SampleWriteAfterProt=1,CpuReadAccess=Enabled,CpuWriteAccess=Enabled,DisableSameAddressErr=Enabled,WriteActivityFactor=0,ReadActivityFactor=100,PortErrPropagate=Disabled",
    Comments => "VOQ_CGM",
    MemLogicalWidth => "80",
    DropGreen => { #Structure Type: MemField;
      Name => "DropGreen",
      RegMem => "MemField",
      Description => "VoqDelayLevel selects offset out of 16.",
      Width => "16",
      Position => "15:0", # Excel Formula: =calc_position(F210,E211,TRUE)
      ArrayItemWidth => "1",
      InitValueSa => "(round_down(line/32) == 0) ? 1 :
(round_down(line/32) == 1 && line%8 >= 2) ? 1 :
(round_down(line/32) == 1 && line%8 < 2) ? 0 :
(line%8  == 7) ? 1 :
((round_down(line/8))%4 == 0 && line%8 >  0 && item > 0) ? 1 : 0",
      InitValueLcNwk => "(round_down(line/32) == 0) ? 1 :
(round_down(line/32) == 1 && line%8 >= 2) ? 1 :
(round_down(line/32) == 1 && line%8 < 2) ? 0 :
(line%8  == 7) ? 1 :
((round_down(line/8))%4 == 0 && line%8 >  0 && item > 0) ? 1 : 0",
      InitValueLcFab => "0",
      InitValueFe => "0",
    },
    DropYellow => { #Structure Type: MemField;
      Name => "DropYellow",
      RegMem => "MemField",
      Description => "VoqDelayLevel selects offset out of 16.",
      Width => "16",
      Position => "31:16", # Excel Formula: =calc_position(F211,E212)
      ArrayItemWidth => "1",
      InitValueSa => "(round_down(line/32) == 0) ? 1 :
(round_down(line/32) == 1 && line%8 >= 2) ? 1 :
(round_down(line/32) == 1 && line%8 < 2) ? 0 :
(line%8  == 7) ? 1 :
((round_down(line/8))%4 == 0 && line%8 >  0 && item > 0) ? 1 : 0",
      InitValueLcNwk => "(round_down(line/32) == 0) ? 1 :
(round_down(line/32) == 1 && line%8 >= 2) ? 1 :
(round_down(line/32) == 1 && line%8 < 2) ? 0 :
(line%8  == 7) ? 1 :
((round_down(line/8))%4 == 0 && line%8 >  0 && item > 0) ? 1 : 0",
      InitValueLcFab => "0",
      InitValueFe => "0",
    },
    EvictToDram => { #Structure Type: MemField;
      Name => "EvictToDram",
      RegMem => "MemField",
      Description => "VoqDelayLevel selects offset out of 16.",
      Width => "16",
      Position => "47:32", # Excel Formula: =calc_position(F212,E213)
      ArrayItemWidth => "1",
      InitValueAllModes => "0",
    },
    MarkGreen => { #Structure Type: MemField;
      Name => "MarkGreen",
      RegMem => "MemField",
      Description => "VoqDelayLevel selects offset out of 16.",
      Width => "16",
      Position => "63:48", # Excel Formula: =calc_position(F213,E214)
      ArrayItemWidth => "1",
      InitValueAllModes => "0",
    },
    MarkYellow => { #Structure Type: MemField;
      Name => "MarkYellow",
      RegMem => "MemField",
      Description => "VoqDelayLevel selects offset out of 16.",
      Width => "16",
      Position => "79:64", # Excel Formula: =calc_position(F214,E215)
      ArrayItemWidth => "1",
      InitValueAllModes => "0",
    },
  },
  VoqEnqRptSize => { #Structure Type: Mem;
    Name => "VoqEnqRptSize",
    RegMem => "Mem",
    Address => "2600000", # Excel Formula: =calc_mem_address(C210,A210,G216,L216)
    Description => "Enq Report Qsize region per context for Enq pipe",
    Width => "12", # Excel Formula: =calc_mem_width(E217:E218,M216,F218,-1)
    Type => "Dynamic",
    UsedBy => "CgmEnq: Read0,CgmRdReq: Read1,CgmEnqRpt: Write",
    MemEntries => "4096", # Excel Formula: =4*1024
    MemWrapper => "2R1W Fast Write",
    MemProtect => "ECC",
    AdditionalInfo => "SampleReadBeforeProt=2,SampleReadAfterProt=1,SampleWriteAfterProt=1,CpuReadAccess=Enabled,CpuWriteAccess=Enabled,DisableSameAddressErr=Enabled,WriteActivityFactor=100,ReadActivityFactor=100,PortErrPropagate=Disabled",
    Comments => "VOQ_CGM",
    MemLogicalWidth => "7",
    BuffRegion => { #Structure Type: MemField;
      Name => "BuffRegion",
      RegMem => "MemField",
      Description => "Qsize in buff region for Context",
      Width => "4", # Excel Formula: =calc_field_width_define("VOQ_CGM_BUF_QSIZE_REGION_WIDTH")
      Position => "3:0", # Excel Formula: =calc_position(F216,E217,TRUE)
    },
    PktRegion => { #Structure Type: MemField;
      Name => "PktRegion",
      RegMem => "MemField",
      Description => "Qsize in Pkt region for Context",
      Width => "3", # Excel Formula: =calc_field_width_define("VOQ_CGM_PKT_QSIZE_REGION_WIDTH")
      Position => "6:4", # Excel Formula: =calc_position(F217,E218)
    },
  },
  VoqDeqRptSize => { #Structure Type: Mem;
    Name => "VoqDeqRptSize",
    RegMem => "Mem",
    Address => "2700000", # Excel Formula: =calc_mem_address(C216,A216,G219,L219)
    Description => "Deq Report Qsize region per context for Enq pipe",
    Width => "12", # Excel Formula: =calc_mem_width(E220:E221,M219,F221,-1)
    Type => "Dynamic",
    UsedBy => "CgmEnq: Read0,CgmRdReq: Read1,CgmDeqRpt: Write",
    MemEntries => "4096", # Excel Formula: =4*1024
    MemWrapper => "2R1W Fast Write",
    MemProtect => "ECC",
    AdditionalInfo => "SampleReadBeforeProt=2,SampleReadAfterProt=1,SampleWriteAfterProt=1,CpuReadAccess=Enabled,CpuWriteAccess=Enabled,DisableSameAddressErr=Enabled,WriteActivityFactor=100,ReadActivityFactor=100,PortErrPropagate=Disabled",
    Comments => "VOQ_CGM",
    MemLogicalWidth => "7",
    BuffRegion => { #Structure Type: MemField;
      Name => "BuffRegion",
      RegMem => "MemField",
      Description => "Qsize in buff region for Context",
      Width => "4", # Excel Formula: =calc_field_width_define("VOQ_CGM_BUF_QSIZE_REGION_WIDTH")
      Position => "3:0", # Excel Formula: =calc_position(F219,E220,TRUE)
    },
    PktRegion => { #Structure Type: MemField;
      Name => "PktRegion",
      RegMem => "MemField",
      Description => "Qsize in Pkt region for Context",
      Width => "3", # Excel Formula: =calc_field_width_define("VOQ_CGM_PKT_QSIZE_REGION_WIDTH")
      Position => "6:4", # Excel Formula: =calc_position(F220,E221)
    },
  },
  LastRptEnqSetMem => { #Structure Type: Mem;
    Name => "LastRptEnqSetMem",
    RegMem => "Mem",
    Address => "2800000", # Excel Formula: =calc_mem_address(C219,A219,G222,L222)
    Description => "Set part of Set Clear Red Memory
Needs to be initiated to 0",
    Width => "39", # Excel Formula: =calc_mem_width(E223:E223,M222,F223,-1)
    Type => "Dynamic",
    UsedBy => "CGM_SCRP",
    MemEntries => "128", # Excel Formula: =4*1024/32
    MemWrapper => "3R1W Fast Write",
    MemProtect => "ECC",
    AdditionalInfo => "SampleReadBeforeProt=2,SampleReadAfterProt=1,SampleWriteAfterProt=1,CpuReadAccess=Enabled,CpuWriteAccess=Enabled,DisableSameAddressErr=Enabled,WriteActivityFactor=100,ReadActivityFactor=100,PortErrPropagate=Disabled",
    Comments => "VOQ_CGM",
    MemLogicalWidth => "32",
    EnqValid => { #Structure Type: MemField;
      Name => "EnqValid",
      RegMem => "MemField",
      Width => "32",
      Position => "31:0", # Excel Formula: =calc_position(F222,E223,TRUE)
      DefaultValue => "h0",
    },
  },
  LastRptEnqSetMemExtra => { #Structure Type: Mem;
    Name => "LastRptEnqSetMemExtra",
    RegMem => "Mem",
    Address => "2900000", # Excel Formula: =calc_mem_address(C222,A222,G224,L224)
    Description => "Set part of Set Clear Red Memory
Needs to be initiated to 0",
    Width => "39", # Excel Formula: =calc_mem_width(E225:E225,M224,F225,-1)
    Type => "Dynamic",
    UsedBy => "CGM_SCRP",
    MemEntries => "128", # Excel Formula: =4*1024/32
    MemWrapper => "1R1W",
    MemProtect => "ECC",
    AdditionalInfo => "SampleReadBeforeProt=2,SampleReadAfterProt=1,SampleWriteAfterProt=1,CpuReadAccess=Enabled,CpuWriteAccess=Enabled,DisableSameAddressErr=Enabled,WriteActivityFactor=100,ReadActivityFactor=100,PortErrPropagate=Disabled",
    Comments => "VOQ_CGM",
    MemLogicalWidth => "32",
    EnqValid => { #Structure Type: MemField;
      Name => "EnqValid",
      RegMem => "MemField",
      Width => "32",
      Position => "31:0", # Excel Formula: =calc_position(F224,E225,TRUE)
      DefaultValue => "h0",
    },
  },
  LastRptEnqClrMem => { #Structure Type: Mem;
    Name => "LastRptEnqClrMem",
    RegMem => "Mem",
    Address => "2A00000", # Excel Formula: =calc_mem_address(C224,A224,G226,L226)
    Description => "Clr part of Set Clear Red Memory
Needs to be initiated to 0",
    Width => "39", # Excel Formula: =calc_mem_width(E227:E227,M226,F227,-1)
    Type => "Dynamic",
    UsedBy => "CGM_SCRP",
    MemEntries => "128", # Excel Formula: =4*1024/32
    MemWrapper => "3R1W Fast Write",
    MemProtect => "ECC",
    AdditionalInfo => "SampleReadBeforeProt=2,SampleReadAfterProt=1,SampleWriteAfterProt=1,CpuReadAccess=Enabled,CpuWriteAccess=Enabled,DisableSameAddressErr=Enabled,WriteActivityFactor=100,ReadActivityFactor=100,PortErrPropagate=Disabled",
    Comments => "VOQ_CGM",
    MemLogicalWidth => "32",
    DeqValid => { #Structure Type: MemField;
      Name => "DeqValid",
      RegMem => "MemField",
      Width => "32",
      Position => "31:0", # Excel Formula: =calc_position(F226,E227,TRUE)
      DefaultValue => "h0",
    },
  },
  LastRptEnqClrMemExtra => { #Structure Type: Mem;
    Name => "LastRptEnqClrMemExtra",
    RegMem => "Mem",
    Address => "2B00000", # Excel Formula: =calc_mem_address(C226,A226,G228,L228)
    Description => "Clr part of Set Clear Red Memory
Needs to be initiated to 0",
    Width => "39", # Excel Formula: =calc_mem_width(E229:E229,M228,F229,-1)
    Type => "Dynamic",
    UsedBy => "CGM_SCRP",
    MemEntries => "128", # Excel Formula: =4*1024/32
    MemWrapper => "1R1W",
    MemProtect => "ECC",
    AdditionalInfo => "SampleReadBeforeProt=2,SampleReadAfterProt=1,SampleWriteAfterProt=1,CpuReadAccess=Enabled,CpuWriteAccess=Enabled,DisableSameAddressErr=Enabled,WriteActivityFactor=100,ReadActivityFactor=100,PortErrPropagate=Disabled",
    Comments => "VOQ_CGM",
    MemLogicalWidth => "32",
    DeqValid => { #Structure Type: MemField;
      Name => "DeqValid",
      RegMem => "MemField",
      Width => "32",
      Position => "31:0", # Excel Formula: =calc_position(F228,E229,TRUE)
      DefaultValue => "h0",
    },
  },
  VoqTenqHeadEnq => { #Structure Type: Mem;
    Name => "VoqTenqHeadEnq",
    RegMem => "Mem",
    Address => "2C00000", # Excel Formula: =calc_mem_address(C228,A228,G230,L230)
    Description => "Enq time for CGM",
    Width => "13", # Excel Formula: =calc_mem_width(E231:E231,M230,F231,-1)
    Type => "Dynamic",
    UsedBy => "CgmEnq: Read,CgmEnqRpt: Write",
    MemEntries => "4096", # Excel Formula: =4*1024
    MemWrapper => "1R1W",
    MemProtect => "ECC",
    AdditionalInfo => "SampleReadBeforeProt=2,SampleReadAfterProt=1,SampleWriteAfterProt=1,CpuReadAccess=Enabled,CpuWriteAccess=Enabled,DisableSameAddressErr=Enabled,WriteActivityFactor=100,ReadActivityFactor=100,PortErrPropagate=Disabled",
    Comments => "VOQ_CGM",
    MemLogicalWidth => "8",
    TEnq => { #Structure Type: MemField;
      Name => "TEnq",
      RegMem => "MemField",
      Description => "First enq device time",
      Width => "8",
      Position => "7:0", # Excel Formula: =calc_position(F230,E231,TRUE)
    },
  },
  VoqTenqHeadRd => { #Structure Type: Mem;
    Name => "VoqTenqHeadRd",
    RegMem => "Mem",
    Address => "2D00000", # Excel Formula: =calc_mem_address(C230,A230,G232,L232)
    Description => "Voq Head time for CGM",
    Width => "13", # Excel Formula: =calc_mem_width(E233:E233,M232,F233,-1)
    Type => "Dynamic",
    UsedBy => "CgmEnq: Read,CgmRdRpt: Write",
    MemEntries => "4096", # Excel Formula: =4*1024
    MemWrapper => "1R1W",
    MemProtect => "ECC",
    AdditionalInfo => "SampleReadBeforeProt=2,SampleReadAfterProt=1,SampleWriteAfterProt=1,CpuReadAccess=Enabled,CpuWriteAccess=Enabled,DisableSameAddressErr=Enabled,WriteActivityFactor=100,ReadActivityFactor=100,PortErrPropagate=Disabled",
    Comments => "VOQ_CGM",
    MemLogicalWidth => "8",
    TEnq => { #Structure Type: MemField;
      Name => "TEnq",
      RegMem => "MemField",
      Description => "Voq Head time for CGM",
      Width => "8",
      Position => "7:0", # Excel Formula: =calc_position(F232,E233,TRUE)
    },
  },
  VoqTenqHeadMsbEnq => { #Structure Type: Mem;
    Name => "VoqTenqHeadMsbEnq",
    RegMem => "Mem",
    Address => "2E00000", # Excel Formula: =calc_mem_address(C232,A232,G234,L234)
    Description => "Enq time for CGM",
    Width => "6", # Excel Formula: =calc_mem_width(E235:E235,M234,F235,-1)
    Type => "Dynamic",
    UsedBy => "CgmAging: Read,CgmEnqRpt: Write",
    MemEntries => "4096", # Excel Formula: =4*1024
    MemWrapper => "1R1W",
    MemProtect => "ECC",
    AdditionalInfo => "SampleReadBeforeProt=2,SampleReadAfterProt=1,SampleWriteAfterProt=1,CpuReadAccess=Enabled,CpuWriteAccess=Enabled,DisableSameAddressErr=Enabled,WriteActivityFactor=100,ReadActivityFactor=100,PortErrPropagate=Disabled",
    Comments => "VOQ_CGM",
    MemLogicalWidth => "2",
    TEnq => { #Structure Type: MemField;
      Name => "TEnq",
      RegMem => "MemField",
      Description => "First enq device time",
      Width => "2",
      Position => "1:0", # Excel Formula: =calc_position(F234,E235,TRUE)
    },
  },
  VoqTenqHeadMsbRd => { #Structure Type: Mem;
    Name => "VoqTenqHeadMsbRd",
    RegMem => "Mem",
    Address => "2F00000", # Excel Formula: =calc_mem_address(C234,A234,G236,L236)
    Description => "Voq Head time for CGM",
    Width => "6", # Excel Formula: =calc_mem_width(E237:E237,M236,F237,-1)
    Type => "Dynamic",
    UsedBy => "CgmAging: Read,CgmRdRpt: Write",
    MemEntries => "4096", # Excel Formula: =4*1024
    MemWrapper => "1R1W",
    MemProtect => "ECC",
    AdditionalInfo => "SampleReadBeforeProt=2,SampleReadAfterProt=1,SampleWriteAfterProt=1,CpuReadAccess=Enabled,CpuWriteAccess=Enabled,DisableSameAddressErr=Enabled,WriteActivityFactor=100,ReadActivityFactor=100,PortErrPropagate=Disabled",
    Comments => "VOQ_CGM",
    MemLogicalWidth => "2",
    TEnq => { #Structure Type: MemField;
      Name => "TEnq",
      RegMem => "MemField",
      Description => "Voq Head time for CGM",
      Width => "2",
      Position => "1:0", # Excel Formula: =calc_position(F236,E237,TRUE)
    },
  },
  HeadTimeEnqSetMem => { #Structure Type: Mem;
    Name => "HeadTimeEnqSetMem",
    RegMem => "Mem",
    Address => "3000000", # Excel Formula: =calc_mem_address(C236,A236,G238,L238)
    Description => "Set part of Set Clear Red Memory
Needs to be initiated to 0",
    Width => "39", # Excel Formula: =calc_mem_width(E239:E239,M238,F239,-1)
    Type => "Dynamic",
    UsedBy => "CGM_SCRP",
    MemEntries => "128", # Excel Formula: =4*1024/32
    MemWrapper => "3R1W Fast Write",
    MemProtect => "ECC",
    AdditionalInfo => "SampleReadBeforeProt=2,SampleReadAfterProt=1,SampleWriteAfterProt=1,CpuReadAccess=Enabled,CpuWriteAccess=Enabled,DisableSameAddressErr=Enabled,WriteActivityFactor=100,ReadActivityFactor=100,PortErrPropagate=Disabled",
    Comments => "VOQ_CGM",
    MemLogicalWidth => "32",
    EnqValid => { #Structure Type: MemField;
      Name => "EnqValid",
      RegMem => "MemField",
      Width => "32",
      Position => "31:0", # Excel Formula: =calc_position(F238,E239,TRUE)
      DefaultValue => "h0",
    },
  },
  HeadTimeEnqSetMemExtra => { #Structure Type: Mem;
    Name => "HeadTimeEnqSetMemExtra",
    RegMem => "Mem",
    Address => "3100000", # Excel Formula: =calc_mem_address(C238,A238,G240,L240)
    Description => "Set part of Set Clear Red Memory
Needs to be initiated to 0",
    Width => "39", # Excel Formula: =calc_mem_width(E241:E241,M240,F241,-1)
    Type => "Dynamic",
    UsedBy => "CGM_SCRP",
    MemEntries => "128", # Excel Formula: =4*1024/32
    MemWrapper => "1R1W",
    MemProtect => "ECC",
    AdditionalInfo => "SampleReadBeforeProt=2,SampleReadAfterProt=1,SampleWriteAfterProt=1,CpuReadAccess=Enabled,CpuWriteAccess=Enabled,DisableSameAddressErr=Enabled,WriteActivityFactor=100,ReadActivityFactor=100,PortErrPropagate=Disabled",
    Comments => "VOQ_CGM",
    MemLogicalWidth => "32",
    EnqValid => { #Structure Type: MemField;
      Name => "EnqValid",
      RegMem => "MemField",
      Width => "32",
      Position => "31:0", # Excel Formula: =calc_position(F240,E241,TRUE)
      DefaultValue => "h0",
    },
  },
  HeadTimeEnqClrMem => { #Structure Type: Mem;
    Name => "HeadTimeEnqClrMem",
    RegMem => "Mem",
    Address => "3200000", # Excel Formula: =calc_mem_address(C240,A240,G242,L242)
    Description => "Clr part of Set Clear Red Memory
Needs to be initiated to 0",
    Width => "39", # Excel Formula: =calc_mem_width(E243:E243,M242,F243,-1)
    Type => "Dynamic",
    UsedBy => "CGM_SCRP",
    MemEntries => "128", # Excel Formula: =4*1024/32
    MemWrapper => "3R1W Fast Write",
    MemProtect => "ECC",
    AdditionalInfo => "SampleReadBeforeProt=2,SampleReadAfterProt=1,SampleWriteAfterProt=1,CpuReadAccess=Enabled,CpuWriteAccess=Enabled,DisableSameAddressErr=Enabled,WriteActivityFactor=100,ReadActivityFactor=100,PortErrPropagate=Disabled",
    Comments => "VOQ_CGM",
    MemLogicalWidth => "32",
    DeqValid => { #Structure Type: MemField;
      Name => "DeqValid",
      RegMem => "MemField",
      Width => "32",
      Position => "31:0", # Excel Formula: =calc_position(F242,E243,TRUE)
      DefaultValue => "h0",
    },
  },
  HeadTimeEnqClrMemExtra => { #Structure Type: Mem;
    Name => "HeadTimeEnqClrMemExtra",
    RegMem => "Mem",
    Address => "3300000", # Excel Formula: =calc_mem_address(C242,A242,G244,L244)
    Description => "Clr part of Set Clear Red Memory
Needs to be initiated to 0",
    Width => "39", # Excel Formula: =calc_mem_width(E245:E245,M244,F245,-1)
    Type => "Dynamic",
    UsedBy => "CGM_SCRP",
    MemEntries => "128", # Excel Formula: =4*1024/32
    MemWrapper => "1R1W",
    MemProtect => "ECC",
    AdditionalInfo => "SampleReadBeforeProt=2,SampleReadAfterProt=1,SampleWriteAfterProt=1,CpuReadAccess=Enabled,CpuWriteAccess=Enabled,DisableSameAddressErr=Enabled,WriteActivityFactor=100,ReadActivityFactor=100,PortErrPropagate=Disabled",
    Comments => "VOQ_CGM",
    MemLogicalWidth => "32",
    DeqValid => { #Structure Type: MemField;
      Name => "DeqValid",
      RegMem => "MemField",
      Width => "32",
      Position => "31:0", # Excel Formula: =calc_position(F244,E245,TRUE)
      DefaultValue => "h0",
    },
  },
  IsAgingSetMem => { #Structure Type: Mem;
    Name => "IsAgingSetMem",
    RegMem => "Mem",
    Address => "3400000", # Excel Formula: =calc_mem_address(C244,A244,G246,L246)
    Description => "Set part of Set Clear Red Memory
Needs to be initiated to 0",
    Width => "39", # Excel Formula: =calc_mem_width(E247:E247,M246,F247,-1)
    Type => "Dynamic",
    UsedBy => "CGM_SCRP",
    MemEntries => "128", # Excel Formula: =4*1024/32
    MemWrapper => "3R1W Fast Write",
    MemProtect => "ECC",
    AdditionalInfo => "SampleReadBeforeProt=2,SampleReadAfterProt=1,SampleWriteAfterProt=1,CpuReadAccess=Enabled,CpuWriteAccess=Enabled,DisableSameAddressErr=Enabled,WriteActivityFactor=100,ReadActivityFactor=100,PortErrPropagate=Disabled",
    Comments => "VOQ_CGM",
    MemLogicalWidth => "32",
    Aging => { #Structure Type: MemField;
      Name => "Aging",
      RegMem => "MemField",
      Width => "32",
      Position => "31:0", # Excel Formula: =calc_position(F246,E247,TRUE)
      DefaultValue => "h0",
    },
  },
  IsAgingClrMem => { #Structure Type: Mem;
    Name => "IsAgingClrMem",
    RegMem => "Mem",
    Address => "3500000", # Excel Formula: =calc_mem_address(C246,A246,G248,L248)
    Description => "Set part of Set Clear Red Memory
Needs to be initiated to 0",
    Width => "39", # Excel Formula: =calc_mem_width(E249:E249,M248,F249,-1)
    Type => "Dynamic",
    UsedBy => "CGM_SCRP",
    MemEntries => "128", # Excel Formula: =4*1024/32
    MemWrapper => "3R1W Fast Write",
    MemProtect => "ECC",
    AdditionalInfo => "SampleReadBeforeProt=2,SampleReadAfterProt=1,SampleWriteAfterProt=1,CpuReadAccess=Enabled,CpuWriteAccess=Enabled,DisableSameAddressErr=Enabled,WriteActivityFactor=100,ReadActivityFactor=100,PortErrPropagate=Disabled",
    Comments => "VOQ_CGM",
    MemLogicalWidth => "32",
    Aging => { #Structure Type: MemField;
      Name => "Aging",
      RegMem => "MemField",
      Width => "32",
      Position => "31:0", # Excel Formula: =calc_position(F248,E249,TRUE)
      DefaultValue => "h0",
    },
  },
  AdmissionResultDram => { #Structure Type: Mem;
    Name => "AdmissionResultDram",
    RegMem => "Mem",
    Address => "3600000", # Excel Formula: =calc_mem_address(C248,A248,G250,L250)
    Description => "Dram Admission Result Memory",
    Width => "13", # Excel Formula: =calc_mem_width(E251:E253,M250,F253,-1)
    Type => "Dynamic",
    UsedBy => "dram: Write,CgmEnq: Read",
    MemEntries => "4096", # Excel Formula: =4*1024
    MemWrapper => "1R1W",
    MemProtect => "ECC",
    AdditionalInfo => "SampleReadBeforeProt=2,SampleReadAfterProt=1,SampleWriteAfterProt=1,CpuReadAccess=Enabled,CpuWriteAccess=Enabled,DisableSameAddressErr=Enabled,WriteActivityFactor=8,ReadActivityFactor=100,PortErrPropagate=Disabled",
    Comments => "VOQ_CGM",
    MemLogicalWidth => "8",
    AdmissionResult => { #Structure Type: MemField;
      Name => "AdmissionResult",
      RegMem => "MemField",
      Description => "Result is packed as {DropDp1,DropDp0}
DropDpx : 0 - Admit; 1 - Drop",
      Width => "2",
      Position => "1:0", # Excel Formula: =calc_position(F250,E251,TRUE)
      DefaultValue => "h0",
    },
    MarkingResult => { #Structure Type: MemField;
      Name => "MarkingResult",
      RegMem => "MemField",
      Description => "Result is packed as {MarkDp1,MarkDp0}",
      Width => "2",
      Position => "3:2", # Excel Formula: =calc_position(F251,E252)
      DefaultValue => "h0",
    },
    WredRegion => { #Structure Type: MemField;
      Name => "WredRegion",
      RegMem => "MemField",
      Description => "The region is mapped to drop/mark probability from the profile using DramWREDLut",
      Width => "4", # Excel Formula: =calc_field_width_define("DRAM_CGM_WRED_NUMBER_OF_REGIONS_WIDTH")
      Position => "7:4", # Excel Formula: =calc_position(F252,E253)
      DefaultValue => "h0",
    },
  },
  ProbLut => { #Structure Type: Mem;
    Name => "ProbLut",
    RegMem => "Mem",
    Address => "3700000", # Excel Formula: =calc_mem_address(C250,A250,G254,L254)
    Description => "This table contain 32 values for WRED.
Each value is a 17 bits probablity threshold, the address is calculated through the relevant dereference table.",
    Width => "17", # Excel Formula: =calc_mem_width(E255:E255,M254,F255,-1)
    Type => "Config",
    UsedBy => "CgmWred",
    MemEntries => "32", # Excel Formula: =calc_field_width_define("VOQ_CGM_NUM_OF_PROFILES")
    MemWrapper => "RegArray",
    MemProtect => "None",
    AdditionalInfo => "CpuReadAccess=Enabled,CpuWriteAccess=Enabled,FfBased=Enabled,DisableSameAddressErr=Enabled,WriteActivityFactor=0,ReadActivityFactor=100,PortErrPropagate=Disabled",
    Comments => "VOQ_CGM",
    MemLogicalWidth => "17",
    ProbabilityEntry => { #Structure Type: MemField;
      Name => "ProbabilityEntry",
      RegMem => "MemField",
      Description => "Probability threshold for WRED",
      Width => "17",
      Position => "16:0", # Excel Formula: =calc_position(F254,E255,TRUE)
      InitValueAllModes => "(line == 0) ? 0 :
(line == 1) ? 17'h51E :
(line == 2) ? 17'h1999 :
(line == 3) ? 17'h3333 :
(line == 4) ? 17'h10000 : 
(line == 5) ? 17'h1FFFF : 0",
    },
  },
  DropGreenProbabilitySelector => { #Structure Type: Mem;
    Name => "DropGreenProbabilitySelector",
    RegMem => "Mem",
    Address => "3800000", # Excel Formula: =calc_mem_address(C254,A254,G256,L256)
    Description => "This table is used to calculate the drop probability of green packets.
The 5 bit output is then used as address to the dereference table ProbLut to retrieve the actual 17 bits probability threshold.
The address is packed as {PacketSizeRange, Profile}
Each address contains 6 entries and DropGreenProbabilityLevel selects the entry.

PacketSizeRange is a 3 bits fixed quantization of the size in bytes of the current packet, the quantization is 
0 - up to 127 bytes
1 - 128 bytes to 255 bytes
2 - 256 bytes to 511 bytes
3 - 512 bytes to 1k-1 bytes
4 - 1k bytes to 2k-1 bytes
5 - 2k bytes and up
6,7 - unused
Profile is 5 bits and is the CGM profile for this VOQ.
DropGreenProbabilityLevel is 3 bit and is a result of the output of BuffersConsumptionLutForEnq for DropGreen.
DropGreenProbabilityLevel relevant values are 1 through 6.
Reminder : DropGreen == 0 means never drop and DropGreen == 7 means always drop.",
    Width => "37", # Excel Formula: =calc_mem_width(E257:E257,M256,F257,-1)
    Type => "Config",
    UsedBy => "CgmWred",
    MemEntries => "192", # Excel Formula: =32*6
    MemWrapper => "1P",
    MemProtect => "ECC",
    AdditionalInfo => "SampleReadBeforeProt=2,SampleReadAfterProt=1,SampleWriteBeforeProt=1,SampleWriteAfterProt=1,CpuReadAccess=Enabled,CpuWriteAccess=Enabled,DisableSameAddressErr=Enabled,WriteActivityFactor=0,ReadActivityFactor=100,PortErrPropagate=Disabled",
    Comments => "VOQ_CGM",
    MemLogicalWidth => "30",
    DropGreenProbabilitySelect => { #Structure Type: MemField;
      Name => "DropGreenProbabilitySelect",
      RegMem => "MemField",
      Description => "Selected probability entry in ProbLut.
6 Entries in each address.
LSB entry is taken when DropGreenProbabilityLevel == 1
MSB entry is taken when DropGreenProbabilityLevel == 6",
      Width => "30", # Excel Formula: =5*6
      Position => "29:0", # Excel Formula: =calc_position(F256,E257,TRUE)
      ArrayItemWidth => "5",
      InitValueAllModes => "(line < 64) ? 0 :
item + 1",
    },
  },
  DropYellowProbabilitySelector => { #Structure Type: Mem;
    Name => "DropYellowProbabilitySelector",
    RegMem => "Mem",
    Address => "3900000", # Excel Formula: =calc_mem_address(C256,A256,G258,L258)
    Description => "This table is used to calculate the drop probability of Yellow packets.
The 5 bit output is then used as address to the dereference table ProbLut to retrieve the actual 17 bits probability threshold.
The address is packed as {PacketSizeRange, Profile}
Each address contains 6 entries and DropYellowProbabilityLevel selects the entry.

PacketSizeRange is a 3 bits fixed quantization of the size in bytes of the current packet, the quantization is 
0 - up to 127 bytes
1 - 128 bytes to 255 bytes
2 - 256 bytes to 511 bytes
3 - 512 bytes to 1k-1 bytes
4 - 1k bytes to 2k-1 bytes
5 - 2k bytes and up
6,7 - unused
Profile is 5 bits and is the CGM profile for this VOQ.
DropYellowProbabilityLevel is 3 bit and is a result of the output of BuffersConsumptionLutForEnq for DropYellow.
DropYellowProbabilityLevel relevant values are 1 through 6.
Reminder : DropYellow == 0 means never drop and DropYellow == 7 means always drop.",
    Width => "37", # Excel Formula: =calc_mem_width(E259:E259,M258,F259,-1)
    Type => "Config",
    UsedBy => "CgmWred",
    MemEntries => "192", # Excel Formula: =32*6
    MemWrapper => "1P",
    MemProtect => "ECC",
    AdditionalInfo => "SampleReadBeforeProt=2,SampleReadAfterProt=1,SampleWriteBeforeProt=1,SampleWriteAfterProt=1,CpuReadAccess=Enabled,CpuWriteAccess=Enabled,DisableSameAddressErr=Enabled,WriteActivityFactor=0,ReadActivityFactor=100,PortErrPropagate=Disabled",
    Comments => "VOQ_CGM",
    MemLogicalWidth => "30",
    DropYellowProbabilitySelect => { #Structure Type: MemField;
      Name => "DropYellowProbabilitySelect",
      RegMem => "MemField",
      Description => "Selected probability entry in ProbLut.
6 Entries in each address.
LSB entry is taken when DropYellowProbabilityLevel == 1
MSB entry is taken when DropYellowProbabilityLevel == 6",
      Width => "30", # Excel Formula: =5*6
      Position => "29:0", # Excel Formula: =calc_position(F258,E259,TRUE)
      ArrayItemWidth => "5",
      InitValueAllModes => "(line < 64) ? 0 :
item + 1",
    },
  },
  MarkProbabilitySelector => { #Structure Type: Mem;
    Name => "MarkProbabilitySelector",
    RegMem => "Mem",
    Address => "3A00000", # Excel Formula: =calc_mem_address(C258,A258,G260,L260)
    Description => "This table is used to calculate the congestion marking probability of packets.
The 5 bit output is then used as address to the dereference table ProbLut to retrieve the actual 17 bits probability threshold.
The address is packed as {PacketSizeRange, Profile}
MarkProbabilityLevel selects entry is used.

PacketSizeRange is a 3 bits fixed quantization of the size in bytes of the current packet, the quantization is 
0 - up to 127 bytes
1 - 128 bytes to 255 bytes
2 - 256 bytes to 511 bytes
3 - 512 bytes to 1k-1 bytes
4 - 1k bytes to 2k-1 bytes
5 - 2k bytes and up
6,7 - unused
Profile is 5 bits and is the CGM profile for this VOQ.
MarkProbabilityLevel is 2 bit and is a result of the output of BuffersConsumptionLutForEnq for CongestionMark such that 
0 - Mark ==  1
1 - Mark == 2
2 - Mark == 3 
Reminder : Mark == 0 means never mark.",
    Width => "30", # Excel Formula: =calc_mem_width(E261:E262,M260,F262,-1)
    Type => "Config",
    UsedBy => "CgmWred",
    MemEntries => "192",
    MemWrapper => "1P",
    MemProtect => "None",
    AdditionalInfo => "SampleReadBeforeProt=2,SampleReadAfterProt=1,SampleWriteBeforeProt=1,SampleWriteAfterProt=1,CpuReadAccess=Enabled,CpuWriteAccess=Enabled,DisableSameAddressErr=Enabled,WriteActivityFactor=0,ReadActivityFactor=100,PortErrPropagate=Disabled",
    Comments => "VOQ_CGM",
    MemLogicalWidth => "30",
    MarkGreenSelect => { #Structure Type: MemField;
      Name => "MarkGreenSelect",
      RegMem => "MemField",
      Description => "Selected probability entry in ProbLut.
3 Entries in each address.
Selected by MarkGreen level received from BuffersConsumptionLutForEnq
",
      Width => "15", # Excel Formula: =5*3
      Position => "14:0", # Excel Formula: =calc_position(F260,E261,TRUE)
      ArrayItemWidth => "5",
      InitValueAllModes => "(item == 0) ? 2 :
(item == 1) ? 3 :
5",
    },
    MarkYellowSelect => { #Structure Type: MemField;
      Name => "MarkYellowSelect",
      RegMem => "MemField",
      Description => "Selected probability entry in ProbLut.
3 Entries in each address.
Selected by MarkYellow level received from BuffersConsumptionLutForEnq
",
      Width => "15", # Excel Formula: =5*3
      Position => "29:15", # Excel Formula: =calc_position(F261,E262)
      ArrayItemWidth => "5",
      InitValueAllModes => "(item == 0) ? 2 :
(item == 1) ? 3 :
5",
    },
  },
  EvictedBuffersConsumptionLut => { #Structure Type: Mem;
    Name => "EvictedBuffersConsumptionLut",
    RegMem => "Mem",
    Address => "3B00000", # Excel Formula: =calc_mem_address(C260,A260,G263,L263)
    Description => "CGM Enqueue test LUT for queue size in buffers for evicted queues.
The result of the test is a 1 bit decision for each of DropGreen, DropYellow.

Address in memory is:
{TotalEvictedBuffers,EvictedProfile,RxpdrIngressCounterRegion,VoqSizeBuffersLevel}
TotalEvictedBuffers - 2 bit level of total DRAM bound SMS buffers.
EvictedProfile is 2 bits profile resulting from mapping the CGM profile to the EvictedProfile.
RxpdrIngressCounterRegion is 2 bits of Rxpdr's CounterA Utilization level.
VoqSizeBuffersLevel is 4 bits and is the quantized queue size in buffers based on ProfileBuffRegionThresholds Memory.",
    Width => "2", # Excel Formula: =calc_mem_width(E264:E265,M263,F265,-1)
    Type => "Config",
    UsedBy => "CGM_enq",
    MemEntries => "1024",
    MemWrapper => "1P",
    MemProtect => "None",
    AdditionalInfo => "SampleReadBeforeProt=2,SampleReadAfterProt=1,SampleWriteAfterProt=1,CpuReadAccess=Enabled,CpuWriteAccess=Enabled,FfBased=Enabled,DisableSameAddressErr=Enabled,WriteActivityFactor=0,ReadActivityFactor=100,PortErrPropagate=Disabled",
    Comments => "VOQ_CGM",
    MemLogicalWidth => "2",
    DropGreen => { #Structure Type: MemField;
      Name => "DropGreen",
      RegMem => "MemField",
      Description => "Drop green decision",
      Width => "1",
      Position => "0", # Excel Formula: =calc_position(F263,E264,TRUE)
      InitValueAllModes => "((round_down(line/16))%4 == 0 && round_down(line/256) == 3 && line%16 >= 5) ||
((round_down(line/16))%4 == 1 && round_down(line/256) == 2 && line%16 >= 5) ||
((round_down(line/16))%4 == 1 && round_down(line/256) == 3) ||
((round_down(line/16))%4 == 2 && round_down(line/256) == 2 && line%16 >= 5) ||
((round_down(line/16))%4 == 2 && round_down(line/256) == 3) ||
((round_down(line/16))%4 == 3 && round_down(line/256) == 1 && line%16 >= 4) ||
((round_down(line/16))%4 == 3 && round_down(line/256) >= 2) ? 1 : 0",
    },
    DropYellow => { #Structure Type: MemField;
      Name => "DropYellow",
      RegMem => "MemField",
      Description => "Drop Yellow decision",
      Width => "1",
      Position => "1", # Excel Formula: =calc_position(F264,E265)
      InitValueAllModes => "((round_down(line/16))%4 == 0 && round_down(line/256) == 3 && line%16 >= 4) ||
((round_down(line/16))%4 == 1 && round_down(line/256) == 2 && line%16 >= 4) ||
((round_down(line/16))%4 == 1 && round_down(line/256) == 3) ||
((round_down(line/16))%4 == 2 && round_down(line/256) == 2 && line%16 >= 4) ||
((round_down(line/16))%4 == 2 && round_down(line/256) == 3) ||
((round_down(line/16))%4 == 3 && round_down(line/256) == 1 && line%16 >= 3) ||
((round_down(line/16))%4 == 3 && round_down(line/256) >= 2) ? 1 : 0",
    },
  },
  EvictedOkLut => { #Structure Type: Mem;
    Name => "EvictedOkLut",
    RegMem => "Mem",
    Address => "3C00000", # Excel Formula: =calc_mem_address(C263,A263,G266,L266)
    Description => "CGM Enqueue test LUT for eviction decision based on available DRAM context level and total DRAM bound SMS buffers..
The result of the test is a 1 bit indication of prevent eviction to DRAM and another 1 bit indication of drop PD on evict decision.

Address in memory is:
{TotalEvictedBuffers,FreeDRAMContextLevel,Profile}
TotalEvictedBuffers - 2 bit level of total DRAM bound SMS buffers.
Profile is 5 bits CGM profile.
",
    Width => "2", # Excel Formula: =calc_mem_width(E267:E268,M266,F268,-1)
    Type => "Config",
    UsedBy => "CGM_enq",
    MemEntries => "1024",
    MemWrapper => "1P",
    MemProtect => "None",
    AdditionalInfo => "SampleReadBeforeProt=2,SampleReadAfterProt=1,SampleWriteAfterProt=1,CpuReadAccess=Enabled,CpuWriteAccess=Enabled,FfBased=Enabled,DisableSameAddressErr=Enabled,WriteActivityFactor=0,ReadActivityFactor=100,PortErrPropagate=Disabled",
    Comments => "VOQ_CGM",
    MemLogicalWidth => "2",
    EvictionOk => { #Structure Type: MemField;
      Name => "EvictionOk",
      RegMem => "MemField",
      Description => "1' - Ok to evict
'0' - Mask eviction decision from other LUT",
      Width => "1",
      Position => "0", # Excel Formula: =calc_position(F266,E267,TRUE)
      InitValueAllModes => "(round_down(line/32))%2 == 1 ? 0 :
(round_down(line/64))%4 >= 2 ? 0 : 1",
    },
    DropOnEviction => { #Structure Type: MemField;
      Name => "DropOnEviction",
      RegMem => "MemField",
      Description => "1' - if other LUT resulted in eviction to DRAM, drop packet.
'0' - Don't drop on eviction decision.",
      Width => "1",
      Position => "1", # Excel Formula: =calc_position(F267,E268)
      InitValueAllModes => "0",
    },
  },
  DramWredLut => { #Structure Type: Mem;
    Name => "DramWredLut",
    RegMem => "Mem",
    Address => "3D00000", # Excel Formula: =calc_mem_address(C266,A266,G269,L269)
    Description => "DRAM WRED probability selector LUT.
The result of the test is a 5 bit index into ProbLut to select probability of each action.
Actions are DropGreen, DropYellow, MarkGreen, MarkYellow.

Address in memory is:
{Profile,PacketSizeRange,DramWredBufferFillLevel}
Profile is 5 bits CGM profile.
PacketSizeRange is 3 bits as described in DropGreenProbabilitySelector
DramWredBufferFillLevel - 4 bit quantized average queue size in DRAM for WRED.
",
    Width => "20", # Excel Formula: =calc_mem_width(E270:E273,M269,F273,-1)
    Type => "Config",
    UsedBy => "CGM_enq",
    MemEntries => "4096", # Excel Formula: =POWER(2,5+4+3)
    MemWrapper => "1P",
    MemProtect => "None",
    AdditionalInfo => "SampleReadBeforeProt=2,SampleReadAfterProt=1,SampleWriteAfterProt=1,CpuReadAccess=Enabled,CpuWriteAccess=Enabled,DisableSameAddressErr=Enabled,WriteActivityFactor=0,ReadActivityFactor=100,PortErrPropagate=Disabled",
    Comments => "VOQ_CGM",
    MemLogicalWidth => "20",
    DropGreenProbIdx => { #Structure Type: MemField;
      Name => "DropGreenProbIdx",
      RegMem => "MemField",
      Description => "Index into ProbLut to select probability of drop green PDs",
      Width => "5",
      Position => "4:0", # Excel Formula: =calc_position(F269,E270,TRUE)
      InitValueAllModes => "0",
    },
    DropYellowProbIdx => { #Structure Type: MemField;
      Name => "DropYellowProbIdx",
      RegMem => "MemField",
      Description => "Index into ProbLut to select probability of drop yellow PDs",
      Width => "5",
      Position => "9:5", # Excel Formula: =calc_position(F270,E271)
      InitValueAllModes => "0",
    },
    MarkGreenProbIdx => { #Structure Type: MemField;
      Name => "MarkGreenProbIdx",
      RegMem => "MemField",
      Description => "Index into ProbLut to select probability of mark green PDs",
      Width => "5",
      Position => "14:10", # Excel Formula: =calc_position(F271,E272)
      InitValueAllModes => "0",
    },
    MarkYellowProbIdx => { #Structure Type: MemField;
      Name => "MarkYellowProbIdx",
      RegMem => "MemField",
      Description => "Index into ProbLut to select probability of mark yellow PDs",
      Width => "5",
      Position => "19:15", # Excel Formula: =calc_position(F272,E273)
      InitValueAllModes => "0",
    },
  },
  DeqBuffersConsumptionLut => { #Structure Type: Mem;
    Name => "DeqBuffersConsumptionLut",
    RegMem => "Mem",
    Address => "3E00000", # Excel Formula: =calc_mem_address(C269,A269,G274,L274)
    Description => "LUT for determining congestion level on packets at dequeue from PDVOQ buffers fill level
Address is {Profile,BufferAvailableLevel,VoqBufferFillLevel}
Profile is 5 bits
BufferAvailableLevel is quantized to 2 bits.
VoqSizeBuffersLevel is 4 bits and is the quantized queue size in buffers based on ProfileBuffRegionThresholds Memory.",
    Width => "64", # Excel Formula: =calc_mem_width(E275:E275,M274,F275,-1)
    Type => "Config",
    UsedBy => "CGM_deq",
    MemEntries => "2048", # Excel Formula: =POWER(2,5+2+4)
    MemWrapper => "1P",
    MemProtect => "None",
    AdditionalInfo => "SampleReadBeforeProt=2,SampleReadAfterProt=1,SampleWriteAfterProt=1,CpuReadAccess=Enabled,CpuWriteAccess=Enabled,DisableSameAddressErr=Enabled,WriteActivityFactor=0,ReadActivityFactor=100,PortErrPropagate=Disabled",
    Comments => "VOQ_CGM",
    MemLogicalWidth => "64",
    CongestionLevel => { #Structure Type: MemField;
      Name => "CongestionLevel",
      RegMem => "MemField",
      Description => "VoqDelayLevel selects offset out of 16.",
      Width => "64", # Excel Formula: =4*16
      Position => "63:0", # Excel Formula: =calc_position(F274,E275,TRUE)
      ArrayItemWidth => "4",
      InitValueSa => "(round_down(line/64) == 1) ? 0 :
((line%64 < 16) && (item < (line%16))) ? item :
(line%64 < 16) ? line%16 :
((line%64 < 32) && (item < 7) && ((line%16) < 7)) ?  7 :
((line%64 < 32) && (item < (line%16))) ? item :
(line%64 < 32) ? line%16 :
((line%64 < 48) && (item < 11) && ((line%16) < 11)) ?  11 :
((line%64 < 48) && (item < (line%16))) ? item :
(line%64 < 48) ? line%16 : 15",
      InitValueLcNwk => "(round_down(line/64) == 1) ? 0 :
((line%64 < 16) && (item < (line%16))) ? item :
(line%64 < 16) ? line%16 :
((line%64 < 32) && (item < 7) && ((line%16) < 7)) ?  7 :
((line%64 < 32) && (item < (line%16))) ? item :
(line%64 < 32) ? line%16 :
((line%64 < 48) && (item < 11) && ((line%16) < 11)) ?  11 :
((line%64 < 48) && (item < (line%16))) ? item :
(line%64 < 48) ? line%16 : 15",
      InitValueLcFab => "0",
      InitValueFe => "0",
    },
  },
  DeqPDsConsumptionLut => { #Structure Type: Mem;
    Name => "DeqPDsConsumptionLut",
    RegMem => "Mem",
    Address => "3F00000", # Excel Formula: =calc_mem_address(C274,A274,G276,L276)
    Description => "LUT for determining congestion level on packets at dequeue from PDVOQ based on PD fill level.
Address is {Profile,PdPoolAvailableLevel,VoqPdFillLevel}
Profile is 5 bits
PdPoolAvailableLevel is quantized to 2 bits.
VoqPdFillLevel is 3 bits and is the quantized queue size in Pds.",
    Width => "64", # Excel Formula: =calc_mem_width(E277:E277,M276,F277,-1)
    Type => "Config",
    UsedBy => "CGM_deq",
    MemEntries => "1024", # Excel Formula: =POWER(2,5+2+3)
    MemWrapper => "1P",
    MemProtect => "None",
    AdditionalInfo => "SampleReadBeforeProt=2,SampleReadAfterProt=1,SampleWriteAfterProt=1,CpuReadAccess=Enabled,CpuWriteAccess=Enabled,DisableSameAddressErr=Enabled,WriteActivityFactor=0,ReadActivityFactor=100,PortErrPropagate=Disabled",
    Comments => "VOQ_CGM",
    MemLogicalWidth => "64",
    CongestionLevel => { #Structure Type: MemField;
      Name => "CongestionLevel",
      RegMem => "MemField",
      Description => "VoqDelayLevel selects offset out of 16.",
      Width => "64", # Excel Formula: =4*16
      Position => "63:0", # Excel Formula: =calc_position(F276,E277,TRUE)
      ArrayItemWidth => "4",
      InitValueAllModes => "0",
    },
  },
};
