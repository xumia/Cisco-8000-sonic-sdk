$block{reassembly} = {
  Defines_db => "Z:\\leaba_reg_db_example\\defines.v",
  ProjectName => "Gibraltar",
  InterruptRegister => { #Structure Type: Reg; Skip Register;
    Name => "InterruptRegister",
    RegMem => "Reg",
    Address => "0",
    Description => "Master Interrupt Register",
    Width => "1",
    Type => "Interrupt",
    MemProtectInterruptSummary => { #Structure Type: RegField;
      Name => "MemProtectInterruptSummary",
      RegMem => "RegField",
      Description => "When this bit is set, MemProtectInterrupt has asserted interrupt",
      Width => "1",
      Position => "0",
      Type => "Interrupt",
    },
  },
  MemProtectInterrupt => { #Structure Type: Reg; Skip Register;
    Name => "MemProtectInterrupt",
    RegMem => "Reg",
    Address => "1",
    Description => "ECC/Parity Interrupt Register",
    Width => "3",
    Type => "Interrupt",
    Ecc_1bErrInterrupt => { #Structure Type: RegField;
      Name => "Ecc_1bErrInterrupt",
      RegMem => "RegField",
      Description => "When this bit is set, ECC 1b error was detected",
      Width => "1",
      Position => "0",
      Type => "Interrupt",
      UsedBy => "SER",
    },
    Ecc_2bErrInterrupt => { #Structure Type: RegField;
      Name => "Ecc_2bErrInterrupt",
      RegMem => "RegField",
      Description => "When this bit is set, ECC 2b error was detected",
      Width => "1",
      Position => "1",
      Type => "Interrupt",
      UsedBy => "SER",
    },
    ParityErrInterrupt => { #Structure Type: RegField;
      Name => "ParityErrInterrupt",
      RegMem => "RegField",
      Description => "When this bit is set, Parity error was detected",
      Width => "1",
      Position => "2",
      Type => "Interrupt",
      UsedBy => "SER",
    },
  },
  MemProtectInterruptTest => { #Structure Type: Reg; Skip Register;
    Name => "MemProtectInterruptTest",
    RegMem => "Reg",
    Address => "2",
    Description => "ECC/Parity Interrupt test register",
    Width => "3",
    Type => "InterruptTest",
    Ecc_1bErrInterruptTest => { #Structure Type: RegField;
      Name => "Ecc_1bErrInterruptTest",
      RegMem => "RegField",
      Description => "Setting this filed to 1 triggers an assertion of the interrupt that is associated with this test field",
      Width => "1",
      Position => "0",
      Type => "InterruptTest",
      UsedBy => "",
      DefaultValue => "b0",
    },
    Ecc_2bErrInterruptTest => { #Structure Type: RegField;
      Name => "Ecc_2bErrInterruptTest",
      RegMem => "RegField",
      Description => "Setting this filed to 1 triggers an assertion of the interrupt that is associated with this test field",
      Width => "1",
      Position => "1",
      Type => "InterruptTest",
      UsedBy => "",
      DefaultValue => "b0",
    },
    ParityErrInterruptTest => { #Structure Type: RegField;
      Name => "ParityErrInterruptTest",
      RegMem => "RegField",
      Description => "Setting this filed to 1 triggers an assertion of the interrupt that is associated with this test field",
      Width => "1",
      Position => "2",
      Type => "InterruptTest",
      UsedBy => "",
      DefaultValue => "b0",
    },
  },
  Ecc_1bErrInterruptRegisterMask => { #Structure Type: Reg; Skip Register;
    Name => "Ecc_1bErrInterruptRegisterMask",
    RegMem => "Reg",
    Address => "3",
    Description => "ECC 1b Error Interrupt Mask Register",
    Width => "20",
    Type => "Config",
    ContextTable0Ecc_1bErrInterruptMask => { #Structure Type: RegField;
      Name => "ContextTable0Ecc_1bErrInterruptMask",
      RegMem => "RegField",
      Description => "When this bit is set, ECC 1b Error indication will be masked",
      Width => "1",
      Position => "0",
      Type => "Config",
      UsedBy => "SER",
      DefaultValue => "b1",
    },
    ContextTable1Ecc_1bErrInterruptMask => { #Structure Type: RegField;
      Name => "ContextTable1Ecc_1bErrInterruptMask",
      RegMem => "RegField",
      Description => "When this bit is set, ECC 1b Error indication will be masked",
      Width => "1",
      Position => "1",
      Type => "Config",
      UsedBy => "SER",
      DefaultValue => "b1",
    },
    ContextTable2Ecc_1bErrInterruptMask => { #Structure Type: RegField;
      Name => "ContextTable2Ecc_1bErrInterruptMask",
      RegMem => "RegField",
      Description => "When this bit is set, ECC 1b Error indication will be masked",
      Width => "1",
      Position => "2",
      Type => "Config",
      UsedBy => "SER",
      DefaultValue => "b1",
    },
    ContextTable3Ecc_1bErrInterruptMask => { #Structure Type: RegField;
      Name => "ContextTable3Ecc_1bErrInterruptMask",
      RegMem => "RegField",
      Description => "When this bit is set, ECC 1b Error indication will be masked",
      Width => "1",
      Position => "3",
      Type => "Config",
      UsedBy => "SER",
      DefaultValue => "b1",
    },
    ContextTable4Ecc_1bErrInterruptMask => { #Structure Type: RegField;
      Name => "ContextTable4Ecc_1bErrInterruptMask",
      RegMem => "RegField",
      Description => "When this bit is set, ECC 1b Error indication will be masked",
      Width => "1",
      Position => "4",
      Type => "Config",
      UsedBy => "SER",
      DefaultValue => "b1",
    },
    ContextTable5Ecc_1bErrInterruptMask => { #Structure Type: RegField;
      Name => "ContextTable5Ecc_1bErrInterruptMask",
      RegMem => "RegField",
      Description => "When this bit is set, ECC 1b Error indication will be masked",
      Width => "1",
      Position => "5",
      Type => "Config",
      UsedBy => "SER",
      DefaultValue => "b1",
    },
    OutPdFIFO0Ecc_1bErrInterruptMask => { #Structure Type: RegField;
      Name => "OutPdFIFO0Ecc_1bErrInterruptMask",
      RegMem => "RegField",
      Description => "When this bit is set, ECC 1b Error indication will be masked",
      Width => "1",
      Position => "6",
      Type => "Config",
      UsedBy => "SER",
      DefaultValue => "b1",
    },
    OutPdFIFO1Ecc_1bErrInterruptMask => { #Structure Type: RegField;
      Name => "OutPdFIFO1Ecc_1bErrInterruptMask",
      RegMem => "RegField",
      Description => "When this bit is set, ECC 1b Error indication will be masked",
      Width => "1",
      Position => "7",
      Type => "Config",
      UsedBy => "SER",
      DefaultValue => "b1",
    },
    OutPdFIFO2Ecc_1bErrInterruptMask => { #Structure Type: RegField;
      Name => "OutPdFIFO2Ecc_1bErrInterruptMask",
      RegMem => "RegField",
      Description => "When this bit is set, ECC 1b Error indication will be masked",
      Width => "1",
      Position => "8",
      Type => "Config",
      UsedBy => "SER",
      DefaultValue => "b1",
    },
    OutPdFIFO3Ecc_1bErrInterruptMask => { #Structure Type: RegField;
      Name => "OutPdFIFO3Ecc_1bErrInterruptMask",
      RegMem => "RegField",
      Description => "When this bit is set, ECC 1b Error indication will be masked",
      Width => "1",
      Position => "9",
      Type => "Config",
      UsedBy => "SER",
      DefaultValue => "b1",
    },
    OutPdFIFO4Ecc_1bErrInterruptMask => { #Structure Type: RegField;
      Name => "OutPdFIFO4Ecc_1bErrInterruptMask",
      RegMem => "RegField",
      Description => "When this bit is set, ECC 1b Error indication will be masked",
      Width => "1",
      Position => "10",
      Type => "Config",
      UsedBy => "SER",
      DefaultValue => "b1",
    },
    OutPdFIFO5Ecc_1bErrInterruptMask => { #Structure Type: RegField;
      Name => "OutPdFIFO5Ecc_1bErrInterruptMask",
      RegMem => "RegField",
      Description => "When this bit is set, ECC 1b Error indication will be masked",
      Width => "1",
      Position => "11",
      Type => "Config",
      UsedBy => "SER",
      DefaultValue => "b1",
    },
    InFifo0Ecc_1bErrInterruptMask => { #Structure Type: RegField;
      Name => "InFifo0Ecc_1bErrInterruptMask",
      RegMem => "RegField",
      Description => "When this bit is set, ECC 1b Error indication will be masked",
      Width => "1",
      Position => "12",
      Type => "Config",
      UsedBy => "SER",
      DefaultValue => "b1",
    },
    InFifo1Ecc_1bErrInterruptMask => { #Structure Type: RegField;
      Name => "InFifo1Ecc_1bErrInterruptMask",
      RegMem => "RegField",
      Description => "When this bit is set, ECC 1b Error indication will be masked",
      Width => "1",
      Position => "13",
      Type => "Config",
      UsedBy => "SER",
      DefaultValue => "b1",
    },
    InFifo2Ecc_1bErrInterruptMask => { #Structure Type: RegField;
      Name => "InFifo2Ecc_1bErrInterruptMask",
      RegMem => "RegField",
      Description => "When this bit is set, ECC 1b Error indication will be masked",
      Width => "1",
      Position => "14",
      Type => "Config",
      UsedBy => "SER",
      DefaultValue => "b1",
    },
    InFifo3Ecc_1bErrInterruptMask => { #Structure Type: RegField;
      Name => "InFifo3Ecc_1bErrInterruptMask",
      RegMem => "RegField",
      Description => "When this bit is set, ECC 1b Error indication will be masked",
      Width => "1",
      Position => "15",
      Type => "Config",
      UsedBy => "SER",
      DefaultValue => "b1",
    },
    InFifo4Ecc_1bErrInterruptMask => { #Structure Type: RegField;
      Name => "InFifo4Ecc_1bErrInterruptMask",
      RegMem => "RegField",
      Description => "When this bit is set, ECC 1b Error indication will be masked",
      Width => "1",
      Position => "16",
      Type => "Config",
      UsedBy => "SER",
      DefaultValue => "b1",
    },
    InFifo5Ecc_1bErrInterruptMask => { #Structure Type: RegField;
      Name => "InFifo5Ecc_1bErrInterruptMask",
      RegMem => "RegField",
      Description => "When this bit is set, ECC 1b Error indication will be masked",
      Width => "1",
      Position => "17",
      Type => "Config",
      UsedBy => "SER",
      DefaultValue => "b1",
    },
    DramInFifoEcc_1bErrInterruptMask => { #Structure Type: RegField;
      Name => "DramInFifoEcc_1bErrInterruptMask",
      RegMem => "RegField",
      Description => "When this bit is set, ECC 1b Error indication will be masked",
      Width => "1",
      Position => "18",
      Type => "Config",
      UsedBy => "SER",
      DefaultValue => "b1",
    },
    DramOutPdFIFO_Ecc_1bErrInterruptMask => { #Structure Type: RegField;
      Name => "DramOutPdFIFO_Ecc_1bErrInterruptMask",
      RegMem => "RegField",
      Description => "When this bit is set, ECC 1b Error indication will be masked",
      Width => "1",
      Position => "19",
      Type => "Config",
      UsedBy => "SER",
      DefaultValue => "b1",
    },
  },
  Ecc_2bErrInterruptRegisterMask => { #Structure Type: Reg; Skip Register;
    Name => "Ecc_2bErrInterruptRegisterMask",
    RegMem => "Reg",
    Address => "4",
    Description => "ECC 2b Error Interrupt Mask Register",
    Width => "20",
    Type => "Config",
    ContextTable0Ecc_2bErrInterruptMask => { #Structure Type: RegField;
      Name => "ContextTable0Ecc_2bErrInterruptMask",
      RegMem => "RegField",
      Description => "When this bit is set, ECC 2b Error indication will be masked",
      Width => "1",
      Position => "0",
      Type => "Config",
      UsedBy => "SER",
      DefaultValue => "b1",
    },
    ContextTable1Ecc_2bErrInterruptMask => { #Structure Type: RegField;
      Name => "ContextTable1Ecc_2bErrInterruptMask",
      RegMem => "RegField",
      Description => "When this bit is set, ECC 2b Error indication will be masked",
      Width => "1",
      Position => "1",
      Type => "Config",
      UsedBy => "SER",
      DefaultValue => "b1",
    },
    ContextTable2Ecc_2bErrInterruptMask => { #Structure Type: RegField;
      Name => "ContextTable2Ecc_2bErrInterruptMask",
      RegMem => "RegField",
      Description => "When this bit is set, ECC 2b Error indication will be masked",
      Width => "1",
      Position => "2",
      Type => "Config",
      UsedBy => "SER",
      DefaultValue => "b1",
    },
    ContextTable3Ecc_2bErrInterruptMask => { #Structure Type: RegField;
      Name => "ContextTable3Ecc_2bErrInterruptMask",
      RegMem => "RegField",
      Description => "When this bit is set, ECC 2b Error indication will be masked",
      Width => "1",
      Position => "3",
      Type => "Config",
      UsedBy => "SER",
      DefaultValue => "b1",
    },
    ContextTable4Ecc_2bErrInterruptMask => { #Structure Type: RegField;
      Name => "ContextTable4Ecc_2bErrInterruptMask",
      RegMem => "RegField",
      Description => "When this bit is set, ECC 2b Error indication will be masked",
      Width => "1",
      Position => "4",
      Type => "Config",
      UsedBy => "SER",
      DefaultValue => "b1",
    },
    ContextTable5Ecc_2bErrInterruptMask => { #Structure Type: RegField;
      Name => "ContextTable5Ecc_2bErrInterruptMask",
      RegMem => "RegField",
      Description => "When this bit is set, ECC 2b Error indication will be masked",
      Width => "1",
      Position => "5",
      Type => "Config",
      UsedBy => "SER",
      DefaultValue => "b1",
    },
    OutPdFIFO0Ecc_2bErrInterruptMask => { #Structure Type: RegField;
      Name => "OutPdFIFO0Ecc_2bErrInterruptMask",
      RegMem => "RegField",
      Description => "When this bit is set, ECC 2b Error indication will be masked",
      Width => "1",
      Position => "6",
      Type => "Config",
      UsedBy => "SER",
      DefaultValue => "b1",
    },
    OutPdFIFO1Ecc_2bErrInterruptMask => { #Structure Type: RegField;
      Name => "OutPdFIFO1Ecc_2bErrInterruptMask",
      RegMem => "RegField",
      Description => "When this bit is set, ECC 2b Error indication will be masked",
      Width => "1",
      Position => "7",
      Type => "Config",
      UsedBy => "SER",
      DefaultValue => "b1",
    },
    OutPdFIFO2Ecc_2bErrInterruptMask => { #Structure Type: RegField;
      Name => "OutPdFIFO2Ecc_2bErrInterruptMask",
      RegMem => "RegField",
      Description => "When this bit is set, ECC 2b Error indication will be masked",
      Width => "1",
      Position => "8",
      Type => "Config",
      UsedBy => "SER",
      DefaultValue => "b1",
    },
    OutPdFIFO3Ecc_2bErrInterruptMask => { #Structure Type: RegField;
      Name => "OutPdFIFO3Ecc_2bErrInterruptMask",
      RegMem => "RegField",
      Description => "When this bit is set, ECC 2b Error indication will be masked",
      Width => "1",
      Position => "9",
      Type => "Config",
      UsedBy => "SER",
      DefaultValue => "b1",
    },
    OutPdFIFO4Ecc_2bErrInterruptMask => { #Structure Type: RegField;
      Name => "OutPdFIFO4Ecc_2bErrInterruptMask",
      RegMem => "RegField",
      Description => "When this bit is set, ECC 2b Error indication will be masked",
      Width => "1",
      Position => "10",
      Type => "Config",
      UsedBy => "SER",
      DefaultValue => "b1",
    },
    OutPdFIFO5Ecc_2bErrInterruptMask => { #Structure Type: RegField;
      Name => "OutPdFIFO5Ecc_2bErrInterruptMask",
      RegMem => "RegField",
      Description => "When this bit is set, ECC 2b Error indication will be masked",
      Width => "1",
      Position => "11",
      Type => "Config",
      UsedBy => "SER",
      DefaultValue => "b1",
    },
    InFifo0Ecc_2bErrInterruptMask => { #Structure Type: RegField;
      Name => "InFifo0Ecc_2bErrInterruptMask",
      RegMem => "RegField",
      Description => "When this bit is set, ECC 2b Error indication will be masked",
      Width => "1",
      Position => "12",
      Type => "Config",
      UsedBy => "SER",
      DefaultValue => "b1",
    },
    InFifo1Ecc_2bErrInterruptMask => { #Structure Type: RegField;
      Name => "InFifo1Ecc_2bErrInterruptMask",
      RegMem => "RegField",
      Description => "When this bit is set, ECC 2b Error indication will be masked",
      Width => "1",
      Position => "13",
      Type => "Config",
      UsedBy => "SER",
      DefaultValue => "b1",
    },
    InFifo2Ecc_2bErrInterruptMask => { #Structure Type: RegField;
      Name => "InFifo2Ecc_2bErrInterruptMask",
      RegMem => "RegField",
      Description => "When this bit is set, ECC 2b Error indication will be masked",
      Width => "1",
      Position => "14",
      Type => "Config",
      UsedBy => "SER",
      DefaultValue => "b1",
    },
    InFifo3Ecc_2bErrInterruptMask => { #Structure Type: RegField;
      Name => "InFifo3Ecc_2bErrInterruptMask",
      RegMem => "RegField",
      Description => "When this bit is set, ECC 2b Error indication will be masked",
      Width => "1",
      Position => "15",
      Type => "Config",
      UsedBy => "SER",
      DefaultValue => "b1",
    },
    InFifo4Ecc_2bErrInterruptMask => { #Structure Type: RegField;
      Name => "InFifo4Ecc_2bErrInterruptMask",
      RegMem => "RegField",
      Description => "When this bit is set, ECC 2b Error indication will be masked",
      Width => "1",
      Position => "16",
      Type => "Config",
      UsedBy => "SER",
      DefaultValue => "b1",
    },
    InFifo5Ecc_2bErrInterruptMask => { #Structure Type: RegField;
      Name => "InFifo5Ecc_2bErrInterruptMask",
      RegMem => "RegField",
      Description => "When this bit is set, ECC 2b Error indication will be masked",
      Width => "1",
      Position => "17",
      Type => "Config",
      UsedBy => "SER",
      DefaultValue => "b1",
    },
    DramInFifoEcc_2bErrInterruptMask => { #Structure Type: RegField;
      Name => "DramInFifoEcc_2bErrInterruptMask",
      RegMem => "RegField",
      Description => "When this bit is set, ECC 2b Error indication will be masked",
      Width => "1",
      Position => "18",
      Type => "Config",
      UsedBy => "SER",
      DefaultValue => "b1",
    },
    DramOutPdFIFO_Ecc_2bErrInterruptMask => { #Structure Type: RegField;
      Name => "DramOutPdFIFO_Ecc_2bErrInterruptMask",
      RegMem => "RegField",
      Description => "When this bit is set, ECC 2b Error indication will be masked",
      Width => "1",
      Position => "19",
      Type => "Config",
      UsedBy => "SER",
      DefaultValue => "b1",
    },
  },

  Ecc_1bErrInitiateRegister => { #Structure Type: Reg; Skip Register;
    Name => "Ecc_1bErrInitiateRegister",
    RegMem => "Reg",
    Address => "30",
    Description => "ECC 1b Error Initiator Register",
    Width => "20",
    Type => "Config",
    ContextTable0Ecc_1bErrInitiate => { #Structure Type: RegField;
      Name => "ContextTable0Ecc_1bErrInitiate",
      RegMem => "RegField",
      Description => "When this bit is set, ECC 1b Error will be initiated",
      Width => "1",
      Position => "0",
      Type => "Config",
      UsedBy => "MEM",
      DefaultValue => "b0",
    },
    ContextTable1Ecc_1bErrInitiate => { #Structure Type: RegField;
      Name => "ContextTable1Ecc_1bErrInitiate",
      RegMem => "RegField",
      Description => "When this bit is set, ECC 1b Error will be initiated",
      Width => "1",
      Position => "1",
      Type => "Config",
      UsedBy => "MEM",
      DefaultValue => "b0",
    },
    ContextTable2Ecc_1bErrInitiate => { #Structure Type: RegField;
      Name => "ContextTable2Ecc_1bErrInitiate",
      RegMem => "RegField",
      Description => "When this bit is set, ECC 1b Error will be initiated",
      Width => "1",
      Position => "2",
      Type => "Config",
      UsedBy => "MEM",
      DefaultValue => "b0",
    },
    ContextTable3Ecc_1bErrInitiate => { #Structure Type: RegField;
      Name => "ContextTable3Ecc_1bErrInitiate",
      RegMem => "RegField",
      Description => "When this bit is set, ECC 1b Error will be initiated",
      Width => "1",
      Position => "3",
      Type => "Config",
      UsedBy => "MEM",
      DefaultValue => "b0",
    },
    ContextTable4Ecc_1bErrInitiate => { #Structure Type: RegField;
      Name => "ContextTable4Ecc_1bErrInitiate",
      RegMem => "RegField",
      Description => "When this bit is set, ECC 1b Error will be initiated",
      Width => "1",
      Position => "4",
      Type => "Config",
      UsedBy => "MEM",
      DefaultValue => "b0",
    },
    ContextTable5Ecc_1bErrInitiate => { #Structure Type: RegField;
      Name => "ContextTable5Ecc_1bErrInitiate",
      RegMem => "RegField",
      Description => "When this bit is set, ECC 1b Error will be initiated",
      Width => "1",
      Position => "5",
      Type => "Config",
      UsedBy => "MEM",
      DefaultValue => "b0",
    },
    OutPdFIFO0Ecc_1bErrInitiate => { #Structure Type: RegField;
      Name => "OutPdFIFO0Ecc_1bErrInitiate",
      RegMem => "RegField",
      Description => "When this bit is set, ECC 1b Error will be initiated",
      Width => "1",
      Position => "6",
      Type => "Config",
      UsedBy => "MEM",
      DefaultValue => "b0",
    },
    OutPdFIFO1Ecc_1bErrInitiate => { #Structure Type: RegField;
      Name => "OutPdFIFO1Ecc_1bErrInitiate",
      RegMem => "RegField",
      Description => "When this bit is set, ECC 1b Error will be initiated",
      Width => "1",
      Position => "7",
      Type => "Config",
      UsedBy => "MEM",
      DefaultValue => "b0",
    },
    OutPdFIFO2Ecc_1bErrInitiate => { #Structure Type: RegField;
      Name => "OutPdFIFO2Ecc_1bErrInitiate",
      RegMem => "RegField",
      Description => "When this bit is set, ECC 1b Error will be initiated",
      Width => "1",
      Position => "8",
      Type => "Config",
      UsedBy => "MEM",
      DefaultValue => "b0",
    },
    OutPdFIFO3Ecc_1bErrInitiate => { #Structure Type: RegField;
      Name => "OutPdFIFO3Ecc_1bErrInitiate",
      RegMem => "RegField",
      Description => "When this bit is set, ECC 1b Error will be initiated",
      Width => "1",
      Position => "9",
      Type => "Config",
      UsedBy => "MEM",
      DefaultValue => "b0",
    },
    OutPdFIFO4Ecc_1bErrInitiate => { #Structure Type: RegField;
      Name => "OutPdFIFO4Ecc_1bErrInitiate",
      RegMem => "RegField",
      Description => "When this bit is set, ECC 1b Error will be initiated",
      Width => "1",
      Position => "10",
      Type => "Config",
      UsedBy => "MEM",
      DefaultValue => "b0",
    },
    OutPdFIFO5Ecc_1bErrInitiate => { #Structure Type: RegField;
      Name => "OutPdFIFO5Ecc_1bErrInitiate",
      RegMem => "RegField",
      Description => "When this bit is set, ECC 1b Error will be initiated",
      Width => "1",
      Position => "11",
      Type => "Config",
      UsedBy => "MEM",
      DefaultValue => "b0",
    },
    InFifo0Ecc_1bErrInitiate => { #Structure Type: RegField;
      Name => "InFifo0Ecc_1bErrInitiate",
      RegMem => "RegField",
      Description => "When this bit is set, ECC 1b Error will be initiated",
      Width => "1",
      Position => "12",
      Type => "Config",
      UsedBy => "MEM",
      DefaultValue => "b0",
    },
    InFifo1Ecc_1bErrInitiate => { #Structure Type: RegField;
      Name => "InFifo1Ecc_1bErrInitiate",
      RegMem => "RegField",
      Description => "When this bit is set, ECC 1b Error will be initiated",
      Width => "1",
      Position => "13",
      Type => "Config",
      UsedBy => "MEM",
      DefaultValue => "b0",
    },
    InFifo2Ecc_1bErrInitiate => { #Structure Type: RegField;
      Name => "InFifo2Ecc_1bErrInitiate",
      RegMem => "RegField",
      Description => "When this bit is set, ECC 1b Error will be initiated",
      Width => "1",
      Position => "14",
      Type => "Config",
      UsedBy => "MEM",
      DefaultValue => "b0",
    },
    InFifo3Ecc_1bErrInitiate => { #Structure Type: RegField;
      Name => "InFifo3Ecc_1bErrInitiate",
      RegMem => "RegField",
      Description => "When this bit is set, ECC 1b Error will be initiated",
      Width => "1",
      Position => "15",
      Type => "Config",
      UsedBy => "MEM",
      DefaultValue => "b0",
    },
    InFifo4Ecc_1bErrInitiate => { #Structure Type: RegField;
      Name => "InFifo4Ecc_1bErrInitiate",
      RegMem => "RegField",
      Description => "When this bit is set, ECC 1b Error will be initiated",
      Width => "1",
      Position => "16",
      Type => "Config",
      UsedBy => "MEM",
      DefaultValue => "b0",
    },
    InFifo5Ecc_1bErrInitiate => { #Structure Type: RegField;
      Name => "InFifo5Ecc_1bErrInitiate",
      RegMem => "RegField",
      Description => "When this bit is set, ECC 1b Error will be initiated",
      Width => "1",
      Position => "17",
      Type => "Config",
      UsedBy => "MEM",
      DefaultValue => "b0",
    },
    DramInFifoEcc_1bErrInitiate => { #Structure Type: RegField;
      Name => "DramInFifoEcc_1bErrInitiate",
      RegMem => "RegField",
      Description => "When this bit is set, ECC 1b Error will be initiated",
      Width => "1",
      Position => "18",
      Type => "Config",
      UsedBy => "MEM",
      DefaultValue => "b0",
    },
    DramOutPdFIFO_Ecc_1bErrInitiate => { #Structure Type: RegField;
      Name => "DramOutPdFIFO_Ecc_1bErrInitiate",
      RegMem => "RegField",
      Description => "When this bit is set, ECC 1b Error will be initiated",
      Width => "1",
      Position => "19",
      Type => "Config",
      UsedBy => "MEM",
      DefaultValue => "b0",
    },
  },
  Ecc_2bErrInitiateRegister => { #Structure Type: Reg; Skip Register;
    Name => "Ecc_2bErrInitiateRegister",
    RegMem => "Reg",
    Address => "31",
    Description => "ECC 2b Error Initiator Register",
    Width => "20",
    Type => "Config",
    ContextTable0Ecc_2bErrInitiate => { #Structure Type: RegField;
      Name => "ContextTable0Ecc_2bErrInitiate",
      RegMem => "RegField",
      Description => "When this bit is set, ECC 2b Error will be initiated",
      Width => "1",
      Position => "0",
      Type => "Config",
      UsedBy => "MEM",
      DefaultValue => "b0",
    },
    ContextTable1Ecc_2bErrInitiate => { #Structure Type: RegField;
      Name => "ContextTable1Ecc_2bErrInitiate",
      RegMem => "RegField",
      Description => "When this bit is set, ECC 2b Error will be initiated",
      Width => "1",
      Position => "1",
      Type => "Config",
      UsedBy => "MEM",
      DefaultValue => "b0",
    },
    ContextTable2Ecc_2bErrInitiate => { #Structure Type: RegField;
      Name => "ContextTable2Ecc_2bErrInitiate",
      RegMem => "RegField",
      Description => "When this bit is set, ECC 2b Error will be initiated",
      Width => "1",
      Position => "2",
      Type => "Config",
      UsedBy => "MEM",
      DefaultValue => "b0",
    },
    ContextTable3Ecc_2bErrInitiate => { #Structure Type: RegField;
      Name => "ContextTable3Ecc_2bErrInitiate",
      RegMem => "RegField",
      Description => "When this bit is set, ECC 2b Error will be initiated",
      Width => "1",
      Position => "3",
      Type => "Config",
      UsedBy => "MEM",
      DefaultValue => "b0",
    },
    ContextTable4Ecc_2bErrInitiate => { #Structure Type: RegField;
      Name => "ContextTable4Ecc_2bErrInitiate",
      RegMem => "RegField",
      Description => "When this bit is set, ECC 2b Error will be initiated",
      Width => "1",
      Position => "4",
      Type => "Config",
      UsedBy => "MEM",
      DefaultValue => "b0",
    },
    ContextTable5Ecc_2bErrInitiate => { #Structure Type: RegField;
      Name => "ContextTable5Ecc_2bErrInitiate",
      RegMem => "RegField",
      Description => "When this bit is set, ECC 2b Error will be initiated",
      Width => "1",
      Position => "5",
      Type => "Config",
      UsedBy => "MEM",
      DefaultValue => "b0",
    },
    OutPdFIFO0Ecc_2bErrInitiate => { #Structure Type: RegField;
      Name => "OutPdFIFO0Ecc_2bErrInitiate",
      RegMem => "RegField",
      Description => "When this bit is set, ECC 2b Error will be initiated",
      Width => "1",
      Position => "6",
      Type => "Config",
      UsedBy => "MEM",
      DefaultValue => "b0",
    },
    OutPdFIFO1Ecc_2bErrInitiate => { #Structure Type: RegField;
      Name => "OutPdFIFO1Ecc_2bErrInitiate",
      RegMem => "RegField",
      Description => "When this bit is set, ECC 2b Error will be initiated",
      Width => "1",
      Position => "7",
      Type => "Config",
      UsedBy => "MEM",
      DefaultValue => "b0",
    },
    OutPdFIFO2Ecc_2bErrInitiate => { #Structure Type: RegField;
      Name => "OutPdFIFO2Ecc_2bErrInitiate",
      RegMem => "RegField",
      Description => "When this bit is set, ECC 2b Error will be initiated",
      Width => "1",
      Position => "8",
      Type => "Config",
      UsedBy => "MEM",
      DefaultValue => "b0",
    },
    OutPdFIFO3Ecc_2bErrInitiate => { #Structure Type: RegField;
      Name => "OutPdFIFO3Ecc_2bErrInitiate",
      RegMem => "RegField",
      Description => "When this bit is set, ECC 2b Error will be initiated",
      Width => "1",
      Position => "9",
      Type => "Config",
      UsedBy => "MEM",
      DefaultValue => "b0",
    },
    OutPdFIFO4Ecc_2bErrInitiate => { #Structure Type: RegField;
      Name => "OutPdFIFO4Ecc_2bErrInitiate",
      RegMem => "RegField",
      Description => "When this bit is set, ECC 2b Error will be initiated",
      Width => "1",
      Position => "10",
      Type => "Config",
      UsedBy => "MEM",
      DefaultValue => "b0",
    },
    OutPdFIFO5Ecc_2bErrInitiate => { #Structure Type: RegField;
      Name => "OutPdFIFO5Ecc_2bErrInitiate",
      RegMem => "RegField",
      Description => "When this bit is set, ECC 2b Error will be initiated",
      Width => "1",
      Position => "11",
      Type => "Config",
      UsedBy => "MEM",
      DefaultValue => "b0",
    },
    InFifo0Ecc_2bErrInitiate => { #Structure Type: RegField;
      Name => "InFifo0Ecc_2bErrInitiate",
      RegMem => "RegField",
      Description => "When this bit is set, ECC 2b Error will be initiated",
      Width => "1",
      Position => "12",
      Type => "Config",
      UsedBy => "MEM",
      DefaultValue => "b0",
    },
    InFifo1Ecc_2bErrInitiate => { #Structure Type: RegField;
      Name => "InFifo1Ecc_2bErrInitiate",
      RegMem => "RegField",
      Description => "When this bit is set, ECC 2b Error will be initiated",
      Width => "1",
      Position => "13",
      Type => "Config",
      UsedBy => "MEM",
      DefaultValue => "b0",
    },
    InFifo2Ecc_2bErrInitiate => { #Structure Type: RegField;
      Name => "InFifo2Ecc_2bErrInitiate",
      RegMem => "RegField",
      Description => "When this bit is set, ECC 2b Error will be initiated",
      Width => "1",
      Position => "14",
      Type => "Config",
      UsedBy => "MEM",
      DefaultValue => "b0",
    },
    InFifo3Ecc_2bErrInitiate => { #Structure Type: RegField;
      Name => "InFifo3Ecc_2bErrInitiate",
      RegMem => "RegField",
      Description => "When this bit is set, ECC 2b Error will be initiated",
      Width => "1",
      Position => "15",
      Type => "Config",
      UsedBy => "MEM",
      DefaultValue => "b0",
    },
    InFifo4Ecc_2bErrInitiate => { #Structure Type: RegField;
      Name => "InFifo4Ecc_2bErrInitiate",
      RegMem => "RegField",
      Description => "When this bit is set, ECC 2b Error will be initiated",
      Width => "1",
      Position => "16",
      Type => "Config",
      UsedBy => "MEM",
      DefaultValue => "b0",
    },
    InFifo5Ecc_2bErrInitiate => { #Structure Type: RegField;
      Name => "InFifo5Ecc_2bErrInitiate",
      RegMem => "RegField",
      Description => "When this bit is set, ECC 2b Error will be initiated",
      Width => "1",
      Position => "17",
      Type => "Config",
      UsedBy => "MEM",
      DefaultValue => "b0",
    },
    DramInFifoEcc_2bErrInitiate => { #Structure Type: RegField;
      Name => "DramInFifoEcc_2bErrInitiate",
      RegMem => "RegField",
      Description => "When this bit is set, ECC 2b Error will be initiated",
      Width => "1",
      Position => "18",
      Type => "Config",
      UsedBy => "MEM",
      DefaultValue => "b0",
    },
    DramOutPdFIFO_Ecc_2bErrInitiate => { #Structure Type: RegField;
      Name => "DramOutPdFIFO_Ecc_2bErrInitiate",
      RegMem => "RegField",
      Description => "When this bit is set, ECC 2b Error will be initiated",
      Width => "1",
      Position => "19",
      Type => "Config",
      UsedBy => "MEM",
      DefaultValue => "b0",
    },
  },
  MemProtectErrStatus => { #Structure Type: Reg; Skip Register;
    Name => "MemProtectErrStatus",
    RegMem => "Reg",
    Address => "33",
    Description => "Memory SER protected error status",
    Width => "20",
    Type => "ReadOnly",
    ContextTable0ErrInt => { #Structure Type: RegField;
      Name => "ContextTable0ErrInt",
      RegMem => "RegField",
      Description => "When this bit is set, SER Error occured",
      Width => "1",
      Position => "0",
      Type => "Status",
      UsedBy => "SER",
    },
    ContextTable1ErrInt => { #Structure Type: RegField;
      Name => "ContextTable1ErrInt",
      RegMem => "RegField",
      Description => "When this bit is set, SER Error occured",
      Width => "1",
      Position => "1",
      Type => "Status",
      UsedBy => "SER",
    },
    ContextTable2ErrInt => { #Structure Type: RegField;
      Name => "ContextTable2ErrInt",
      RegMem => "RegField",
      Description => "When this bit is set, SER Error occured",
      Width => "1",
      Position => "2",
      Type => "Status",
      UsedBy => "SER",
    },
    ContextTable3ErrInt => { #Structure Type: RegField;
      Name => "ContextTable3ErrInt",
      RegMem => "RegField",
      Description => "When this bit is set, SER Error occured",
      Width => "1",
      Position => "3",
      Type => "Status",
      UsedBy => "SER",
    },
    ContextTable4ErrInt => { #Structure Type: RegField;
      Name => "ContextTable4ErrInt",
      RegMem => "RegField",
      Description => "When this bit is set, SER Error occured",
      Width => "1",
      Position => "4",
      Type => "Status",
      UsedBy => "SER",
    },
    ContextTable5ErrInt => { #Structure Type: RegField;
      Name => "ContextTable5ErrInt",
      RegMem => "RegField",
      Description => "When this bit is set, SER Error occured",
      Width => "1",
      Position => "5",
      Type => "Status",
      UsedBy => "SER",
    },
    OutPdFIFO0ErrInt => { #Structure Type: RegField;
      Name => "OutPdFIFO0ErrInt",
      RegMem => "RegField",
      Description => "When this bit is set, SER Error occured",
      Width => "1",
      Position => "6",
      Type => "Status",
      UsedBy => "SER",
    },
    OutPdFIFO1ErrInt => { #Structure Type: RegField;
      Name => "OutPdFIFO1ErrInt",
      RegMem => "RegField",
      Description => "When this bit is set, SER Error occured",
      Width => "1",
      Position => "7",
      Type => "Status",
      UsedBy => "SER",
    },
    OutPdFIFO2ErrInt => { #Structure Type: RegField;
      Name => "OutPdFIFO2ErrInt",
      RegMem => "RegField",
      Description => "When this bit is set, SER Error occured",
      Width => "1",
      Position => "8",
      Type => "Status",
      UsedBy => "SER",
    },
    OutPdFIFO3ErrInt => { #Structure Type: RegField;
      Name => "OutPdFIFO3ErrInt",
      RegMem => "RegField",
      Description => "When this bit is set, SER Error occured",
      Width => "1",
      Position => "9",
      Type => "Status",
      UsedBy => "SER",
    },
    OutPdFIFO4ErrInt => { #Structure Type: RegField;
      Name => "OutPdFIFO4ErrInt",
      RegMem => "RegField",
      Description => "When this bit is set, SER Error occured",
      Width => "1",
      Position => "10",
      Type => "Status",
      UsedBy => "SER",
    },
    OutPdFIFO5ErrInt => { #Structure Type: RegField;
      Name => "OutPdFIFO5ErrInt",
      RegMem => "RegField",
      Description => "When this bit is set, SER Error occured",
      Width => "1",
      Position => "11",
      Type => "Status",
      UsedBy => "SER",
    },
    InFifo0ErrInt => { #Structure Type: RegField;
      Name => "InFifo0ErrInt",
      RegMem => "RegField",
      Description => "When this bit is set, SER Error occured",
      Width => "1",
      Position => "12",
      Type => "Status",
      UsedBy => "SER",
    },
    InFifo1ErrInt => { #Structure Type: RegField;
      Name => "InFifo1ErrInt",
      RegMem => "RegField",
      Description => "When this bit is set, SER Error occured",
      Width => "1",
      Position => "13",
      Type => "Status",
      UsedBy => "SER",
    },
    InFifo2ErrInt => { #Structure Type: RegField;
      Name => "InFifo2ErrInt",
      RegMem => "RegField",
      Description => "When this bit is set, SER Error occured",
      Width => "1",
      Position => "14",
      Type => "Status",
      UsedBy => "SER",
    },
    InFifo3ErrInt => { #Structure Type: RegField;
      Name => "InFifo3ErrInt",
      RegMem => "RegField",
      Description => "When this bit is set, SER Error occured",
      Width => "1",
      Position => "15",
      Type => "Status",
      UsedBy => "SER",
    },
    InFifo4ErrInt => { #Structure Type: RegField;
      Name => "InFifo4ErrInt",
      RegMem => "RegField",
      Description => "When this bit is set, SER Error occured",
      Width => "1",
      Position => "16",
      Type => "Status",
      UsedBy => "SER",
    },
    InFifo5ErrInt => { #Structure Type: RegField;
      Name => "InFifo5ErrInt",
      RegMem => "RegField",
      Description => "When this bit is set, SER Error occured",
      Width => "1",
      Position => "17",
      Type => "Status",
      UsedBy => "SER",
    },
    DramInFifoErrInt => { #Structure Type: RegField;
      Name => "DramInFifoErrInt",
      RegMem => "RegField",
      Description => "When this bit is set, SER Error occured",
      Width => "1",
      Position => "18",
      Type => "Status",
      UsedBy => "SER",
    },
    DramOutPdFIFO_ErrInt => { #Structure Type: RegField;
      Name => "DramOutPdFIFO_ErrInt",
      RegMem => "RegField",
      Description => "When this bit is set, SER Error occured",
      Width => "1",
      Position => "19",
      Type => "Status",
      UsedBy => "SER",
    },
  },
  SelectedSerErrorInfo => { #Structure Type: Reg; Skip Register;
    Name => "SelectedSerErrorInfo",
    RegMem => "Reg",
    Address => "34",
    Description => "Address and Type of SER error of selected memory",
    Width => "12",
    Type => "ReadOnly",
    MemErrAddr => { #Structure Type: RegField;
      Name => "MemErrAddr",
      RegMem => "RegField",
      Description => "Address of SER error of selected memory",
      Width => "10",
      Position => "9:0",
      Type => "Status",
      UsedBy => "SER",
    },
    MemErrType => { #Structure Type: RegField;
      Name => "MemErrType",
      RegMem => "RegField",
      Description => "0 = ECC 1b, 1 = ECC 2b, 2 = Parity",
      Width => "2",
      Position => "11:10",
      Type => "Status",
      UsedBy => "SER",
    },
  },
  SerErrorDebugConfiguration => { #Structure Type: Reg; Skip Register;
    Name => "SerErrorDebugConfiguration",
    RegMem => "Reg",
    Address => "35",
    Description => "Address and Type of SER error of selected memory",
    Width => "6",
    Type => "Config",
    ErroneousMemorySelector => { #Structure Type: RegField;
      Name => "ErroneousMemorySelector",
      RegMem => "RegField",
      Description => "Selects which memory error address and error type to set on the status register",
      Width => "5",
      Position => "4:0",
      Type => "Config",
      UsedBy => "SER",
      DefaultValue => "b0",
    },
    ResetMemoryErrors => { #Structure Type: RegField;
      Name => "ResetMemoryErrors",
      RegMem => "RegField",
      Description => "When set to 1 - all the memory SER errors are reset. Need to set back to 0 to resume error recording",
      Width => "1",
      Position => "5",
      Type => "Config",
      UsedBy => "SER",
      DefaultValue => "b0",
    },
  },
  Ecc_1bErrDebug => { #Structure Type: Reg; Skip Register;
    Name => "Ecc_1bErrDebug",
    RegMem => "Reg",
    Address => "36",
    Description => "ECC 1b Error Counter",
    Width => "16",
    Type => "ReadOnly",
    Ecc_1bErrCounter => { #Structure Type: RegField;
      Name => "Ecc_1bErrCounter",
      RegMem => "RegField",
      Description => "Counts number of ECC 1b errors",
      Width => "16",
      Position => "15:0",
      Type => "Counter",
      UsedBy => "SER",
      AdditionalInfo => "CounterIncrWidth=1",
    },
  },
  Ecc_2bErrDebug => { #Structure Type: Reg; Skip Register;
    Name => "Ecc_2bErrDebug",
    RegMem => "Reg",
    Address => "37",
    Description => "ECC 2b Error Counter",
    Width => "16",
    Type => "ReadOnly",
    Ecc_2bErrCounter => { #Structure Type: RegField;
      Name => "Ecc_2bErrCounter",
      RegMem => "RegField",
      Description => "Counts number of ECC 2b errors",
      Width => "16",
      Position => "15:0",
      Type => "Counter",
      UsedBy => "SER",
      AdditionalInfo => "CounterIncrWidth=1",
    },
  },

  CounterTimer => { #Structure Type: Reg; Skip Register;
    Name => "CounterTimer",
    RegMem => "Reg",
    Address => "40",
    Description => "Defines Counter Timer parameters",
    Width => "33", # Excel Formula: =calc_reg_width(E8:E9,F9)
    Type => "Config",
    CounterTimerEnable => { #Structure Type: RegField;
      Name => "CounterTimerEnable",
      RegMem => "RegField",
      Description => "If set, Counter Timer will applied for the counters, otherwise the counters are free running",
      Width => "1",
      Position => "0", # Excel Formula: =calc_position(F7,E8,TRUE)
      Type => "Config",
      UsedBy => "CIF",
      DefaultValue => "b0",
    },
    CounterTimerCycle => { #Structure Type: RegField;
      Name => "CounterTimerCycle",
      RegMem => "RegField",
      Description => "When activated, CounterTimer will count for CounterTimerCycle",
      Width => "32",
      Position => "32:1", # Excel Formula: =calc_position(F8,E9)
      Type => "Config",
      UsedBy => "CIF",
      DefaultValue => "h3B9ACA00",
    },
  },
  CounterTimerTriggerReg => { #Structure Type: Reg; Skip Register;
    Name => "CounterTimerTriggerReg",
    RegMem => "Reg",
    Address => "41", # Excel Formula: =calc_reg_address(C7,A7,G7)
    Description => "Activates Counter Timer",
    Width => "1", # Excel Formula: =calc_reg_width(E11:E11,F11)
    Type => "External",
    UsedBy => "CIF",
    CounterTimerTrigger => { #Structure Type: RegField;
      Name => "CounterTimerTrigger",
      RegMem => "RegField",
      Description => "When activated, CounterTimer will count for CounterTimerCycle",
      Width => "1",
      Position => "0", # Excel Formula: =calc_position(F10,E11,TRUE)
      Type => "External",
    },
  },
  MemoryAccessTimeout => { #Structure Type: Reg; Skip Register;
    Name => "MemoryAccessTimeout",
    RegMem => "Reg",
    Address => "42", # Excel Formula: =calc_reg_address(C10,A10,G10)
    Description => "Defines parameters for memory access timer expiry",
    Width => "38", # Excel Formula: =calc_reg_width(E13:E15,F15)
    Type => "Config",
    BubbleCounterThr => { #Structure Type: RegField;
      Name => "BubbleCounterThr",
      RegMem => "RegField",
      Description => "When BubbleCounterThr clocks passed from CIF memory access without grant, Bubble Request signal raised towards the block ",
      Width => "16",
      Position => "15:0", # Excel Formula: =calc_position(F12,E13,TRUE)
      Type => "Config",
      UsedBy => "CIF",
      DefaultValue => "d256",
    },
    TimeoutCounterThr => { #Structure Type: RegField;
      Name => "TimeoutCounterThr",
      RegMem => "RegField",
      Description => "When TimeoutCounterThr clocks passed from CIF memory access without grant, the access is terminated with error ",
      Width => "16",
      Position => "31:16", # Excel Formula: =calc_position(F13,E14)
      Type => "Config",
      UsedBy => "CIF",
      DefaultValue => "d4096",
    },
    AnsWindowCounterThr => { #Structure Type: RegField;
      Name => "AnsWindowCounterThr",
      RegMem => "RegField",
      Description => "When memory access is terminated because of  TimeoutCounterThr, the CIF waits AnsWindowCounterThr clocks for access termination",
      Width => "6",
      Position => "37:32", # Excel Formula: =calc_position(F14,E15)
      Type => "Config",
      UsedBy => "CIF",
      DefaultValue => "d16",
    },
  },
  BroadcastConfigReg => { #Structure Type: Reg; Skip Register;
    Name => "BroadcastConfigReg",
    RegMem => "Reg",
    Address => "43", # Excel Formula: =calc_reg_address(C12,A12,G12)
    Description => "Config Top broadcast parameters",
    Width => "12", # Excel Formula: =calc_reg_width(E17:E17,F17)
    Type => "Config",
    BroadcastId => { #Structure Type: RegField;
      Name => "BroadcastId",
      RegMem => "RegField",
      Description => "Broadcast ID used by Config Top protocol for broadcast messages",
      Width => "12",
      Position => "11:0", # Excel Formula: =calc_position(F16,E17,TRUE)
      Type => "Config",
      UsedBy => "CIF",
      DefaultValue => "hFFF",
    },
  },
  MemoryProtBypass => { #Structure Type: Reg; Skip Register;
    Name => "MemoryProtBypass",
    RegMem => "Reg",
    Address => "44", # Excel Formula: =calc_reg_address(C16,A16,G16)
    Description => "Bypass for ECC/Parity, used for debug",
    Width => "3", # Excel Formula: =calc_reg_width(E19:E21,F21)
    Type => "Config",
    DisableEcc => { #Structure Type: RegField;
      Name => "DisableEcc",
      RegMem => "RegField",
      Description => "If set, ECC fix is bypassed and is taken from payload",
      Width => "1",
      Position => "0", # Excel Formula: =calc_position(F18,E19,TRUE)
      Type => "Config",
      UsedBy => "MEM",
      DefaultValue => "b0",
    },
    CifProtGenBypass => { #Structure Type: RegField;
      Name => "CifProtGenBypass",
      RegMem => "RegField",
      Description => "If set, ECC/Parity generation is bypassed and is taken from payload for CIF access",
      Width => "1",
      Position => "1", # Excel Formula: =calc_position(F19,E20)
      Type => "Config",
      UsedBy => "MEM",
      DefaultValue => "b0",
    },
    CifProtFixBypass => { #Structure Type: RegField;
      Name => "CifProtFixBypass",
      RegMem => "RegField",
      Description => "If set, ECC/Parity fix is bypassed and original ECC/Parity is forwarded towards the CIF",
      Width => "1",
      Position => "2", # Excel Formula: =calc_position(F20,E21)
      Type => "Config",
      UsedBy => "MEM",
      DefaultValue => "b0",
    },
  },
  SoftResetConfiguration => { #Structure Type: Reg; Skip Register;
    Name => "SoftResetConfiguration",
    RegMem => "Reg",
    Address => "45", # Excel Formula: =calc_reg_address(C18,A18,G18)
    Description => "Soft Reset Configuration for the block",
    Width => "1", # Excel Formula: =calc_reg_width(E23:E23,F23)
    Type => "Config",
    SoftRstn => { #Structure Type: RegField;
      Name => "SoftRstn",
      RegMem => "RegField",
      Description => "Triggers soft reset signal for the block, active low register",
      Width => "1",
      Position => "0", # Excel Formula: =calc_position(F22,E23,TRUE)
      Type => "Config",
      UsedBy => "CIF",
      DefaultValue => "b0",
    },
  },
  MbistConfiguration => { #Structure Type: Reg; Skip Register;
    Name => "MbistConfiguration",
    RegMem => "Reg",
    Address => "46", # Excel Formula: =calc_reg_address(C22,A22,G22)
    Description => "MBIST Configuration for the block",
    Width => "73", # Excel Formula: =calc_reg_width(E25:E53,F53)
    Type => "Config",
    SACR1P_RME => { #Structure Type: RegField;
      Name => "SACR1P_RME",
      RegMem => "RegField",
      Description => "MBIST logic - Read Margin Enable",
      Width => "1",
      Position => "0", # Excel Formula: =calc_position(F24,E25,TRUE)
      Type => "Config",
      UsedBy => "MEM",
      DefaultValue => "b0",
    },
    SACR1P_RM => { #Structure Type: RegField;
      Name => "SACR1P_RM",
      RegMem => "RegField",
      Description => "MBIST logic - Read Margin",
      Width => "4",
      Position => "4:1", # Excel Formula: =calc_position(F25,E26)
      Type => "Config",
      UsedBy => "MEM",
      DefaultValue => "b0",
    },
    SACU2P_RME => { #Structure Type: RegField;
      Name => "SACU2P_RME",
      RegMem => "RegField",
      Description => "MBIST logic - Read Margin Enable",
      Width => "1",
      Position => "5", # Excel Formula: =calc_position(F26,E27)
      Type => "Config",
      UsedBy => "MEM",
      DefaultValue => "b0",
    },
    SACU2P_RM => { #Structure Type: RegField;
      Name => "SACU2P_RM",
      RegMem => "RegField",
      Description => "MBIST logic - Read Margin",
      Width => "4",
      Position => "9:6", # Excel Formula: =calc_position(F27,E28)
      Type => "Config",
      UsedBy => "MEM",
      DefaultValue => "b0",
    },
    SADC1P_RME => { #Structure Type: RegField;
      Name => "SADC1P_RME",
      RegMem => "RegField",
      Description => "MBIST logic - Read Margin Enable",
      Width => "1",
      Position => "10", # Excel Formula: =calc_position(F28,E29)
      Type => "Config",
      UsedBy => "MEM",
      DefaultValue => "b0",
    },
    SADC1P_RM => { #Structure Type: RegField;
      Name => "SADC1P_RM",
      RegMem => "RegField",
      Description => "MBIST logic - Read Margin",
      Width => "4",
      Position => "14:11", # Excel Formula: =calc_position(F29,E30)
      Type => "Config",
      UsedBy => "MEM",
      DefaultValue => "b0",
    },
    SADR2P_RMEA => { #Structure Type: RegField;
      Name => "SADR2P_RMEA",
      RegMem => "RegField",
      Description => "MBIST logic - Read Margin Enable port A",
      Width => "1",
      Position => "15", # Excel Formula: =calc_position(F30,E31)
      Type => "Config",
      UsedBy => "MEM",
      DefaultValue => "b0",
    },
    SADR2P_RMA => { #Structure Type: RegField;
      Name => "SADR2P_RMA",
      RegMem => "RegField",
      Description => "MBIST logic - Read Margin port A",
      Width => "4",
      Position => "19:16", # Excel Formula: =calc_position(F31,E32)
      Type => "Config",
      UsedBy => "MEM",
      DefaultValue => "b0",
    },
    SADR2P_RMEB => { #Structure Type: RegField;
      Name => "SADR2P_RMEB",
      RegMem => "RegField",
      Description => "MBIST logic - Read Margin Enable port B",
      Width => "1",
      Position => "20", # Excel Formula: =calc_position(F32,E33)
      Type => "Config",
      UsedBy => "MEM",
      DefaultValue => "b0",
    },
    SADR2P_RMB => { #Structure Type: RegField;
      Name => "SADR2P_RMB",
      RegMem => "RegField",
      Description => "MBIST logic - Read Margin port B",
      Width => "4",
      Position => "24:21", # Excel Formula: =calc_position(F33,E34)
      Type => "Config",
      UsedBy => "MEM",
      DefaultValue => "b0",
    },
    SADS2P_RMEA => { #Structure Type: RegField;
      Name => "SADS2P_RMEA",
      RegMem => "RegField",
      Description => "MBIST logic - Read Margin Enable port A",
      Width => "1",
      Position => "25", # Excel Formula: =calc_position(F34,E35)
      Type => "Config",
      UsedBy => "MEM",
      DefaultValue => "b0",
    },
    SADS2P_RMA => { #Structure Type: RegField;
      Name => "SADS2P_RMA",
      RegMem => "RegField",
      Description => "MBIST logic - Read Margin port A",
      Width => "4",
      Position => "29:26", # Excel Formula: =calc_position(F35,E36)
      Type => "Config",
      UsedBy => "MEM",
      DefaultValue => "b0",
    },
    SADS2P_RMEB => { #Structure Type: RegField;
      Name => "SADS2P_RMEB",
      RegMem => "RegField",
      Description => "MBIST logic - Read Margin Enable port B",
      Width => "1",
      Position => "30", # Excel Formula: =calc_position(F36,E37)
      Type => "Config",
      UsedBy => "MEM",
      DefaultValue => "b0",
    },
    SADS2P_RMB => { #Structure Type: RegField;
      Name => "SADS2P_RMB",
      RegMem => "RegField",
      Description => "MBIST logic - Read Margin port B",
      Width => "4",
      Position => "34:31", # Excel Formula: =calc_position(F37,E38)
      Type => "Config",
      UsedBy => "MEM",
      DefaultValue => "b0",
    },
    SASR1P_RME => { #Structure Type: RegField;
      Name => "SASR1P_RME",
      RegMem => "RegField",
      Description => "MBIST logic - Read Margin Enable",
      Width => "1",
      Position => "35", # Excel Formula: =calc_position(F38,E39)
      Type => "Config",
      UsedBy => "MEM",
      DefaultValue => "b0",
    },
    SASR1P_RM => { #Structure Type: RegField;
      Name => "SASR1P_RM",
      RegMem => "RegField",
      Description => "MBIST logic - Read Margin",
      Width => "4",
      Position => "39:36", # Excel Formula: =calc_position(F39,E40)
      Type => "Config",
      UsedBy => "MEM",
      DefaultValue => "b0",
    },
    SASS1P_RME => { #Structure Type: RegField;
      Name => "SASS1P_RME",
      RegMem => "RegField",
      Description => "MBIST logic - Read Margin Enable",
      Width => "1",
      Position => "40", # Excel Formula: =calc_position(F40,E41)
      Type => "Config",
      UsedBy => "MEM",
      DefaultValue => "b0",
    },
    SASS1P_RM => { #Structure Type: RegField;
      Name => "SASS1P_RM",
      RegMem => "RegField",
      Description => "MBIST logic - Read Margin",
      Width => "4",
      Position => "44:41", # Excel Formula: =calc_position(F41,E42)
      Type => "Config",
      UsedBy => "MEM",
      DefaultValue => "b0",
    },
    SASS2P_RMEA => { #Structure Type: RegField;
      Name => "SASS2P_RMEA",
      RegMem => "RegField",
      Description => "MBIST logic - Read Margin Enable port A",
      Width => "1",
      Position => "45", # Excel Formula: =calc_position(F42,E43)
      Type => "Config",
      UsedBy => "MEM",
      DefaultValue => "b0",
    },
    SASS2P_RMA => { #Structure Type: RegField;
      Name => "SASS2P_RMA",
      RegMem => "RegField",
      Description => "MBIST logic - Read Margin port A",
      Width => "4",
      Position => "49:46", # Excel Formula: =calc_position(F43,E44)
      Type => "Config",
      UsedBy => "MEM",
      DefaultValue => "b0",
    },
    SASS2P_RMEB => { #Structure Type: RegField;
      Name => "SASS2P_RMEB",
      RegMem => "RegField",
      Description => "MBIST logic - Read Margin Enable port B",
      Width => "1",
      Position => "50", # Excel Formula: =calc_position(F44,E45)
      Type => "Config",
      UsedBy => "MEM",
      DefaultValue => "b0",
    },
    SASS2P_RMB => { #Structure Type: RegField;
      Name => "SASS2P_RMB",
      RegMem => "RegField",
      Description => "MBIST logic - Read Margin port B",
      Width => "4",
      Position => "54:51", # Excel Formula: =calc_position(F45,E46)
      Type => "Config",
      UsedBy => "MEM",
      DefaultValue => "b0",
    },
    SASU2P_RME => { #Structure Type: RegField;
      Name => "SASU2P_RME",
      RegMem => "RegField",
      Description => "MBIST logic - Read Margin Enable",
      Width => "1",
      Position => "55", # Excel Formula: =calc_position(F46,E47)
      Type => "Config",
      UsedBy => "MEM",
      DefaultValue => "b0",
    },
    SASU2P_RM => { #Structure Type: RegField;
      Name => "SASU2P_RM",
      RegMem => "RegField",
      Description => "MBIST logic - Read Margin",
      Width => "4",
      Position => "59:56", # Excel Formula: =calc_position(F47,E48)
      Type => "Config",
      UsedBy => "MEM",
      DefaultValue => "b0",
    },
    SADU1P_RME => { #Structure Type: RegField;
      Name => "SADU1P_RME",
      RegMem => "RegField",
      Description => "MBIST logic - Read Margin Enable",
      Width => "1",
      Position => "60", # Excel Formula: =calc_position(F48,E49)
      Type => "Config",
      UsedBy => "MEM",
      DefaultValue => "b0",
    },
    SADU1P_RM => { #Structure Type: RegField;
      Name => "SADU1P_RM",
      RegMem => "RegField",
      Description => "MBIST logic - Read Margin",
      Width => "4",
      Position => "64:61", # Excel Formula: =calc_position(F49,E50)
      Type => "Config",
      UsedBy => "MEM",
      DefaultValue => "b0",
    },
    SADS2P_RA => { #Structure Type: RegField;
      Name => "SADS2P_RA",
      RegMem => "RegField",
      Description => "MBIST logic - Read Assist for Dual port",
      Width => "2",
      Position => "66:65", # Excel Formula: =calc_position(F50,E51)
      Type => "Config",
      UsedBy => "MEM",
      DefaultValue => "b0",
    },
    SADU1P_WA => { #Structure Type: RegField;
      Name => "SADU1P_WA",
      RegMem => "RegField",
      Description => "Write-Assist configuration for the SP SADU compiler",
      Width => "3",
      Position => "69:67", # Excel Formula: =calc_position(F51,E52)
      Type => "Config",
      UsedBy => "MEM",
      DefaultValue => "d5",
    },
    SADU1P_WPULSE => { #Structure Type: RegField;
      Name => "SADU1P_WPULSE",
      RegMem => "RegField",
      Description => "Write-Assist-Pulse configuration for the SP SADU compiler",
      Width => "3",
      Position => "72:70", # Excel Formula: =calc_position(F52,E53)
      Type => "Config",
      UsedBy => "MEM",
      DefaultValue => "b0",
    },
  },
  PowerDownConfiguration => { #Structure Type: Reg; Skip Register;
    Name => "PowerDownConfiguration",
    RegMem => "Reg",
    Address => "47", # Excel Formula: =calc_reg_address(C24,A24,G24)
    Description => "Power Down Configuration for the block",
    Width => "1", # Excel Formula: =calc_reg_width(E55:E55,F55)
    Type => "Config",
    PowerDown => { #Structure Type: RegField;
      Name => "PowerDown",
      RegMem => "RegField",
      Description => "If set, disables the clock of the block",
      Width => "1",
      Position => "0", # Excel Formula: =calc_position(F54,E55,TRUE)
      Type => "Config",
      UsedBy => "CIF",
      DefaultValue => "b0",
      Comments => "Default value should always be 0",
    },
  },
  SpareReg => { #Structure Type: Reg; Skip Register;
    Name => "SpareReg",
    RegMem => "Reg",
    Address => "48", # Excel Formula: =calc_reg_address(C54,A54,G54)
    Description => "Spare register",
    Width => "128", # Excel Formula: =calc_reg_width(E57:E57,F57)
    Type => "Config",
    SpareRegister => { #Structure Type: RegField;
      Name => "SpareRegister",
      RegMem => "RegField",
      Description => "Spare register ",
      Width => "128",
      Position => "127:0", # Excel Formula: =calc_position(F56,E57,TRUE)
      Type => "Config",
      UsedBy => "CIF",
      DefaultValue => "hffffffffffffffff",
    },
  },
  PmroCtrl => { #Structure Type: Reg; Skip Register;
    Name => "PmroCtrl",
    RegMem => "Reg",
    Address => "49", # Excel Formula: =calc_reg_address(C56,A56,G56)
    Description => "PMRO controller configuration",
    Width => "32", # Excel Formula: =calc_reg_width(E59:E63,F63)
    Type => "Config",
    PmroRstn => { #Structure Type: RegField;
      Name => "PmroRstn",
      RegMem => "RegField",
      Description => "PMRO reset, active low",
      Width => "1",
      Position => "0", # Excel Formula: =calc_position(F58,E59,TRUE)
      Type => "Config",
      UsedBy => "pmro",
      DefaultValue => "d0",
    },
    PmroConfigEn => { #Structure Type: RegField;
      Name => "PmroConfigEn",
      RegMem => "RegField",
      Description => "Enable pmro configuration, when equals to 0 configurations are locked",
      Width => "1",
      Position => "1", # Excel Formula: =calc_position(F59,E60)
      Type => "Config",
      UsedBy => "pmro",
      DefaultValue => "d0",
    },
    PmroStart => { #Structure Type: RegField;
      Name => "PmroStart",
      RegMem => "RegField",
      Description => "Start the pmro operation",
      Width => "1",
      Position => "2", # Excel Formula: =calc_position(F60,E61)
      Type => "Config",
      UsedBy => "pmro",
      DefaultValue => "d0",
    },
    PmroRingEn => { #Structure Type: RegField;
      Name => "PmroRingEn",
      RegMem => "RegField",
      Description => "Determines which PMRO ring to activate, should be configured as one hot",
      Width => "7",
      Position => "9:3", # Excel Formula: =calc_position(F61,E62)
      Type => "Config",
      UsedBy => "pmro",
      DefaultValue => "d1",
    },
    PmroCntPeriod => { #Structure Type: RegField;
      Name => "PmroCntPeriod",
      RegMem => "RegField",
      Description => "Number of core clock cycles on which PMRO is measured",
      Width => "22",
      Position => "31:10", # Excel Formula: =calc_position(F62,E63)
      Type => "Config",
      UsedBy => "pmro",
      DefaultValue => "h3FFFFF",
    },
  },
  PmroStatus => { #Structure Type: Reg; Skip Register;
    Name => "PmroStatus",
    RegMem => "Reg",
    Address => "4A", # Excel Formula: =calc_reg_address(C58,A58,G58)
    Description => "PMRO status configuration",
    Width => "23", # Excel Formula: =calc_reg_width(E65:E66,F66)
    Type => "ReadOnly",
    PmroCountOut => { #Structure Type: RegField;
      Name => "PmroCountOut",
      RegMem => "RegField",
      Description => "The ring oscilator counter value.",
      Width => "22",
      Position => "21:0", # Excel Formula: =calc_position(F64,E65,TRUE)
      Type => "Status",
      UsedBy => "pmro",
    },
    PmroDone => { #Structure Type: RegField;
      Name => "PmroDone",
      RegMem => "RegField",
      Description => "Pmro operation done, PmroCountOut is valid.",
      Width => "1",
      Position => "22", # Excel Formula: =calc_position(F65,E66)
      Type => "Status",
      UsedBy => "pmro",
    },
  },
  MirrorBusConfReg => { #Structure Type: Reg; Skip Register;
    Name => "MirrorBusConfReg",
    RegMem => "Reg",
    Address => "4B", # Excel Formula: =calc_reg_address(C64,A64,G64)
    Description => "Mirror Bus configurations",
    Width => "11", # Excel Formula: =calc_reg_width(E68:E69,F69)
    Type => "Config",
    MirrorBusEn => { #Structure Type: RegField;
      Name => "MirrorBusEn",
      RegMem => "RegField",
      Description => "Enable Mirror Bus",
      Width => "1",
      Position => "0", # Excel Formula: =calc_position(F67,E68,TRUE)
      Type => "Config",
      UsedBy => "BLOCK",
      DefaultValue => "h0",
    },
    MirrorBusSel => { #Structure Type: RegField;
      Name => "MirrorBusSel",
      RegMem => "RegField",
      Description => "Mirror Bus selector",
      Width => "10",
      Position => "10:1", # Excel Formula: =calc_position(F68,E69)
      Type => "Config",
      UsedBy => "BLOCK",
      DefaultValue => "h0",
    },
  },
  MirrorBusStatus => { #Structure Type: Reg; Skip Register;
    Name => "MirrorBusStatus",
    RegMem => "Reg",
    Address => "4C", # Excel Formula: =calc_reg_address(C67,A67,G67)
    Description => "Mirror Bus status result",
    Width => "32", # Excel Formula: =calc_reg_width(E71:E71,F71)
    Type => "ReadOnly",
    MirrorBus => { #Structure Type: RegField;
      Name => "MirrorBus",
      RegMem => "RegField",
      Description => "Mirror Bus status result",
      Width => "32",
      Position => "31:0", # Excel Formula: =calc_position(F70,E71,TRUE)
      Type => "Status",
      UsedBy => "BLOCK",
    },
  },
  DeviceTimeOffsetCfg => { #Structure Type: Reg; Skip Register;
    Name => "DeviceTimeOffsetCfg",
    RegMem => "Reg",
    Address => "4D", # Excel Formula: =calc_reg_address(C70,A70,G70)
    Description => "Define time offset configuration",
    Width => "10", # Excel Formula: =calc_reg_width(E73:E73,F73)
    Type => "Config",
    DeviceTimeOffset => { #Structure Type: RegField;
      Name => "DeviceTimeOffset",
      RegMem => "RegField",
      Description => "Define time offset",
      Width => "10",
      Position => "9:0", # Excel Formula: =calc_position(F72,E73,TRUE)
      Type => "Config",
      UsedBy => "CIF",
      DefaultValue => "h0",
    },
  },
  ReassemblyConfReg10 => { #Structure Type: Reg; ArrayLength: 7; ArrayIndex: 0; ArrayLocationInName: 19;
    Name => "ReassemblyConfReg1[7]",
    RegMem => "Reg",
    Address => "100",
    Description => "This register was used for tuning parameters during the design phase. The value of these fields is optimized for the current silicon, thus the user is not expected to change its value unless instructed by Cisco Systems, Inc.",
    Width => "41", # Excel Formula: =calc_reg_width(E8:E15,F15)
    Type => "Config",
    AdditionalInfo => "PackArrayToBus",
    ArrayLength => "7",
    ArrayIndex => "0",
    LlDb0WriteFifoFullThreshold => { #Structure Type: RegField; ArrayLength: 7; ArrayIndex: 0; ArrayLocationInName: 5;
      Name => "LlDb[n]WriteFifoFullThreshold",
      RegMem => "RegField",
      Description => "The fill level threshold of the FIFO that holds write requests to the FDLL from which the FIFO is considered full thus the reassembly will not insert new PD/FDs to the pipe and will create backpressure.",
      Width => "4",
      Position => "3:0", # Excel Formula: =calc_position(F7,E8,TRUE)
      Type => "Config",
      UsedBy => "DSN",
      DefaultValue => "h2",
      Comments => "Constant",
    },
    InFifo0IfgPauseThreshold => { #Structure Type: RegField; ArrayLength: 7; ArrayIndex: 0; ArrayLocationInName: 7;
      Name => "InFifo[n]IfgPauseThreshold",
      RegMem => "RegField",
      Description => "When the reassembly FIFO that holds new packets (FD/PD) reached this threshold a pause indication is sent to the IFG.
The FIFO is expected to absorb all packets that are on the way due to the response time of the IFG.",
      Width => "8",
      Position => "11:4", # Excel Formula: =calc_position(F8,E9)
      Type => "Config",
      UsedBy => "DSN",
      DefaultValue => "h30",
      Comments => "Constant",
      InitValueAllModes => "16",
    },
    InFifo0RxppPauseThreshold => { #Structure Type: RegField; ArrayLength: 7; ArrayIndex: 0; ArrayLocationInName: 7;
      Name => "InFifo[n]RxppPauseThreshold",
      RegMem => "RegField",
      Description => "When the reassembly FIFO that holds new packets (FD/PD) reached this threshold a pause indication is sent to the RXPP.
The FIFO is expected to absorb all packets that are on the way due to the response time of the RXPP.",
      Width => "8",
      Position => "19:12", # Excel Formula: =calc_position(F9,E10)
      Type => "Config",
      UsedBy => "DSN",
      DefaultValue => "h30",
      Comments => "Constant",
      InitValueAllModes => "32",
    },
    OutPdFifo0FullThreshold => { #Structure Type: RegField; ArrayLength: 7; ArrayIndex: 0; ArrayLocationInName: 10;
      Name => "OutPdFifo[n]FullThreshold",
      RegMem => "RegField",
      Description => "The fill level threshold of the out FIFO that holds PDs from which the FIFO is considered full thus the reassembly will not insert new PD/FDs to the pipe and will create backpressure.",
      Width => "7",
      Position => "26:20", # Excel Formula: =calc_position(F10,E11)
      Type => "Config",
      UsedBy => "DSN",
      DefaultValue => "d66",
      Comments => "Constant",
    },
    OutPdControlFifo0FullThreshold => { #Structure Type: RegField; ArrayLength: 7; ArrayIndex: 0; ArrayLocationInName: 17;
      Name => "OutPdControlFifo[n]FullThreshold",
      RegMem => "RegField",
      Description => "The fill level threshold of the out PD control FIFO from which the FIFO is considered full thus the reassembly will not insert new PD/FDs to the pipe and will create backpressure.",
      Width => "7",
      Position => "33:27", # Excel Formula: =calc_position(F11,E12)
      Type => "Config",
      UsedBy => "DSN",
      DefaultValue => "d66",
      Comments => "Constant",
    },
    Slice0DisableContextRelease => { #Structure Type: RegField; ArrayLength: 7; ArrayIndex: 0; ArrayLocationInName: 6;
      Name => "Slice[n]DisableContextRelease",
      RegMem => "RegField",
      Description => "Prevents the reassmebly from releasing contexts to the free buffer manager.
Relevant for debug testing mode where packets are generated from a configurable memory thus not used from context allocation but from memory configuration.",
      Width => "1",
      Position => "34", # Excel Formula: =calc_position(F12,E13)
      Type => "Config",
      UsedBy => "DSN",
      DefaultValue => "h0",
      Comments => "Constant",
    },
    Slice0ReassemblyCreditDelay => { #Structure Type: RegField; ArrayLength: 7; ArrayIndex: 0; ArrayLocationInName: 6;
      Name => "Slice[n]ReassemblyCreditDelay",
      RegMem => "RegField",
      Description => "Delayes the credits coming from the fdll to the logic that delayes PDs until it's corrosponding fdll link is popped from the FDLL CBR. Configuring to value above 0 will delay the credits.
Resolution is 1cc.",
      Width => "5",
      Position => "39:35", # Excel Formula: =calc_position(F13,E14)
      Type => "Config",
      UsedBy => "DSN",
      DefaultValue => "h0",
      Comments => "Constant",
    },
    Slice0DisableWaitForFdllCredit => { #Structure Type: RegField; ArrayLength: 7; ArrayIndex: 0; ArrayLocationInName: 6;
      Name => "Slice[n]DisableWaitForFdllCredit",
      RegMem => "RegField",
      Description => "Disables the halt of PDs until all requests of the packet that were sent to the FDLL were popped from the FDLL CBR.
If disabled - the latency will be reduced but there is a risk of read before write in the FDLL.",
      Width => "1",
      Position => "40", # Excel Formula: =calc_position(F14,E15)
      Type => "Config",
      UsedBy => "DSN",
      DefaultValue => "h0",
      Comments => "Constant",
    },
  },
  ReassemblyConfReg11 => { #Structure Type: Reg; ArrayLength: 7; ArrayIndex: 1; ArrayLocationInName: 19;
    Name => "ReassemblyConfReg1[7]",
    RegMem => "Reg",
    Address => "101",
    Description => "This register was used for tuning parameters during the design phase. The value of these fields is optimized for the current silicon, thus the user is not expected to change its value unless instructed by Cisco Systems, Inc.",
    Width => "41", # Excel Formula: =calc_reg_width(E8:E15,F15)
    Type => "Config",
    AdditionalInfo => "PackArrayToBus",
    ArrayLength => "7",
    ArrayIndex => "1",
    LlDb1WriteFifoFullThreshold => { #Structure Type: RegField; ArrayLength: 7; ArrayIndex: 1; ArrayLocationInName: 5;
      Name => "LlDb[n]WriteFifoFullThreshold",
      RegMem => "RegField",
      Description => "The fill level threshold of the FIFO that holds write requests to the FDLL from which the FIFO is considered full thus the reassembly will not insert new PD/FDs to the pipe and will create backpressure.",
      Width => "4",
      Position => "3:0", # Excel Formula: =calc_position(F7,E8,TRUE)
      Type => "Config",
      UsedBy => "DSN",
      DefaultValue => "h2",
      Comments => "Constant",
    },
    InFifo1IfgPauseThreshold => { #Structure Type: RegField; ArrayLength: 7; ArrayIndex: 1; ArrayLocationInName: 7;
      Name => "InFifo[n]IfgPauseThreshold",
      RegMem => "RegField",
      Description => "When the reassembly FIFO that holds new packets (FD/PD) reached this threshold a pause indication is sent to the IFG.
The FIFO is expected to absorb all packets that are on the way due to the response time of the IFG.",
      Width => "8",
      Position => "11:4", # Excel Formula: =calc_position(F8,E9)
      Type => "Config",
      UsedBy => "DSN",
      DefaultValue => "h30",
      Comments => "Constant",
      InitValueAllModes => "16",
    },
    InFifo1RxppPauseThreshold => { #Structure Type: RegField; ArrayLength: 7; ArrayIndex: 1; ArrayLocationInName: 7;
      Name => "InFifo[n]RxppPauseThreshold",
      RegMem => "RegField",
      Description => "When the reassembly FIFO that holds new packets (FD/PD) reached this threshold a pause indication is sent to the RXPP.
The FIFO is expected to absorb all packets that are on the way due to the response time of the RXPP.",
      Width => "8",
      Position => "19:12", # Excel Formula: =calc_position(F9,E10)
      Type => "Config",
      UsedBy => "DSN",
      DefaultValue => "h30",
      Comments => "Constant",
      InitValueAllModes => "32",
    },
    OutPdFifo1FullThreshold => { #Structure Type: RegField; ArrayLength: 7; ArrayIndex: 1; ArrayLocationInName: 10;
      Name => "OutPdFifo[n]FullThreshold",
      RegMem => "RegField",
      Description => "The fill level threshold of the out FIFO that holds PDs from which the FIFO is considered full thus the reassembly will not insert new PD/FDs to the pipe and will create backpressure.",
      Width => "7",
      Position => "26:20", # Excel Formula: =calc_position(F10,E11)
      Type => "Config",
      UsedBy => "DSN",
      DefaultValue => "d66",
      Comments => "Constant",
    },
    OutPdControlFifo1FullThreshold => { #Structure Type: RegField; ArrayLength: 7; ArrayIndex: 1; ArrayLocationInName: 17;
      Name => "OutPdControlFifo[n]FullThreshold",
      RegMem => "RegField",
      Description => "The fill level threshold of the out PD control FIFO from which the FIFO is considered full thus the reassembly will not insert new PD/FDs to the pipe and will create backpressure.",
      Width => "7",
      Position => "33:27", # Excel Formula: =calc_position(F11,E12)
      Type => "Config",
      UsedBy => "DSN",
      DefaultValue => "d66",
      Comments => "Constant",
    },
    Slice1DisableContextRelease => { #Structure Type: RegField; ArrayLength: 7; ArrayIndex: 1; ArrayLocationInName: 6;
      Name => "Slice[n]DisableContextRelease",
      RegMem => "RegField",
      Description => "Prevents the reassmebly from releasing contexts to the free buffer manager.
Relevant for debug testing mode where packets are generated from a configurable memory thus not used from context allocation but from memory configuration.",
      Width => "1",
      Position => "34", # Excel Formula: =calc_position(F12,E13)
      Type => "Config",
      UsedBy => "DSN",
      DefaultValue => "h0",
      Comments => "Constant",
    },
    Slice1ReassemblyCreditDelay => { #Structure Type: RegField; ArrayLength: 7; ArrayIndex: 1; ArrayLocationInName: 6;
      Name => "Slice[n]ReassemblyCreditDelay",
      RegMem => "RegField",
      Description => "Delayes the credits coming from the fdll to the logic that delayes PDs until it's corrosponding fdll link is popped from the FDLL CBR. Configuring to value above 0 will delay the credits.
Resolution is 1cc.",
      Width => "5",
      Position => "39:35", # Excel Formula: =calc_position(F13,E14)
      Type => "Config",
      UsedBy => "DSN",
      DefaultValue => "h0",
      Comments => "Constant",
    },
    Slice1DisableWaitForFdllCredit => { #Structure Type: RegField; ArrayLength: 7; ArrayIndex: 1; ArrayLocationInName: 6;
      Name => "Slice[n]DisableWaitForFdllCredit",
      RegMem => "RegField",
      Description => "Disables the halt of PDs until all requests of the packet that were sent to the FDLL were popped from the FDLL CBR.
If disabled - the latency will be reduced but there is a risk of read before write in the FDLL.",
      Width => "1",
      Position => "40", # Excel Formula: =calc_position(F14,E15)
      Type => "Config",
      UsedBy => "DSN",
      DefaultValue => "h0",
      Comments => "Constant",
    },
  },
  ReassemblyConfReg12 => { #Structure Type: Reg; ArrayLength: 7; ArrayIndex: 2; ArrayLocationInName: 19;
    Name => "ReassemblyConfReg1[7]",
    RegMem => "Reg",
    Address => "102",
    Description => "This register was used for tuning parameters during the design phase. The value of these fields is optimized for the current silicon, thus the user is not expected to change its value unless instructed by Cisco Systems, Inc.",
    Width => "41", # Excel Formula: =calc_reg_width(E8:E15,F15)
    Type => "Config",
    AdditionalInfo => "PackArrayToBus",
    ArrayLength => "7",
    ArrayIndex => "2",
    LlDb2WriteFifoFullThreshold => { #Structure Type: RegField; ArrayLength: 7; ArrayIndex: 2; ArrayLocationInName: 5;
      Name => "LlDb[n]WriteFifoFullThreshold",
      RegMem => "RegField",
      Description => "The fill level threshold of the FIFO that holds write requests to the FDLL from which the FIFO is considered full thus the reassembly will not insert new PD/FDs to the pipe and will create backpressure.",
      Width => "4",
      Position => "3:0", # Excel Formula: =calc_position(F7,E8,TRUE)
      Type => "Config",
      UsedBy => "DSN",
      DefaultValue => "h2",
      Comments => "Constant",
    },
    InFifo2IfgPauseThreshold => { #Structure Type: RegField; ArrayLength: 7; ArrayIndex: 2; ArrayLocationInName: 7;
      Name => "InFifo[n]IfgPauseThreshold",
      RegMem => "RegField",
      Description => "When the reassembly FIFO that holds new packets (FD/PD) reached this threshold a pause indication is sent to the IFG.
The FIFO is expected to absorb all packets that are on the way due to the response time of the IFG.",
      Width => "8",
      Position => "11:4", # Excel Formula: =calc_position(F8,E9)
      Type => "Config",
      UsedBy => "DSN",
      DefaultValue => "h30",
      Comments => "Constant",
      InitValueAllModes => "16",
    },
    InFifo2RxppPauseThreshold => { #Structure Type: RegField; ArrayLength: 7; ArrayIndex: 2; ArrayLocationInName: 7;
      Name => "InFifo[n]RxppPauseThreshold",
      RegMem => "RegField",
      Description => "When the reassembly FIFO that holds new packets (FD/PD) reached this threshold a pause indication is sent to the RXPP.
The FIFO is expected to absorb all packets that are on the way due to the response time of the RXPP.",
      Width => "8",
      Position => "19:12", # Excel Formula: =calc_position(F9,E10)
      Type => "Config",
      UsedBy => "DSN",
      DefaultValue => "h30",
      Comments => "Constant",
      InitValueAllModes => "32",
    },
    OutPdFifo2FullThreshold => { #Structure Type: RegField; ArrayLength: 7; ArrayIndex: 2; ArrayLocationInName: 10;
      Name => "OutPdFifo[n]FullThreshold",
      RegMem => "RegField",
      Description => "The fill level threshold of the out FIFO that holds PDs from which the FIFO is considered full thus the reassembly will not insert new PD/FDs to the pipe and will create backpressure.",
      Width => "7",
      Position => "26:20", # Excel Formula: =calc_position(F10,E11)
      Type => "Config",
      UsedBy => "DSN",
      DefaultValue => "d66",
      Comments => "Constant",
    },
    OutPdControlFifo2FullThreshold => { #Structure Type: RegField; ArrayLength: 7; ArrayIndex: 2; ArrayLocationInName: 17;
      Name => "OutPdControlFifo[n]FullThreshold",
      RegMem => "RegField",
      Description => "The fill level threshold of the out PD control FIFO from which the FIFO is considered full thus the reassembly will not insert new PD/FDs to the pipe and will create backpressure.",
      Width => "7",
      Position => "33:27", # Excel Formula: =calc_position(F11,E12)
      Type => "Config",
      UsedBy => "DSN",
      DefaultValue => "d66",
      Comments => "Constant",
    },
    Slice2DisableContextRelease => { #Structure Type: RegField; ArrayLength: 7; ArrayIndex: 2; ArrayLocationInName: 6;
      Name => "Slice[n]DisableContextRelease",
      RegMem => "RegField",
      Description => "Prevents the reassmebly from releasing contexts to the free buffer manager.
Relevant for debug testing mode where packets are generated from a configurable memory thus not used from context allocation but from memory configuration.",
      Width => "1",
      Position => "34", # Excel Formula: =calc_position(F12,E13)
      Type => "Config",
      UsedBy => "DSN",
      DefaultValue => "h0",
      Comments => "Constant",
    },
    Slice2ReassemblyCreditDelay => { #Structure Type: RegField; ArrayLength: 7; ArrayIndex: 2; ArrayLocationInName: 6;
      Name => "Slice[n]ReassemblyCreditDelay",
      RegMem => "RegField",
      Description => "Delayes the credits coming from the fdll to the logic that delayes PDs until it's corrosponding fdll link is popped from the FDLL CBR. Configuring to value above 0 will delay the credits.
Resolution is 1cc.",
      Width => "5",
      Position => "39:35", # Excel Formula: =calc_position(F13,E14)
      Type => "Config",
      UsedBy => "DSN",
      DefaultValue => "h0",
      Comments => "Constant",
    },
    Slice2DisableWaitForFdllCredit => { #Structure Type: RegField; ArrayLength: 7; ArrayIndex: 2; ArrayLocationInName: 6;
      Name => "Slice[n]DisableWaitForFdllCredit",
      RegMem => "RegField",
      Description => "Disables the halt of PDs until all requests of the packet that were sent to the FDLL were popped from the FDLL CBR.
If disabled - the latency will be reduced but there is a risk of read before write in the FDLL.",
      Width => "1",
      Position => "40", # Excel Formula: =calc_position(F14,E15)
      Type => "Config",
      UsedBy => "DSN",
      DefaultValue => "h0",
      Comments => "Constant",
    },
  },
  ReassemblyConfReg13 => { #Structure Type: Reg; ArrayLength: 7; ArrayIndex: 3; ArrayLocationInName: 19;
    Name => "ReassemblyConfReg1[7]",
    RegMem => "Reg",
    Address => "103",
    Description => "This register was used for tuning parameters during the design phase. The value of these fields is optimized for the current silicon, thus the user is not expected to change its value unless instructed by Cisco Systems, Inc.",
    Width => "41", # Excel Formula: =calc_reg_width(E8:E15,F15)
    Type => "Config",
    AdditionalInfo => "PackArrayToBus",
    ArrayLength => "7",
    ArrayIndex => "3",
    LlDb3WriteFifoFullThreshold => { #Structure Type: RegField; ArrayLength: 7; ArrayIndex: 3; ArrayLocationInName: 5;
      Name => "LlDb[n]WriteFifoFullThreshold",
      RegMem => "RegField",
      Description => "The fill level threshold of the FIFO that holds write requests to the FDLL from which the FIFO is considered full thus the reassembly will not insert new PD/FDs to the pipe and will create backpressure.",
      Width => "4",
      Position => "3:0", # Excel Formula: =calc_position(F7,E8,TRUE)
      Type => "Config",
      UsedBy => "DSN",
      DefaultValue => "h2",
      Comments => "Constant",
    },
    InFifo3IfgPauseThreshold => { #Structure Type: RegField; ArrayLength: 7; ArrayIndex: 3; ArrayLocationInName: 7;
      Name => "InFifo[n]IfgPauseThreshold",
      RegMem => "RegField",
      Description => "When the reassembly FIFO that holds new packets (FD/PD) reached this threshold a pause indication is sent to the IFG.
The FIFO is expected to absorb all packets that are on the way due to the response time of the IFG.",
      Width => "8",
      Position => "11:4", # Excel Formula: =calc_position(F8,E9)
      Type => "Config",
      UsedBy => "DSN",
      DefaultValue => "h30",
      Comments => "Constant",
      InitValueAllModes => "16",
    },
    InFifo3RxppPauseThreshold => { #Structure Type: RegField; ArrayLength: 7; ArrayIndex: 3; ArrayLocationInName: 7;
      Name => "InFifo[n]RxppPauseThreshold",
      RegMem => "RegField",
      Description => "When the reassembly FIFO that holds new packets (FD/PD) reached this threshold a pause indication is sent to the RXPP.
The FIFO is expected to absorb all packets that are on the way due to the response time of the RXPP.",
      Width => "8",
      Position => "19:12", # Excel Formula: =calc_position(F9,E10)
      Type => "Config",
      UsedBy => "DSN",
      DefaultValue => "h30",
      Comments => "Constant",
      InitValueAllModes => "32",
    },
    OutPdFifo3FullThreshold => { #Structure Type: RegField; ArrayLength: 7; ArrayIndex: 3; ArrayLocationInName: 10;
      Name => "OutPdFifo[n]FullThreshold",
      RegMem => "RegField",
      Description => "The fill level threshold of the out FIFO that holds PDs from which the FIFO is considered full thus the reassembly will not insert new PD/FDs to the pipe and will create backpressure.",
      Width => "7",
      Position => "26:20", # Excel Formula: =calc_position(F10,E11)
      Type => "Config",
      UsedBy => "DSN",
      DefaultValue => "d66",
      Comments => "Constant",
    },
    OutPdControlFifo3FullThreshold => { #Structure Type: RegField; ArrayLength: 7; ArrayIndex: 3; ArrayLocationInName: 17;
      Name => "OutPdControlFifo[n]FullThreshold",
      RegMem => "RegField",
      Description => "The fill level threshold of the out PD control FIFO from which the FIFO is considered full thus the reassembly will not insert new PD/FDs to the pipe and will create backpressure.",
      Width => "7",
      Position => "33:27", # Excel Formula: =calc_position(F11,E12)
      Type => "Config",
      UsedBy => "DSN",
      DefaultValue => "d66",
      Comments => "Constant",
    },
    Slice3DisableContextRelease => { #Structure Type: RegField; ArrayLength: 7; ArrayIndex: 3; ArrayLocationInName: 6;
      Name => "Slice[n]DisableContextRelease",
      RegMem => "RegField",
      Description => "Prevents the reassmebly from releasing contexts to the free buffer manager.
Relevant for debug testing mode where packets are generated from a configurable memory thus not used from context allocation but from memory configuration.",
      Width => "1",
      Position => "34", # Excel Formula: =calc_position(F12,E13)
      Type => "Config",
      UsedBy => "DSN",
      DefaultValue => "h0",
      Comments => "Constant",
    },
    Slice3ReassemblyCreditDelay => { #Structure Type: RegField; ArrayLength: 7; ArrayIndex: 3; ArrayLocationInName: 6;
      Name => "Slice[n]ReassemblyCreditDelay",
      RegMem => "RegField",
      Description => "Delayes the credits coming from the fdll to the logic that delayes PDs until it's corrosponding fdll link is popped from the FDLL CBR. Configuring to value above 0 will delay the credits.
Resolution is 1cc.",
      Width => "5",
      Position => "39:35", # Excel Formula: =calc_position(F13,E14)
      Type => "Config",
      UsedBy => "DSN",
      DefaultValue => "h0",
      Comments => "Constant",
    },
    Slice3DisableWaitForFdllCredit => { #Structure Type: RegField; ArrayLength: 7; ArrayIndex: 3; ArrayLocationInName: 6;
      Name => "Slice[n]DisableWaitForFdllCredit",
      RegMem => "RegField",
      Description => "Disables the halt of PDs until all requests of the packet that were sent to the FDLL were popped from the FDLL CBR.
If disabled - the latency will be reduced but there is a risk of read before write in the FDLL.",
      Width => "1",
      Position => "40", # Excel Formula: =calc_position(F14,E15)
      Type => "Config",
      UsedBy => "DSN",
      DefaultValue => "h0",
      Comments => "Constant",
    },
  },
  ReassemblyConfReg14 => { #Structure Type: Reg; ArrayLength: 7; ArrayIndex: 4; ArrayLocationInName: 19;
    Name => "ReassemblyConfReg1[7]",
    RegMem => "Reg",
    Address => "104",
    Description => "This register was used for tuning parameters during the design phase. The value of these fields is optimized for the current silicon, thus the user is not expected to change its value unless instructed by Cisco Systems, Inc.",
    Width => "41", # Excel Formula: =calc_reg_width(E8:E15,F15)
    Type => "Config",
    AdditionalInfo => "PackArrayToBus",
    ArrayLength => "7",
    ArrayIndex => "4",
    LlDb4WriteFifoFullThreshold => { #Structure Type: RegField; ArrayLength: 7; ArrayIndex: 4; ArrayLocationInName: 5;
      Name => "LlDb[n]WriteFifoFullThreshold",
      RegMem => "RegField",
      Description => "The fill level threshold of the FIFO that holds write requests to the FDLL from which the FIFO is considered full thus the reassembly will not insert new PD/FDs to the pipe and will create backpressure.",
      Width => "4",
      Position => "3:0", # Excel Formula: =calc_position(F7,E8,TRUE)
      Type => "Config",
      UsedBy => "DSN",
      DefaultValue => "h2",
      Comments => "Constant",
    },
    InFifo4IfgPauseThreshold => { #Structure Type: RegField; ArrayLength: 7; ArrayIndex: 4; ArrayLocationInName: 7;
      Name => "InFifo[n]IfgPauseThreshold",
      RegMem => "RegField",
      Description => "When the reassembly FIFO that holds new packets (FD/PD) reached this threshold a pause indication is sent to the IFG.
The FIFO is expected to absorb all packets that are on the way due to the response time of the IFG.",
      Width => "8",
      Position => "11:4", # Excel Formula: =calc_position(F8,E9)
      Type => "Config",
      UsedBy => "DSN",
      DefaultValue => "h30",
      Comments => "Constant",
      InitValueAllModes => "16",
    },
    InFifo4RxppPauseThreshold => { #Structure Type: RegField; ArrayLength: 7; ArrayIndex: 4; ArrayLocationInName: 7;
      Name => "InFifo[n]RxppPauseThreshold",
      RegMem => "RegField",
      Description => "When the reassembly FIFO that holds new packets (FD/PD) reached this threshold a pause indication is sent to the RXPP.
The FIFO is expected to absorb all packets that are on the way due to the response time of the RXPP.",
      Width => "8",
      Position => "19:12", # Excel Formula: =calc_position(F9,E10)
      Type => "Config",
      UsedBy => "DSN",
      DefaultValue => "h30",
      Comments => "Constant",
      InitValueAllModes => "32",
    },
    OutPdFifo4FullThreshold => { #Structure Type: RegField; ArrayLength: 7; ArrayIndex: 4; ArrayLocationInName: 10;
      Name => "OutPdFifo[n]FullThreshold",
      RegMem => "RegField",
      Description => "The fill level threshold of the out FIFO that holds PDs from which the FIFO is considered full thus the reassembly will not insert new PD/FDs to the pipe and will create backpressure.",
      Width => "7",
      Position => "26:20", # Excel Formula: =calc_position(F10,E11)
      Type => "Config",
      UsedBy => "DSN",
      DefaultValue => "d66",
      Comments => "Constant",
    },
    OutPdControlFifo4FullThreshold => { #Structure Type: RegField; ArrayLength: 7; ArrayIndex: 4; ArrayLocationInName: 17;
      Name => "OutPdControlFifo[n]FullThreshold",
      RegMem => "RegField",
      Description => "The fill level threshold of the out PD control FIFO from which the FIFO is considered full thus the reassembly will not insert new PD/FDs to the pipe and will create backpressure.",
      Width => "7",
      Position => "33:27", # Excel Formula: =calc_position(F11,E12)
      Type => "Config",
      UsedBy => "DSN",
      DefaultValue => "d66",
      Comments => "Constant",
    },
    Slice4DisableContextRelease => { #Structure Type: RegField; ArrayLength: 7; ArrayIndex: 4; ArrayLocationInName: 6;
      Name => "Slice[n]DisableContextRelease",
      RegMem => "RegField",
      Description => "Prevents the reassmebly from releasing contexts to the free buffer manager.
Relevant for debug testing mode where packets are generated from a configurable memory thus not used from context allocation but from memory configuration.",
      Width => "1",
      Position => "34", # Excel Formula: =calc_position(F12,E13)
      Type => "Config",
      UsedBy => "DSN",
      DefaultValue => "h0",
      Comments => "Constant",
    },
    Slice4ReassemblyCreditDelay => { #Structure Type: RegField; ArrayLength: 7; ArrayIndex: 4; ArrayLocationInName: 6;
      Name => "Slice[n]ReassemblyCreditDelay",
      RegMem => "RegField",
      Description => "Delayes the credits coming from the fdll to the logic that delayes PDs until it's corrosponding fdll link is popped from the FDLL CBR. Configuring to value above 0 will delay the credits.
Resolution is 1cc.",
      Width => "5",
      Position => "39:35", # Excel Formula: =calc_position(F13,E14)
      Type => "Config",
      UsedBy => "DSN",
      DefaultValue => "h0",
      Comments => "Constant",
    },
    Slice4DisableWaitForFdllCredit => { #Structure Type: RegField; ArrayLength: 7; ArrayIndex: 4; ArrayLocationInName: 6;
      Name => "Slice[n]DisableWaitForFdllCredit",
      RegMem => "RegField",
      Description => "Disables the halt of PDs until all requests of the packet that were sent to the FDLL were popped from the FDLL CBR.
If disabled - the latency will be reduced but there is a risk of read before write in the FDLL.",
      Width => "1",
      Position => "40", # Excel Formula: =calc_position(F14,E15)
      Type => "Config",
      UsedBy => "DSN",
      DefaultValue => "h0",
      Comments => "Constant",
    },
  },
  ReassemblyConfReg15 => { #Structure Type: Reg; ArrayLength: 7; ArrayIndex: 5; ArrayLocationInName: 19;
    Name => "ReassemblyConfReg1[7]",
    RegMem => "Reg",
    Address => "105",
    Description => "This register was used for tuning parameters during the design phase. The value of these fields is optimized for the current silicon, thus the user is not expected to change its value unless instructed by Cisco Systems, Inc.",
    Width => "41", # Excel Formula: =calc_reg_width(E8:E15,F15)
    Type => "Config",
    AdditionalInfo => "PackArrayToBus",
    ArrayLength => "7",
    ArrayIndex => "5",
    LlDb5WriteFifoFullThreshold => { #Structure Type: RegField; ArrayLength: 7; ArrayIndex: 5; ArrayLocationInName: 5;
      Name => "LlDb[n]WriteFifoFullThreshold",
      RegMem => "RegField",
      Description => "The fill level threshold of the FIFO that holds write requests to the FDLL from which the FIFO is considered full thus the reassembly will not insert new PD/FDs to the pipe and will create backpressure.",
      Width => "4",
      Position => "3:0", # Excel Formula: =calc_position(F7,E8,TRUE)
      Type => "Config",
      UsedBy => "DSN",
      DefaultValue => "h2",
      Comments => "Constant",
    },
    InFifo5IfgPauseThreshold => { #Structure Type: RegField; ArrayLength: 7; ArrayIndex: 5; ArrayLocationInName: 7;
      Name => "InFifo[n]IfgPauseThreshold",
      RegMem => "RegField",
      Description => "When the reassembly FIFO that holds new packets (FD/PD) reached this threshold a pause indication is sent to the IFG.
The FIFO is expected to absorb all packets that are on the way due to the response time of the IFG.",
      Width => "8",
      Position => "11:4", # Excel Formula: =calc_position(F8,E9)
      Type => "Config",
      UsedBy => "DSN",
      DefaultValue => "h30",
      Comments => "Constant",
      InitValueAllModes => "16",
    },
    InFifo5RxppPauseThreshold => { #Structure Type: RegField; ArrayLength: 7; ArrayIndex: 5; ArrayLocationInName: 7;
      Name => "InFifo[n]RxppPauseThreshold",
      RegMem => "RegField",
      Description => "When the reassembly FIFO that holds new packets (FD/PD) reached this threshold a pause indication is sent to the RXPP.
The FIFO is expected to absorb all packets that are on the way due to the response time of the RXPP.",
      Width => "8",
      Position => "19:12", # Excel Formula: =calc_position(F9,E10)
      Type => "Config",
      UsedBy => "DSN",
      DefaultValue => "h30",
      Comments => "Constant",
      InitValueAllModes => "32",
    },
    OutPdFifo5FullThreshold => { #Structure Type: RegField; ArrayLength: 7; ArrayIndex: 5; ArrayLocationInName: 10;
      Name => "OutPdFifo[n]FullThreshold",
      RegMem => "RegField",
      Description => "The fill level threshold of the out FIFO that holds PDs from which the FIFO is considered full thus the reassembly will not insert new PD/FDs to the pipe and will create backpressure.",
      Width => "7",
      Position => "26:20", # Excel Formula: =calc_position(F10,E11)
      Type => "Config",
      UsedBy => "DSN",
      DefaultValue => "d66",
      Comments => "Constant",
    },
    OutPdControlFifo5FullThreshold => { #Structure Type: RegField; ArrayLength: 7; ArrayIndex: 5; ArrayLocationInName: 17;
      Name => "OutPdControlFifo[n]FullThreshold",
      RegMem => "RegField",
      Description => "The fill level threshold of the out PD control FIFO from which the FIFO is considered full thus the reassembly will not insert new PD/FDs to the pipe and will create backpressure.",
      Width => "7",
      Position => "33:27", # Excel Formula: =calc_position(F11,E12)
      Type => "Config",
      UsedBy => "DSN",
      DefaultValue => "d66",
      Comments => "Constant",
    },
    Slice5DisableContextRelease => { #Structure Type: RegField; ArrayLength: 7; ArrayIndex: 5; ArrayLocationInName: 6;
      Name => "Slice[n]DisableContextRelease",
      RegMem => "RegField",
      Description => "Prevents the reassmebly from releasing contexts to the free buffer manager.
Relevant for debug testing mode where packets are generated from a configurable memory thus not used from context allocation but from memory configuration.",
      Width => "1",
      Position => "34", # Excel Formula: =calc_position(F12,E13)
      Type => "Config",
      UsedBy => "DSN",
      DefaultValue => "h0",
      Comments => "Constant",
    },
    Slice5ReassemblyCreditDelay => { #Structure Type: RegField; ArrayLength: 7; ArrayIndex: 5; ArrayLocationInName: 6;
      Name => "Slice[n]ReassemblyCreditDelay",
      RegMem => "RegField",
      Description => "Delayes the credits coming from the fdll to the logic that delayes PDs until it's corrosponding fdll link is popped from the FDLL CBR. Configuring to value above 0 will delay the credits.
Resolution is 1cc.",
      Width => "5",
      Position => "39:35", # Excel Formula: =calc_position(F13,E14)
      Type => "Config",
      UsedBy => "DSN",
      DefaultValue => "h0",
      Comments => "Constant",
    },
    Slice5DisableWaitForFdllCredit => { #Structure Type: RegField; ArrayLength: 7; ArrayIndex: 5; ArrayLocationInName: 6;
      Name => "Slice[n]DisableWaitForFdllCredit",
      RegMem => "RegField",
      Description => "Disables the halt of PDs until all requests of the packet that were sent to the FDLL were popped from the FDLL CBR.
If disabled - the latency will be reduced but there is a risk of read before write in the FDLL.",
      Width => "1",
      Position => "40", # Excel Formula: =calc_position(F14,E15)
      Type => "Config",
      UsedBy => "DSN",
      DefaultValue => "h0",
      Comments => "Constant",
    },
  },
  ReassemblyConfReg16 => { #Structure Type: Reg; ArrayLength: 7; ArrayIndex: 6; ArrayLocationInName: 19;
    Name => "ReassemblyConfReg1[7]",
    RegMem => "Reg",
    Address => "106",
    Description => "This register was used for tuning parameters during the design phase. The value of these fields is optimized for the current silicon, thus the user is not expected to change its value unless instructed by Cisco Systems, Inc.",
    Width => "41", # Excel Formula: =calc_reg_width(E8:E15,F15)
    Type => "Config",
    AdditionalInfo => "PackArrayToBus",
    ArrayLength => "7",
    ArrayIndex => "6",
    LlDb6WriteFifoFullThreshold => { #Structure Type: RegField; ArrayLength: 7; ArrayIndex: 6; ArrayLocationInName: 5;
      Name => "LlDb[n]WriteFifoFullThreshold",
      RegMem => "RegField",
      Description => "The fill level threshold of the FIFO that holds write requests to the FDLL from which the FIFO is considered full thus the reassembly will not insert new PD/FDs to the pipe and will create backpressure.",
      Width => "4",
      Position => "3:0", # Excel Formula: =calc_position(F7,E8,TRUE)
      Type => "Config",
      UsedBy => "DSN",
      DefaultValue => "h2",
      Comments => "Constant",
    },
    InFifo6IfgPauseThreshold => { #Structure Type: RegField; ArrayLength: 7; ArrayIndex: 6; ArrayLocationInName: 7;
      Name => "InFifo[n]IfgPauseThreshold",
      RegMem => "RegField",
      Description => "When the reassembly FIFO that holds new packets (FD/PD) reached this threshold a pause indication is sent to the IFG.
The FIFO is expected to absorb all packets that are on the way due to the response time of the IFG.",
      Width => "8",
      Position => "11:4", # Excel Formula: =calc_position(F8,E9)
      Type => "Config",
      UsedBy => "DSN",
      DefaultValue => "h30",
      Comments => "Constant",
      InitValueAllModes => "16",
    },
    InFifo6RxppPauseThreshold => { #Structure Type: RegField; ArrayLength: 7; ArrayIndex: 6; ArrayLocationInName: 7;
      Name => "InFifo[n]RxppPauseThreshold",
      RegMem => "RegField",
      Description => "When the reassembly FIFO that holds new packets (FD/PD) reached this threshold a pause indication is sent to the RXPP.
The FIFO is expected to absorb all packets that are on the way due to the response time of the RXPP.",
      Width => "8",
      Position => "19:12", # Excel Formula: =calc_position(F9,E10)
      Type => "Config",
      UsedBy => "DSN",
      DefaultValue => "h30",
      Comments => "Constant",
      InitValueAllModes => "32",
    },
    OutPdFifo6FullThreshold => { #Structure Type: RegField; ArrayLength: 7; ArrayIndex: 6; ArrayLocationInName: 10;
      Name => "OutPdFifo[n]FullThreshold",
      RegMem => "RegField",
      Description => "The fill level threshold of the out FIFO that holds PDs from which the FIFO is considered full thus the reassembly will not insert new PD/FDs to the pipe and will create backpressure.",
      Width => "7",
      Position => "26:20", # Excel Formula: =calc_position(F10,E11)
      Type => "Config",
      UsedBy => "DSN",
      DefaultValue => "d66",
      Comments => "Constant",
    },
    OutPdControlFifo6FullThreshold => { #Structure Type: RegField; ArrayLength: 7; ArrayIndex: 6; ArrayLocationInName: 17;
      Name => "OutPdControlFifo[n]FullThreshold",
      RegMem => "RegField",
      Description => "The fill level threshold of the out PD control FIFO from which the FIFO is considered full thus the reassembly will not insert new PD/FDs to the pipe and will create backpressure.",
      Width => "7",
      Position => "33:27", # Excel Formula: =calc_position(F11,E12)
      Type => "Config",
      UsedBy => "DSN",
      DefaultValue => "d66",
      Comments => "Constant",
    },
    Slice6DisableContextRelease => { #Structure Type: RegField; ArrayLength: 7; ArrayIndex: 6; ArrayLocationInName: 6;
      Name => "Slice[n]DisableContextRelease",
      RegMem => "RegField",
      Description => "Prevents the reassmebly from releasing contexts to the free buffer manager.
Relevant for debug testing mode where packets are generated from a configurable memory thus not used from context allocation but from memory configuration.",
      Width => "1",
      Position => "34", # Excel Formula: =calc_position(F12,E13)
      Type => "Config",
      UsedBy => "DSN",
      DefaultValue => "h0",
      Comments => "Constant",
    },
    Slice6ReassemblyCreditDelay => { #Structure Type: RegField; ArrayLength: 7; ArrayIndex: 6; ArrayLocationInName: 6;
      Name => "Slice[n]ReassemblyCreditDelay",
      RegMem => "RegField",
      Description => "Delayes the credits coming from the fdll to the logic that delayes PDs until it's corrosponding fdll link is popped from the FDLL CBR. Configuring to value above 0 will delay the credits.
Resolution is 1cc.",
      Width => "5",
      Position => "39:35", # Excel Formula: =calc_position(F13,E14)
      Type => "Config",
      UsedBy => "DSN",
      DefaultValue => "h0",
      Comments => "Constant",
    },
    Slice6DisableWaitForFdllCredit => { #Structure Type: RegField; ArrayLength: 7; ArrayIndex: 6; ArrayLocationInName: 6;
      Name => "Slice[n]DisableWaitForFdllCredit",
      RegMem => "RegField",
      Description => "Disables the halt of PDs until all requests of the packet that were sent to the FDLL were popped from the FDLL CBR.
If disabled - the latency will be reduced but there is a risk of read before write in the FDLL.",
      Width => "1",
      Position => "40", # Excel Formula: =calc_position(F14,E15)
      Type => "Config",
      UsedBy => "DSN",
      DefaultValue => "h0",
      Comments => "Constant",
    },
  },
  ReassemblySliceCounters0 => { #Structure Type: Reg; ArrayLength: 7; ArrayIndex: 0; ArrayLocationInName: 24;
    Name => "ReassemblySliceCounters[7]",
    RegMem => "Reg",
    Address => "107", # Excel Formula: =calc_reg_address(C7,A7,G7)
    Width => "32", # Excel Formula: =calc_reg_width(E17:E17,F17)
    Type => "ReadOnly",
    AdditionalInfo => "PackArrayToBus",
    ArrayLength => "7",
    ArrayIndex => "0",
    IncomingPacketCounterSlice0 => { #Structure Type: RegField; ArrayLength: 7; ArrayIndex: 0; ArrayLocationInName: 27;
      Name => "IncomingPacketCounterSlice[n]",
      RegMem => "RegField",
      Description => "Counts the number of packets that entered the reassembly from the corresponding slice.
Note  - the counter count SOP indications.",
      Width => "32",
      Position => "31:0", # Excel Formula: =calc_position(F16,E17,TRUE)
      Type => "Counter",
      UsedBy => "DSN",
      AdditionalInfo => "CounterIncrWidth=1",
    },
  },
  ReassemblySliceCounters1 => { #Structure Type: Reg; ArrayLength: 7; ArrayIndex: 1; ArrayLocationInName: 24;
    Name => "ReassemblySliceCounters[7]",
    RegMem => "Reg",
    Address => "108",
    Width => "32", # Excel Formula: =calc_reg_width(E17:E17,F17)
    Type => "ReadOnly",
    AdditionalInfo => "PackArrayToBus",
    ArrayLength => "7",
    ArrayIndex => "1",
    IncomingPacketCounterSlice1 => { #Structure Type: RegField; ArrayLength: 7; ArrayIndex: 1; ArrayLocationInName: 27;
      Name => "IncomingPacketCounterSlice[n]",
      RegMem => "RegField",
      Description => "Counts the number of packets that entered the reassembly from the corresponding slice.
Note  - the counter count SOP indications.",
      Width => "32",
      Position => "31:0", # Excel Formula: =calc_position(F16,E17,TRUE)
      Type => "Counter",
      UsedBy => "DSN",
      AdditionalInfo => "CounterIncrWidth=1",
    },
  },
  ReassemblySliceCounters2 => { #Structure Type: Reg; ArrayLength: 7; ArrayIndex: 2; ArrayLocationInName: 24;
    Name => "ReassemblySliceCounters[7]",
    RegMem => "Reg",
    Address => "109",
    Width => "32", # Excel Formula: =calc_reg_width(E17:E17,F17)
    Type => "ReadOnly",
    AdditionalInfo => "PackArrayToBus",
    ArrayLength => "7",
    ArrayIndex => "2",
    IncomingPacketCounterSlice2 => { #Structure Type: RegField; ArrayLength: 7; ArrayIndex: 2; ArrayLocationInName: 27;
      Name => "IncomingPacketCounterSlice[n]",
      RegMem => "RegField",
      Description => "Counts the number of packets that entered the reassembly from the corresponding slice.
Note  - the counter count SOP indications.",
      Width => "32",
      Position => "31:0", # Excel Formula: =calc_position(F16,E17,TRUE)
      Type => "Counter",
      UsedBy => "DSN",
      AdditionalInfo => "CounterIncrWidth=1",
    },
  },
  ReassemblySliceCounters3 => { #Structure Type: Reg; ArrayLength: 7; ArrayIndex: 3; ArrayLocationInName: 24;
    Name => "ReassemblySliceCounters[7]",
    RegMem => "Reg",
    Address => "10A",
    Width => "32", # Excel Formula: =calc_reg_width(E17:E17,F17)
    Type => "ReadOnly",
    AdditionalInfo => "PackArrayToBus",
    ArrayLength => "7",
    ArrayIndex => "3",
    IncomingPacketCounterSlice3 => { #Structure Type: RegField; ArrayLength: 7; ArrayIndex: 3; ArrayLocationInName: 27;
      Name => "IncomingPacketCounterSlice[n]",
      RegMem => "RegField",
      Description => "Counts the number of packets that entered the reassembly from the corresponding slice.
Note  - the counter count SOP indications.",
      Width => "32",
      Position => "31:0", # Excel Formula: =calc_position(F16,E17,TRUE)
      Type => "Counter",
      UsedBy => "DSN",
      AdditionalInfo => "CounterIncrWidth=1",
    },
  },
  ReassemblySliceCounters4 => { #Structure Type: Reg; ArrayLength: 7; ArrayIndex: 4; ArrayLocationInName: 24;
    Name => "ReassemblySliceCounters[7]",
    RegMem => "Reg",
    Address => "10B",
    Width => "32", # Excel Formula: =calc_reg_width(E17:E17,F17)
    Type => "ReadOnly",
    AdditionalInfo => "PackArrayToBus",
    ArrayLength => "7",
    ArrayIndex => "4",
    IncomingPacketCounterSlice4 => { #Structure Type: RegField; ArrayLength: 7; ArrayIndex: 4; ArrayLocationInName: 27;
      Name => "IncomingPacketCounterSlice[n]",
      RegMem => "RegField",
      Description => "Counts the number of packets that entered the reassembly from the corresponding slice.
Note  - the counter count SOP indications.",
      Width => "32",
      Position => "31:0", # Excel Formula: =calc_position(F16,E17,TRUE)
      Type => "Counter",
      UsedBy => "DSN",
      AdditionalInfo => "CounterIncrWidth=1",
    },
  },
  ReassemblySliceCounters5 => { #Structure Type: Reg; ArrayLength: 7; ArrayIndex: 5; ArrayLocationInName: 24;
    Name => "ReassemblySliceCounters[7]",
    RegMem => "Reg",
    Address => "10C",
    Width => "32", # Excel Formula: =calc_reg_width(E17:E17,F17)
    Type => "ReadOnly",
    AdditionalInfo => "PackArrayToBus",
    ArrayLength => "7",
    ArrayIndex => "5",
    IncomingPacketCounterSlice5 => { #Structure Type: RegField; ArrayLength: 7; ArrayIndex: 5; ArrayLocationInName: 27;
      Name => "IncomingPacketCounterSlice[n]",
      RegMem => "RegField",
      Description => "Counts the number of packets that entered the reassembly from the corresponding slice.
Note  - the counter count SOP indications.",
      Width => "32",
      Position => "31:0", # Excel Formula: =calc_position(F16,E17,TRUE)
      Type => "Counter",
      UsedBy => "DSN",
      AdditionalInfo => "CounterIncrWidth=1",
    },
  },
  ReassemblySliceCounters6 => { #Structure Type: Reg; ArrayLength: 7; ArrayIndex: 6; ArrayLocationInName: 24;
    Name => "ReassemblySliceCounters[7]",
    RegMem => "Reg",
    Address => "10D",
    Width => "32", # Excel Formula: =calc_reg_width(E17:E17,F17)
    Type => "ReadOnly",
    AdditionalInfo => "PackArrayToBus",
    ArrayLength => "7",
    ArrayIndex => "6",
    IncomingPacketCounterSlice6 => { #Structure Type: RegField; ArrayLength: 7; ArrayIndex: 6; ArrayLocationInName: 27;
      Name => "IncomingPacketCounterSlice[n]",
      RegMem => "RegField",
      Description => "Counts the number of packets that entered the reassembly from the corresponding slice.
Note  - the counter count SOP indications.",
      Width => "32",
      Position => "31:0", # Excel Formula: =calc_position(F16,E17,TRUE)
      Type => "Counter",
      UsedBy => "DSN",
      AdditionalInfo => "CounterIncrWidth=1",
    },
  },
  ReassemblyCounters => { #Structure Type: Reg;
    Name => "ReassemblyCounters",
    RegMem => "Reg",
    Address => "10E", # Excel Formula: =calc_reg_address(C16,A16,G16)
    Width => "52", # Excel Formula: =calc_reg_width(E19:E21,F21)
    Type => "ReadOnly",
    SlbBufferCounter => { #Structure Type: RegField;
      Name => "SlbBufferCounter",
      RegMem => "RegField",
      Description => "A counter that counts the number of buffers occupied by SLB packets.
Counter is incremented by the reassembly and decremented by the reorder.",
      Width => "19",
      Position => "18:0", # Excel Formula: =calc_position(F18,E19,TRUE)
      Type => "Status",
      UsedBy => "DSN",
    },
    SlbBufferCounterWraparound => { #Structure Type: RegField;
      Name => "SlbBufferCounterWraparound",
      RegMem => "RegField",
      Description => "Indicates that the SLB buffer counter wraparounded (changed from 0xFFF... to 0 or from 0 to 0xFFF)
This event should not occur.",
      Width => "1",
      Position => "19", # Excel Formula: =calc_position(F19,E20)
      Type => "Event",
      UsedBy => "DSN",
    },
    SlbDropPktCounter => { #Structure Type: RegField;
      Name => "SlbDropPktCounter",
      RegMem => "RegField",
      Description => "A counter that counts the number of SLB packets that were dropped in the reassembly due to the SLB buffer limit.",
      Width => "32",
      Position => "51:20", # Excel Formula: =calc_position(F20,E21)
      Type => "Status",
      UsedBy => "DSN",
    },
  },
  SliceModeReg0 => { #Structure Type: Reg; ArrayLength: 7; ArrayIndex: 0; ArrayLocationInName: 13;
    Name => "SliceModeReg[7]",
    RegMem => "Reg",
    Address => "10F", # Excel Formula: =calc_reg_address(C18,A18,G18)
    Width => "4", # Excel Formula: =calc_reg_width(E23:E23,F23)
    Type => "Config",
    AdditionalInfo => "PackArrayToBus",
    InstanceAllocation => "per_slice",
    ArrayLength => "7",
    ArrayIndex => "0",
    SliceMode0 => { #Structure Type: RegField; ArrayLength: 7; ArrayIndex: 0; ArrayLocationInName: 10;
      Name => "SliceMode[n]",
      RegMem => "RegField",
      Description => "0  // Linecard mode CRF TS network slice
1  // Linecard mode CRF SN network slice
2  // Linecard mode CRF TS fabric slice
3  // Linecard mode CRF SN fabric slice
4  // TOR mode network slice 
5  // TOR mode fabric slice
6  // FE mode with TS
7  // FE mode with SN
8  // Stand alone
9 // DRAM slice ",
      Width => "4",
      Position => "3:0", # Excel Formula: =calc_position(F22,E23,TRUE)
      Type => "Config",
      UsedBy => "DSN",
      DefaultValue => "d0",
      InitValueSa => "`SLICE_MODE_SA",
      InitValueLcNwk => "`SLICE_MODE_CRF_NWK_TS",
      InitValueLcFab => "`SLICE_MODE_CRF_FAB_TS",
      InitValueFe => "`SLICE_MODE_FE_TS",
    },
  },
  SliceModeReg1 => { #Structure Type: Reg; ArrayLength: 7; ArrayIndex: 1; ArrayLocationInName: 13;
    Name => "SliceModeReg[7]",
    RegMem => "Reg",
    Address => "110",
    Width => "4", # Excel Formula: =calc_reg_width(E23:E23,F23)
    Type => "Config",
    AdditionalInfo => "PackArrayToBus",
    InstanceAllocation => "per_slice",
    ArrayLength => "7",
    ArrayIndex => "1",
    SliceMode1 => { #Structure Type: RegField; ArrayLength: 7; ArrayIndex: 1; ArrayLocationInName: 10;
      Name => "SliceMode[n]",
      RegMem => "RegField",
      Description => "0  // Linecard mode CRF TS network slice
1  // Linecard mode CRF SN network slice
2  // Linecard mode CRF TS fabric slice
3  // Linecard mode CRF SN fabric slice
4  // TOR mode network slice 
5  // TOR mode fabric slice
6  // FE mode with TS
7  // FE mode with SN
8  // Stand alone
9 // DRAM slice ",
      Width => "4",
      Position => "3:0", # Excel Formula: =calc_position(F22,E23,TRUE)
      Type => "Config",
      UsedBy => "DSN",
      DefaultValue => "d0",
      InitValueSa => "`SLICE_MODE_SA",
      InitValueLcNwk => "`SLICE_MODE_CRF_NWK_TS",
      InitValueLcFab => "`SLICE_MODE_CRF_FAB_TS",
      InitValueFe => "`SLICE_MODE_FE_TS",
    },
  },
  SliceModeReg2 => { #Structure Type: Reg; ArrayLength: 7; ArrayIndex: 2; ArrayLocationInName: 13;
    Name => "SliceModeReg[7]",
    RegMem => "Reg",
    Address => "111",
    Width => "4", # Excel Formula: =calc_reg_width(E23:E23,F23)
    Type => "Config",
    AdditionalInfo => "PackArrayToBus",
    InstanceAllocation => "per_slice",
    ArrayLength => "7",
    ArrayIndex => "2",
    SliceMode2 => { #Structure Type: RegField; ArrayLength: 7; ArrayIndex: 2; ArrayLocationInName: 10;
      Name => "SliceMode[n]",
      RegMem => "RegField",
      Description => "0  // Linecard mode CRF TS network slice
1  // Linecard mode CRF SN network slice
2  // Linecard mode CRF TS fabric slice
3  // Linecard mode CRF SN fabric slice
4  // TOR mode network slice 
5  // TOR mode fabric slice
6  // FE mode with TS
7  // FE mode with SN
8  // Stand alone
9 // DRAM slice ",
      Width => "4",
      Position => "3:0", # Excel Formula: =calc_position(F22,E23,TRUE)
      Type => "Config",
      UsedBy => "DSN",
      DefaultValue => "d0",
      InitValueSa => "`SLICE_MODE_SA",
      InitValueLcNwk => "`SLICE_MODE_CRF_NWK_TS",
      InitValueLcFab => "`SLICE_MODE_CRF_FAB_TS",
      InitValueFe => "`SLICE_MODE_FE_TS",
    },
  },
  SliceModeReg3 => { #Structure Type: Reg; ArrayLength: 7; ArrayIndex: 3; ArrayLocationInName: 13;
    Name => "SliceModeReg[7]",
    RegMem => "Reg",
    Address => "112",
    Width => "4", # Excel Formula: =calc_reg_width(E23:E23,F23)
    Type => "Config",
    AdditionalInfo => "PackArrayToBus",
    InstanceAllocation => "per_slice",
    ArrayLength => "7",
    ArrayIndex => "3",
    SliceMode3 => { #Structure Type: RegField; ArrayLength: 7; ArrayIndex: 3; ArrayLocationInName: 10;
      Name => "SliceMode[n]",
      RegMem => "RegField",
      Description => "0  // Linecard mode CRF TS network slice
1  // Linecard mode CRF SN network slice
2  // Linecard mode CRF TS fabric slice
3  // Linecard mode CRF SN fabric slice
4  // TOR mode network slice 
5  // TOR mode fabric slice
6  // FE mode with TS
7  // FE mode with SN
8  // Stand alone
9 // DRAM slice ",
      Width => "4",
      Position => "3:0", # Excel Formula: =calc_position(F22,E23,TRUE)
      Type => "Config",
      UsedBy => "DSN",
      DefaultValue => "d0",
      InitValueSa => "`SLICE_MODE_SA",
      InitValueLcNwk => "`SLICE_MODE_CRF_NWK_TS",
      InitValueLcFab => "`SLICE_MODE_CRF_FAB_TS",
      InitValueFe => "`SLICE_MODE_FE_TS",
    },
  },
  SliceModeReg4 => { #Structure Type: Reg; ArrayLength: 7; ArrayIndex: 4; ArrayLocationInName: 13;
    Name => "SliceModeReg[7]",
    RegMem => "Reg",
    Address => "113",
    Width => "4", # Excel Formula: =calc_reg_width(E23:E23,F23)
    Type => "Config",
    AdditionalInfo => "PackArrayToBus",
    InstanceAllocation => "per_slice",
    ArrayLength => "7",
    ArrayIndex => "4",
    SliceMode4 => { #Structure Type: RegField; ArrayLength: 7; ArrayIndex: 4; ArrayLocationInName: 10;
      Name => "SliceMode[n]",
      RegMem => "RegField",
      Description => "0  // Linecard mode CRF TS network slice
1  // Linecard mode CRF SN network slice
2  // Linecard mode CRF TS fabric slice
3  // Linecard mode CRF SN fabric slice
4  // TOR mode network slice 
5  // TOR mode fabric slice
6  // FE mode with TS
7  // FE mode with SN
8  // Stand alone
9 // DRAM slice ",
      Width => "4",
      Position => "3:0", # Excel Formula: =calc_position(F22,E23,TRUE)
      Type => "Config",
      UsedBy => "DSN",
      DefaultValue => "d0",
      InitValueSa => "`SLICE_MODE_SA",
      InitValueLcNwk => "`SLICE_MODE_CRF_NWK_TS",
      InitValueLcFab => "`SLICE_MODE_CRF_FAB_TS",
      InitValueFe => "`SLICE_MODE_FE_TS",
    },
  },
  SliceModeReg5 => { #Structure Type: Reg; ArrayLength: 7; ArrayIndex: 5; ArrayLocationInName: 13;
    Name => "SliceModeReg[7]",
    RegMem => "Reg",
    Address => "114",
    Width => "4", # Excel Formula: =calc_reg_width(E23:E23,F23)
    Type => "Config",
    AdditionalInfo => "PackArrayToBus",
    InstanceAllocation => "per_slice",
    ArrayLength => "7",
    ArrayIndex => "5",
    SliceMode5 => { #Structure Type: RegField; ArrayLength: 7; ArrayIndex: 5; ArrayLocationInName: 10;
      Name => "SliceMode[n]",
      RegMem => "RegField",
      Description => "0  // Linecard mode CRF TS network slice
1  // Linecard mode CRF SN network slice
2  // Linecard mode CRF TS fabric slice
3  // Linecard mode CRF SN fabric slice
4  // TOR mode network slice 
5  // TOR mode fabric slice
6  // FE mode with TS
7  // FE mode with SN
8  // Stand alone
9 // DRAM slice ",
      Width => "4",
      Position => "3:0", # Excel Formula: =calc_position(F22,E23,TRUE)
      Type => "Config",
      UsedBy => "DSN",
      DefaultValue => "d0",
      InitValueSa => "`SLICE_MODE_SA",
      InitValueLcNwk => "`SLICE_MODE_CRF_NWK_TS",
      InitValueLcFab => "`SLICE_MODE_CRF_FAB_TS",
      InitValueFe => "`SLICE_MODE_FE_TS",
    },
  },
  SliceModeReg6 => { #Structure Type: Reg; ArrayLength: 7; ArrayIndex: 6; ArrayLocationInName: 13;
    Name => "SliceModeReg[7]",
    RegMem => "Reg",
    Address => "115",
    Width => "4", # Excel Formula: =calc_reg_width(E23:E23,F23)
    Type => "Config",
    AdditionalInfo => "PackArrayToBus",
    InstanceAllocation => "per_slice",
    ArrayLength => "7",
    ArrayIndex => "6",
    SliceMode6 => { #Structure Type: RegField; ArrayLength: 7; ArrayIndex: 6; ArrayLocationInName: 10;
      Name => "SliceMode[n]",
      RegMem => "RegField",
      Description => "0  // Linecard mode CRF TS network slice
1  // Linecard mode CRF SN network slice
2  // Linecard mode CRF TS fabric slice
3  // Linecard mode CRF SN fabric slice
4  // TOR mode network slice 
5  // TOR mode fabric slice
6  // FE mode with TS
7  // FE mode with SN
8  // Stand alone
9 // DRAM slice ",
      Width => "4",
      Position => "3:0", # Excel Formula: =calc_position(F22,E23,TRUE)
      Type => "Config",
      UsedBy => "DSN",
      DefaultValue => "d0",
      InitValueSa => "`SLICE_MODE_SA",
      InitValueLcNwk => "`SLICE_MODE_CRF_NWK_TS",
      InitValueLcFab => "`SLICE_MODE_CRF_FAB_TS",
      InitValueFe => "`SLICE_MODE_FE_TS",
    },
  },
  ReassemblyPktRateConf0 => { #Structure Type: Reg; ArrayLength: 7; ArrayIndex: 0; ArrayLocationInName: 22;
    Name => "ReassemblyPktRateConf[7]",
    RegMem => "Reg",
    Address => "116", # Excel Formula: =calc_reg_address(C22,A22,G22)
    Description => "This register enables to limit the rate of packets that are sent from the reassembly to the next block.",
    Width => "24", # Excel Formula: =calc_reg_width(E25:E26,F26)
    Type => "Config",
    AdditionalInfo => "PackArrayToBus",
    ArrayLength => "7",
    ArrayIndex => "0",
    Slice0PktRateWindow => { #Structure Type: RegField; ArrayLength: 7; ArrayIndex: 0; ArrayLocationInName: 6;
      Name => "Slice[n]PktRateWindow",
      RegMem => "RegField",
      Description => "
Defines the time window in clock cycles where the reassembly may pass up to PktRateNumOfPkts packets to the next block.
To disable rate limiting - set the PktRateNumOfPkts to PktRateWindow + 1.",
      Width => "12",
      Position => "11:0", # Excel Formula: =calc_position(F24,E25,TRUE)
      Type => "Config",
      UsedBy => "DSN",
      DefaultValue => "hFFE",
    },
    Slice0PktRateNumOfPkts => { #Structure Type: RegField; ArrayLength: 7; ArrayIndex: 0; ArrayLocationInName: 6;
      Name => "Slice[n]PktRateNumOfPkts",
      RegMem => "RegField",
      Description => "Defines the number of packets allowed within the time window.
To disable rate limiting - set the PktRateNumOfPkts to PktRateWindow + 1.",
      Width => "12",
      Position => "23:12", # Excel Formula: =calc_position(F25,E26)
      Type => "Config",
      UsedBy => "DSN",
      DefaultValue => "hFFF",
    },
  },
  ReassemblyPktRateConf1 => { #Structure Type: Reg; ArrayLength: 7; ArrayIndex: 1; ArrayLocationInName: 22;
    Name => "ReassemblyPktRateConf[7]",
    RegMem => "Reg",
    Address => "117",
    Description => "This register enables to limit the rate of packets that are sent from the reassembly to the next block.",
    Width => "24", # Excel Formula: =calc_reg_width(E25:E26,F26)
    Type => "Config",
    AdditionalInfo => "PackArrayToBus",
    ArrayLength => "7",
    ArrayIndex => "1",
    Slice1PktRateWindow => { #Structure Type: RegField; ArrayLength: 7; ArrayIndex: 1; ArrayLocationInName: 6;
      Name => "Slice[n]PktRateWindow",
      RegMem => "RegField",
      Description => "
Defines the time window in clock cycles where the reassembly may pass up to PktRateNumOfPkts packets to the next block.
To disable rate limiting - set the PktRateNumOfPkts to PktRateWindow + 1.",
      Width => "12",
      Position => "11:0", # Excel Formula: =calc_position(F24,E25,TRUE)
      Type => "Config",
      UsedBy => "DSN",
      DefaultValue => "hFFE",
    },
    Slice1PktRateNumOfPkts => { #Structure Type: RegField; ArrayLength: 7; ArrayIndex: 1; ArrayLocationInName: 6;
      Name => "Slice[n]PktRateNumOfPkts",
      RegMem => "RegField",
      Description => "Defines the number of packets allowed within the time window.
To disable rate limiting - set the PktRateNumOfPkts to PktRateWindow + 1.",
      Width => "12",
      Position => "23:12", # Excel Formula: =calc_position(F25,E26)
      Type => "Config",
      UsedBy => "DSN",
      DefaultValue => "hFFF",
    },
  },
  ReassemblyPktRateConf2 => { #Structure Type: Reg; ArrayLength: 7; ArrayIndex: 2; ArrayLocationInName: 22;
    Name => "ReassemblyPktRateConf[7]",
    RegMem => "Reg",
    Address => "118",
    Description => "This register enables to limit the rate of packets that are sent from the reassembly to the next block.",
    Width => "24", # Excel Formula: =calc_reg_width(E25:E26,F26)
    Type => "Config",
    AdditionalInfo => "PackArrayToBus",
    ArrayLength => "7",
    ArrayIndex => "2",
    Slice2PktRateWindow => { #Structure Type: RegField; ArrayLength: 7; ArrayIndex: 2; ArrayLocationInName: 6;
      Name => "Slice[n]PktRateWindow",
      RegMem => "RegField",
      Description => "
Defines the time window in clock cycles where the reassembly may pass up to PktRateNumOfPkts packets to the next block.
To disable rate limiting - set the PktRateNumOfPkts to PktRateWindow + 1.",
      Width => "12",
      Position => "11:0", # Excel Formula: =calc_position(F24,E25,TRUE)
      Type => "Config",
      UsedBy => "DSN",
      DefaultValue => "hFFE",
    },
    Slice2PktRateNumOfPkts => { #Structure Type: RegField; ArrayLength: 7; ArrayIndex: 2; ArrayLocationInName: 6;
      Name => "Slice[n]PktRateNumOfPkts",
      RegMem => "RegField",
      Description => "Defines the number of packets allowed within the time window.
To disable rate limiting - set the PktRateNumOfPkts to PktRateWindow + 1.",
      Width => "12",
      Position => "23:12", # Excel Formula: =calc_position(F25,E26)
      Type => "Config",
      UsedBy => "DSN",
      DefaultValue => "hFFF",
    },
  },
  ReassemblyPktRateConf3 => { #Structure Type: Reg; ArrayLength: 7; ArrayIndex: 3; ArrayLocationInName: 22;
    Name => "ReassemblyPktRateConf[7]",
    RegMem => "Reg",
    Address => "119",
    Description => "This register enables to limit the rate of packets that are sent from the reassembly to the next block.",
    Width => "24", # Excel Formula: =calc_reg_width(E25:E26,F26)
    Type => "Config",
    AdditionalInfo => "PackArrayToBus",
    ArrayLength => "7",
    ArrayIndex => "3",
    Slice3PktRateWindow => { #Structure Type: RegField; ArrayLength: 7; ArrayIndex: 3; ArrayLocationInName: 6;
      Name => "Slice[n]PktRateWindow",
      RegMem => "RegField",
      Description => "
Defines the time window in clock cycles where the reassembly may pass up to PktRateNumOfPkts packets to the next block.
To disable rate limiting - set the PktRateNumOfPkts to PktRateWindow + 1.",
      Width => "12",
      Position => "11:0", # Excel Formula: =calc_position(F24,E25,TRUE)
      Type => "Config",
      UsedBy => "DSN",
      DefaultValue => "hFFE",
    },
    Slice3PktRateNumOfPkts => { #Structure Type: RegField; ArrayLength: 7; ArrayIndex: 3; ArrayLocationInName: 6;
      Name => "Slice[n]PktRateNumOfPkts",
      RegMem => "RegField",
      Description => "Defines the number of packets allowed within the time window.
To disable rate limiting - set the PktRateNumOfPkts to PktRateWindow + 1.",
      Width => "12",
      Position => "23:12", # Excel Formula: =calc_position(F25,E26)
      Type => "Config",
      UsedBy => "DSN",
      DefaultValue => "hFFF",
    },
  },
  ReassemblyPktRateConf4 => { #Structure Type: Reg; ArrayLength: 7; ArrayIndex: 4; ArrayLocationInName: 22;
    Name => "ReassemblyPktRateConf[7]",
    RegMem => "Reg",
    Address => "11A",
    Description => "This register enables to limit the rate of packets that are sent from the reassembly to the next block.",
    Width => "24", # Excel Formula: =calc_reg_width(E25:E26,F26)
    Type => "Config",
    AdditionalInfo => "PackArrayToBus",
    ArrayLength => "7",
    ArrayIndex => "4",
    Slice4PktRateWindow => { #Structure Type: RegField; ArrayLength: 7; ArrayIndex: 4; ArrayLocationInName: 6;
      Name => "Slice[n]PktRateWindow",
      RegMem => "RegField",
      Description => "
Defines the time window in clock cycles where the reassembly may pass up to PktRateNumOfPkts packets to the next block.
To disable rate limiting - set the PktRateNumOfPkts to PktRateWindow + 1.",
      Width => "12",
      Position => "11:0", # Excel Formula: =calc_position(F24,E25,TRUE)
      Type => "Config",
      UsedBy => "DSN",
      DefaultValue => "hFFE",
    },
    Slice4PktRateNumOfPkts => { #Structure Type: RegField; ArrayLength: 7; ArrayIndex: 4; ArrayLocationInName: 6;
      Name => "Slice[n]PktRateNumOfPkts",
      RegMem => "RegField",
      Description => "Defines the number of packets allowed within the time window.
To disable rate limiting - set the PktRateNumOfPkts to PktRateWindow + 1.",
      Width => "12",
      Position => "23:12", # Excel Formula: =calc_position(F25,E26)
      Type => "Config",
      UsedBy => "DSN",
      DefaultValue => "hFFF",
    },
  },
  ReassemblyPktRateConf5 => { #Structure Type: Reg; ArrayLength: 7; ArrayIndex: 5; ArrayLocationInName: 22;
    Name => "ReassemblyPktRateConf[7]",
    RegMem => "Reg",
    Address => "11B",
    Description => "This register enables to limit the rate of packets that are sent from the reassembly to the next block.",
    Width => "24", # Excel Formula: =calc_reg_width(E25:E26,F26)
    Type => "Config",
    AdditionalInfo => "PackArrayToBus",
    ArrayLength => "7",
    ArrayIndex => "5",
    Slice5PktRateWindow => { #Structure Type: RegField; ArrayLength: 7; ArrayIndex: 5; ArrayLocationInName: 6;
      Name => "Slice[n]PktRateWindow",
      RegMem => "RegField",
      Description => "
Defines the time window in clock cycles where the reassembly may pass up to PktRateNumOfPkts packets to the next block.
To disable rate limiting - set the PktRateNumOfPkts to PktRateWindow + 1.",
      Width => "12",
      Position => "11:0", # Excel Formula: =calc_position(F24,E25,TRUE)
      Type => "Config",
      UsedBy => "DSN",
      DefaultValue => "hFFE",
    },
    Slice5PktRateNumOfPkts => { #Structure Type: RegField; ArrayLength: 7; ArrayIndex: 5; ArrayLocationInName: 6;
      Name => "Slice[n]PktRateNumOfPkts",
      RegMem => "RegField",
      Description => "Defines the number of packets allowed within the time window.
To disable rate limiting - set the PktRateNumOfPkts to PktRateWindow + 1.",
      Width => "12",
      Position => "23:12", # Excel Formula: =calc_position(F25,E26)
      Type => "Config",
      UsedBy => "DSN",
      DefaultValue => "hFFF",
    },
  },
  ReassemblyPktRateConf6 => { #Structure Type: Reg; ArrayLength: 7; ArrayIndex: 6; ArrayLocationInName: 22;
    Name => "ReassemblyPktRateConf[7]",
    RegMem => "Reg",
    Address => "11C",
    Description => "This register enables to limit the rate of packets that are sent from the reassembly to the next block.",
    Width => "24", # Excel Formula: =calc_reg_width(E25:E26,F26)
    Type => "Config",
    AdditionalInfo => "PackArrayToBus",
    ArrayLength => "7",
    ArrayIndex => "6",
    Slice6PktRateWindow => { #Structure Type: RegField; ArrayLength: 7; ArrayIndex: 6; ArrayLocationInName: 6;
      Name => "Slice[n]PktRateWindow",
      RegMem => "RegField",
      Description => "
Defines the time window in clock cycles where the reassembly may pass up to PktRateNumOfPkts packets to the next block.
To disable rate limiting - set the PktRateNumOfPkts to PktRateWindow + 1.",
      Width => "12",
      Position => "11:0", # Excel Formula: =calc_position(F24,E25,TRUE)
      Type => "Config",
      UsedBy => "DSN",
      DefaultValue => "hFFE",
    },
    Slice6PktRateNumOfPkts => { #Structure Type: RegField; ArrayLength: 7; ArrayIndex: 6; ArrayLocationInName: 6;
      Name => "Slice[n]PktRateNumOfPkts",
      RegMem => "RegField",
      Description => "Defines the number of packets allowed within the time window.
To disable rate limiting - set the PktRateNumOfPkts to PktRateWindow + 1.",
      Width => "12",
      Position => "23:12", # Excel Formula: =calc_position(F25,E26)
      Type => "Config",
      UsedBy => "DSN",
      DefaultValue => "hFFF",
    },
  },
  ReassemblyCgmConf => { #Structure Type: Reg;
    Name => "ReassemblyCgmConf",
    RegMem => "Reg",
    Address => "11D", # Excel Formula: =calc_reg_address(C24,A24,G24)
    Width => "32", # Excel Formula: =calc_reg_width(E28:E29,F29)
    Type => "Config",
    ReorderSlbBuffersThreshold => { #Structure Type: RegField;
      Name => "ReorderSlbBuffersThreshold",
      RegMem => "RegField",
      Description => "When the number of buffers of SLB packets in the reorder crosses this threshold -SLB packets will be dropped in the reassembly.",
      Width => "19",
      Position => "18:0", # Excel Formula: =calc_position(F27,E28,TRUE)
      Type => "Config",
      UsedBy => "DSN",
      DefaultValue => "h1FFF",
    },
    SlbMaxSnrContext => { #Structure Type: RegField;
      Name => "SlbMaxSnrContext",
      RegMem => "RegField",
      Description => "The SNR context maximal value that identifies the packet as SLB.
This field was used for tuning parameters during the design phase. The value of this field is optimized for the current silicon, thus the user is not expected to change its value unless instructed by Cisco Systems, Inc.",
      Width => "13",
      Position => "31:19", # Excel Formula: =calc_position(F28,E29)
      Type => "Config",
      UsedBy => "DSN",
      DefaultValue => "hFFF",
    },
  },
  StatusRegister => { #Structure Type: Reg;
    Name => "StatusRegister",
    RegMem => "Reg",
    Address => "11E", # Excel Formula: =calc_reg_address(C27,A27,G27)
    Width => "1", # Excel Formula: =calc_reg_width(E31:E31,F31)
    Type => "ReadOnly",
    InitDone => { #Structure Type: RegField;
      Name => "InitDone",
      RegMem => "RegField",
      Description => "Indication that the reassembly completed the initialization process.",
      Width => "1",
      Position => "0", # Excel Formula: =calc_position(F30,E31,TRUE)
      Type => "Status",
      UsedBy => "DSN",
    },
  },
  SlbBuffHistogram => { #Structure Type: Reg;
    Name => "SlbBuffHistogram",
    RegMem => "Reg",
    Address => "11F", # Excel Formula: =calc_reg_address(C30,A30,G30)
    Width => "1", # Excel Formula: =calc_reg_width(E33:E33,F33)
    Type => "Histogram",
    AdditionalInfo => "HistType=Static,NumOfBins=8,BinWidth=32,HistThWidth=19,TimeIntervalWidth=10,RateEventWidth=14",
    SlbBuffHist => { #Structure Type: RegField;
      Name => "SlbBuffHist",
      RegMem => "RegField",
      Description => "A histogram of the amount of buffers in the reorder occupied by SLB packets",
      Width => "1",
      Position => "0", # Excel Formula: =calc_position(F32,E33,TRUE)
      Type => "Histogram",
      UsedBy => "DSN",
    },
  },
  ReassemblyLastInPdFd => { #Structure Type: Reg;
    Name => "ReassemblyLastInPdFd",
    RegMem => "Reg",
    Address => "120", # Excel Formula: =calc_reg_address(C32,A32,G32)
    Width => "80", # Excel Formula: =calc_reg_width(E35:E38,F38)
    Type => "External",
    UsedBy => "DSN",
    ReassemblyLastIncomingPd => { #Structure Type: RegField;
      Name => "ReassemblyLastIncomingPd",
      RegMem => "RegField",
      Description => "This register holds the 32 bits of the PD muxed by LastIncomingPdMuxSel",
      Width => "32",
      Position => "31:0", # Excel Formula: =calc_position(F34,E35,TRUE)
      Type => "External",
    },
    ReassemblyLastIncomingFd => { #Structure Type: RegField;
      Name => "ReassemblyLastIncomingFd",
      RegMem => "RegField",
      Description => "This register holds 16 bits of the FD muxed by LastIncomingFdMuxSel",
      Width => "16",
      Position => "47:32", # Excel Formula: =calc_position(F35,E36)
      Type => "External",
    },
    ReassemblyLastIncomingDramPd => { #Structure Type: RegField;
      Name => "ReassemblyLastIncomingDramPd",
      RegMem => "RegField",
      Description => "This register holds 16 bits of the DRAM PD muxed by LastIncomingDramPdMuxSel",
      Width => "16",
      Position => "63:48", # Excel Formula: =calc_position(F36,E37)
      Type => "External",
    },
    ReassemblyLastIncomingDramFd => { #Structure Type: RegField;
      Name => "ReassemblyLastIncomingDramFd",
      RegMem => "RegField",
      Description => "This register holds 16 bits of the DRAM PD muxed by LastIncomingDramFdMuxSel",
      Width => "16",
      Position => "79:64", # Excel Formula: =calc_position(F37,E38)
      Type => "External",
    },
  },
  ReassemblyDebugConf => { #Structure Type: Reg;
    Name => "ReassemblyDebugConf",
    RegMem => "Reg",
    Address => "121", # Excel Formula: =calc_reg_address(C34,A34,G34)
    Width => "16", # Excel Formula: =calc_reg_width(E40:E43,F43)
    Type => "Config",
    LastIncomingPdMuxSel => { #Structure Type: RegField;
      Name => "LastIncomingPdMuxSel",
      RegMem => "RegField",
      Description => "Selector for the debug mux of ReassemblyLastIncomingPd",
      Width => "6",
      Position => "5:0", # Excel Formula: =calc_position(F39,E40,TRUE)
      Type => "Config",
      UsedBy => "DSN",
      DefaultValue => "h0",
    },
    LastIncomingFdMuxSel => { #Structure Type: RegField;
      Name => "LastIncomingFdMuxSel",
      RegMem => "RegField",
      Description => "Selector for the debug mux of ReassemblyLastIncomingFd",
      Width => "5",
      Position => "10:6", # Excel Formula: =calc_position(F40,E41)
      Type => "Config",
      UsedBy => "DSN",
      DefaultValue => "h0",
    },
    LastIncomingDramPdMuxSel => { #Structure Type: RegField;
      Name => "LastIncomingDramPdMuxSel",
      RegMem => "RegField",
      Description => "Selector for the debug mux of ReassemblyLastIncomingDramPd",
      Width => "3",
      Position => "13:11", # Excel Formula: =calc_position(F41,E42)
      Type => "Config",
      UsedBy => "DSN",
      DefaultValue => "h0",
    },
    LastIncomingDramFdMuxSel => { #Structure Type: RegField;
      Name => "LastIncomingDramFdMuxSel",
      RegMem => "RegField",
      Description => "Selector for the debug mux of ReassemblyLastIncomingDramFd",
      Width => "2",
      Position => "15:14", # Excel Formula: =calc_position(F42,E43)
      Type => "Config",
      UsedBy => "DSN",
      DefaultValue => "h0",
    },
  },
  ReassemblyDebugReg0 => { #Structure Type: Reg; ArrayLength: 7; ArrayIndex: 0; ArrayLocationInName: 19;
    Name => "ReassemblyDebugReg[7]",
    RegMem => "Reg",
    Address => "122", # Excel Formula: =calc_reg_address(C39,A39,G39)
    Width => "17", # Excel Formula: =calc_reg_width(E45:E52,F52)
    Type => "ReadOnly",
    AdditionalInfo => "PackArrayToBus",
    ArrayLength => "7",
    ArrayIndex => "0",
    Slice0FreeContextCount => { #Structure Type: RegField; ArrayLength: 7; ArrayIndex: 0; ArrayLocationInName: 6;
      Name => "Slice[n]FreeContextCount",
      RegMem => "RegField",
      Description => "Current number of free reassembly contexts",
      Width => "10",
      Position => "9:0", # Excel Formula: =calc_position(F44,E45,TRUE)
      Type => "Status",
      UsedBy => "DSN",
    },
    Slice0ContextManagerEmpty => { #Structure Type: RegField; ArrayLength: 7; ArrayIndex: 0; ArrayLocationInName: 6;
      Name => "Slice[n]ContextManagerEmpty",
      RegMem => "RegField",
      Description => "This event indicates that the reassmebly context manager was empty.",
      Width => "1",
      Position => "10", # Excel Formula: =calc_position(F45,E46)
      Type => "Event",
      UsedBy => "DSN",
    },
    Slice0PauseToIfg => { #Structure Type: RegField; ArrayLength: 7; ArrayIndex: 0; ArrayLocationInName: 6;
      Name => "Slice[n]PauseToIfg",
      RegMem => "RegField",
      Description => "This event indicates that the reassembly issued pause to the IFG.",
      Width => "1",
      Position => "11", # Excel Formula: =calc_position(F46,E47)
      Type => "Event",
      UsedBy => "DSN",
    },
    Slice0PauseToRxpp => { #Structure Type: RegField; ArrayLength: 7; ArrayIndex: 0; ArrayLocationInName: 6;
      Name => "Slice[n]PauseToRxpp",
      RegMem => "RegField",
      Description => "This event indicates that the reassembly issued pause to the RXPP.",
      Width => "1",
      Position => "12", # Excel Formula: =calc_position(F47,E48)
      Type => "Event",
      UsedBy => "DSN",
    },
    Slice0OutPdFifoFull => { #Structure Type: RegField; ArrayLength: 7; ArrayIndex: 0; ArrayLocationInName: 6;
      Name => "Slice[n]OutPdFifoFull",
      RegMem => "RegField",
      Description => "This event indicates that the reassembly pipe halted due to the out FIFO being full. It may be caused by backpressure to the reassembly or packet rate limiter halting the pipe.",
      Width => "1",
      Position => "13", # Excel Formula: =calc_position(F48,E49)
      Type => "Event",
      UsedBy => "DSN",
    },
    Slice0OutPdControlFifoFull => { #Structure Type: RegField; ArrayLength: 7; ArrayIndex: 0; ArrayLocationInName: 6;
      Name => "Slice[n]OutPdControlFifoFull",
      RegMem => "RegField",
      Description => "This event indicates that the reassembly pipe halted due to the out control FIFO being full. It may be caused by backpressure to the reassembly or packet rate limiter halting the pipe.",
      Width => "1",
      Position => "14", # Excel Formula: =calc_position(F49,E50)
      Type => "Event",
      UsedBy => "DSN",
    },
    Slice0FdllFifoFull => { #Structure Type: RegField; ArrayLength: 7; ArrayIndex: 0; ArrayLocationInName: 6;
      Name => "Slice[n]FdllFifoFull",
      RegMem => "RegField",
      Description => "This event indicates that the reassembly pipe halted due to the FIFO towards the FDLL being full.",
      Width => "1",
      Position => "15", # Excel Formula: =calc_position(F50,E51)
      Type => "Event",
      UsedBy => "DSN",
    },
    Slice0InFifoOverflow => { #Structure Type: RegField; ArrayLength: 7; ArrayIndex: 0; ArrayLocationInName: 6;
      Name => "Slice[n]InFifoOverflow",
      RegMem => "RegField",
      Description => "This event indicates that the in PD/FD FIFO had an overflow.
Should not occur since a pause indication to the IFG and RXPP should prevent the FIFO from overflow.",
      Width => "1",
      Position => "16", # Excel Formula: =calc_position(F51,E52)
      Type => "Event",
      UsedBy => "DSN",
    },
  },
  ReassemblyDebugReg1 => { #Structure Type: Reg; ArrayLength: 7; ArrayIndex: 1; ArrayLocationInName: 19;
    Name => "ReassemblyDebugReg[7]",
    RegMem => "Reg",
    Address => "123",
    Width => "17", # Excel Formula: =calc_reg_width(E45:E52,F52)
    Type => "ReadOnly",
    AdditionalInfo => "PackArrayToBus",
    ArrayLength => "7",
    ArrayIndex => "1",
    Slice1FreeContextCount => { #Structure Type: RegField; ArrayLength: 7; ArrayIndex: 1; ArrayLocationInName: 6;
      Name => "Slice[n]FreeContextCount",
      RegMem => "RegField",
      Description => "Current number of free reassembly contexts",
      Width => "10",
      Position => "9:0", # Excel Formula: =calc_position(F44,E45,TRUE)
      Type => "Status",
      UsedBy => "DSN",
    },
    Slice1ContextManagerEmpty => { #Structure Type: RegField; ArrayLength: 7; ArrayIndex: 1; ArrayLocationInName: 6;
      Name => "Slice[n]ContextManagerEmpty",
      RegMem => "RegField",
      Description => "This event indicates that the reassmebly context manager was empty.",
      Width => "1",
      Position => "10", # Excel Formula: =calc_position(F45,E46)
      Type => "Event",
      UsedBy => "DSN",
    },
    Slice1PauseToIfg => { #Structure Type: RegField; ArrayLength: 7; ArrayIndex: 1; ArrayLocationInName: 6;
      Name => "Slice[n]PauseToIfg",
      RegMem => "RegField",
      Description => "This event indicates that the reassembly issued pause to the IFG.",
      Width => "1",
      Position => "11", # Excel Formula: =calc_position(F46,E47)
      Type => "Event",
      UsedBy => "DSN",
    },
    Slice1PauseToRxpp => { #Structure Type: RegField; ArrayLength: 7; ArrayIndex: 1; ArrayLocationInName: 6;
      Name => "Slice[n]PauseToRxpp",
      RegMem => "RegField",
      Description => "This event indicates that the reassembly issued pause to the RXPP.",
      Width => "1",
      Position => "12", # Excel Formula: =calc_position(F47,E48)
      Type => "Event",
      UsedBy => "DSN",
    },
    Slice1OutPdFifoFull => { #Structure Type: RegField; ArrayLength: 7; ArrayIndex: 1; ArrayLocationInName: 6;
      Name => "Slice[n]OutPdFifoFull",
      RegMem => "RegField",
      Description => "This event indicates that the reassembly pipe halted due to the out FIFO being full. It may be caused by backpressure to the reassembly or packet rate limiter halting the pipe.",
      Width => "1",
      Position => "13", # Excel Formula: =calc_position(F48,E49)
      Type => "Event",
      UsedBy => "DSN",
    },
    Slice1OutPdControlFifoFull => { #Structure Type: RegField; ArrayLength: 7; ArrayIndex: 1; ArrayLocationInName: 6;
      Name => "Slice[n]OutPdControlFifoFull",
      RegMem => "RegField",
      Description => "This event indicates that the reassembly pipe halted due to the out control FIFO being full. It may be caused by backpressure to the reassembly or packet rate limiter halting the pipe.",
      Width => "1",
      Position => "14", # Excel Formula: =calc_position(F49,E50)
      Type => "Event",
      UsedBy => "DSN",
    },
    Slice1FdllFifoFull => { #Structure Type: RegField; ArrayLength: 7; ArrayIndex: 1; ArrayLocationInName: 6;
      Name => "Slice[n]FdllFifoFull",
      RegMem => "RegField",
      Description => "This event indicates that the reassembly pipe halted due to the FIFO towards the FDLL being full.",
      Width => "1",
      Position => "15", # Excel Formula: =calc_position(F50,E51)
      Type => "Event",
      UsedBy => "DSN",
    },
    Slice1InFifoOverflow => { #Structure Type: RegField; ArrayLength: 7; ArrayIndex: 1; ArrayLocationInName: 6;
      Name => "Slice[n]InFifoOverflow",
      RegMem => "RegField",
      Description => "This event indicates that the in PD/FD FIFO had an overflow.
Should not occur since a pause indication to the IFG and RXPP should prevent the FIFO from overflow.",
      Width => "1",
      Position => "16", # Excel Formula: =calc_position(F51,E52)
      Type => "Event",
      UsedBy => "DSN",
    },
  },
  ReassemblyDebugReg2 => { #Structure Type: Reg; ArrayLength: 7; ArrayIndex: 2; ArrayLocationInName: 19;
    Name => "ReassemblyDebugReg[7]",
    RegMem => "Reg",
    Address => "124",
    Width => "17", # Excel Formula: =calc_reg_width(E45:E52,F52)
    Type => "ReadOnly",
    AdditionalInfo => "PackArrayToBus",
    ArrayLength => "7",
    ArrayIndex => "2",
    Slice2FreeContextCount => { #Structure Type: RegField; ArrayLength: 7; ArrayIndex: 2; ArrayLocationInName: 6;
      Name => "Slice[n]FreeContextCount",
      RegMem => "RegField",
      Description => "Current number of free reassembly contexts",
      Width => "10",
      Position => "9:0", # Excel Formula: =calc_position(F44,E45,TRUE)
      Type => "Status",
      UsedBy => "DSN",
    },
    Slice2ContextManagerEmpty => { #Structure Type: RegField; ArrayLength: 7; ArrayIndex: 2; ArrayLocationInName: 6;
      Name => "Slice[n]ContextManagerEmpty",
      RegMem => "RegField",
      Description => "This event indicates that the reassmebly context manager was empty.",
      Width => "1",
      Position => "10", # Excel Formula: =calc_position(F45,E46)
      Type => "Event",
      UsedBy => "DSN",
    },
    Slice2PauseToIfg => { #Structure Type: RegField; ArrayLength: 7; ArrayIndex: 2; ArrayLocationInName: 6;
      Name => "Slice[n]PauseToIfg",
      RegMem => "RegField",
      Description => "This event indicates that the reassembly issued pause to the IFG.",
      Width => "1",
      Position => "11", # Excel Formula: =calc_position(F46,E47)
      Type => "Event",
      UsedBy => "DSN",
    },
    Slice2PauseToRxpp => { #Structure Type: RegField; ArrayLength: 7; ArrayIndex: 2; ArrayLocationInName: 6;
      Name => "Slice[n]PauseToRxpp",
      RegMem => "RegField",
      Description => "This event indicates that the reassembly issued pause to the RXPP.",
      Width => "1",
      Position => "12", # Excel Formula: =calc_position(F47,E48)
      Type => "Event",
      UsedBy => "DSN",
    },
    Slice2OutPdFifoFull => { #Structure Type: RegField; ArrayLength: 7; ArrayIndex: 2; ArrayLocationInName: 6;
      Name => "Slice[n]OutPdFifoFull",
      RegMem => "RegField",
      Description => "This event indicates that the reassembly pipe halted due to the out FIFO being full. It may be caused by backpressure to the reassembly or packet rate limiter halting the pipe.",
      Width => "1",
      Position => "13", # Excel Formula: =calc_position(F48,E49)
      Type => "Event",
      UsedBy => "DSN",
    },
    Slice2OutPdControlFifoFull => { #Structure Type: RegField; ArrayLength: 7; ArrayIndex: 2; ArrayLocationInName: 6;
      Name => "Slice[n]OutPdControlFifoFull",
      RegMem => "RegField",
      Description => "This event indicates that the reassembly pipe halted due to the out control FIFO being full. It may be caused by backpressure to the reassembly or packet rate limiter halting the pipe.",
      Width => "1",
      Position => "14", # Excel Formula: =calc_position(F49,E50)
      Type => "Event",
      UsedBy => "DSN",
    },
    Slice2FdllFifoFull => { #Structure Type: RegField; ArrayLength: 7; ArrayIndex: 2; ArrayLocationInName: 6;
      Name => "Slice[n]FdllFifoFull",
      RegMem => "RegField",
      Description => "This event indicates that the reassembly pipe halted due to the FIFO towards the FDLL being full.",
      Width => "1",
      Position => "15", # Excel Formula: =calc_position(F50,E51)
      Type => "Event",
      UsedBy => "DSN",
    },
    Slice2InFifoOverflow => { #Structure Type: RegField; ArrayLength: 7; ArrayIndex: 2; ArrayLocationInName: 6;
      Name => "Slice[n]InFifoOverflow",
      RegMem => "RegField",
      Description => "This event indicates that the in PD/FD FIFO had an overflow.
Should not occur since a pause indication to the IFG and RXPP should prevent the FIFO from overflow.",
      Width => "1",
      Position => "16", # Excel Formula: =calc_position(F51,E52)
      Type => "Event",
      UsedBy => "DSN",
    },
  },
  ReassemblyDebugReg3 => { #Structure Type: Reg; ArrayLength: 7; ArrayIndex: 3; ArrayLocationInName: 19;
    Name => "ReassemblyDebugReg[7]",
    RegMem => "Reg",
    Address => "125",
    Width => "17", # Excel Formula: =calc_reg_width(E45:E52,F52)
    Type => "ReadOnly",
    AdditionalInfo => "PackArrayToBus",
    ArrayLength => "7",
    ArrayIndex => "3",
    Slice3FreeContextCount => { #Structure Type: RegField; ArrayLength: 7; ArrayIndex: 3; ArrayLocationInName: 6;
      Name => "Slice[n]FreeContextCount",
      RegMem => "RegField",
      Description => "Current number of free reassembly contexts",
      Width => "10",
      Position => "9:0", # Excel Formula: =calc_position(F44,E45,TRUE)
      Type => "Status",
      UsedBy => "DSN",
    },
    Slice3ContextManagerEmpty => { #Structure Type: RegField; ArrayLength: 7; ArrayIndex: 3; ArrayLocationInName: 6;
      Name => "Slice[n]ContextManagerEmpty",
      RegMem => "RegField",
      Description => "This event indicates that the reassmebly context manager was empty.",
      Width => "1",
      Position => "10", # Excel Formula: =calc_position(F45,E46)
      Type => "Event",
      UsedBy => "DSN",
    },
    Slice3PauseToIfg => { #Structure Type: RegField; ArrayLength: 7; ArrayIndex: 3; ArrayLocationInName: 6;
      Name => "Slice[n]PauseToIfg",
      RegMem => "RegField",
      Description => "This event indicates that the reassembly issued pause to the IFG.",
      Width => "1",
      Position => "11", # Excel Formula: =calc_position(F46,E47)
      Type => "Event",
      UsedBy => "DSN",
    },
    Slice3PauseToRxpp => { #Structure Type: RegField; ArrayLength: 7; ArrayIndex: 3; ArrayLocationInName: 6;
      Name => "Slice[n]PauseToRxpp",
      RegMem => "RegField",
      Description => "This event indicates that the reassembly issued pause to the RXPP.",
      Width => "1",
      Position => "12", # Excel Formula: =calc_position(F47,E48)
      Type => "Event",
      UsedBy => "DSN",
    },
    Slice3OutPdFifoFull => { #Structure Type: RegField; ArrayLength: 7; ArrayIndex: 3; ArrayLocationInName: 6;
      Name => "Slice[n]OutPdFifoFull",
      RegMem => "RegField",
      Description => "This event indicates that the reassembly pipe halted due to the out FIFO being full. It may be caused by backpressure to the reassembly or packet rate limiter halting the pipe.",
      Width => "1",
      Position => "13", # Excel Formula: =calc_position(F48,E49)
      Type => "Event",
      UsedBy => "DSN",
    },
    Slice3OutPdControlFifoFull => { #Structure Type: RegField; ArrayLength: 7; ArrayIndex: 3; ArrayLocationInName: 6;
      Name => "Slice[n]OutPdControlFifoFull",
      RegMem => "RegField",
      Description => "This event indicates that the reassembly pipe halted due to the out control FIFO being full. It may be caused by backpressure to the reassembly or packet rate limiter halting the pipe.",
      Width => "1",
      Position => "14", # Excel Formula: =calc_position(F49,E50)
      Type => "Event",
      UsedBy => "DSN",
    },
    Slice3FdllFifoFull => { #Structure Type: RegField; ArrayLength: 7; ArrayIndex: 3; ArrayLocationInName: 6;
      Name => "Slice[n]FdllFifoFull",
      RegMem => "RegField",
      Description => "This event indicates that the reassembly pipe halted due to the FIFO towards the FDLL being full.",
      Width => "1",
      Position => "15", # Excel Formula: =calc_position(F50,E51)
      Type => "Event",
      UsedBy => "DSN",
    },
    Slice3InFifoOverflow => { #Structure Type: RegField; ArrayLength: 7; ArrayIndex: 3; ArrayLocationInName: 6;
      Name => "Slice[n]InFifoOverflow",
      RegMem => "RegField",
      Description => "This event indicates that the in PD/FD FIFO had an overflow.
Should not occur since a pause indication to the IFG and RXPP should prevent the FIFO from overflow.",
      Width => "1",
      Position => "16", # Excel Formula: =calc_position(F51,E52)
      Type => "Event",
      UsedBy => "DSN",
    },
  },
  ReassemblyDebugReg4 => { #Structure Type: Reg; ArrayLength: 7; ArrayIndex: 4; ArrayLocationInName: 19;
    Name => "ReassemblyDebugReg[7]",
    RegMem => "Reg",
    Address => "126",
    Width => "17", # Excel Formula: =calc_reg_width(E45:E52,F52)
    Type => "ReadOnly",
    AdditionalInfo => "PackArrayToBus",
    ArrayLength => "7",
    ArrayIndex => "4",
    Slice4FreeContextCount => { #Structure Type: RegField; ArrayLength: 7; ArrayIndex: 4; ArrayLocationInName: 6;
      Name => "Slice[n]FreeContextCount",
      RegMem => "RegField",
      Description => "Current number of free reassembly contexts",
      Width => "10",
      Position => "9:0", # Excel Formula: =calc_position(F44,E45,TRUE)
      Type => "Status",
      UsedBy => "DSN",
    },
    Slice4ContextManagerEmpty => { #Structure Type: RegField; ArrayLength: 7; ArrayIndex: 4; ArrayLocationInName: 6;
      Name => "Slice[n]ContextManagerEmpty",
      RegMem => "RegField",
      Description => "This event indicates that the reassmebly context manager was empty.",
      Width => "1",
      Position => "10", # Excel Formula: =calc_position(F45,E46)
      Type => "Event",
      UsedBy => "DSN",
    },
    Slice4PauseToIfg => { #Structure Type: RegField; ArrayLength: 7; ArrayIndex: 4; ArrayLocationInName: 6;
      Name => "Slice[n]PauseToIfg",
      RegMem => "RegField",
      Description => "This event indicates that the reassembly issued pause to the IFG.",
      Width => "1",
      Position => "11", # Excel Formula: =calc_position(F46,E47)
      Type => "Event",
      UsedBy => "DSN",
    },
    Slice4PauseToRxpp => { #Structure Type: RegField; ArrayLength: 7; ArrayIndex: 4; ArrayLocationInName: 6;
      Name => "Slice[n]PauseToRxpp",
      RegMem => "RegField",
      Description => "This event indicates that the reassembly issued pause to the RXPP.",
      Width => "1",
      Position => "12", # Excel Formula: =calc_position(F47,E48)
      Type => "Event",
      UsedBy => "DSN",
    },
    Slice4OutPdFifoFull => { #Structure Type: RegField; ArrayLength: 7; ArrayIndex: 4; ArrayLocationInName: 6;
      Name => "Slice[n]OutPdFifoFull",
      RegMem => "RegField",
      Description => "This event indicates that the reassembly pipe halted due to the out FIFO being full. It may be caused by backpressure to the reassembly or packet rate limiter halting the pipe.",
      Width => "1",
      Position => "13", # Excel Formula: =calc_position(F48,E49)
      Type => "Event",
      UsedBy => "DSN",
    },
    Slice4OutPdControlFifoFull => { #Structure Type: RegField; ArrayLength: 7; ArrayIndex: 4; ArrayLocationInName: 6;
      Name => "Slice[n]OutPdControlFifoFull",
      RegMem => "RegField",
      Description => "This event indicates that the reassembly pipe halted due to the out control FIFO being full. It may be caused by backpressure to the reassembly or packet rate limiter halting the pipe.",
      Width => "1",
      Position => "14", # Excel Formula: =calc_position(F49,E50)
      Type => "Event",
      UsedBy => "DSN",
    },
    Slice4FdllFifoFull => { #Structure Type: RegField; ArrayLength: 7; ArrayIndex: 4; ArrayLocationInName: 6;
      Name => "Slice[n]FdllFifoFull",
      RegMem => "RegField",
      Description => "This event indicates that the reassembly pipe halted due to the FIFO towards the FDLL being full.",
      Width => "1",
      Position => "15", # Excel Formula: =calc_position(F50,E51)
      Type => "Event",
      UsedBy => "DSN",
    },
    Slice4InFifoOverflow => { #Structure Type: RegField; ArrayLength: 7; ArrayIndex: 4; ArrayLocationInName: 6;
      Name => "Slice[n]InFifoOverflow",
      RegMem => "RegField",
      Description => "This event indicates that the in PD/FD FIFO had an overflow.
Should not occur since a pause indication to the IFG and RXPP should prevent the FIFO from overflow.",
      Width => "1",
      Position => "16", # Excel Formula: =calc_position(F51,E52)
      Type => "Event",
      UsedBy => "DSN",
    },
  },
  ReassemblyDebugReg5 => { #Structure Type: Reg; ArrayLength: 7; ArrayIndex: 5; ArrayLocationInName: 19;
    Name => "ReassemblyDebugReg[7]",
    RegMem => "Reg",
    Address => "127",
    Width => "17", # Excel Formula: =calc_reg_width(E45:E52,F52)
    Type => "ReadOnly",
    AdditionalInfo => "PackArrayToBus",
    ArrayLength => "7",
    ArrayIndex => "5",
    Slice5FreeContextCount => { #Structure Type: RegField; ArrayLength: 7; ArrayIndex: 5; ArrayLocationInName: 6;
      Name => "Slice[n]FreeContextCount",
      RegMem => "RegField",
      Description => "Current number of free reassembly contexts",
      Width => "10",
      Position => "9:0", # Excel Formula: =calc_position(F44,E45,TRUE)
      Type => "Status",
      UsedBy => "DSN",
    },
    Slice5ContextManagerEmpty => { #Structure Type: RegField; ArrayLength: 7; ArrayIndex: 5; ArrayLocationInName: 6;
      Name => "Slice[n]ContextManagerEmpty",
      RegMem => "RegField",
      Description => "This event indicates that the reassmebly context manager was empty.",
      Width => "1",
      Position => "10", # Excel Formula: =calc_position(F45,E46)
      Type => "Event",
      UsedBy => "DSN",
    },
    Slice5PauseToIfg => { #Structure Type: RegField; ArrayLength: 7; ArrayIndex: 5; ArrayLocationInName: 6;
      Name => "Slice[n]PauseToIfg",
      RegMem => "RegField",
      Description => "This event indicates that the reassembly issued pause to the IFG.",
      Width => "1",
      Position => "11", # Excel Formula: =calc_position(F46,E47)
      Type => "Event",
      UsedBy => "DSN",
    },
    Slice5PauseToRxpp => { #Structure Type: RegField; ArrayLength: 7; ArrayIndex: 5; ArrayLocationInName: 6;
      Name => "Slice[n]PauseToRxpp",
      RegMem => "RegField",
      Description => "This event indicates that the reassembly issued pause to the RXPP.",
      Width => "1",
      Position => "12", # Excel Formula: =calc_position(F47,E48)
      Type => "Event",
      UsedBy => "DSN",
    },
    Slice5OutPdFifoFull => { #Structure Type: RegField; ArrayLength: 7; ArrayIndex: 5; ArrayLocationInName: 6;
      Name => "Slice[n]OutPdFifoFull",
      RegMem => "RegField",
      Description => "This event indicates that the reassembly pipe halted due to the out FIFO being full. It may be caused by backpressure to the reassembly or packet rate limiter halting the pipe.",
      Width => "1",
      Position => "13", # Excel Formula: =calc_position(F48,E49)
      Type => "Event",
      UsedBy => "DSN",
    },
    Slice5OutPdControlFifoFull => { #Structure Type: RegField; ArrayLength: 7; ArrayIndex: 5; ArrayLocationInName: 6;
      Name => "Slice[n]OutPdControlFifoFull",
      RegMem => "RegField",
      Description => "This event indicates that the reassembly pipe halted due to the out control FIFO being full. It may be caused by backpressure to the reassembly or packet rate limiter halting the pipe.",
      Width => "1",
      Position => "14", # Excel Formula: =calc_position(F49,E50)
      Type => "Event",
      UsedBy => "DSN",
    },
    Slice5FdllFifoFull => { #Structure Type: RegField; ArrayLength: 7; ArrayIndex: 5; ArrayLocationInName: 6;
      Name => "Slice[n]FdllFifoFull",
      RegMem => "RegField",
      Description => "This event indicates that the reassembly pipe halted due to the FIFO towards the FDLL being full.",
      Width => "1",
      Position => "15", # Excel Formula: =calc_position(F50,E51)
      Type => "Event",
      UsedBy => "DSN",
    },
    Slice5InFifoOverflow => { #Structure Type: RegField; ArrayLength: 7; ArrayIndex: 5; ArrayLocationInName: 6;
      Name => "Slice[n]InFifoOverflow",
      RegMem => "RegField",
      Description => "This event indicates that the in PD/FD FIFO had an overflow.
Should not occur since a pause indication to the IFG and RXPP should prevent the FIFO from overflow.",
      Width => "1",
      Position => "16", # Excel Formula: =calc_position(F51,E52)
      Type => "Event",
      UsedBy => "DSN",
    },
  },
  ReassemblyDebugReg6 => { #Structure Type: Reg; ArrayLength: 7; ArrayIndex: 6; ArrayLocationInName: 19;
    Name => "ReassemblyDebugReg[7]",
    RegMem => "Reg",
    Address => "128",
    Width => "17", # Excel Formula: =calc_reg_width(E45:E52,F52)
    Type => "ReadOnly",
    AdditionalInfo => "PackArrayToBus",
    ArrayLength => "7",
    ArrayIndex => "6",
    Slice6FreeContextCount => { #Structure Type: RegField; ArrayLength: 7; ArrayIndex: 6; ArrayLocationInName: 6;
      Name => "Slice[n]FreeContextCount",
      RegMem => "RegField",
      Description => "Current number of free reassembly contexts",
      Width => "10",
      Position => "9:0", # Excel Formula: =calc_position(F44,E45,TRUE)
      Type => "Status",
      UsedBy => "DSN",
    },
    Slice6ContextManagerEmpty => { #Structure Type: RegField; ArrayLength: 7; ArrayIndex: 6; ArrayLocationInName: 6;
      Name => "Slice[n]ContextManagerEmpty",
      RegMem => "RegField",
      Description => "This event indicates that the reassmebly context manager was empty.",
      Width => "1",
      Position => "10", # Excel Formula: =calc_position(F45,E46)
      Type => "Event",
      UsedBy => "DSN",
    },
    Slice6PauseToIfg => { #Structure Type: RegField; ArrayLength: 7; ArrayIndex: 6; ArrayLocationInName: 6;
      Name => "Slice[n]PauseToIfg",
      RegMem => "RegField",
      Description => "This event indicates that the reassembly issued pause to the IFG.",
      Width => "1",
      Position => "11", # Excel Formula: =calc_position(F46,E47)
      Type => "Event",
      UsedBy => "DSN",
    },
    Slice6PauseToRxpp => { #Structure Type: RegField; ArrayLength: 7; ArrayIndex: 6; ArrayLocationInName: 6;
      Name => "Slice[n]PauseToRxpp",
      RegMem => "RegField",
      Description => "This event indicates that the reassembly issued pause to the RXPP.",
      Width => "1",
      Position => "12", # Excel Formula: =calc_position(F47,E48)
      Type => "Event",
      UsedBy => "DSN",
    },
    Slice6OutPdFifoFull => { #Structure Type: RegField; ArrayLength: 7; ArrayIndex: 6; ArrayLocationInName: 6;
      Name => "Slice[n]OutPdFifoFull",
      RegMem => "RegField",
      Description => "This event indicates that the reassembly pipe halted due to the out FIFO being full. It may be caused by backpressure to the reassembly or packet rate limiter halting the pipe.",
      Width => "1",
      Position => "13", # Excel Formula: =calc_position(F48,E49)
      Type => "Event",
      UsedBy => "DSN",
    },
    Slice6OutPdControlFifoFull => { #Structure Type: RegField; ArrayLength: 7; ArrayIndex: 6; ArrayLocationInName: 6;
      Name => "Slice[n]OutPdControlFifoFull",
      RegMem => "RegField",
      Description => "This event indicates that the reassembly pipe halted due to the out control FIFO being full. It may be caused by backpressure to the reassembly or packet rate limiter halting the pipe.",
      Width => "1",
      Position => "14", # Excel Formula: =calc_position(F49,E50)
      Type => "Event",
      UsedBy => "DSN",
    },
    Slice6FdllFifoFull => { #Structure Type: RegField; ArrayLength: 7; ArrayIndex: 6; ArrayLocationInName: 6;
      Name => "Slice[n]FdllFifoFull",
      RegMem => "RegField",
      Description => "This event indicates that the reassembly pipe halted due to the FIFO towards the FDLL being full.",
      Width => "1",
      Position => "15", # Excel Formula: =calc_position(F50,E51)
      Type => "Event",
      UsedBy => "DSN",
    },
    Slice6InFifoOverflow => { #Structure Type: RegField; ArrayLength: 7; ArrayIndex: 6; ArrayLocationInName: 6;
      Name => "Slice[n]InFifoOverflow",
      RegMem => "RegField",
      Description => "This event indicates that the in PD/FD FIFO had an overflow.
Should not occur since a pause indication to the IFG and RXPP should prevent the FIFO from overflow.",
      Width => "1",
      Position => "16", # Excel Formula: =calc_position(F51,E52)
      Type => "Event",
      UsedBy => "DSN",
    },
  },
  DebugPdFieldCfg => { #Structure Type: Reg;
    Name => "DebugPdFieldCfg",
    RegMem => "Reg",
    Address => "129", # Excel Formula: =calc_reg_address(C44,A44,G44)
    Description => "PD debugger",
    Width => "4", # Excel Formula: =calc_reg_width(E54:E55,F55)
    Type => "Config",
    DebugPdFieldSlice => { #Structure Type: RegField;
      Name => "DebugPdFieldSlice",
      RegMem => "RegField",
      Description => "Slice number for debug",
      Width => "3",
      Position => "2:0", # Excel Formula: =calc_position(F53,E54,TRUE)
      Type => "Config",
      UsedBy => "DBG",
      DefaultValue => "b0",
      InitValueAllModes => "6",
    },
    DebugPdHaltTraficOnMatch => { #Structure Type: RegField;
      Name => "DebugPdHaltTraficOnMatch",
      RegMem => "RegField",
      Description => "If set to 1 - when a PD that matches the filter configured in DebugPdFieldValueCfg is encountered - the traffic from the reassembly to the next block halts.",
      Width => "1",
      Position => "3", # Excel Formula: =calc_position(F54,E55)
      Type => "Config",
      UsedBy => "DBG",
      DefaultValue => "b0",
    },
  },
  DebugPdFieldStatus => { #Structure Type: Reg;
    Name => "DebugPdFieldStatus",
    RegMem => "Reg",
    Address => "12A", # Excel Formula: =calc_reg_address(C53,A53,G53)
    Description => "PD debug counters",
    Width => "96", # Excel Formula: =calc_reg_width(E57:E59,F59)
    Type => "ReadOnly",
    DebugPdFieldCnt => { #Structure Type: RegField;
      Name => "DebugPdFieldCnt",
      RegMem => "RegField",
      Description => "A counter that counts the number of PDs that matched the filer configured in DebugPdFieldValueCfg.",
      Width => "32",
      Position => "31:0", # Excel Formula: =calc_position(F56,E57,TRUE)
      Type => "Counter",
      UsedBy => "DBG",
      AdditionalInfo => "CounterIncrWidth=1",
    },
    DebugPdTotalPdCnt => { #Structure Type: RegField;
      Name => "DebugPdTotalPdCnt",
      RegMem => "RegField",
      Description => "A counter that counts the number of packets that enteres the slice defined by DebugPdFieldSlice.",
      Width => "32",
      Position => "63:32", # Excel Formula: =calc_position(F57,E58)
      Type => "Counter",
      UsedBy => "DBG",
      AdditionalInfo => "CounterIncrWidth=1",
    },
    DebugPdTotalByteCnt => { #Structure Type: RegField;
      Name => "DebugPdTotalByteCnt",
      RegMem => "RegField",
      Description => "A counter that counts the number of bytes that enteres the slice defined by DebugPdFieldSlice.",
      Width => "32",
      Position => "95:64", # Excel Formula: =calc_position(F58,E59)
      Type => "Counter",
      UsedBy => "DBG",
      AdditionalInfo => "CounterIncrWidth=14",
    },
  },
  CbtNotReadyCounters0 => { #Structure Type: Reg; ArrayLength: 7; ArrayIndex: 0; ArrayLocationInName: 20;
    Name => "CbtNotReadyCounters[7]",
    RegMem => "Reg",
    Address => "12B", # Excel Formula: =calc_reg_address(C56,A56,G56)
    Description => "Counters counting number of cc CBT was not ready",
    Width => "120", # Excel Formula: =calc_reg_width(E61:E64,F64)
    Type => "ReadOnly",
    AdditionalInfo => "PackArrayToBus",
    ArrayLength => "7",
    ArrayIndex => "0",
    Slice0Ifg0NotReady => { #Structure Type: RegField; ArrayLength: 7; ArrayIndex: 0; ArrayLocationInName: 6;
      Name => "Slice[n]Ifg0NotReady",
      RegMem => "RegField",
      Description => "CBT of context allocation to IFG 0 not ready counter (unused for DRAM slice)",
      Width => "20",
      Position => "19:0", # Excel Formula: =calc_position(F60,E61,TRUE)
      Type => "Counter",
      UsedBy => "CBT",
      AdditionalInfo => "CounterIncrWidth=1",
    },
    Slice0Ifg1NotReady => { #Structure Type: RegField; ArrayLength: 7; ArrayIndex: 0; ArrayLocationInName: 6;
      Name => "Slice[n]Ifg1NotReady",
      RegMem => "RegField",
      Description => "CBT of context allocation to IFG 1 not ready counter (unused for DRAM slice)",
      Width => "20",
      Position => "39:20", # Excel Formula: =calc_position(F61,E62)
      Type => "Counter",
      UsedBy => "CBT",
      AdditionalInfo => "CounterIncrWidth=1",
    },
    Slice0RxMeterNotReady => { #Structure Type: RegField; ArrayLength: 7; ArrayIndex: 0; ArrayLocationInName: 6;
      Name => "Slice[n]RxMeterNotReady",
      RegMem => "RegField",
      Description => "CBT of output to RX-Meter (or PDVOQ in DRAM slice) not ready counter",
      Width => "48",
      Position => "87:40", # Excel Formula: =calc_position(F62,E63)
      Type => "Counter",
      UsedBy => "CBT",
      AdditionalInfo => "CounterIncrWidth=1",
    },
    Slice0FdllNotReady => { #Structure Type: RegField; ArrayLength: 7; ArrayIndex: 0; ArrayLocationInName: 6;
      Name => "Slice[n]FdllNotReady",
      RegMem => "RegField",
      Description => "CBT of output to FDLL not ready counter",
      Width => "32",
      Position => "119:88", # Excel Formula: =calc_position(F63,E64)
      Type => "Counter",
      UsedBy => "CBT",
      AdditionalInfo => "CounterIncrWidth=1",
    },
  },
  CbtNotReadyCounters1 => { #Structure Type: Reg; ArrayLength: 7; ArrayIndex: 1; ArrayLocationInName: 20;
    Name => "CbtNotReadyCounters[7]",
    RegMem => "Reg",
    Address => "12C",
    Description => "Counters counting number of cc CBT was not ready",
    Width => "120", # Excel Formula: =calc_reg_width(E61:E64,F64)
    Type => "ReadOnly",
    AdditionalInfo => "PackArrayToBus",
    ArrayLength => "7",
    ArrayIndex => "1",
    Slice1Ifg0NotReady => { #Structure Type: RegField; ArrayLength: 7; ArrayIndex: 1; ArrayLocationInName: 6;
      Name => "Slice[n]Ifg0NotReady",
      RegMem => "RegField",
      Description => "CBT of context allocation to IFG 0 not ready counter (unused for DRAM slice)",
      Width => "20",
      Position => "19:0", # Excel Formula: =calc_position(F60,E61,TRUE)
      Type => "Counter",
      UsedBy => "CBT",
      AdditionalInfo => "CounterIncrWidth=1",
    },
    Slice1Ifg1NotReady => { #Structure Type: RegField; ArrayLength: 7; ArrayIndex: 1; ArrayLocationInName: 6;
      Name => "Slice[n]Ifg1NotReady",
      RegMem => "RegField",
      Description => "CBT of context allocation to IFG 1 not ready counter (unused for DRAM slice)",
      Width => "20",
      Position => "39:20", # Excel Formula: =calc_position(F61,E62)
      Type => "Counter",
      UsedBy => "CBT",
      AdditionalInfo => "CounterIncrWidth=1",
    },
    Slice1RxMeterNotReady => { #Structure Type: RegField; ArrayLength: 7; ArrayIndex: 1; ArrayLocationInName: 6;
      Name => "Slice[n]RxMeterNotReady",
      RegMem => "RegField",
      Description => "CBT of output to RX-Meter (or PDVOQ in DRAM slice) not ready counter",
      Width => "48",
      Position => "87:40", # Excel Formula: =calc_position(F62,E63)
      Type => "Counter",
      UsedBy => "CBT",
      AdditionalInfo => "CounterIncrWidth=1",
    },
    Slice1FdllNotReady => { #Structure Type: RegField; ArrayLength: 7; ArrayIndex: 1; ArrayLocationInName: 6;
      Name => "Slice[n]FdllNotReady",
      RegMem => "RegField",
      Description => "CBT of output to FDLL not ready counter",
      Width => "32",
      Position => "119:88", # Excel Formula: =calc_position(F63,E64)
      Type => "Counter",
      UsedBy => "CBT",
      AdditionalInfo => "CounterIncrWidth=1",
    },
  },
  CbtNotReadyCounters2 => { #Structure Type: Reg; ArrayLength: 7; ArrayIndex: 2; ArrayLocationInName: 20;
    Name => "CbtNotReadyCounters[7]",
    RegMem => "Reg",
    Address => "12D",
    Description => "Counters counting number of cc CBT was not ready",
    Width => "120", # Excel Formula: =calc_reg_width(E61:E64,F64)
    Type => "ReadOnly",
    AdditionalInfo => "PackArrayToBus",
    ArrayLength => "7",
    ArrayIndex => "2",
    Slice2Ifg0NotReady => { #Structure Type: RegField; ArrayLength: 7; ArrayIndex: 2; ArrayLocationInName: 6;
      Name => "Slice[n]Ifg0NotReady",
      RegMem => "RegField",
      Description => "CBT of context allocation to IFG 0 not ready counter (unused for DRAM slice)",
      Width => "20",
      Position => "19:0", # Excel Formula: =calc_position(F60,E61,TRUE)
      Type => "Counter",
      UsedBy => "CBT",
      AdditionalInfo => "CounterIncrWidth=1",
    },
    Slice2Ifg1NotReady => { #Structure Type: RegField; ArrayLength: 7; ArrayIndex: 2; ArrayLocationInName: 6;
      Name => "Slice[n]Ifg1NotReady",
      RegMem => "RegField",
      Description => "CBT of context allocation to IFG 1 not ready counter (unused for DRAM slice)",
      Width => "20",
      Position => "39:20", # Excel Formula: =calc_position(F61,E62)
      Type => "Counter",
      UsedBy => "CBT",
      AdditionalInfo => "CounterIncrWidth=1",
    },
    Slice2RxMeterNotReady => { #Structure Type: RegField; ArrayLength: 7; ArrayIndex: 2; ArrayLocationInName: 6;
      Name => "Slice[n]RxMeterNotReady",
      RegMem => "RegField",
      Description => "CBT of output to RX-Meter (or PDVOQ in DRAM slice) not ready counter",
      Width => "48",
      Position => "87:40", # Excel Formula: =calc_position(F62,E63)
      Type => "Counter",
      UsedBy => "CBT",
      AdditionalInfo => "CounterIncrWidth=1",
    },
    Slice2FdllNotReady => { #Structure Type: RegField; ArrayLength: 7; ArrayIndex: 2; ArrayLocationInName: 6;
      Name => "Slice[n]FdllNotReady",
      RegMem => "RegField",
      Description => "CBT of output to FDLL not ready counter",
      Width => "32",
      Position => "119:88", # Excel Formula: =calc_position(F63,E64)
      Type => "Counter",
      UsedBy => "CBT",
      AdditionalInfo => "CounterIncrWidth=1",
    },
  },
  CbtNotReadyCounters3 => { #Structure Type: Reg; ArrayLength: 7; ArrayIndex: 3; ArrayLocationInName: 20;
    Name => "CbtNotReadyCounters[7]",
    RegMem => "Reg",
    Address => "12E",
    Description => "Counters counting number of cc CBT was not ready",
    Width => "120", # Excel Formula: =calc_reg_width(E61:E64,F64)
    Type => "ReadOnly",
    AdditionalInfo => "PackArrayToBus",
    ArrayLength => "7",
    ArrayIndex => "3",
    Slice3Ifg0NotReady => { #Structure Type: RegField; ArrayLength: 7; ArrayIndex: 3; ArrayLocationInName: 6;
      Name => "Slice[n]Ifg0NotReady",
      RegMem => "RegField",
      Description => "CBT of context allocation to IFG 0 not ready counter (unused for DRAM slice)",
      Width => "20",
      Position => "19:0", # Excel Formula: =calc_position(F60,E61,TRUE)
      Type => "Counter",
      UsedBy => "CBT",
      AdditionalInfo => "CounterIncrWidth=1",
    },
    Slice3Ifg1NotReady => { #Structure Type: RegField; ArrayLength: 7; ArrayIndex: 3; ArrayLocationInName: 6;
      Name => "Slice[n]Ifg1NotReady",
      RegMem => "RegField",
      Description => "CBT of context allocation to IFG 1 not ready counter (unused for DRAM slice)",
      Width => "20",
      Position => "39:20", # Excel Formula: =calc_position(F61,E62)
      Type => "Counter",
      UsedBy => "CBT",
      AdditionalInfo => "CounterIncrWidth=1",
    },
    Slice3RxMeterNotReady => { #Structure Type: RegField; ArrayLength: 7; ArrayIndex: 3; ArrayLocationInName: 6;
      Name => "Slice[n]RxMeterNotReady",
      RegMem => "RegField",
      Description => "CBT of output to RX-Meter (or PDVOQ in DRAM slice) not ready counter",
      Width => "48",
      Position => "87:40", # Excel Formula: =calc_position(F62,E63)
      Type => "Counter",
      UsedBy => "CBT",
      AdditionalInfo => "CounterIncrWidth=1",
    },
    Slice3FdllNotReady => { #Structure Type: RegField; ArrayLength: 7; ArrayIndex: 3; ArrayLocationInName: 6;
      Name => "Slice[n]FdllNotReady",
      RegMem => "RegField",
      Description => "CBT of output to FDLL not ready counter",
      Width => "32",
      Position => "119:88", # Excel Formula: =calc_position(F63,E64)
      Type => "Counter",
      UsedBy => "CBT",
      AdditionalInfo => "CounterIncrWidth=1",
    },
  },
  CbtNotReadyCounters4 => { #Structure Type: Reg; ArrayLength: 7; ArrayIndex: 4; ArrayLocationInName: 20;
    Name => "CbtNotReadyCounters[7]",
    RegMem => "Reg",
    Address => "12F",
    Description => "Counters counting number of cc CBT was not ready",
    Width => "120", # Excel Formula: =calc_reg_width(E61:E64,F64)
    Type => "ReadOnly",
    AdditionalInfo => "PackArrayToBus",
    ArrayLength => "7",
    ArrayIndex => "4",
    Slice4Ifg0NotReady => { #Structure Type: RegField; ArrayLength: 7; ArrayIndex: 4; ArrayLocationInName: 6;
      Name => "Slice[n]Ifg0NotReady",
      RegMem => "RegField",
      Description => "CBT of context allocation to IFG 0 not ready counter (unused for DRAM slice)",
      Width => "20",
      Position => "19:0", # Excel Formula: =calc_position(F60,E61,TRUE)
      Type => "Counter",
      UsedBy => "CBT",
      AdditionalInfo => "CounterIncrWidth=1",
    },
    Slice4Ifg1NotReady => { #Structure Type: RegField; ArrayLength: 7; ArrayIndex: 4; ArrayLocationInName: 6;
      Name => "Slice[n]Ifg1NotReady",
      RegMem => "RegField",
      Description => "CBT of context allocation to IFG 1 not ready counter (unused for DRAM slice)",
      Width => "20",
      Position => "39:20", # Excel Formula: =calc_position(F61,E62)
      Type => "Counter",
      UsedBy => "CBT",
      AdditionalInfo => "CounterIncrWidth=1",
    },
    Slice4RxMeterNotReady => { #Structure Type: RegField; ArrayLength: 7; ArrayIndex: 4; ArrayLocationInName: 6;
      Name => "Slice[n]RxMeterNotReady",
      RegMem => "RegField",
      Description => "CBT of output to RX-Meter (or PDVOQ in DRAM slice) not ready counter",
      Width => "48",
      Position => "87:40", # Excel Formula: =calc_position(F62,E63)
      Type => "Counter",
      UsedBy => "CBT",
      AdditionalInfo => "CounterIncrWidth=1",
    },
    Slice4FdllNotReady => { #Structure Type: RegField; ArrayLength: 7; ArrayIndex: 4; ArrayLocationInName: 6;
      Name => "Slice[n]FdllNotReady",
      RegMem => "RegField",
      Description => "CBT of output to FDLL not ready counter",
      Width => "32",
      Position => "119:88", # Excel Formula: =calc_position(F63,E64)
      Type => "Counter",
      UsedBy => "CBT",
      AdditionalInfo => "CounterIncrWidth=1",
    },
  },
  CbtNotReadyCounters5 => { #Structure Type: Reg; ArrayLength: 7; ArrayIndex: 5; ArrayLocationInName: 20;
    Name => "CbtNotReadyCounters[7]",
    RegMem => "Reg",
    Address => "130",
    Description => "Counters counting number of cc CBT was not ready",
    Width => "120", # Excel Formula: =calc_reg_width(E61:E64,F64)
    Type => "ReadOnly",
    AdditionalInfo => "PackArrayToBus",
    ArrayLength => "7",
    ArrayIndex => "5",
    Slice5Ifg0NotReady => { #Structure Type: RegField; ArrayLength: 7; ArrayIndex: 5; ArrayLocationInName: 6;
      Name => "Slice[n]Ifg0NotReady",
      RegMem => "RegField",
      Description => "CBT of context allocation to IFG 0 not ready counter (unused for DRAM slice)",
      Width => "20",
      Position => "19:0", # Excel Formula: =calc_position(F60,E61,TRUE)
      Type => "Counter",
      UsedBy => "CBT",
      AdditionalInfo => "CounterIncrWidth=1",
    },
    Slice5Ifg1NotReady => { #Structure Type: RegField; ArrayLength: 7; ArrayIndex: 5; ArrayLocationInName: 6;
      Name => "Slice[n]Ifg1NotReady",
      RegMem => "RegField",
      Description => "CBT of context allocation to IFG 1 not ready counter (unused for DRAM slice)",
      Width => "20",
      Position => "39:20", # Excel Formula: =calc_position(F61,E62)
      Type => "Counter",
      UsedBy => "CBT",
      AdditionalInfo => "CounterIncrWidth=1",
    },
    Slice5RxMeterNotReady => { #Structure Type: RegField; ArrayLength: 7; ArrayIndex: 5; ArrayLocationInName: 6;
      Name => "Slice[n]RxMeterNotReady",
      RegMem => "RegField",
      Description => "CBT of output to RX-Meter (or PDVOQ in DRAM slice) not ready counter",
      Width => "48",
      Position => "87:40", # Excel Formula: =calc_position(F62,E63)
      Type => "Counter",
      UsedBy => "CBT",
      AdditionalInfo => "CounterIncrWidth=1",
    },
    Slice5FdllNotReady => { #Structure Type: RegField; ArrayLength: 7; ArrayIndex: 5; ArrayLocationInName: 6;
      Name => "Slice[n]FdllNotReady",
      RegMem => "RegField",
      Description => "CBT of output to FDLL not ready counter",
      Width => "32",
      Position => "119:88", # Excel Formula: =calc_position(F63,E64)
      Type => "Counter",
      UsedBy => "CBT",
      AdditionalInfo => "CounterIncrWidth=1",
    },
  },
  CbtNotReadyCounters6 => { #Structure Type: Reg; ArrayLength: 7; ArrayIndex: 6; ArrayLocationInName: 20;
    Name => "CbtNotReadyCounters[7]",
    RegMem => "Reg",
    Address => "131",
    Description => "Counters counting number of cc CBT was not ready",
    Width => "120", # Excel Formula: =calc_reg_width(E61:E64,F64)
    Type => "ReadOnly",
    AdditionalInfo => "PackArrayToBus",
    ArrayLength => "7",
    ArrayIndex => "6",
    Slice6Ifg0NotReady => { #Structure Type: RegField; ArrayLength: 7; ArrayIndex: 6; ArrayLocationInName: 6;
      Name => "Slice[n]Ifg0NotReady",
      RegMem => "RegField",
      Description => "CBT of context allocation to IFG 0 not ready counter (unused for DRAM slice)",
      Width => "20",
      Position => "19:0", # Excel Formula: =calc_position(F60,E61,TRUE)
      Type => "Counter",
      UsedBy => "CBT",
      AdditionalInfo => "CounterIncrWidth=1",
    },
    Slice6Ifg1NotReady => { #Structure Type: RegField; ArrayLength: 7; ArrayIndex: 6; ArrayLocationInName: 6;
      Name => "Slice[n]Ifg1NotReady",
      RegMem => "RegField",
      Description => "CBT of context allocation to IFG 1 not ready counter (unused for DRAM slice)",
      Width => "20",
      Position => "39:20", # Excel Formula: =calc_position(F61,E62)
      Type => "Counter",
      UsedBy => "CBT",
      AdditionalInfo => "CounterIncrWidth=1",
    },
    Slice6RxMeterNotReady => { #Structure Type: RegField; ArrayLength: 7; ArrayIndex: 6; ArrayLocationInName: 6;
      Name => "Slice[n]RxMeterNotReady",
      RegMem => "RegField",
      Description => "CBT of output to RX-Meter (or PDVOQ in DRAM slice) not ready counter",
      Width => "48",
      Position => "87:40", # Excel Formula: =calc_position(F62,E63)
      Type => "Counter",
      UsedBy => "CBT",
      AdditionalInfo => "CounterIncrWidth=1",
    },
    Slice6FdllNotReady => { #Structure Type: RegField; ArrayLength: 7; ArrayIndex: 6; ArrayLocationInName: 6;
      Name => "Slice[n]FdllNotReady",
      RegMem => "RegField",
      Description => "CBT of output to FDLL not ready counter",
      Width => "32",
      Position => "119:88", # Excel Formula: =calc_position(F63,E64)
      Type => "Counter",
      UsedBy => "CBT",
      AdditionalInfo => "CounterIncrWidth=1",
    },
  },
  ContextTable0 => { #Structure Type: Mem; ArrayLength: 6; ArrayIndex: 0; ArrayLocationInName: 13;
    Name => "ContextTable[6]",
    RegMem => "Mem",
    Address => "100000",
    Description => "The Context Table keeps track of the pakcet fragments and combines it to a PD that is sent to the pipe when the packet is received completely.",
    Width => "310", # Excel Formula: =calc_mem_width(E66:E72,M65,F72,-1)
    Type => "Dynamic",
    UsedBy => "DSN",
    MemEntries => "960",
    MemWrapper => "1R1W",
    MemProtect => "ECC",
    AdditionalInfo => "SampleReadAccess=1,SampleReadBeforeProt=2,SampleReadAfterProt=1,SampleWriteAfterProt=1,CpuReadAccess=Enabled,CpuWriteAccess=Enabled,PackArrayToBus=Enabled,DisableSameAddressErr=Enabled,WriteActivityFactor=50,ReadActivityFactor=50,PortErrPropagate=Disabled",
    Comments => "Read and write latency must be equal to DramContextTable",
    ArrayLength => "6",
    ArrayIndex => "0",
    MemLogicalWidth => "300",
    Status0 => { #Structure Type: MemField; ArrayLength: 6; ArrayIndex: 0; ArrayLocationInName: 7;
      Name => "Status[n]",
      RegMem => "MemField",
      Description => "Indicates the status of the connection:
0 - Invalid
1 - Valid (Address not necessarily valid but Error is valid)
2 - SOP/EOP arrived (means that the next SOP/EOP will trigger PD out)",
      Width => "2",
      Position => "1:0", # Excel Formula: =calc_position(F65,E66,TRUE)
      DefaultValue => "h0",
    },
    PacketSize0 => { #Structure Type: MemField; ArrayLength: 6; ArrayIndex: 0; ArrayLocationInName: 11;
      Name => "PacketSize[n]",
      RegMem => "MemField",
      Description => "The total fragment sizes that were written to the SMS.",
      Width => "14",
      Position => "15:2", # Excel Formula: =calc_position(F66,E67)
      DefaultValue => "h0",
    },
    PacketID0 => { #Structure Type: MemField; ArrayLength: 6; ArrayIndex: 0; ArrayLocationInName: 9;
      Name => "PacketID[n]",
      RegMem => "MemField",
      Description => "The address of the SMS buffer that belong to either the 1st or 2nd packet fragment that were written to the SMS.",
      Width => "19",
      Position => "34:16", # Excel Formula: =calc_position(F67,E68)
      DefaultValue => "h0",
    },
    FragmentSeqNum0 => { #Structure Type: MemField; ArrayLength: 6; ArrayIndex: 0; ArrayLocationInName: 15;
      Name => "FragmentSeqNum[n]",
      RegMem => "MemField",
      Description => "Holds the sequence number of the next fragment.",
      Width => "5",
      Position => "39:35", # Excel Formula: =calc_position(F68,E69)
      DefaultValue => "h0",
    },
    PD0 => { #Structure Type: MemField; ArrayLength: 6; ArrayIndex: 0; ArrayLocationInName: 3;
      Name => "PD[n]",
      RegMem => "MemField",
      Description => "Holds the PD fields that should be forwarded to the next unit (width is incoming PD width).",
      Width => "258",
      Position => "297:40", # Excel Formula: =calc_position(F69,E70)
      DefaultValue => "h0",
    },
    Drop0 => { #Structure Type: MemField; ArrayLength: 6; ArrayIndex: 0; ArrayLocationInName: 5;
      Name => "Drop[n]",
      RegMem => "MemField",
      Description => "Indicates the packet had errors and thus should be dropped.
Possible errors are:
1. Packet arrived with bad CRC.
2. One of the packets fragments could not be written to the SMS due to lack of buffers.
3. Oversized packet",
      Width => "1",
      Position => "298", # Excel Formula: =calc_position(F70,E71)
      DefaultValue => "h0",
    },
    CrcError0 => { #Structure Type: MemField; ArrayLength: 6; ArrayIndex: 0; ArrayLocationInName: 9;
      Name => "CrcError[n]",
      RegMem => "MemField",
      Description => "Indicates the packet had CRC error thus the packet data is corrupted.",
      Width => "1",
      Position => "299", # Excel Formula: =calc_position(F71,E72)
      DefaultValue => "h0",
    },
  },
  ContextTable1 => { #Structure Type: Mem; ArrayLength: 6; ArrayIndex: 1; ArrayLocationInName: 13;
    Name => "ContextTable[6]",
    RegMem => "Mem",
    Address => "200000",
    Description => "The Context Table keeps track of the pakcet fragments and combines it to a PD that is sent to the pipe when the packet is received completely.",
    Width => "310", # Excel Formula: =calc_mem_width(E66:E72,M65,F72,-1)
    Type => "Dynamic",
    UsedBy => "DSN",
    MemEntries => "960",
    MemWrapper => "1R1W",
    MemProtect => "ECC",
    AdditionalInfo => "SampleReadAccess=1,SampleReadBeforeProt=2,SampleReadAfterProt=1,SampleWriteAfterProt=1,CpuReadAccess=Enabled,CpuWriteAccess=Enabled,PackArrayToBus=Enabled,DisableSameAddressErr=Enabled,WriteActivityFactor=50,ReadActivityFactor=50,PortErrPropagate=Disabled",
    Comments => "Read and write latency must be equal to DramContextTable",
    ArrayLength => "6",
    ArrayIndex => "1",
    MemLogicalWidth => "300",
    Status1 => { #Structure Type: MemField; ArrayLength: 6; ArrayIndex: 1; ArrayLocationInName: 7;
      Name => "Status[n]",
      RegMem => "MemField",
      Description => "Indicates the status of the connection:
0 - Invalid
1 - Valid (Address not necessarily valid but Error is valid)
2 - SOP/EOP arrived (means that the next SOP/EOP will trigger PD out)",
      Width => "2",
      Position => "1:0", # Excel Formula: =calc_position(F65,E66,TRUE)
      DefaultValue => "h0",
    },
    PacketSize1 => { #Structure Type: MemField; ArrayLength: 6; ArrayIndex: 1; ArrayLocationInName: 11;
      Name => "PacketSize[n]",
      RegMem => "MemField",
      Description => "The total fragment sizes that were written to the SMS.",
      Width => "14",
      Position => "15:2", # Excel Formula: =calc_position(F66,E67)
      DefaultValue => "h0",
    },
    PacketID1 => { #Structure Type: MemField; ArrayLength: 6; ArrayIndex: 1; ArrayLocationInName: 9;
      Name => "PacketID[n]",
      RegMem => "MemField",
      Description => "The address of the SMS buffer that belong to either the 1st or 2nd packet fragment that were written to the SMS.",
      Width => "19",
      Position => "34:16", # Excel Formula: =calc_position(F67,E68)
      DefaultValue => "h0",
    },
    FragmentSeqNum1 => { #Structure Type: MemField; ArrayLength: 6; ArrayIndex: 1; ArrayLocationInName: 15;
      Name => "FragmentSeqNum[n]",
      RegMem => "MemField",
      Description => "Holds the sequence number of the next fragment.",
      Width => "5",
      Position => "39:35", # Excel Formula: =calc_position(F68,E69)
      DefaultValue => "h0",
    },
    PD1 => { #Structure Type: MemField; ArrayLength: 6; ArrayIndex: 1; ArrayLocationInName: 3;
      Name => "PD[n]",
      RegMem => "MemField",
      Description => "Holds the PD fields that should be forwarded to the next unit (width is incoming PD width).",
      Width => "258",
      Position => "297:40", # Excel Formula: =calc_position(F69,E70)
      DefaultValue => "h0",
    },
    Drop1 => { #Structure Type: MemField; ArrayLength: 6; ArrayIndex: 1; ArrayLocationInName: 5;
      Name => "Drop[n]",
      RegMem => "MemField",
      Description => "Indicates the packet had errors and thus should be dropped.
Possible errors are:
1. Packet arrived with bad CRC.
2. One of the packets fragments could not be written to the SMS due to lack of buffers.
3. Oversized packet",
      Width => "1",
      Position => "298", # Excel Formula: =calc_position(F70,E71)
      DefaultValue => "h0",
    },
    CrcError1 => { #Structure Type: MemField; ArrayLength: 6; ArrayIndex: 1; ArrayLocationInName: 9;
      Name => "CrcError[n]",
      RegMem => "MemField",
      Description => "Indicates the packet had CRC error thus the packet data is corrupted.",
      Width => "1",
      Position => "299", # Excel Formula: =calc_position(F71,E72)
      DefaultValue => "h0",
    },
  },
  ContextTable2 => { #Structure Type: Mem; ArrayLength: 6; ArrayIndex: 2; ArrayLocationInName: 13;
    Name => "ContextTable[6]",
    RegMem => "Mem",
    Address => "300000",
    Description => "The Context Table keeps track of the pakcet fragments and combines it to a PD that is sent to the pipe when the packet is received completely.",
    Width => "310", # Excel Formula: =calc_mem_width(E66:E72,M65,F72,-1)
    Type => "Dynamic",
    UsedBy => "DSN",
    MemEntries => "960",
    MemWrapper => "1R1W",
    MemProtect => "ECC",
    AdditionalInfo => "SampleReadAccess=1,SampleReadBeforeProt=2,SampleReadAfterProt=1,SampleWriteAfterProt=1,CpuReadAccess=Enabled,CpuWriteAccess=Enabled,PackArrayToBus=Enabled,DisableSameAddressErr=Enabled,WriteActivityFactor=50,ReadActivityFactor=50,PortErrPropagate=Disabled",
    Comments => "Read and write latency must be equal to DramContextTable",
    ArrayLength => "6",
    ArrayIndex => "2",
    MemLogicalWidth => "300",
    Status2 => { #Structure Type: MemField; ArrayLength: 6; ArrayIndex: 2; ArrayLocationInName: 7;
      Name => "Status[n]",
      RegMem => "MemField",
      Description => "Indicates the status of the connection:
0 - Invalid
1 - Valid (Address not necessarily valid but Error is valid)
2 - SOP/EOP arrived (means that the next SOP/EOP will trigger PD out)",
      Width => "2",
      Position => "1:0", # Excel Formula: =calc_position(F65,E66,TRUE)
      DefaultValue => "h0",
    },
    PacketSize2 => { #Structure Type: MemField; ArrayLength: 6; ArrayIndex: 2; ArrayLocationInName: 11;
      Name => "PacketSize[n]",
      RegMem => "MemField",
      Description => "The total fragment sizes that were written to the SMS.",
      Width => "14",
      Position => "15:2", # Excel Formula: =calc_position(F66,E67)
      DefaultValue => "h0",
    },
    PacketID2 => { #Structure Type: MemField; ArrayLength: 6; ArrayIndex: 2; ArrayLocationInName: 9;
      Name => "PacketID[n]",
      RegMem => "MemField",
      Description => "The address of the SMS buffer that belong to either the 1st or 2nd packet fragment that were written to the SMS.",
      Width => "19",
      Position => "34:16", # Excel Formula: =calc_position(F67,E68)
      DefaultValue => "h0",
    },
    FragmentSeqNum2 => { #Structure Type: MemField; ArrayLength: 6; ArrayIndex: 2; ArrayLocationInName: 15;
      Name => "FragmentSeqNum[n]",
      RegMem => "MemField",
      Description => "Holds the sequence number of the next fragment.",
      Width => "5",
      Position => "39:35", # Excel Formula: =calc_position(F68,E69)
      DefaultValue => "h0",
    },
    PD2 => { #Structure Type: MemField; ArrayLength: 6; ArrayIndex: 2; ArrayLocationInName: 3;
      Name => "PD[n]",
      RegMem => "MemField",
      Description => "Holds the PD fields that should be forwarded to the next unit (width is incoming PD width).",
      Width => "258",
      Position => "297:40", # Excel Formula: =calc_position(F69,E70)
      DefaultValue => "h0",
    },
    Drop2 => { #Structure Type: MemField; ArrayLength: 6; ArrayIndex: 2; ArrayLocationInName: 5;
      Name => "Drop[n]",
      RegMem => "MemField",
      Description => "Indicates the packet had errors and thus should be dropped.
Possible errors are:
1. Packet arrived with bad CRC.
2. One of the packets fragments could not be written to the SMS due to lack of buffers.
3. Oversized packet",
      Width => "1",
      Position => "298", # Excel Formula: =calc_position(F70,E71)
      DefaultValue => "h0",
    },
    CrcError2 => { #Structure Type: MemField; ArrayLength: 6; ArrayIndex: 2; ArrayLocationInName: 9;
      Name => "CrcError[n]",
      RegMem => "MemField",
      Description => "Indicates the packet had CRC error thus the packet data is corrupted.",
      Width => "1",
      Position => "299", # Excel Formula: =calc_position(F71,E72)
      DefaultValue => "h0",
    },
  },
  ContextTable3 => { #Structure Type: Mem; ArrayLength: 6; ArrayIndex: 3; ArrayLocationInName: 13;
    Name => "ContextTable[6]",
    RegMem => "Mem",
    Address => "400000",
    Description => "The Context Table keeps track of the pakcet fragments and combines it to a PD that is sent to the pipe when the packet is received completely.",
    Width => "310", # Excel Formula: =calc_mem_width(E66:E72,M65,F72,-1)
    Type => "Dynamic",
    UsedBy => "DSN",
    MemEntries => "960",
    MemWrapper => "1R1W",
    MemProtect => "ECC",
    AdditionalInfo => "SampleReadAccess=1,SampleReadBeforeProt=2,SampleReadAfterProt=1,SampleWriteAfterProt=1,CpuReadAccess=Enabled,CpuWriteAccess=Enabled,PackArrayToBus=Enabled,DisableSameAddressErr=Enabled,WriteActivityFactor=50,ReadActivityFactor=50,PortErrPropagate=Disabled",
    Comments => "Read and write latency must be equal to DramContextTable",
    ArrayLength => "6",
    ArrayIndex => "3",
    MemLogicalWidth => "300",
    Status3 => { #Structure Type: MemField; ArrayLength: 6; ArrayIndex: 3; ArrayLocationInName: 7;
      Name => "Status[n]",
      RegMem => "MemField",
      Description => "Indicates the status of the connection:
0 - Invalid
1 - Valid (Address not necessarily valid but Error is valid)
2 - SOP/EOP arrived (means that the next SOP/EOP will trigger PD out)",
      Width => "2",
      Position => "1:0", # Excel Formula: =calc_position(F65,E66,TRUE)
      DefaultValue => "h0",
    },
    PacketSize3 => { #Structure Type: MemField; ArrayLength: 6; ArrayIndex: 3; ArrayLocationInName: 11;
      Name => "PacketSize[n]",
      RegMem => "MemField",
      Description => "The total fragment sizes that were written to the SMS.",
      Width => "14",
      Position => "15:2", # Excel Formula: =calc_position(F66,E67)
      DefaultValue => "h0",
    },
    PacketID3 => { #Structure Type: MemField; ArrayLength: 6; ArrayIndex: 3; ArrayLocationInName: 9;
      Name => "PacketID[n]",
      RegMem => "MemField",
      Description => "The address of the SMS buffer that belong to either the 1st or 2nd packet fragment that were written to the SMS.",
      Width => "19",
      Position => "34:16", # Excel Formula: =calc_position(F67,E68)
      DefaultValue => "h0",
    },
    FragmentSeqNum3 => { #Structure Type: MemField; ArrayLength: 6; ArrayIndex: 3; ArrayLocationInName: 15;
      Name => "FragmentSeqNum[n]",
      RegMem => "MemField",
      Description => "Holds the sequence number of the next fragment.",
      Width => "5",
      Position => "39:35", # Excel Formula: =calc_position(F68,E69)
      DefaultValue => "h0",
    },
    PD3 => { #Structure Type: MemField; ArrayLength: 6; ArrayIndex: 3; ArrayLocationInName: 3;
      Name => "PD[n]",
      RegMem => "MemField",
      Description => "Holds the PD fields that should be forwarded to the next unit (width is incoming PD width).",
      Width => "258",
      Position => "297:40", # Excel Formula: =calc_position(F69,E70)
      DefaultValue => "h0",
    },
    Drop3 => { #Structure Type: MemField; ArrayLength: 6; ArrayIndex: 3; ArrayLocationInName: 5;
      Name => "Drop[n]",
      RegMem => "MemField",
      Description => "Indicates the packet had errors and thus should be dropped.
Possible errors are:
1. Packet arrived with bad CRC.
2. One of the packets fragments could not be written to the SMS due to lack of buffers.
3. Oversized packet",
      Width => "1",
      Position => "298", # Excel Formula: =calc_position(F70,E71)
      DefaultValue => "h0",
    },
    CrcError3 => { #Structure Type: MemField; ArrayLength: 6; ArrayIndex: 3; ArrayLocationInName: 9;
      Name => "CrcError[n]",
      RegMem => "MemField",
      Description => "Indicates the packet had CRC error thus the packet data is corrupted.",
      Width => "1",
      Position => "299", # Excel Formula: =calc_position(F71,E72)
      DefaultValue => "h0",
    },
  },
  ContextTable4 => { #Structure Type: Mem; ArrayLength: 6; ArrayIndex: 4; ArrayLocationInName: 13;
    Name => "ContextTable[6]",
    RegMem => "Mem",
    Address => "500000",
    Description => "The Context Table keeps track of the pakcet fragments and combines it to a PD that is sent to the pipe when the packet is received completely.",
    Width => "310", # Excel Formula: =calc_mem_width(E66:E72,M65,F72,-1)
    Type => "Dynamic",
    UsedBy => "DSN",
    MemEntries => "960",
    MemWrapper => "1R1W",
    MemProtect => "ECC",
    AdditionalInfo => "SampleReadAccess=1,SampleReadBeforeProt=2,SampleReadAfterProt=1,SampleWriteAfterProt=1,CpuReadAccess=Enabled,CpuWriteAccess=Enabled,PackArrayToBus=Enabled,DisableSameAddressErr=Enabled,WriteActivityFactor=50,ReadActivityFactor=50,PortErrPropagate=Disabled",
    Comments => "Read and write latency must be equal to DramContextTable",
    ArrayLength => "6",
    ArrayIndex => "4",
    MemLogicalWidth => "300",
    Status4 => { #Structure Type: MemField; ArrayLength: 6; ArrayIndex: 4; ArrayLocationInName: 7;
      Name => "Status[n]",
      RegMem => "MemField",
      Description => "Indicates the status of the connection:
0 - Invalid
1 - Valid (Address not necessarily valid but Error is valid)
2 - SOP/EOP arrived (means that the next SOP/EOP will trigger PD out)",
      Width => "2",
      Position => "1:0", # Excel Formula: =calc_position(F65,E66,TRUE)
      DefaultValue => "h0",
    },
    PacketSize4 => { #Structure Type: MemField; ArrayLength: 6; ArrayIndex: 4; ArrayLocationInName: 11;
      Name => "PacketSize[n]",
      RegMem => "MemField",
      Description => "The total fragment sizes that were written to the SMS.",
      Width => "14",
      Position => "15:2", # Excel Formula: =calc_position(F66,E67)
      DefaultValue => "h0",
    },
    PacketID4 => { #Structure Type: MemField; ArrayLength: 6; ArrayIndex: 4; ArrayLocationInName: 9;
      Name => "PacketID[n]",
      RegMem => "MemField",
      Description => "The address of the SMS buffer that belong to either the 1st or 2nd packet fragment that were written to the SMS.",
      Width => "19",
      Position => "34:16", # Excel Formula: =calc_position(F67,E68)
      DefaultValue => "h0",
    },
    FragmentSeqNum4 => { #Structure Type: MemField; ArrayLength: 6; ArrayIndex: 4; ArrayLocationInName: 15;
      Name => "FragmentSeqNum[n]",
      RegMem => "MemField",
      Description => "Holds the sequence number of the next fragment.",
      Width => "5",
      Position => "39:35", # Excel Formula: =calc_position(F68,E69)
      DefaultValue => "h0",
    },
    PD4 => { #Structure Type: MemField; ArrayLength: 6; ArrayIndex: 4; ArrayLocationInName: 3;
      Name => "PD[n]",
      RegMem => "MemField",
      Description => "Holds the PD fields that should be forwarded to the next unit (width is incoming PD width).",
      Width => "258",
      Position => "297:40", # Excel Formula: =calc_position(F69,E70)
      DefaultValue => "h0",
    },
    Drop4 => { #Structure Type: MemField; ArrayLength: 6; ArrayIndex: 4; ArrayLocationInName: 5;
      Name => "Drop[n]",
      RegMem => "MemField",
      Description => "Indicates the packet had errors and thus should be dropped.
Possible errors are:
1. Packet arrived with bad CRC.
2. One of the packets fragments could not be written to the SMS due to lack of buffers.
3. Oversized packet",
      Width => "1",
      Position => "298", # Excel Formula: =calc_position(F70,E71)
      DefaultValue => "h0",
    },
    CrcError4 => { #Structure Type: MemField; ArrayLength: 6; ArrayIndex: 4; ArrayLocationInName: 9;
      Name => "CrcError[n]",
      RegMem => "MemField",
      Description => "Indicates the packet had CRC error thus the packet data is corrupted.",
      Width => "1",
      Position => "299", # Excel Formula: =calc_position(F71,E72)
      DefaultValue => "h0",
    },
  },
  ContextTable5 => { #Structure Type: Mem; ArrayLength: 6; ArrayIndex: 5; ArrayLocationInName: 13;
    Name => "ContextTable[6]",
    RegMem => "Mem",
    Address => "600000",
    Description => "The Context Table keeps track of the pakcet fragments and combines it to a PD that is sent to the pipe when the packet is received completely.",
    Width => "310", # Excel Formula: =calc_mem_width(E66:E72,M65,F72,-1)
    Type => "Dynamic",
    UsedBy => "DSN",
    MemEntries => "960",
    MemWrapper => "1R1W",
    MemProtect => "ECC",
    AdditionalInfo => "SampleReadAccess=1,SampleReadBeforeProt=2,SampleReadAfterProt=1,SampleWriteAfterProt=1,CpuReadAccess=Enabled,CpuWriteAccess=Enabled,PackArrayToBus=Enabled,DisableSameAddressErr=Enabled,WriteActivityFactor=50,ReadActivityFactor=50,PortErrPropagate=Disabled",
    Comments => "Read and write latency must be equal to DramContextTable",
    ArrayLength => "6",
    ArrayIndex => "5",
    MemLogicalWidth => "300",
    Status5 => { #Structure Type: MemField; ArrayLength: 6; ArrayIndex: 5; ArrayLocationInName: 7;
      Name => "Status[n]",
      RegMem => "MemField",
      Description => "Indicates the status of the connection:
0 - Invalid
1 - Valid (Address not necessarily valid but Error is valid)
2 - SOP/EOP arrived (means that the next SOP/EOP will trigger PD out)",
      Width => "2",
      Position => "1:0", # Excel Formula: =calc_position(F65,E66,TRUE)
      DefaultValue => "h0",
    },
    PacketSize5 => { #Structure Type: MemField; ArrayLength: 6; ArrayIndex: 5; ArrayLocationInName: 11;
      Name => "PacketSize[n]",
      RegMem => "MemField",
      Description => "The total fragment sizes that were written to the SMS.",
      Width => "14",
      Position => "15:2", # Excel Formula: =calc_position(F66,E67)
      DefaultValue => "h0",
    },
    PacketID5 => { #Structure Type: MemField; ArrayLength: 6; ArrayIndex: 5; ArrayLocationInName: 9;
      Name => "PacketID[n]",
      RegMem => "MemField",
      Description => "The address of the SMS buffer that belong to either the 1st or 2nd packet fragment that were written to the SMS.",
      Width => "19",
      Position => "34:16", # Excel Formula: =calc_position(F67,E68)
      DefaultValue => "h0",
    },
    FragmentSeqNum5 => { #Structure Type: MemField; ArrayLength: 6; ArrayIndex: 5; ArrayLocationInName: 15;
      Name => "FragmentSeqNum[n]",
      RegMem => "MemField",
      Description => "Holds the sequence number of the next fragment.",
      Width => "5",
      Position => "39:35", # Excel Formula: =calc_position(F68,E69)
      DefaultValue => "h0",
    },
    PD5 => { #Structure Type: MemField; ArrayLength: 6; ArrayIndex: 5; ArrayLocationInName: 3;
      Name => "PD[n]",
      RegMem => "MemField",
      Description => "Holds the PD fields that should be forwarded to the next unit (width is incoming PD width).",
      Width => "258",
      Position => "297:40", # Excel Formula: =calc_position(F69,E70)
      DefaultValue => "h0",
    },
    Drop5 => { #Structure Type: MemField; ArrayLength: 6; ArrayIndex: 5; ArrayLocationInName: 5;
      Name => "Drop[n]",
      RegMem => "MemField",
      Description => "Indicates the packet had errors and thus should be dropped.
Possible errors are:
1. Packet arrived with bad CRC.
2. One of the packets fragments could not be written to the SMS due to lack of buffers.
3. Oversized packet",
      Width => "1",
      Position => "298", # Excel Formula: =calc_position(F70,E71)
      DefaultValue => "h0",
    },
    CrcError5 => { #Structure Type: MemField; ArrayLength: 6; ArrayIndex: 5; ArrayLocationInName: 9;
      Name => "CrcError[n]",
      RegMem => "MemField",
      Description => "Indicates the packet had CRC error thus the packet data is corrupted.",
      Width => "1",
      Position => "299", # Excel Formula: =calc_position(F71,E72)
      DefaultValue => "h0",
    },
  },
  DramContextTable => { #Structure Type: Mem;
    Name => "DramContextTable",
    RegMem => "Mem",
    Address => "700000", # Excel Formula: =calc_mem_address(C65,A65,G73,L73)
    Description => "Holds a 2 entries for the reassmebly of the DRAM slice",
    Width => "300", # Excel Formula: =calc_mem_width(E74:E74,M73,F74,-1)
    Type => "Dynamic",
    UsedBy => "DSN",
    MemEntries => "2",
    MemWrapper => "1R1W",
    MemProtect => "None",
    AdditionalInfo => "SampleReadAccess=1,SampleReadBeforeProt=2,SampleReadAfterProt=1,SampleWriteAfterProt=1,CpuReadAccess=Enabled,CpuWriteAccess=Enabled,FfBased=Enabled,DisableSameAddressErr=Enabled,PortErrPropagate=Disabled",
    Comments => "Read and write latency must be equal to ContextTable",
    MemLogicalWidth => "300",
    DramContextTableEntry => { #Structure Type: MemField;
      Name => "DramContextTableEntry",
      RegMem => "MemField",
      Description => "The parsing is the same as the ContextTable",
      Width => "300", # Excel Formula: =SUM(E66:E72)
      Position => "299:0", # Excel Formula: =calc_position(F73,E74,TRUE)
      DefaultValue => "h0",
    },
  },
  ContextManager0 => { #Structure Type: Mem; ArrayLength: 6; ArrayIndex: 0; ArrayLocationInName: 15;
    Name => "ContextManager[6]",
    RegMem => "Mem",
    Address => "800000", # Excel Formula: =calc_mem_address(C73,A73,G75,L75)
    Width => "16", # Excel Formula: =calc_mem_width(E76:E76,M75,F76,-1)
    Type => "Dynamic",
    UsedBy => "DSN",
    MemEntries => "60",
    MemWrapper => "1R1W",
    MemProtect => "None",
    AdditionalInfo => "SampleReadAccess=1,SampleReadBeforeProt=1,SampleWriteAfterProt=1,CpuReadAccess=Enabled,CpuWriteAccess=Enabled,PackArrayToBus=Enabled,FfBased=Enabled,PortErrPropagate=Disabled",
    Comments => "Changed to FfBased due to PD request
Read latency must be 3cc
Must have 1 sample on Read/Write access",
    ArrayLength => "6",
    ArrayIndex => "0",
    MemLogicalWidth => "16",
    ContextAvailable0 => { #Structure Type: MemField; ArrayLength: 6; ArrayIndex: 0; ArrayLocationInName: 17;
      Name => "ContextAvailable[n]",
      RegMem => "MemField",
      Description => "A bit per reassembly context number that indicates if it is available for allocation.",
      Width => "16",
      Position => "15:0", # Excel Formula: =calc_position(F75,E76,TRUE)
      DefaultValue => "hFFFF",
    },
  },
  ContextManager1 => { #Structure Type: Mem; ArrayLength: 6; ArrayIndex: 1; ArrayLocationInName: 15;
    Name => "ContextManager[6]",
    RegMem => "Mem",
    Address => "900000",
    Width => "16", # Excel Formula: =calc_mem_width(E76:E76,M75,F76,-1)
    Type => "Dynamic",
    UsedBy => "DSN",
    MemEntries => "60",
    MemWrapper => "1R1W",
    MemProtect => "None",
    AdditionalInfo => "SampleReadAccess=1,SampleReadBeforeProt=1,SampleWriteAfterProt=1,CpuReadAccess=Enabled,CpuWriteAccess=Enabled,PackArrayToBus=Enabled,FfBased=Enabled,PortErrPropagate=Disabled",
    Comments => "Changed to FfBased due to PD request
Read latency must be 3cc
Must have 1 sample on Read/Write access",
    ArrayLength => "6",
    ArrayIndex => "1",
    MemLogicalWidth => "16",
    ContextAvailable1 => { #Structure Type: MemField; ArrayLength: 6; ArrayIndex: 1; ArrayLocationInName: 17;
      Name => "ContextAvailable[n]",
      RegMem => "MemField",
      Description => "A bit per reassembly context number that indicates if it is available for allocation.",
      Width => "16",
      Position => "15:0", # Excel Formula: =calc_position(F75,E76,TRUE)
      DefaultValue => "hFFFF",
    },
  },
  ContextManager2 => { #Structure Type: Mem; ArrayLength: 6; ArrayIndex: 2; ArrayLocationInName: 15;
    Name => "ContextManager[6]",
    RegMem => "Mem",
    Address => "A00000",
    Width => "16", # Excel Formula: =calc_mem_width(E76:E76,M75,F76,-1)
    Type => "Dynamic",
    UsedBy => "DSN",
    MemEntries => "60",
    MemWrapper => "1R1W",
    MemProtect => "None",
    AdditionalInfo => "SampleReadAccess=1,SampleReadBeforeProt=1,SampleWriteAfterProt=1,CpuReadAccess=Enabled,CpuWriteAccess=Enabled,PackArrayToBus=Enabled,FfBased=Enabled,PortErrPropagate=Disabled",
    Comments => "Changed to FfBased due to PD request
Read latency must be 3cc
Must have 1 sample on Read/Write access",
    ArrayLength => "6",
    ArrayIndex => "2",
    MemLogicalWidth => "16",
    ContextAvailable2 => { #Structure Type: MemField; ArrayLength: 6; ArrayIndex: 2; ArrayLocationInName: 17;
      Name => "ContextAvailable[n]",
      RegMem => "MemField",
      Description => "A bit per reassembly context number that indicates if it is available for allocation.",
      Width => "16",
      Position => "15:0", # Excel Formula: =calc_position(F75,E76,TRUE)
      DefaultValue => "hFFFF",
    },
  },
  ContextManager3 => { #Structure Type: Mem; ArrayLength: 6; ArrayIndex: 3; ArrayLocationInName: 15;
    Name => "ContextManager[6]",
    RegMem => "Mem",
    Address => "B00000",
    Width => "16", # Excel Formula: =calc_mem_width(E76:E76,M75,F76,-1)
    Type => "Dynamic",
    UsedBy => "DSN",
    MemEntries => "60",
    MemWrapper => "1R1W",
    MemProtect => "None",
    AdditionalInfo => "SampleReadAccess=1,SampleReadBeforeProt=1,SampleWriteAfterProt=1,CpuReadAccess=Enabled,CpuWriteAccess=Enabled,PackArrayToBus=Enabled,FfBased=Enabled,PortErrPropagate=Disabled",
    Comments => "Changed to FfBased due to PD request
Read latency must be 3cc
Must have 1 sample on Read/Write access",
    ArrayLength => "6",
    ArrayIndex => "3",
    MemLogicalWidth => "16",
    ContextAvailable3 => { #Structure Type: MemField; ArrayLength: 6; ArrayIndex: 3; ArrayLocationInName: 17;
      Name => "ContextAvailable[n]",
      RegMem => "MemField",
      Description => "A bit per reassembly context number that indicates if it is available for allocation.",
      Width => "16",
      Position => "15:0", # Excel Formula: =calc_position(F75,E76,TRUE)
      DefaultValue => "hFFFF",
    },
  },
  ContextManager4 => { #Structure Type: Mem; ArrayLength: 6; ArrayIndex: 4; ArrayLocationInName: 15;
    Name => "ContextManager[6]",
    RegMem => "Mem",
    Address => "C00000",
    Width => "16", # Excel Formula: =calc_mem_width(E76:E76,M75,F76,-1)
    Type => "Dynamic",
    UsedBy => "DSN",
    MemEntries => "60",
    MemWrapper => "1R1W",
    MemProtect => "None",
    AdditionalInfo => "SampleReadAccess=1,SampleReadBeforeProt=1,SampleWriteAfterProt=1,CpuReadAccess=Enabled,CpuWriteAccess=Enabled,PackArrayToBus=Enabled,FfBased=Enabled,PortErrPropagate=Disabled",
    Comments => "Changed to FfBased due to PD request
Read latency must be 3cc
Must have 1 sample on Read/Write access",
    ArrayLength => "6",
    ArrayIndex => "4",
    MemLogicalWidth => "16",
    ContextAvailable4 => { #Structure Type: MemField; ArrayLength: 6; ArrayIndex: 4; ArrayLocationInName: 17;
      Name => "ContextAvailable[n]",
      RegMem => "MemField",
      Description => "A bit per reassembly context number that indicates if it is available for allocation.",
      Width => "16",
      Position => "15:0", # Excel Formula: =calc_position(F75,E76,TRUE)
      DefaultValue => "hFFFF",
    },
  },
  ContextManager5 => { #Structure Type: Mem; ArrayLength: 6; ArrayIndex: 5; ArrayLocationInName: 15;
    Name => "ContextManager[6]",
    RegMem => "Mem",
    Address => "D00000",
    Width => "16", # Excel Formula: =calc_mem_width(E76:E76,M75,F76,-1)
    Type => "Dynamic",
    UsedBy => "DSN",
    MemEntries => "60",
    MemWrapper => "1R1W",
    MemProtect => "None",
    AdditionalInfo => "SampleReadAccess=1,SampleReadBeforeProt=1,SampleWriteAfterProt=1,CpuReadAccess=Enabled,CpuWriteAccess=Enabled,PackArrayToBus=Enabled,FfBased=Enabled,PortErrPropagate=Disabled",
    Comments => "Changed to FfBased due to PD request
Read latency must be 3cc
Must have 1 sample on Read/Write access",
    ArrayLength => "6",
    ArrayIndex => "5",
    MemLogicalWidth => "16",
    ContextAvailable5 => { #Structure Type: MemField; ArrayLength: 6; ArrayIndex: 5; ArrayLocationInName: 17;
      Name => "ContextAvailable[n]",
      RegMem => "MemField",
      Description => "A bit per reassembly context number that indicates if it is available for allocation.",
      Width => "16",
      Position => "15:0", # Excel Formula: =calc_position(F75,E76,TRUE)
      DefaultValue => "hFFFF",
    },
  },
  OutPdFIFO0 => { #Structure Type: Mem; ArrayLength: 6; ArrayIndex: 0; ArrayLocationInName: 10;
    Name => "OutPdFIFO[6]",
    RegMem => "Mem",
    Address => "E00000", # Excel Formula: =calc_mem_address(C75,A75,G77,L77)
    Width => "301", # Excel Formula: =calc_mem_width(E78:E78,M77,F78,-1)
    Type => "Dynamic",
    UsedBy => "DSN",
    MemEntries => "80",
    MemWrapper => "Fifo",
    MemProtect => "ECC",
    AdditionalInfo => "SampleReadAccess=1,SampleReadBeforeProt=1,SampleWriteBeforeProt=1,CpuReadAccess=Enabled,PackArrayToBus=Enabled,WriteActivityFactor=50,ReadActivityFactor=50,PortErrPropagate=Disabled,CpuWriteAccess=Disabled",
    ArrayLength => "6",
    ArrayIndex => "0",
    MemLogicalWidth => "291",
    OutPdFifoData0 => { #Structure Type: MemField; ArrayLength: 6; ArrayIndex: 0; ArrayLocationInName: 14;
      Name => "OutPdFifoData[n]",
      RegMem => "MemField",
      Description => "This FIFO holds the PD that is sent out from the reassembly to the next block.",
      Width => "291",
      Position => "290:0", # Excel Formula: =calc_position(F77,E78,TRUE)
      DefaultValue => "N/A",
    },
  },
  OutPdFIFO1 => { #Structure Type: Mem; ArrayLength: 6; ArrayIndex: 1; ArrayLocationInName: 10;
    Name => "OutPdFIFO[6]",
    RegMem => "Mem",
    Address => "F00000",
    Width => "301", # Excel Formula: =calc_mem_width(E78:E78,M77,F78,-1)
    Type => "Dynamic",
    UsedBy => "DSN",
    MemEntries => "80",
    MemWrapper => "Fifo",
    MemProtect => "ECC",
    AdditionalInfo => "SampleReadAccess=1,SampleReadBeforeProt=1,SampleWriteBeforeProt=1,CpuReadAccess=Enabled,PackArrayToBus=Enabled,WriteActivityFactor=50,ReadActivityFactor=50,PortErrPropagate=Disabled,CpuWriteAccess=Disabled",
    ArrayLength => "6",
    ArrayIndex => "1",
    MemLogicalWidth => "291",
    OutPdFifoData1 => { #Structure Type: MemField; ArrayLength: 6; ArrayIndex: 1; ArrayLocationInName: 14;
      Name => "OutPdFifoData[n]",
      RegMem => "MemField",
      Description => "This FIFO holds the PD that is sent out from the reassembly to the next block.",
      Width => "291",
      Position => "290:0", # Excel Formula: =calc_position(F77,E78,TRUE)
      DefaultValue => "N/A",
    },
  },
  OutPdFIFO2 => { #Structure Type: Mem; ArrayLength: 6; ArrayIndex: 2; ArrayLocationInName: 10;
    Name => "OutPdFIFO[6]",
    RegMem => "Mem",
    Address => "1000000",
    Width => "301", # Excel Formula: =calc_mem_width(E78:E78,M77,F78,-1)
    Type => "Dynamic",
    UsedBy => "DSN",
    MemEntries => "80",
    MemWrapper => "Fifo",
    MemProtect => "ECC",
    AdditionalInfo => "SampleReadAccess=1,SampleReadBeforeProt=1,SampleWriteBeforeProt=1,CpuReadAccess=Enabled,PackArrayToBus=Enabled,WriteActivityFactor=50,ReadActivityFactor=50,PortErrPropagate=Disabled,CpuWriteAccess=Disabled",
    ArrayLength => "6",
    ArrayIndex => "2",
    MemLogicalWidth => "291",
    OutPdFifoData2 => { #Structure Type: MemField; ArrayLength: 6; ArrayIndex: 2; ArrayLocationInName: 14;
      Name => "OutPdFifoData[n]",
      RegMem => "MemField",
      Description => "This FIFO holds the PD that is sent out from the reassembly to the next block.",
      Width => "291",
      Position => "290:0", # Excel Formula: =calc_position(F77,E78,TRUE)
      DefaultValue => "N/A",
    },
  },
  OutPdFIFO3 => { #Structure Type: Mem; ArrayLength: 6; ArrayIndex: 3; ArrayLocationInName: 10;
    Name => "OutPdFIFO[6]",
    RegMem => "Mem",
    Address => "1100000",
    Width => "301", # Excel Formula: =calc_mem_width(E78:E78,M77,F78,-1)
    Type => "Dynamic",
    UsedBy => "DSN",
    MemEntries => "80",
    MemWrapper => "Fifo",
    MemProtect => "ECC",
    AdditionalInfo => "SampleReadAccess=1,SampleReadBeforeProt=1,SampleWriteBeforeProt=1,CpuReadAccess=Enabled,PackArrayToBus=Enabled,WriteActivityFactor=50,ReadActivityFactor=50,PortErrPropagate=Disabled,CpuWriteAccess=Disabled",
    ArrayLength => "6",
    ArrayIndex => "3",
    MemLogicalWidth => "291",
    OutPdFifoData3 => { #Structure Type: MemField; ArrayLength: 6; ArrayIndex: 3; ArrayLocationInName: 14;
      Name => "OutPdFifoData[n]",
      RegMem => "MemField",
      Description => "This FIFO holds the PD that is sent out from the reassembly to the next block.",
      Width => "291",
      Position => "290:0", # Excel Formula: =calc_position(F77,E78,TRUE)
      DefaultValue => "N/A",
    },
  },
  OutPdFIFO4 => { #Structure Type: Mem; ArrayLength: 6; ArrayIndex: 4; ArrayLocationInName: 10;
    Name => "OutPdFIFO[6]",
    RegMem => "Mem",
    Address => "1200000",
    Width => "301", # Excel Formula: =calc_mem_width(E78:E78,M77,F78,-1)
    Type => "Dynamic",
    UsedBy => "DSN",
    MemEntries => "80",
    MemWrapper => "Fifo",
    MemProtect => "ECC",
    AdditionalInfo => "SampleReadAccess=1,SampleReadBeforeProt=1,SampleWriteBeforeProt=1,CpuReadAccess=Enabled,PackArrayToBus=Enabled,WriteActivityFactor=50,ReadActivityFactor=50,PortErrPropagate=Disabled,CpuWriteAccess=Disabled",
    ArrayLength => "6",
    ArrayIndex => "4",
    MemLogicalWidth => "291",
    OutPdFifoData4 => { #Structure Type: MemField; ArrayLength: 6; ArrayIndex: 4; ArrayLocationInName: 14;
      Name => "OutPdFifoData[n]",
      RegMem => "MemField",
      Description => "This FIFO holds the PD that is sent out from the reassembly to the next block.",
      Width => "291",
      Position => "290:0", # Excel Formula: =calc_position(F77,E78,TRUE)
      DefaultValue => "N/A",
    },
  },
  OutPdFIFO5 => { #Structure Type: Mem; ArrayLength: 6; ArrayIndex: 5; ArrayLocationInName: 10;
    Name => "OutPdFIFO[6]",
    RegMem => "Mem",
    Address => "1300000",
    Width => "301", # Excel Formula: =calc_mem_width(E78:E78,M77,F78,-1)
    Type => "Dynamic",
    UsedBy => "DSN",
    MemEntries => "80",
    MemWrapper => "Fifo",
    MemProtect => "ECC",
    AdditionalInfo => "SampleReadAccess=1,SampleReadBeforeProt=1,SampleWriteBeforeProt=1,CpuReadAccess=Enabled,PackArrayToBus=Enabled,WriteActivityFactor=50,ReadActivityFactor=50,PortErrPropagate=Disabled,CpuWriteAccess=Disabled",
    ArrayLength => "6",
    ArrayIndex => "5",
    MemLogicalWidth => "291",
    OutPdFifoData5 => { #Structure Type: MemField; ArrayLength: 6; ArrayIndex: 5; ArrayLocationInName: 14;
      Name => "OutPdFifoData[n]",
      RegMem => "MemField",
      Description => "This FIFO holds the PD that is sent out from the reassembly to the next block.",
      Width => "291",
      Position => "290:0", # Excel Formula: =calc_position(F77,E78,TRUE)
      DefaultValue => "N/A",
    },
  },
  InFifo0 => { #Structure Type: Mem; ArrayLength: 6; ArrayIndex: 0; ArrayLocationInName: 7;
    Name => "InFifo[6]",
    RegMem => "Mem",
    Address => "1400000", # Excel Formula: =calc_mem_address(C77,A77,G79,L79)
    Width => "310", # Excel Formula: =calc_mem_width(E80:E80,M79,F80,-1)
    Type => "Dynamic",
    UsedBy => "DSN",
    MemEntries => "122",
    MemWrapper => "Fifo",
    MemProtect => "ECC",
    AdditionalInfo => "SampleReadAccess=2,SampleReadBeforeProt=2,SampleReadAfterProt=1,SampleWriteBeforeProt=1,SampleWriteAfterProt=1,CpuReadAccess=Enabled,PackArrayToBus=Enabled,WriteActivityFactor=50,ReadActivityFactor=50,PortErrPropagate=Disabled,CpuWriteAccess=Disabled",
    Comments => "Added write samples due to PD request",
    ArrayLength => "6",
    ArrayIndex => "0",
    MemLogicalWidth => "300",
    InFifoData0 => { #Structure Type: MemField; ArrayLength: 6; ArrayIndex: 0; ArrayLocationInName: 11;
      Name => "InFifoData[n]",
      RegMem => "MemField",
      Description => "This FIFO holds the PD and FD that enter the reassembly.",
      Width => "300", # Excel Formula: =SUM(E66:E72)
      Position => "299:0", # Excel Formula: =calc_position(F79,E80,TRUE)
      DefaultValue => "N/A",
    },
  },
  InFifo1 => { #Structure Type: Mem; ArrayLength: 6; ArrayIndex: 1; ArrayLocationInName: 7;
    Name => "InFifo[6]",
    RegMem => "Mem",
    Address => "1500000",
    Width => "310", # Excel Formula: =calc_mem_width(E80:E80,M79,F80,-1)
    Type => "Dynamic",
    UsedBy => "DSN",
    MemEntries => "122",
    MemWrapper => "Fifo",
    MemProtect => "ECC",
    AdditionalInfo => "SampleReadAccess=2,SampleReadBeforeProt=2,SampleReadAfterProt=1,SampleWriteBeforeProt=1,SampleWriteAfterProt=1,CpuReadAccess=Enabled,PackArrayToBus=Enabled,WriteActivityFactor=50,ReadActivityFactor=50,PortErrPropagate=Disabled,CpuWriteAccess=Disabled",
    Comments => "Added write samples due to PD request",
    ArrayLength => "6",
    ArrayIndex => "1",
    MemLogicalWidth => "300",
    InFifoData1 => { #Structure Type: MemField; ArrayLength: 6; ArrayIndex: 1; ArrayLocationInName: 11;
      Name => "InFifoData[n]",
      RegMem => "MemField",
      Description => "This FIFO holds the PD and FD that enter the reassembly.",
      Width => "300", # Excel Formula: =SUM(E66:E72)
      Position => "299:0", # Excel Formula: =calc_position(F79,E80,TRUE)
      DefaultValue => "N/A",
    },
  },
  InFifo2 => { #Structure Type: Mem; ArrayLength: 6; ArrayIndex: 2; ArrayLocationInName: 7;
    Name => "InFifo[6]",
    RegMem => "Mem",
    Address => "1600000",
    Width => "310", # Excel Formula: =calc_mem_width(E80:E80,M79,F80,-1)
    Type => "Dynamic",
    UsedBy => "DSN",
    MemEntries => "122",
    MemWrapper => "Fifo",
    MemProtect => "ECC",
    AdditionalInfo => "SampleReadAccess=2,SampleReadBeforeProt=2,SampleReadAfterProt=1,SampleWriteBeforeProt=1,SampleWriteAfterProt=1,CpuReadAccess=Enabled,PackArrayToBus=Enabled,WriteActivityFactor=50,ReadActivityFactor=50,PortErrPropagate=Disabled,CpuWriteAccess=Disabled",
    Comments => "Added write samples due to PD request",
    ArrayLength => "6",
    ArrayIndex => "2",
    MemLogicalWidth => "300",
    InFifoData2 => { #Structure Type: MemField; ArrayLength: 6; ArrayIndex: 2; ArrayLocationInName: 11;
      Name => "InFifoData[n]",
      RegMem => "MemField",
      Description => "This FIFO holds the PD and FD that enter the reassembly.",
      Width => "300", # Excel Formula: =SUM(E66:E72)
      Position => "299:0", # Excel Formula: =calc_position(F79,E80,TRUE)
      DefaultValue => "N/A",
    },
  },
  InFifo3 => { #Structure Type: Mem; ArrayLength: 6; ArrayIndex: 3; ArrayLocationInName: 7;
    Name => "InFifo[6]",
    RegMem => "Mem",
    Address => "1700000",
    Width => "310", # Excel Formula: =calc_mem_width(E80:E80,M79,F80,-1)
    Type => "Dynamic",
    UsedBy => "DSN",
    MemEntries => "122",
    MemWrapper => "Fifo",
    MemProtect => "ECC",
    AdditionalInfo => "SampleReadAccess=2,SampleReadBeforeProt=2,SampleReadAfterProt=1,SampleWriteBeforeProt=1,SampleWriteAfterProt=1,CpuReadAccess=Enabled,PackArrayToBus=Enabled,WriteActivityFactor=50,ReadActivityFactor=50,PortErrPropagate=Disabled,CpuWriteAccess=Disabled",
    Comments => "Added write samples due to PD request",
    ArrayLength => "6",
    ArrayIndex => "3",
    MemLogicalWidth => "300",
    InFifoData3 => { #Structure Type: MemField; ArrayLength: 6; ArrayIndex: 3; ArrayLocationInName: 11;
      Name => "InFifoData[n]",
      RegMem => "MemField",
      Description => "This FIFO holds the PD and FD that enter the reassembly.",
      Width => "300", # Excel Formula: =SUM(E66:E72)
      Position => "299:0", # Excel Formula: =calc_position(F79,E80,TRUE)
      DefaultValue => "N/A",
    },
  },
  InFifo4 => { #Structure Type: Mem; ArrayLength: 6; ArrayIndex: 4; ArrayLocationInName: 7;
    Name => "InFifo[6]",
    RegMem => "Mem",
    Address => "1800000",
    Width => "310", # Excel Formula: =calc_mem_width(E80:E80,M79,F80,-1)
    Type => "Dynamic",
    UsedBy => "DSN",
    MemEntries => "122",
    MemWrapper => "Fifo",
    MemProtect => "ECC",
    AdditionalInfo => "SampleReadAccess=2,SampleReadBeforeProt=2,SampleReadAfterProt=1,SampleWriteBeforeProt=1,SampleWriteAfterProt=1,CpuReadAccess=Enabled,PackArrayToBus=Enabled,WriteActivityFactor=50,ReadActivityFactor=50,PortErrPropagate=Disabled,CpuWriteAccess=Disabled",
    Comments => "Added write samples due to PD request",
    ArrayLength => "6",
    ArrayIndex => "4",
    MemLogicalWidth => "300",
    InFifoData4 => { #Structure Type: MemField; ArrayLength: 6; ArrayIndex: 4; ArrayLocationInName: 11;
      Name => "InFifoData[n]",
      RegMem => "MemField",
      Description => "This FIFO holds the PD and FD that enter the reassembly.",
      Width => "300", # Excel Formula: =SUM(E66:E72)
      Position => "299:0", # Excel Formula: =calc_position(F79,E80,TRUE)
      DefaultValue => "N/A",
    },
  },
  InFifo5 => { #Structure Type: Mem; ArrayLength: 6; ArrayIndex: 5; ArrayLocationInName: 7;
    Name => "InFifo[6]",
    RegMem => "Mem",
    Address => "1900000",
    Width => "310", # Excel Formula: =calc_mem_width(E80:E80,M79,F80,-1)
    Type => "Dynamic",
    UsedBy => "DSN",
    MemEntries => "122",
    MemWrapper => "Fifo",
    MemProtect => "ECC",
    AdditionalInfo => "SampleReadAccess=2,SampleReadBeforeProt=2,SampleReadAfterProt=1,SampleWriteBeforeProt=1,SampleWriteAfterProt=1,CpuReadAccess=Enabled,PackArrayToBus=Enabled,WriteActivityFactor=50,ReadActivityFactor=50,PortErrPropagate=Disabled,CpuWriteAccess=Disabled",
    Comments => "Added write samples due to PD request",
    ArrayLength => "6",
    ArrayIndex => "5",
    MemLogicalWidth => "300",
    InFifoData5 => { #Structure Type: MemField; ArrayLength: 6; ArrayIndex: 5; ArrayLocationInName: 11;
      Name => "InFifoData[n]",
      RegMem => "MemField",
      Description => "This FIFO holds the PD and FD that enter the reassembly.",
      Width => "300", # Excel Formula: =SUM(E66:E72)
      Position => "299:0", # Excel Formula: =calc_position(F79,E80,TRUE)
      DefaultValue => "N/A",
    },
  },
  SourcePortMapTable0 => { #Structure Type: Mem; ArrayLength: 6; ArrayIndex: 0; ArrayLocationInName: 19;
    Name => "SourcePortMapTable[6]",
    RegMem => "Mem",
    Address => "1A00000", # Excel Formula: =calc_mem_address(C79,A79,G81,L81)
    Description => "Table per slice",
    Width => "6", # Excel Formula: =calc_mem_width(E82:E82,M81,F82,-1)
    Type => "Config",
    UsedBy => "DSN",
    MemEntries => "64",
    MemWrapper => "RegArray",
    MemProtect => "None",
    AdditionalInfo => "CpuReadAccess=Enabled,CpuWriteAccess=Enabled,PackArrayToBus=Enabled,WriteActivityFactor=0,ReadActivityFactor=0,PortErrPropagate=Disabled",
    InstanceAllocation => "per_slice",
    ArrayLength => "6",
    ArrayIndex => "0",
    MemLogicalWidth => "6",
    SourcePortMap0 => { #Structure Type: MemField; ArrayLength: 6; ArrayIndex: 0; ArrayLocationInName: 14;
      Name => "SourcePortMap[n]",
      RegMem => "MemField",
      Description => "The table contains the mapped port number that will be set in the OutPD<SourceIf[7:2]> that is sent from the reassembly to the next block.
The table is accessed according to InPD<SourceIf[7:2]>.",
      Width => "6",
      Position => "5:0", # Excel Formula: =calc_position(F81,E82,TRUE)
      DefaultValue => "N/A",
      InitValueAllModes => "(slice == 1 || slice == 2 || slice == 5)  & (line < 32)  ? `NUM_OF_PORTS_IN_IFG + line : (slice == 1 || slice == 2 || slice == 5) ? line - 32 : (line < 32) ?  line :  `NUM_OF_PORTS_IN_IFG + (line-32)",
    },
  },
  SourcePortMapTable1 => { #Structure Type: Mem; ArrayLength: 6; ArrayIndex: 1; ArrayLocationInName: 19;
    Name => "SourcePortMapTable[6]",
    RegMem => "Mem",
    Address => "1B00000",
    Description => "Table per slice",
    Width => "6", # Excel Formula: =calc_mem_width(E82:E82,M81,F82,-1)
    Type => "Config",
    UsedBy => "DSN",
    MemEntries => "64",
    MemWrapper => "RegArray",
    MemProtect => "None",
    AdditionalInfo => "CpuReadAccess=Enabled,CpuWriteAccess=Enabled,PackArrayToBus=Enabled,WriteActivityFactor=0,ReadActivityFactor=0,PortErrPropagate=Disabled",
    InstanceAllocation => "per_slice",
    ArrayLength => "6",
    ArrayIndex => "1",
    MemLogicalWidth => "6",
    SourcePortMap1 => { #Structure Type: MemField; ArrayLength: 6; ArrayIndex: 1; ArrayLocationInName: 14;
      Name => "SourcePortMap[n]",
      RegMem => "MemField",
      Description => "The table contains the mapped port number that will be set in the OutPD<SourceIf[7:2]> that is sent from the reassembly to the next block.
The table is accessed according to InPD<SourceIf[7:2]>.",
      Width => "6",
      Position => "5:0", # Excel Formula: =calc_position(F81,E82,TRUE)
      DefaultValue => "N/A",
      InitValueAllModes => "(slice == 1 || slice == 2 || slice == 5)  & (line < 32)  ? `NUM_OF_PORTS_IN_IFG + line : (slice == 1 || slice == 2 || slice == 5) ? line - 32 : (line < 32) ?  line :  `NUM_OF_PORTS_IN_IFG + (line-32)",
    },
  },
  SourcePortMapTable2 => { #Structure Type: Mem; ArrayLength: 6; ArrayIndex: 2; ArrayLocationInName: 19;
    Name => "SourcePortMapTable[6]",
    RegMem => "Mem",
    Address => "1C00000",
    Description => "Table per slice",
    Width => "6", # Excel Formula: =calc_mem_width(E82:E82,M81,F82,-1)
    Type => "Config",
    UsedBy => "DSN",
    MemEntries => "64",
    MemWrapper => "RegArray",
    MemProtect => "None",
    AdditionalInfo => "CpuReadAccess=Enabled,CpuWriteAccess=Enabled,PackArrayToBus=Enabled,WriteActivityFactor=0,ReadActivityFactor=0,PortErrPropagate=Disabled",
    InstanceAllocation => "per_slice",
    ArrayLength => "6",
    ArrayIndex => "2",
    MemLogicalWidth => "6",
    SourcePortMap2 => { #Structure Type: MemField; ArrayLength: 6; ArrayIndex: 2; ArrayLocationInName: 14;
      Name => "SourcePortMap[n]",
      RegMem => "MemField",
      Description => "The table contains the mapped port number that will be set in the OutPD<SourceIf[7:2]> that is sent from the reassembly to the next block.
The table is accessed according to InPD<SourceIf[7:2]>.",
      Width => "6",
      Position => "5:0", # Excel Formula: =calc_position(F81,E82,TRUE)
      DefaultValue => "N/A",
      InitValueAllModes => "(slice == 1 || slice == 2 || slice == 5)  & (line < 32)  ? `NUM_OF_PORTS_IN_IFG + line : (slice == 1 || slice == 2 || slice == 5) ? line - 32 : (line < 32) ?  line :  `NUM_OF_PORTS_IN_IFG + (line-32)",
    },
  },
  SourcePortMapTable3 => { #Structure Type: Mem; ArrayLength: 6; ArrayIndex: 3; ArrayLocationInName: 19;
    Name => "SourcePortMapTable[6]",
    RegMem => "Mem",
    Address => "1D00000",
    Description => "Table per slice",
    Width => "6", # Excel Formula: =calc_mem_width(E82:E82,M81,F82,-1)
    Type => "Config",
    UsedBy => "DSN",
    MemEntries => "64",
    MemWrapper => "RegArray",
    MemProtect => "None",
    AdditionalInfo => "CpuReadAccess=Enabled,CpuWriteAccess=Enabled,PackArrayToBus=Enabled,WriteActivityFactor=0,ReadActivityFactor=0,PortErrPropagate=Disabled",
    InstanceAllocation => "per_slice",
    ArrayLength => "6",
    ArrayIndex => "3",
    MemLogicalWidth => "6",
    SourcePortMap3 => { #Structure Type: MemField; ArrayLength: 6; ArrayIndex: 3; ArrayLocationInName: 14;
      Name => "SourcePortMap[n]",
      RegMem => "MemField",
      Description => "The table contains the mapped port number that will be set in the OutPD<SourceIf[7:2]> that is sent from the reassembly to the next block.
The table is accessed according to InPD<SourceIf[7:2]>.",
      Width => "6",
      Position => "5:0", # Excel Formula: =calc_position(F81,E82,TRUE)
      DefaultValue => "N/A",
      InitValueAllModes => "(slice == 1 || slice == 2 || slice == 5)  & (line < 32)  ? `NUM_OF_PORTS_IN_IFG + line : (slice == 1 || slice == 2 || slice == 5) ? line - 32 : (line < 32) ?  line :  `NUM_OF_PORTS_IN_IFG + (line-32)",
    },
  },
  SourcePortMapTable4 => { #Structure Type: Mem; ArrayLength: 6; ArrayIndex: 4; ArrayLocationInName: 19;
    Name => "SourcePortMapTable[6]",
    RegMem => "Mem",
    Address => "1E00000",
    Description => "Table per slice",
    Width => "6", # Excel Formula: =calc_mem_width(E82:E82,M81,F82,-1)
    Type => "Config",
    UsedBy => "DSN",
    MemEntries => "64",
    MemWrapper => "RegArray",
    MemProtect => "None",
    AdditionalInfo => "CpuReadAccess=Enabled,CpuWriteAccess=Enabled,PackArrayToBus=Enabled,WriteActivityFactor=0,ReadActivityFactor=0,PortErrPropagate=Disabled",
    InstanceAllocation => "per_slice",
    ArrayLength => "6",
    ArrayIndex => "4",
    MemLogicalWidth => "6",
    SourcePortMap4 => { #Structure Type: MemField; ArrayLength: 6; ArrayIndex: 4; ArrayLocationInName: 14;
      Name => "SourcePortMap[n]",
      RegMem => "MemField",
      Description => "The table contains the mapped port number that will be set in the OutPD<SourceIf[7:2]> that is sent from the reassembly to the next block.
The table is accessed according to InPD<SourceIf[7:2]>.",
      Width => "6",
      Position => "5:0", # Excel Formula: =calc_position(F81,E82,TRUE)
      DefaultValue => "N/A",
      InitValueAllModes => "(slice == 1 || slice == 2 || slice == 5)  & (line < 32)  ? `NUM_OF_PORTS_IN_IFG + line : (slice == 1 || slice == 2 || slice == 5) ? line - 32 : (line < 32) ?  line :  `NUM_OF_PORTS_IN_IFG + (line-32)",
    },
  },
  SourcePortMapTable5 => { #Structure Type: Mem; ArrayLength: 6; ArrayIndex: 5; ArrayLocationInName: 19;
    Name => "SourcePortMapTable[6]",
    RegMem => "Mem",
    Address => "1F00000",
    Description => "Table per slice",
    Width => "6", # Excel Formula: =calc_mem_width(E82:E82,M81,F82,-1)
    Type => "Config",
    UsedBy => "DSN",
    MemEntries => "64",
    MemWrapper => "RegArray",
    MemProtect => "None",
    AdditionalInfo => "CpuReadAccess=Enabled,CpuWriteAccess=Enabled,PackArrayToBus=Enabled,WriteActivityFactor=0,ReadActivityFactor=0,PortErrPropagate=Disabled",
    InstanceAllocation => "per_slice",
    ArrayLength => "6",
    ArrayIndex => "5",
    MemLogicalWidth => "6",
    SourcePortMap5 => { #Structure Type: MemField; ArrayLength: 6; ArrayIndex: 5; ArrayLocationInName: 14;
      Name => "SourcePortMap[n]",
      RegMem => "MemField",
      Description => "The table contains the mapped port number that will be set in the OutPD<SourceIf[7:2]> that is sent from the reassembly to the next block.
The table is accessed according to InPD<SourceIf[7:2]>.",
      Width => "6",
      Position => "5:0", # Excel Formula: =calc_position(F81,E82,TRUE)
      DefaultValue => "N/A",
      InitValueAllModes => "(slice == 1 || slice == 2 || slice == 5)  & (line < 32)  ? `NUM_OF_PORTS_IN_IFG + line : (slice == 1 || slice == 2 || slice == 5) ? line - 32 : (line < 32) ?  line :  `NUM_OF_PORTS_IN_IFG + (line-32)",
    },
  },
  DebugPdFieldValueCfg => { #Structure Type: Mem;
    Name => "DebugPdFieldValueCfg",
    RegMem => "Mem",
    Address => "2000000", # Excel Formula: =calc_mem_address(C81,A81,G83,L83)
    Width => "291", # Excel Formula: =calc_mem_width(E84:E84,M83,F84,-1)
    Type => "Config",
    UsedBy => "DSN",
    MemEntries => "1",
    MemWrapper => "RegArray",
    MemProtect => "None",
    AdditionalInfo => "CpuReadAccess=Enabled,CpuWriteAccess=Enabled,WriteActivityFactor=0,ReadActivityFactor=0,PortErrPropagate=Disabled",
    MemLogicalWidth => "291",
    DebugPdFieldValue => { #Structure Type: MemField;
      Name => "DebugPdFieldValue",
      RegMem => "MemField",
      Description => "This field is the outgoing PD value that when combined with the DebugPdFieldMaskCfg and matches the outgoing PD will trigger counting in DebugPdFieldCnt and halting the traffic if enabled by DebugPdHaltTraficOnMatch.
The width of this field equals the outgoing PD width.
",
      Width => "291",
      Position => "290:0", # Excel Formula: =calc_position(F83,E84,TRUE)
      DefaultValue => "N/A",
      Comments => "For Physical Design - Should have multicycle from on this configuration",
      InitValueAllModes => "1 << 11",
    },
  },
  DebugPdFieldMaskCfg => { #Structure Type: Mem;
    Name => "DebugPdFieldMaskCfg",
    RegMem => "Mem",
    Address => "2100000", # Excel Formula: =calc_mem_address(C83,A83,G85,L85)
    Width => "291", # Excel Formula: =calc_mem_width(E86:E86,M85,F86,-1)
    Type => "Config",
    UsedBy => "DSN",
    MemEntries => "1",
    MemWrapper => "RegArray",
    MemProtect => "None",
    AdditionalInfo => "CpuReadAccess=Enabled,CpuWriteAccess=Enabled,WriteActivityFactor=0,ReadActivityFactor=0,PortErrPropagate=Disabled",
    MemLogicalWidth => "291",
    DebugPdFieldMask => { #Structure Type: MemField;
      Name => "DebugPdFieldMask",
      RegMem => "MemField",
      Description => "This field is the outgoing PD mask that when combined with the DebugPdFieldValue and matches the outgoing PD will trigger counting in DebugPdFieldCnt and halting the traffic if enabled by DebugPdHaltTraficOnMatch.
The width of this field equals the outgoing PD width.
",
      Width => "291",
      Position => "290:0", # Excel Formula: =calc_position(F85,E86,TRUE)
      DefaultValue => "N/A",
      Comments => "For Physical Design - Should have multicycle from on this configuration",
      InitValueAllModes => "1 << 11",
    },
  },
  DramInFifo => { #Structure Type: Mem;
    Name => "DramInFifo",
    RegMem => "Mem",
    Address => "2200000", # Excel Formula: =calc_mem_address(C85,A85,G87,L87)
    Width => "141", # Excel Formula: =calc_mem_width(E88:E88,M87,F88,-1)
    Type => "Dynamic",
    UsedBy => "DSN",
    MemEntries => "122",
    MemWrapper => "Fifo",
    MemProtect => "ECC",
    AdditionalInfo => "SampleReadAccess=2,SampleReadBeforeProt=2,SampleReadAfterProt=1,SampleWriteBeforeProt=1,SampleWriteAfterProt=1,CpuReadAccess=Enabled,WriteActivityFactor=50,ReadActivityFactor=50,PortErrPropagate=Disabled,CpuWriteAccess=Disabled",
    Comments => "Added write samples due to PD request",
    MemLogicalWidth => "132",
    DramInFifoData => { #Structure Type: MemField;
      Name => "DramInFifoData",
      RegMem => "MemField",
      Description => "In FIFO holds the incoming PD and FD of the DRAM slice",
      Width => "132",
      Position => "131:0", # Excel Formula: =calc_position(F87,E88,TRUE)
      DefaultValue => "N/A",
    },
  },
  DramOutPdFIFO => { #Structure Type: Mem;
    Name => "DramOutPdFIFO",
    RegMem => "Mem",
    Address => "2300000", # Excel Formula: =calc_mem_address(C87,A87,G89,L89)
    Width => "146", # Excel Formula: =calc_mem_width(E90:E90,M89,F90,-1)
    Type => "Dynamic",
    UsedBy => "DSN",
    MemEntries => "80",
    MemWrapper => "Fifo",
    MemProtect => "ECC",
    AdditionalInfo => "SampleReadAccess=1,SampleReadBeforeProt=1,SampleWriteBeforeProt=1,CpuReadAccess=Enabled,WriteActivityFactor=50,ReadActivityFactor=50,PortErrPropagate=Disabled,CpuWriteAccess=Disabled",
    MemLogicalWidth => "137",
    DramOutPdFifoData => { #Structure Type: MemField;
      Name => "DramOutPdFifoData",
      RegMem => "MemField",
      Description => "Out PD fifo of the DRAM slice",
      Width => "137",
      Position => "136:0", # Excel Formula: =calc_position(F89,E90,TRUE)
      DefaultValue => "N/A",
    },
  },
  SlbBuffHistogramCfg => { #Structure Type: Reg; Skip Register;
    Name => "SlbBuffHistogramCfg",
    RegMem => "Reg",
    Address => "132", # Excel Formula: =calc_reg_address(C60,A60,G60)
    Description => "Histogram configurations register, see fields description",
    Width => "143", # Excel Formula: =calc_reg_width(E92:E99,F99)
    Type => "Config",
    Comments => "EM Skip Reg",
    SlbBuffHistogramTh0 => { #Structure Type: RegField;
      Name => "SlbBuffHistogramTh0",
      RegMem => "RegField",
      Description => "Thresholds for bin detection. If compared value <= SlbBuffHistogramTh0, bin 0 is incremented",
      Width => "19",
      Position => "18:0", # Excel Formula: =calc_position(F91,E92,TRUE)
      Type => "Config",
      UsedBy => "CIF",
      DefaultValue => "d0",
    },
    SlbBuffHistogramTh1 => { #Structure Type: RegField;
      Name => "SlbBuffHistogramTh1",
      RegMem => "RegField",
      Description => "Thresholds for bin detection. If compared value <= SlbBuffHistogramTh1, bin 1 is incremented",
      Width => "19",
      Position => "37:19", # Excel Formula: =calc_position(F92,E93)
      Type => "Config",
      UsedBy => "CIF",
      DefaultValue => "d0",
    },
    SlbBuffHistogramTh2 => { #Structure Type: RegField;
      Name => "SlbBuffHistogramTh2",
      RegMem => "RegField",
      Description => "Thresholds for bin detection. If compared value <= SlbBuffHistogramTh2, bin 2 is incremented",
      Width => "19",
      Position => "56:38", # Excel Formula: =calc_position(F93,E94)
      Type => "Config",
      UsedBy => "CIF",
      DefaultValue => "d0",
    },
    SlbBuffHistogramTh3 => { #Structure Type: RegField;
      Name => "SlbBuffHistogramTh3",
      RegMem => "RegField",
      Description => "Thresholds for bin detection. If compared value <= SlbBuffHistogramTh3, bin 3 is incremented",
      Width => "19",
      Position => "75:57", # Excel Formula: =calc_position(F94,E95)
      Type => "Config",
      UsedBy => "CIF",
      DefaultValue => "d0",
    },
    SlbBuffHistogramTh4 => { #Structure Type: RegField;
      Name => "SlbBuffHistogramTh4",
      RegMem => "RegField",
      Description => "Thresholds for bin detection. If compared value <= SlbBuffHistogramTh4, bin 4 is incremented",
      Width => "19",
      Position => "94:76", # Excel Formula: =calc_position(F95,E96)
      Type => "Config",
      UsedBy => "CIF",
      DefaultValue => "d0",
    },
    SlbBuffHistogramTh5 => { #Structure Type: RegField;
      Name => "SlbBuffHistogramTh5",
      RegMem => "RegField",
      Description => "Thresholds for bin detection. If compared value <= SlbBuffHistogramTh5, bin 5 is incremented",
      Width => "19",
      Position => "113:95", # Excel Formula: =calc_position(F96,E97)
      Type => "Config",
      UsedBy => "CIF",
      DefaultValue => "d0",
    },
    SlbBuffHistogramTh6 => { #Structure Type: RegField;
      Name => "SlbBuffHistogramTh6",
      RegMem => "RegField",
      Description => "Thresholds for bin detection. If compared value <= SlbBuffHistogramTh6, bin 6 is incremented",
      Width => "19",
      Position => "132:114", # Excel Formula: =calc_position(F97,E98)
      Type => "Config",
      UsedBy => "CIF",
      DefaultValue => "d0",
    },
    SlbBuffHistogramTimeInterval => { #Structure Type: RegField;
      Name => "SlbBuffHistogramTimeInterval",
      RegMem => "RegField",
      Description => "Number of clocks between histogram sample events",
      Width => "10",
      Position => "142:133", # Excel Formula: =calc_position(F98,E99)
      Type => "Config",
      UsedBy => "CIF",
      DefaultValue => "d0",
    },
  },
  SlbBuffHistogramStatus => { #Structure Type: Reg; Skip Register;
    Name => "SlbBuffHistogramStatus",
    RegMem => "Reg",
    Address => "133", # Excel Formula: =calc_reg_address(C91,A91,G91)
    Description => "Histogram status register, see fields description",
    Width => "264", # Excel Formula: =calc_reg_width(E101:E116,F116)
    Type => "ReadOnly",
    AdditionalInfo => "MirrorReadAccess",
    Comments => "EM Skip Reg",
    SlbBuffHistogramValue0 => { #Structure Type: RegField;
      Name => "SlbBuffHistogramValue0",
      RegMem => "RegField",
      Description => "Bin value",
      Width => "32",
      Position => "31:0", # Excel Formula: =calc_position(F100,E101,TRUE)
      Type => "Status",
      UsedBy => "CIF",
    },
    SlbBuffHistogramOverflow0 => { #Structure Type: RegField;
      Name => "SlbBuffHistogramOverflow0",
      RegMem => "RegField",
      Description => "Bin overflow indication",
      Width => "1",
      Position => "32", # Excel Formula: =calc_position(F101,E102)
      Type => "Status",
      UsedBy => "CIF",
    },
    SlbBuffHistogramValue1 => { #Structure Type: RegField;
      Name => "SlbBuffHistogramValue1",
      RegMem => "RegField",
      Description => "Bin value",
      Width => "32",
      Position => "64:33", # Excel Formula: =calc_position(F102,E103)
      Type => "Status",
      UsedBy => "CIF",
    },
    SlbBuffHistogramOverflow1 => { #Structure Type: RegField;
      Name => "SlbBuffHistogramOverflow1",
      RegMem => "RegField",
      Description => "Bin overflow indication",
      Width => "1",
      Position => "65", # Excel Formula: =calc_position(F103,E104)
      Type => "Status",
      UsedBy => "CIF",
    },
    SlbBuffHistogramValue2 => { #Structure Type: RegField;
      Name => "SlbBuffHistogramValue2",
      RegMem => "RegField",
      Description => "Bin value",
      Width => "32",
      Position => "97:66", # Excel Formula: =calc_position(F104,E105)
      Type => "Status",
      UsedBy => "CIF",
    },
    SlbBuffHistogramOverflow2 => { #Structure Type: RegField;
      Name => "SlbBuffHistogramOverflow2",
      RegMem => "RegField",
      Description => "Bin overflow indication",
      Width => "1",
      Position => "98", # Excel Formula: =calc_position(F105,E106)
      Type => "Status",
      UsedBy => "CIF",
    },
    SlbBuffHistogramValue3 => { #Structure Type: RegField;
      Name => "SlbBuffHistogramValue3",
      RegMem => "RegField",
      Description => "Bin value",
      Width => "32",
      Position => "130:99", # Excel Formula: =calc_position(F106,E107)
      Type => "Status",
      UsedBy => "CIF",
    },
    SlbBuffHistogramOverflow3 => { #Structure Type: RegField;
      Name => "SlbBuffHistogramOverflow3",
      RegMem => "RegField",
      Description => "Bin overflow indication",
      Width => "1",
      Position => "131", # Excel Formula: =calc_position(F107,E108)
      Type => "Status",
      UsedBy => "CIF",
    },
    SlbBuffHistogramValue4 => { #Structure Type: RegField;
      Name => "SlbBuffHistogramValue4",
      RegMem => "RegField",
      Description => "Bin value",
      Width => "32",
      Position => "163:132", # Excel Formula: =calc_position(F108,E109)
      Type => "Status",
      UsedBy => "CIF",
    },
    SlbBuffHistogramOverflow4 => { #Structure Type: RegField;
      Name => "SlbBuffHistogramOverflow4",
      RegMem => "RegField",
      Description => "Bin overflow indication",
      Width => "1",
      Position => "164", # Excel Formula: =calc_position(F109,E110)
      Type => "Status",
      UsedBy => "CIF",
    },
    SlbBuffHistogramValue5 => { #Structure Type: RegField;
      Name => "SlbBuffHistogramValue5",
      RegMem => "RegField",
      Description => "Bin value",
      Width => "32",
      Position => "196:165", # Excel Formula: =calc_position(F110,E111)
      Type => "Status",
      UsedBy => "CIF",
    },
    SlbBuffHistogramOverflow5 => { #Structure Type: RegField;
      Name => "SlbBuffHistogramOverflow5",
      RegMem => "RegField",
      Description => "Bin overflow indication",
      Width => "1",
      Position => "197", # Excel Formula: =calc_position(F111,E112)
      Type => "Status",
      UsedBy => "CIF",
    },
    SlbBuffHistogramValue6 => { #Structure Type: RegField;
      Name => "SlbBuffHistogramValue6",
      RegMem => "RegField",
      Description => "Bin value",
      Width => "32",
      Position => "229:198", # Excel Formula: =calc_position(F112,E113)
      Type => "Status",
      UsedBy => "CIF",
    },
    SlbBuffHistogramOverflow6 => { #Structure Type: RegField;
      Name => "SlbBuffHistogramOverflow6",
      RegMem => "RegField",
      Description => "Bin overflow indication",
      Width => "1",
      Position => "230", # Excel Formula: =calc_position(F113,E114)
      Type => "Status",
      UsedBy => "CIF",
    },
    SlbBuffHistogramValue7 => { #Structure Type: RegField;
      Name => "SlbBuffHistogramValue7",
      RegMem => "RegField",
      Description => "Bin value",
      Width => "32",
      Position => "262:231", # Excel Formula: =calc_position(F114,E115)
      Type => "Status",
      UsedBy => "CIF",
    },
    SlbBuffHistogramOverflow7 => { #Structure Type: RegField;
      Name => "SlbBuffHistogramOverflow7",
      RegMem => "RegField",
      Description => "Bin overflow indication",
      Width => "1",
      Position => "263", # Excel Formula: =calc_position(F115,E116)
      Type => "Status",
      UsedBy => "CIF",
    },
  },
  SlbBuffHistogramMaxWmkReg => { #Structure Type: Reg; Skip Register;
    Name => "SlbBuffHistogramMaxWmkReg",
    RegMem => "Reg",
    Address => "134", # Excel Formula: =calc_reg_address(C100,A100,G100)
    Description => "Histogram max watermark register, see fields description",
    Width => "51", # Excel Formula: =calc_reg_width(E118:E119,F119)
    Type => "ReadOnly",
    Comments => "EM Skip Reg",
    SlbBuffHistogramMaxWmk => { #Structure Type: RegField;
      Name => "SlbBuffHistogramMaxWmk",
      RegMem => "RegField",
      Description => "Histogram max watermark",
      Width => "19",
      Position => "18:0", # Excel Formula: =calc_position(F117,E118,TRUE)
      Type => "MaxWmk",
      UsedBy => "CIF",
    },
    SlbBuffHistogramMaxWmkTime => { #Structure Type: RegField;
      Name => "SlbBuffHistogramMaxWmkTime",
      RegMem => "RegField",
      Description => "Time of last max watermark update",
      Width => "32",
      Position => "50:19", # Excel Formula: =calc_position(F118,E119)
      Type => "Capture",
      UsedBy => "CIF",
    },
  },
};
