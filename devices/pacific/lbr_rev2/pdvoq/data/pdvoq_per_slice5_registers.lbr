$block{PDVOQ_SLICE5} = {
  Defines_db => "..\\verilog\\pdvoq_defines.v,..\\..\\defines\\pd_fd_defines.v,..\\..\\defines\\control_common_defines.v,..\\..\\voq_cgm\\verilog\\voq_cgm_defines.v",
  ProjectName => "Pacific",
  InterruptRegister => { #Structure Type: Reg; Skip Register;
    Name => "InterruptRegister",
    RegMem => "Reg",
    Address => "0",
    Description => "Master Interrupt Register",
    Width => "2",
    Type => "Interrupt",
    MemProtectInterruptSummary => { #Structure Type: RegField;
      Name => "MemProtectInterruptSummary",
      RegMem => "RegField",
      Description => "When this bit is set, MemProtectInterrupt has asserted interrupt",
      Width => "1",
      Position => "0",
      Type => "Interrupt",
    },
    GeneralInterruptRegisterSummary => { #Structure Type: RegField;
      Name => "GeneralInterruptRegisterSummary",
      RegMem => "RegField",
      Description => "When this bit is set, GeneralInterruptRegister has asserted interrupt",
      Width => "1",
      Position => "1",
      Type => "Interrupt",
    },
  },
  MemProtectInterrupt => { #Structure Type: Reg; Skip Register;
    Name => "MemProtectInterrupt",
    RegMem => "Reg",
    Address => "1",
    Description => "ECC/Parity Interrupt Register",
    Width => "3",
    Type => "Interrupt",
    Ecc_1bErrInterrupt => { #Structure Type: RegField;
      Name => "Ecc_1bErrInterrupt",
      RegMem => "RegField",
      Description => "When this bit is set, ECC 1b error was detected",
      Width => "1",
      Position => "0",
      Type => "Interrupt",
      UsedBy => "SER",
    },
    Ecc_2bErrInterrupt => { #Structure Type: RegField;
      Name => "Ecc_2bErrInterrupt",
      RegMem => "RegField",
      Description => "When this bit is set, ECC 2b error was detected",
      Width => "1",
      Position => "1",
      Type => "Interrupt",
      UsedBy => "SER",
    },
    ParityErrInterrupt => { #Structure Type: RegField;
      Name => "ParityErrInterrupt",
      RegMem => "RegField",
      Description => "When this bit is set, Parity error was detected",
      Width => "1",
      Position => "2",
      Type => "Interrupt",
      UsedBy => "SER",
    },
  },
  MemProtectInterruptTest => { #Structure Type: Reg; Skip Register;
    Name => "MemProtectInterruptTest",
    RegMem => "Reg",
    Address => "2",
    Description => "ECC/Parity Interrupt Register",
    Width => "3",
    Type => "InterruptTest",
    Ecc_1bErrInterruptTest => { #Structure Type: RegField;
      Name => "Ecc_1bErrInterruptTest",
      RegMem => "RegField",
      Description => "This field masks Ecc_1bErrInterrupt",
      Width => "1",
      Position => "0",
      Type => "InterruptTest",
      UsedBy => "",
      DefaultValue => "b0",
    },
    Ecc_2bErrInterruptTest => { #Structure Type: RegField;
      Name => "Ecc_2bErrInterruptTest",
      RegMem => "RegField",
      Description => "This field masks Ecc_2bErrInterrupt",
      Width => "1",
      Position => "1",
      Type => "InterruptTest",
      UsedBy => "",
      DefaultValue => "b0",
    },
    ParityErrInterruptTest => { #Structure Type: RegField;
      Name => "ParityErrInterruptTest",
      RegMem => "RegField",
      Description => "This field masks ParityErrInterrupt",
      Width => "1",
      Position => "2",
      Type => "InterruptTest",
      UsedBy => "",
      DefaultValue => "b0",
    },
  },
  Ecc_1bErrInterruptRegisterMask => { #Structure Type: Reg; Skip Register;
    Name => "Ecc_1bErrInterruptRegisterMask",
    RegMem => "Reg",
    Address => "3",
    Description => "ECC 1b Error Interrupt Mask Register",
    Width => "55",
    Type => "Config",
    rdrqsnEcc_1bErrInterruptMask => { #Structure Type: RegField;
      Name => "rdrqsnEcc_1bErrInterruptMask",
      RegMem => "RegField",
      Description => "When this bit is set, ECC 1b Error indication will be masked",
      Width => "1",
      Position => "0",
      Type => "Config",
      UsedBy => "SER",
      DefaultValue => "b1",
    },
    rdsnEcc_1bErrInterruptMask => { #Structure Type: RegField;
      Name => "rdsnEcc_1bErrInterruptMask",
      RegMem => "RegField",
      Description => "When this bit is set, ECC 1b Error indication will be masked",
      Width => "1",
      Position => "1",
      Type => "Config",
      UsedBy => "SER",
      DefaultValue => "b1",
    },
    rdbcEcc_1bErrInterruptMask => { #Structure Type: RegField;
      Name => "rdbcEcc_1bErrInterruptMask",
      RegMem => "RegField",
      Description => "When this bit is set, ECC 1b Error indication will be masked",
      Width => "1",
      Position => "2",
      Type => "Config",
      UsedBy => "SER",
      DefaultValue => "b1",
    },
    rdbufcntEcc_1bErrInterruptMask => { #Structure Type: RegField;
      Name => "rdbufcntEcc_1bErrInterruptMask",
      RegMem => "RegField",
      Description => "When this bit is set, ECC 1b Error indication will be masked",
      Width => "1",
      Position => "3",
      Type => "Config",
      UsedBy => "SER",
      DefaultValue => "b1",
    },
    wrrqsnEcc_1bErrInterruptMask => { #Structure Type: RegField;
      Name => "wrrqsnEcc_1bErrInterruptMask",
      RegMem => "RegField",
      Description => "When this bit is set, ECC 1b Error indication will be masked",
      Width => "1",
      Position => "4",
      Type => "Config",
      UsedBy => "SER",
      DefaultValue => "b1",
    },
    wrsnEcc_1bErrInterruptMask => { #Structure Type: RegField;
      Name => "wrsnEcc_1bErrInterruptMask",
      RegMem => "RegField",
      Description => "When this bit is set, ECC 1b Error indication will be masked",
      Width => "1",
      Position => "5",
      Type => "Config",
      UsedBy => "SER",
      DefaultValue => "b1",
    },
    wrbcEcc_1bErrInterruptMask => { #Structure Type: RegField;
      Name => "wrbcEcc_1bErrInterruptMask",
      RegMem => "RegField",
      Description => "When this bit is set, ECC 1b Error indication will be masked",
      Width => "1",
      Position => "6",
      Type => "Config",
      UsedBy => "SER",
      DefaultValue => "b1",
    },
    wrbufcntEcc_1bErrInterruptMask => { #Structure Type: RegField;
      Name => "wrbufcntEcc_1bErrInterruptMask",
      RegMem => "RegField",
      Description => "When this bit is set, ECC 1b Error indication will be masked",
      Width => "1",
      Position => "7",
      Type => "Config",
      UsedBy => "SER",
      DefaultValue => "b1",
    },
    voq2contextEcc_1bErrInterruptMask => { #Structure Type: RegField;
      Name => "voq2contextEcc_1bErrInterruptMask",
      RegMem => "RegField",
      Description => "When this bit is set, ECC 1b Error indication will be masked",
      Width => "1",
      Position => "8",
      Type => "Config",
      UsedBy => "SER",
      DefaultValue => "b1",
    },
    CandRelFifoEcc_1bErrInterruptMask => { #Structure Type: RegField;
      Name => "CandRelFifoEcc_1bErrInterruptMask",
      RegMem => "RegField",
      Description => "When this bit is set, ECC 1b Error indication will be masked",
      Width => "1",
      Position => "9",
      Type => "Config",
      UsedBy => "SER",
      DefaultValue => "b1",
    },
    InCandRelFifoSetEcc_1bErrInterruptMask => { #Structure Type: RegField;
      Name => "InCandRelFifoSetEcc_1bErrInterruptMask",
      RegMem => "RegField",
      Description => "When this bit is set, ECC 1b Error indication will be masked",
      Width => "1",
      Position => "10",
      Type => "Config",
      UsedBy => "SER",
      DefaultValue => "b1",
    },
    InCandRelFifoClrEcc_1bErrInterruptMask => { #Structure Type: RegField;
      Name => "InCandRelFifoClrEcc_1bErrInterruptMask",
      RegMem => "RegField",
      Description => "When this bit is set, ECC 1b Error indication will be masked",
      Width => "1",
      Position => "11",
      Type => "Config",
      UsedBy => "SER",
      DefaultValue => "b1",
    },
    ContextReleaseEligibleSetEcc_1bErrInterruptMask => { #Structure Type: RegField;
      Name => "ContextReleaseEligibleSetEcc_1bErrInterruptMask",
      RegMem => "RegField",
      Description => "When this bit is set, ECC 1b Error indication will be masked",
      Width => "1",
      Position => "12",
      Type => "Config",
      UsedBy => "SER",
      DefaultValue => "b1",
    },
    ContextReleaseEligibleClrEcc_1bErrInterruptMask => { #Structure Type: RegField;
      Name => "ContextReleaseEligibleClrEcc_1bErrInterruptMask",
      RegMem => "RegField",
      Description => "When this bit is set, ECC 1b Error indication will be masked",
      Width => "1",
      Position => "13",
      Type => "Config",
      UsedBy => "SER",
      DefaultValue => "b1",
    },
    ContextInDramSetEcc_1bErrInterruptMask => { #Structure Type: RegField;
      Name => "ContextInDramSetEcc_1bErrInterruptMask",
      RegMem => "RegField",
      Description => "When this bit is set, ECC 1b Error indication will be masked",
      Width => "1",
      Position => "14",
      Type => "Config",
      UsedBy => "SER",
      DefaultValue => "b1",
    },
    ContextInDramClrEcc_1bErrInterruptMask => { #Structure Type: RegField;
      Name => "ContextInDramClrEcc_1bErrInterruptMask",
      RegMem => "RegField",
      Description => "When this bit is set, ECC 1b Error indication will be masked",
      Width => "1",
      Position => "15",
      Type => "Config",
      UsedBy => "SER",
      DefaultValue => "b1",
    },
    ContextMapValidSetEcc_1bErrInterruptMask => { #Structure Type: RegField;
      Name => "ContextMapValidSetEcc_1bErrInterruptMask",
      RegMem => "RegField",
      Description => "When this bit is set, ECC 1b Error indication will be masked",
      Width => "1",
      Position => "16",
      Type => "Config",
      UsedBy => "SER",
      DefaultValue => "b1",
    },
    ContextMapValidClrEcc_1bErrInterruptMask => { #Structure Type: RegField;
      Name => "ContextMapValidClrEcc_1bErrInterruptMask",
      RegMem => "RegField",
      Description => "When this bit is set, ECC 1b Error indication will be masked",
      Width => "1",
      Position => "17",
      Type => "Config",
      UsedBy => "SER",
      DefaultValue => "b1",
    },
    contextfbmBmpEcc_1bErrInterruptMask => { #Structure Type: RegField;
      Name => "contextfbmBmpEcc_1bErrInterruptMask",
      RegMem => "RegField",
      Description => "When this bit is set, ECC 1b Error indication will be masked",
      Width => "1",
      Position => "18",
      Type => "Config",
      UsedBy => "SER",
      DefaultValue => "b1",
    },
    NewVoqSetEcc_1bErrInterruptMask => { #Structure Type: RegField;
      Name => "NewVoqSetEcc_1bErrInterruptMask",
      RegMem => "RegField",
      Description => "When this bit is set, ECC 1b Error indication will be masked",
      Width => "1",
      Position => "19",
      Type => "Config",
      UsedBy => "SER",
      DefaultValue => "b1",
    },
    NewVoqClrEcc_1bErrInterruptMask => { #Structure Type: RegField;
      Name => "NewVoqClrEcc_1bErrInterruptMask",
      RegMem => "RegField",
      Description => "When this bit is set, ECC 1b Error indication will be masked",
      Width => "1",
      Position => "20",
      Type => "Config",
      UsedBy => "SER",
      DefaultValue => "b1",
    },
    voqPropertiesEcc_1bErrInterruptMask => { #Structure Type: RegField;
      Name => "voqPropertiesEcc_1bErrInterruptMask",
      RegMem => "RegField",
      Description => "When this bit is set, ECC 1b Error indication will be masked",
      Width => "1",
      Position => "21",
      Type => "Config",
      UsedBy => "SER",
      DefaultValue => "b1",
    },
    staticMappingEcc_1bErrInterruptMask => { #Structure Type: RegField;
      Name => "staticMappingEcc_1bErrInterruptMask",
      RegMem => "RegField",
      Description => "When this bit is set, ECC 1b Error indication will be masked",
      Width => "1",
      Position => "22",
      Type => "Config",
      UsedBy => "SER",
      DefaultValue => "b1",
    },
    context_allocate_set_masterEcc_1bErrInterruptMask => { #Structure Type: RegField;
      Name => "context_allocate_set_masterEcc_1bErrInterruptMask",
      RegMem => "RegField",
      Description => "When this bit is set, ECC 1b Error indication will be masked",
      Width => "1",
      Position => "23",
      Type => "Config",
      UsedBy => "SER",
      DefaultValue => "b1",
    },
    context_allocate_set_slaveEcc_1bErrInterruptMask => { #Structure Type: RegField;
      Name => "context_allocate_set_slaveEcc_1bErrInterruptMask",
      RegMem => "RegField",
      Description => "When this bit is set, ECC 1b Error indication will be masked",
      Width => "1",
      Position => "24",
      Type => "Config",
      UsedBy => "SER",
      DefaultValue => "b1",
    },
    context_allocate_clr_masterEcc_1bErrInterruptMask => { #Structure Type: RegField;
      Name => "context_allocate_clr_masterEcc_1bErrInterruptMask",
      RegMem => "RegField",
      Description => "When this bit is set, ECC 1b Error indication will be masked",
      Width => "1",
      Position => "25",
      Type => "Config",
      UsedBy => "SER",
      DefaultValue => "b1",
    },
    context_allocate_clr_slaveEcc_1bErrInterruptMask => { #Structure Type: RegField;
      Name => "context_allocate_clr_slaveEcc_1bErrInterruptMask",
      RegMem => "RegField",
      Description => "When this bit is set, ECC 1b Error indication will be masked",
      Width => "1",
      Position => "26",
      Type => "Config",
      UsedBy => "SER",
      DefaultValue => "b1",
    },
    context_allocate_grant_setEcc_1bErrInterruptMask => { #Structure Type: RegField;
      Name => "context_allocate_grant_setEcc_1bErrInterruptMask",
      RegMem => "RegField",
      Description => "When this bit is set, ECC 1b Error indication will be masked",
      Width => "1",
      Position => "27",
      Type => "Config",
      UsedBy => "SER",
      DefaultValue => "b1",
    },
    context_allocate_grant_clrEcc_1bErrInterruptMask => { #Structure Type: RegField;
      Name => "context_allocate_grant_clrEcc_1bErrInterruptMask",
      RegMem => "RegField",
      Description => "When this bit is set, ECC 1b Error indication will be masked",
      Width => "1",
      Position => "28",
      Type => "Config",
      UsedBy => "SER",
      DefaultValue => "b1",
    },
    Context2voqEcc_1bErrInterruptMask => { #Structure Type: RegField;
      Name => "Context2voqEcc_1bErrInterruptMask",
      RegMem => "RegField",
      Description => "When this bit is set, ECC 1b Error indication will be masked",
      Width => "1",
      Position => "29",
      Type => "Config",
      UsedBy => "SER",
      DefaultValue => "b1",
    },
    RqmFreeFifoEcc_1bErrInterruptMask => { #Structure Type: RegField;
      Name => "RqmFreeFifoEcc_1bErrInterruptMask",
      RegMem => "RegField",
      Description => "When this bit is set, ECC 1b Error indication will be masked",
      Width => "1",
      Position => "30",
      Type => "Config",
      UsedBy => "SER",
      DefaultValue => "b1",
    },
    voqcgmProfileEcc_1bErrInterruptMask => { #Structure Type: RegField;
      Name => "voqcgmProfileEcc_1bErrInterruptMask",
      RegMem => "RegField",
      Description => "When this bit is set, ECC 1b Error indication will be masked",
      Width => "1",
      Position => "31",
      Type => "Config",
      UsedBy => "SER",
      DefaultValue => "b1",
    },
    DramCgmProfileEcc_1bErrInterruptMask => { #Structure Type: RegField;
      Name => "DramCgmProfileEcc_1bErrInterruptMask",
      RegMem => "RegField",
      Description => "When this bit is set, ECC 1b Error indication will be masked",
      Width => "1",
      Position => "32",
      Type => "Config",
      UsedBy => "SER",
      DefaultValue => "b1",
    },
    BuffersConsumptionLutForEnqEcc_1bErrInterruptMask => { #Structure Type: RegField;
      Name => "BuffersConsumptionLutForEnqEcc_1bErrInterruptMask",
      RegMem => "RegField",
      Description => "When this bit is set, ECC 1b Error indication will be masked",
      Width => "1",
      Position => "33",
      Type => "Config",
      UsedBy => "SER",
      DefaultValue => "b1",
    },
    PdConsumptionLutForEnqEcc_1bErrInterruptMask => { #Structure Type: RegField;
      Name => "PdConsumptionLutForEnqEcc_1bErrInterruptMask",
      RegMem => "RegField",
      Description => "When this bit is set, ECC 1b Error indication will be masked",
      Width => "1",
      Position => "34",
      Type => "Config",
      UsedBy => "SER",
      DefaultValue => "b1",
    },
    VoqEnqRptSizeForEnqEcc_1bErrInterruptMask => { #Structure Type: RegField;
      Name => "VoqEnqRptSizeForEnqEcc_1bErrInterruptMask",
      RegMem => "RegField",
      Description => "When this bit is set, ECC 1b Error indication will be masked",
      Width => "1",
      Position => "35",
      Type => "Config",
      UsedBy => "SER",
      DefaultValue => "b1",
    },
    VoqDeqRptSizeForEnqEcc_1bErrInterruptMask => { #Structure Type: RegField;
      Name => "VoqDeqRptSizeForEnqEcc_1bErrInterruptMask",
      RegMem => "RegField",
      Description => "When this bit is set, ECC 1b Error indication will be masked",
      Width => "1",
      Position => "36",
      Type => "Config",
      UsedBy => "SER",
      DefaultValue => "b1",
    },
    VoqEnqRptSizeForDeqEcc_1bErrInterruptMask => { #Structure Type: RegField;
      Name => "VoqEnqRptSizeForDeqEcc_1bErrInterruptMask",
      RegMem => "RegField",
      Description => "When this bit is set, ECC 1b Error indication will be masked",
      Width => "1",
      Position => "37",
      Type => "Config",
      UsedBy => "SER",
      DefaultValue => "b1",
    },
    VoqDeqRptSizeForDeqEcc_1bErrInterruptMask => { #Structure Type: RegField;
      Name => "VoqDeqRptSizeForDeqEcc_1bErrInterruptMask",
      RegMem => "RegField",
      Description => "When this bit is set, ECC 1b Error indication will be masked",
      Width => "1",
      Position => "38",
      Type => "Config",
      UsedBy => "SER",
      DefaultValue => "b1",
    },
    LastRptEnqSetMemEcc_1bErrInterruptMask => { #Structure Type: RegField;
      Name => "LastRptEnqSetMemEcc_1bErrInterruptMask",
      RegMem => "RegField",
      Description => "When this bit is set, ECC 1b Error indication will be masked",
      Width => "1",
      Position => "39",
      Type => "Config",
      UsedBy => "SER",
      DefaultValue => "b1",
    },
    LastRptEnqSetMemExtraEcc_1bErrInterruptMask => { #Structure Type: RegField;
      Name => "LastRptEnqSetMemExtraEcc_1bErrInterruptMask",
      RegMem => "RegField",
      Description => "When this bit is set, ECC 1b Error indication will be masked",
      Width => "1",
      Position => "40",
      Type => "Config",
      UsedBy => "SER",
      DefaultValue => "b1",
    },
    LastRptEnqClrMemEcc_1bErrInterruptMask => { #Structure Type: RegField;
      Name => "LastRptEnqClrMemEcc_1bErrInterruptMask",
      RegMem => "RegField",
      Description => "When this bit is set, ECC 1b Error indication will be masked",
      Width => "1",
      Position => "41",
      Type => "Config",
      UsedBy => "SER",
      DefaultValue => "b1",
    },
    LastRptEnqClrMemExtraEcc_1bErrInterruptMask => { #Structure Type: RegField;
      Name => "LastRptEnqClrMemExtraEcc_1bErrInterruptMask",
      RegMem => "RegField",
      Description => "When this bit is set, ECC 1b Error indication will be masked",
      Width => "1",
      Position => "42",
      Type => "Config",
      UsedBy => "SER",
      DefaultValue => "b1",
    },
    VoqTenqHeadEnqEcc_1bErrInterruptMask => { #Structure Type: RegField;
      Name => "VoqTenqHeadEnqEcc_1bErrInterruptMask",
      RegMem => "RegField",
      Description => "When this bit is set, ECC 1b Error indication will be masked",
      Width => "1",
      Position => "43",
      Type => "Config",
      UsedBy => "SER",
      DefaultValue => "b1",
    },
    VoqTenqHeadRdEcc_1bErrInterruptMask => { #Structure Type: RegField;
      Name => "VoqTenqHeadRdEcc_1bErrInterruptMask",
      RegMem => "RegField",
      Description => "When this bit is set, ECC 1b Error indication will be masked",
      Width => "1",
      Position => "44",
      Type => "Config",
      UsedBy => "SER",
      DefaultValue => "b1",
    },
    VoqTenqHeadMsbEnqEcc_1bErrInterruptMask => { #Structure Type: RegField;
      Name => "VoqTenqHeadMsbEnqEcc_1bErrInterruptMask",
      RegMem => "RegField",
      Description => "When this bit is set, ECC 1b Error indication will be masked",
      Width => "1",
      Position => "45",
      Type => "Config",
      UsedBy => "SER",
      DefaultValue => "b1",
    },
    VoqTenqHeadMsbRdEcc_1bErrInterruptMask => { #Structure Type: RegField;
      Name => "VoqTenqHeadMsbRdEcc_1bErrInterruptMask",
      RegMem => "RegField",
      Description => "When this bit is set, ECC 1b Error indication will be masked",
      Width => "1",
      Position => "46",
      Type => "Config",
      UsedBy => "SER",
      DefaultValue => "b1",
    },
    HeadTimeEnqSetMemEcc_1bErrInterruptMask => { #Structure Type: RegField;
      Name => "HeadTimeEnqSetMemEcc_1bErrInterruptMask",
      RegMem => "RegField",
      Description => "When this bit is set, ECC 1b Error indication will be masked",
      Width => "1",
      Position => "47",
      Type => "Config",
      UsedBy => "SER",
      DefaultValue => "b1",
    },
    HeadTimeEnqSetMemExtraEcc_1bErrInterruptMask => { #Structure Type: RegField;
      Name => "HeadTimeEnqSetMemExtraEcc_1bErrInterruptMask",
      RegMem => "RegField",
      Description => "When this bit is set, ECC 1b Error indication will be masked",
      Width => "1",
      Position => "48",
      Type => "Config",
      UsedBy => "SER",
      DefaultValue => "b1",
    },
    HeadTimeEnqClrMemEcc_1bErrInterruptMask => { #Structure Type: RegField;
      Name => "HeadTimeEnqClrMemEcc_1bErrInterruptMask",
      RegMem => "RegField",
      Description => "When this bit is set, ECC 1b Error indication will be masked",
      Width => "1",
      Position => "49",
      Type => "Config",
      UsedBy => "SER",
      DefaultValue => "b1",
    },
    HeadTimeEnqClrMemExtraEcc_1bErrInterruptMask => { #Structure Type: RegField;
      Name => "HeadTimeEnqClrMemExtraEcc_1bErrInterruptMask",
      RegMem => "RegField",
      Description => "When this bit is set, ECC 1b Error indication will be masked",
      Width => "1",
      Position => "50",
      Type => "Config",
      UsedBy => "SER",
      DefaultValue => "b1",
    },
    IsAgingSetMemEcc_1bErrInterruptMask => { #Structure Type: RegField;
      Name => "IsAgingSetMemEcc_1bErrInterruptMask",
      RegMem => "RegField",
      Description => "When this bit is set, ECC 1b Error indication will be masked",
      Width => "1",
      Position => "51",
      Type => "Config",
      UsedBy => "SER",
      DefaultValue => "b1",
    },
    IsAgingClrMemEcc_1bErrInterruptMask => { #Structure Type: RegField;
      Name => "IsAgingClrMemEcc_1bErrInterruptMask",
      RegMem => "RegField",
      Description => "When this bit is set, ECC 1b Error indication will be masked",
      Width => "1",
      Position => "52",
      Type => "Config",
      UsedBy => "SER",
      DefaultValue => "b1",
    },
    AdmissionResultDramEcc_1bErrInterruptMask => { #Structure Type: RegField;
      Name => "AdmissionResultDramEcc_1bErrInterruptMask",
      RegMem => "RegField",
      Description => "When this bit is set, ECC 1b Error indication will be masked",
      Width => "1",
      Position => "53",
      Type => "Config",
      UsedBy => "SER",
      DefaultValue => "b1",
    },
    WredRegionEcc_1bErrInterruptMask => { #Structure Type: RegField;
      Name => "WredRegionEcc_1bErrInterruptMask",
      RegMem => "RegField",
      Description => "When this bit is set, ECC 1b Error indication will be masked",
      Width => "1",
      Position => "54",
      Type => "Config",
      UsedBy => "SER",
      DefaultValue => "b1",
    },
  },
  Ecc_2bErrInterruptRegisterMask => { #Structure Type: Reg; Skip Register;
    Name => "Ecc_2bErrInterruptRegisterMask",
    RegMem => "Reg",
    Address => "4",
    Description => "ECC 2b Error Interrupt Mask Register",
    Width => "55",
    Type => "Config",
    rdrqsnEcc_2bErrInterruptMask => { #Structure Type: RegField;
      Name => "rdrqsnEcc_2bErrInterruptMask",
      RegMem => "RegField",
      Description => "When this bit is set, ECC 2b Error indication will be masked",
      Width => "1",
      Position => "0",
      Type => "Config",
      UsedBy => "SER",
      DefaultValue => "b1",
    },
    rdsnEcc_2bErrInterruptMask => { #Structure Type: RegField;
      Name => "rdsnEcc_2bErrInterruptMask",
      RegMem => "RegField",
      Description => "When this bit is set, ECC 2b Error indication will be masked",
      Width => "1",
      Position => "1",
      Type => "Config",
      UsedBy => "SER",
      DefaultValue => "b1",
    },
    rdbcEcc_2bErrInterruptMask => { #Structure Type: RegField;
      Name => "rdbcEcc_2bErrInterruptMask",
      RegMem => "RegField",
      Description => "When this bit is set, ECC 2b Error indication will be masked",
      Width => "1",
      Position => "2",
      Type => "Config",
      UsedBy => "SER",
      DefaultValue => "b1",
    },
    rdbufcntEcc_2bErrInterruptMask => { #Structure Type: RegField;
      Name => "rdbufcntEcc_2bErrInterruptMask",
      RegMem => "RegField",
      Description => "When this bit is set, ECC 2b Error indication will be masked",
      Width => "1",
      Position => "3",
      Type => "Config",
      UsedBy => "SER",
      DefaultValue => "b1",
    },
    wrrqsnEcc_2bErrInterruptMask => { #Structure Type: RegField;
      Name => "wrrqsnEcc_2bErrInterruptMask",
      RegMem => "RegField",
      Description => "When this bit is set, ECC 2b Error indication will be masked",
      Width => "1",
      Position => "4",
      Type => "Config",
      UsedBy => "SER",
      DefaultValue => "b1",
    },
    wrsnEcc_2bErrInterruptMask => { #Structure Type: RegField;
      Name => "wrsnEcc_2bErrInterruptMask",
      RegMem => "RegField",
      Description => "When this bit is set, ECC 2b Error indication will be masked",
      Width => "1",
      Position => "5",
      Type => "Config",
      UsedBy => "SER",
      DefaultValue => "b1",
    },
    wrbcEcc_2bErrInterruptMask => { #Structure Type: RegField;
      Name => "wrbcEcc_2bErrInterruptMask",
      RegMem => "RegField",
      Description => "When this bit is set, ECC 2b Error indication will be masked",
      Width => "1",
      Position => "6",
      Type => "Config",
      UsedBy => "SER",
      DefaultValue => "b1",
    },
    wrbufcntEcc_2bErrInterruptMask => { #Structure Type: RegField;
      Name => "wrbufcntEcc_2bErrInterruptMask",
      RegMem => "RegField",
      Description => "When this bit is set, ECC 2b Error indication will be masked",
      Width => "1",
      Position => "7",
      Type => "Config",
      UsedBy => "SER",
      DefaultValue => "b1",
    },
    voq2contextEcc_2bErrInterruptMask => { #Structure Type: RegField;
      Name => "voq2contextEcc_2bErrInterruptMask",
      RegMem => "RegField",
      Description => "When this bit is set, ECC 2b Error indication will be masked",
      Width => "1",
      Position => "8",
      Type => "Config",
      UsedBy => "SER",
      DefaultValue => "b1",
    },
    CandRelFifoEcc_2bErrInterruptMask => { #Structure Type: RegField;
      Name => "CandRelFifoEcc_2bErrInterruptMask",
      RegMem => "RegField",
      Description => "When this bit is set, ECC 2b Error indication will be masked",
      Width => "1",
      Position => "9",
      Type => "Config",
      UsedBy => "SER",
      DefaultValue => "b1",
    },
    InCandRelFifoSetEcc_2bErrInterruptMask => { #Structure Type: RegField;
      Name => "InCandRelFifoSetEcc_2bErrInterruptMask",
      RegMem => "RegField",
      Description => "When this bit is set, ECC 2b Error indication will be masked",
      Width => "1",
      Position => "10",
      Type => "Config",
      UsedBy => "SER",
      DefaultValue => "b1",
    },
    InCandRelFifoClrEcc_2bErrInterruptMask => { #Structure Type: RegField;
      Name => "InCandRelFifoClrEcc_2bErrInterruptMask",
      RegMem => "RegField",
      Description => "When this bit is set, ECC 2b Error indication will be masked",
      Width => "1",
      Position => "11",
      Type => "Config",
      UsedBy => "SER",
      DefaultValue => "b1",
    },
    ContextReleaseEligibleSetEcc_2bErrInterruptMask => { #Structure Type: RegField;
      Name => "ContextReleaseEligibleSetEcc_2bErrInterruptMask",
      RegMem => "RegField",
      Description => "When this bit is set, ECC 2b Error indication will be masked",
      Width => "1",
      Position => "12",
      Type => "Config",
      UsedBy => "SER",
      DefaultValue => "b1",
    },
    ContextReleaseEligibleClrEcc_2bErrInterruptMask => { #Structure Type: RegField;
      Name => "ContextReleaseEligibleClrEcc_2bErrInterruptMask",
      RegMem => "RegField",
      Description => "When this bit is set, ECC 2b Error indication will be masked",
      Width => "1",
      Position => "13",
      Type => "Config",
      UsedBy => "SER",
      DefaultValue => "b1",
    },
    ContextInDramSetEcc_2bErrInterruptMask => { #Structure Type: RegField;
      Name => "ContextInDramSetEcc_2bErrInterruptMask",
      RegMem => "RegField",
      Description => "When this bit is set, ECC 2b Error indication will be masked",
      Width => "1",
      Position => "14",
      Type => "Config",
      UsedBy => "SER",
      DefaultValue => "b1",
    },
    ContextInDramClrEcc_2bErrInterruptMask => { #Structure Type: RegField;
      Name => "ContextInDramClrEcc_2bErrInterruptMask",
      RegMem => "RegField",
      Description => "When this bit is set, ECC 2b Error indication will be masked",
      Width => "1",
      Position => "15",
      Type => "Config",
      UsedBy => "SER",
      DefaultValue => "b1",
    },
    ContextMapValidSetEcc_2bErrInterruptMask => { #Structure Type: RegField;
      Name => "ContextMapValidSetEcc_2bErrInterruptMask",
      RegMem => "RegField",
      Description => "When this bit is set, ECC 2b Error indication will be masked",
      Width => "1",
      Position => "16",
      Type => "Config",
      UsedBy => "SER",
      DefaultValue => "b1",
    },
    ContextMapValidClrEcc_2bErrInterruptMask => { #Structure Type: RegField;
      Name => "ContextMapValidClrEcc_2bErrInterruptMask",
      RegMem => "RegField",
      Description => "When this bit is set, ECC 2b Error indication will be masked",
      Width => "1",
      Position => "17",
      Type => "Config",
      UsedBy => "SER",
      DefaultValue => "b1",
    },
    contextfbmBmpEcc_2bErrInterruptMask => { #Structure Type: RegField;
      Name => "contextfbmBmpEcc_2bErrInterruptMask",
      RegMem => "RegField",
      Description => "When this bit is set, ECC 2b Error indication will be masked",
      Width => "1",
      Position => "18",
      Type => "Config",
      UsedBy => "SER",
      DefaultValue => "b1",
    },
    NewVoqSetEcc_2bErrInterruptMask => { #Structure Type: RegField;
      Name => "NewVoqSetEcc_2bErrInterruptMask",
      RegMem => "RegField",
      Description => "When this bit is set, ECC 2b Error indication will be masked",
      Width => "1",
      Position => "19",
      Type => "Config",
      UsedBy => "SER",
      DefaultValue => "b1",
    },
    NewVoqClrEcc_2bErrInterruptMask => { #Structure Type: RegField;
      Name => "NewVoqClrEcc_2bErrInterruptMask",
      RegMem => "RegField",
      Description => "When this bit is set, ECC 2b Error indication will be masked",
      Width => "1",
      Position => "20",
      Type => "Config",
      UsedBy => "SER",
      DefaultValue => "b1",
    },
    voqPropertiesEcc_2bErrInterruptMask => { #Structure Type: RegField;
      Name => "voqPropertiesEcc_2bErrInterruptMask",
      RegMem => "RegField",
      Description => "When this bit is set, ECC 2b Error indication will be masked",
      Width => "1",
      Position => "21",
      Type => "Config",
      UsedBy => "SER",
      DefaultValue => "b1",
    },
    staticMappingEcc_2bErrInterruptMask => { #Structure Type: RegField;
      Name => "staticMappingEcc_2bErrInterruptMask",
      RegMem => "RegField",
      Description => "When this bit is set, ECC 2b Error indication will be masked",
      Width => "1",
      Position => "22",
      Type => "Config",
      UsedBy => "SER",
      DefaultValue => "b1",
    },
    context_allocate_set_masterEcc_2bErrInterruptMask => { #Structure Type: RegField;
      Name => "context_allocate_set_masterEcc_2bErrInterruptMask",
      RegMem => "RegField",
      Description => "When this bit is set, ECC 2b Error indication will be masked",
      Width => "1",
      Position => "23",
      Type => "Config",
      UsedBy => "SER",
      DefaultValue => "b1",
    },
    context_allocate_set_slaveEcc_2bErrInterruptMask => { #Structure Type: RegField;
      Name => "context_allocate_set_slaveEcc_2bErrInterruptMask",
      RegMem => "RegField",
      Description => "When this bit is set, ECC 2b Error indication will be masked",
      Width => "1",
      Position => "24",
      Type => "Config",
      UsedBy => "SER",
      DefaultValue => "b1",
    },
    context_allocate_clr_masterEcc_2bErrInterruptMask => { #Structure Type: RegField;
      Name => "context_allocate_clr_masterEcc_2bErrInterruptMask",
      RegMem => "RegField",
      Description => "When this bit is set, ECC 2b Error indication will be masked",
      Width => "1",
      Position => "25",
      Type => "Config",
      UsedBy => "SER",
      DefaultValue => "b1",
    },
    context_allocate_clr_slaveEcc_2bErrInterruptMask => { #Structure Type: RegField;
      Name => "context_allocate_clr_slaveEcc_2bErrInterruptMask",
      RegMem => "RegField",
      Description => "When this bit is set, ECC 2b Error indication will be masked",
      Width => "1",
      Position => "26",
      Type => "Config",
      UsedBy => "SER",
      DefaultValue => "b1",
    },
    context_allocate_grant_setEcc_2bErrInterruptMask => { #Structure Type: RegField;
      Name => "context_allocate_grant_setEcc_2bErrInterruptMask",
      RegMem => "RegField",
      Description => "When this bit is set, ECC 2b Error indication will be masked",
      Width => "1",
      Position => "27",
      Type => "Config",
      UsedBy => "SER",
      DefaultValue => "b1",
    },
    context_allocate_grant_clrEcc_2bErrInterruptMask => { #Structure Type: RegField;
      Name => "context_allocate_grant_clrEcc_2bErrInterruptMask",
      RegMem => "RegField",
      Description => "When this bit is set, ECC 2b Error indication will be masked",
      Width => "1",
      Position => "28",
      Type => "Config",
      UsedBy => "SER",
      DefaultValue => "b1",
    },
    Context2voqEcc_2bErrInterruptMask => { #Structure Type: RegField;
      Name => "Context2voqEcc_2bErrInterruptMask",
      RegMem => "RegField",
      Description => "When this bit is set, ECC 2b Error indication will be masked",
      Width => "1",
      Position => "29",
      Type => "Config",
      UsedBy => "SER",
      DefaultValue => "b1",
    },
    RqmFreeFifoEcc_2bErrInterruptMask => { #Structure Type: RegField;
      Name => "RqmFreeFifoEcc_2bErrInterruptMask",
      RegMem => "RegField",
      Description => "When this bit is set, ECC 2b Error indication will be masked",
      Width => "1",
      Position => "30",
      Type => "Config",
      UsedBy => "SER",
      DefaultValue => "b1",
    },
    voqcgmProfileEcc_2bErrInterruptMask => { #Structure Type: RegField;
      Name => "voqcgmProfileEcc_2bErrInterruptMask",
      RegMem => "RegField",
      Description => "When this bit is set, ECC 2b Error indication will be masked",
      Width => "1",
      Position => "31",
      Type => "Config",
      UsedBy => "SER",
      DefaultValue => "b1",
    },
    DramCgmProfileEcc_2bErrInterruptMask => { #Structure Type: RegField;
      Name => "DramCgmProfileEcc_2bErrInterruptMask",
      RegMem => "RegField",
      Description => "When this bit is set, ECC 2b Error indication will be masked",
      Width => "1",
      Position => "32",
      Type => "Config",
      UsedBy => "SER",
      DefaultValue => "b1",
    },
    BuffersConsumptionLutForEnqEcc_2bErrInterruptMask => { #Structure Type: RegField;
      Name => "BuffersConsumptionLutForEnqEcc_2bErrInterruptMask",
      RegMem => "RegField",
      Description => "When this bit is set, ECC 2b Error indication will be masked",
      Width => "1",
      Position => "33",
      Type => "Config",
      UsedBy => "SER",
      DefaultValue => "b1",
    },
    PdConsumptionLutForEnqEcc_2bErrInterruptMask => { #Structure Type: RegField;
      Name => "PdConsumptionLutForEnqEcc_2bErrInterruptMask",
      RegMem => "RegField",
      Description => "When this bit is set, ECC 2b Error indication will be masked",
      Width => "1",
      Position => "34",
      Type => "Config",
      UsedBy => "SER",
      DefaultValue => "b1",
    },
    VoqEnqRptSizeForEnqEcc_2bErrInterruptMask => { #Structure Type: RegField;
      Name => "VoqEnqRptSizeForEnqEcc_2bErrInterruptMask",
      RegMem => "RegField",
      Description => "When this bit is set, ECC 2b Error indication will be masked",
      Width => "1",
      Position => "35",
      Type => "Config",
      UsedBy => "SER",
      DefaultValue => "b1",
    },
    VoqDeqRptSizeForEnqEcc_2bErrInterruptMask => { #Structure Type: RegField;
      Name => "VoqDeqRptSizeForEnqEcc_2bErrInterruptMask",
      RegMem => "RegField",
      Description => "When this bit is set, ECC 2b Error indication will be masked",
      Width => "1",
      Position => "36",
      Type => "Config",
      UsedBy => "SER",
      DefaultValue => "b1",
    },
    VoqEnqRptSizeForDeqEcc_2bErrInterruptMask => { #Structure Type: RegField;
      Name => "VoqEnqRptSizeForDeqEcc_2bErrInterruptMask",
      RegMem => "RegField",
      Description => "When this bit is set, ECC 2b Error indication will be masked",
      Width => "1",
      Position => "37",
      Type => "Config",
      UsedBy => "SER",
      DefaultValue => "b1",
    },
    VoqDeqRptSizeForDeqEcc_2bErrInterruptMask => { #Structure Type: RegField;
      Name => "VoqDeqRptSizeForDeqEcc_2bErrInterruptMask",
      RegMem => "RegField",
      Description => "When this bit is set, ECC 2b Error indication will be masked",
      Width => "1",
      Position => "38",
      Type => "Config",
      UsedBy => "SER",
      DefaultValue => "b1",
    },
    LastRptEnqSetMemEcc_2bErrInterruptMask => { #Structure Type: RegField;
      Name => "LastRptEnqSetMemEcc_2bErrInterruptMask",
      RegMem => "RegField",
      Description => "When this bit is set, ECC 2b Error indication will be masked",
      Width => "1",
      Position => "39",
      Type => "Config",
      UsedBy => "SER",
      DefaultValue => "b1",
    },
    LastRptEnqSetMemExtraEcc_2bErrInterruptMask => { #Structure Type: RegField;
      Name => "LastRptEnqSetMemExtraEcc_2bErrInterruptMask",
      RegMem => "RegField",
      Description => "When this bit is set, ECC 2b Error indication will be masked",
      Width => "1",
      Position => "40",
      Type => "Config",
      UsedBy => "SER",
      DefaultValue => "b1",
    },
    LastRptEnqClrMemEcc_2bErrInterruptMask => { #Structure Type: RegField;
      Name => "LastRptEnqClrMemEcc_2bErrInterruptMask",
      RegMem => "RegField",
      Description => "When this bit is set, ECC 2b Error indication will be masked",
      Width => "1",
      Position => "41",
      Type => "Config",
      UsedBy => "SER",
      DefaultValue => "b1",
    },
    LastRptEnqClrMemExtraEcc_2bErrInterruptMask => { #Structure Type: RegField;
      Name => "LastRptEnqClrMemExtraEcc_2bErrInterruptMask",
      RegMem => "RegField",
      Description => "When this bit is set, ECC 2b Error indication will be masked",
      Width => "1",
      Position => "42",
      Type => "Config",
      UsedBy => "SER",
      DefaultValue => "b1",
    },
    VoqTenqHeadEnqEcc_2bErrInterruptMask => { #Structure Type: RegField;
      Name => "VoqTenqHeadEnqEcc_2bErrInterruptMask",
      RegMem => "RegField",
      Description => "When this bit is set, ECC 2b Error indication will be masked",
      Width => "1",
      Position => "43",
      Type => "Config",
      UsedBy => "SER",
      DefaultValue => "b1",
    },
    VoqTenqHeadRdEcc_2bErrInterruptMask => { #Structure Type: RegField;
      Name => "VoqTenqHeadRdEcc_2bErrInterruptMask",
      RegMem => "RegField",
      Description => "When this bit is set, ECC 2b Error indication will be masked",
      Width => "1",
      Position => "44",
      Type => "Config",
      UsedBy => "SER",
      DefaultValue => "b1",
    },
    VoqTenqHeadMsbEnqEcc_2bErrInterruptMask => { #Structure Type: RegField;
      Name => "VoqTenqHeadMsbEnqEcc_2bErrInterruptMask",
      RegMem => "RegField",
      Description => "When this bit is set, ECC 2b Error indication will be masked",
      Width => "1",
      Position => "45",
      Type => "Config",
      UsedBy => "SER",
      DefaultValue => "b1",
    },
    VoqTenqHeadMsbRdEcc_2bErrInterruptMask => { #Structure Type: RegField;
      Name => "VoqTenqHeadMsbRdEcc_2bErrInterruptMask",
      RegMem => "RegField",
      Description => "When this bit is set, ECC 2b Error indication will be masked",
      Width => "1",
      Position => "46",
      Type => "Config",
      UsedBy => "SER",
      DefaultValue => "b1",
    },
    HeadTimeEnqSetMemEcc_2bErrInterruptMask => { #Structure Type: RegField;
      Name => "HeadTimeEnqSetMemEcc_2bErrInterruptMask",
      RegMem => "RegField",
      Description => "When this bit is set, ECC 2b Error indication will be masked",
      Width => "1",
      Position => "47",
      Type => "Config",
      UsedBy => "SER",
      DefaultValue => "b1",
    },
    HeadTimeEnqSetMemExtraEcc_2bErrInterruptMask => { #Structure Type: RegField;
      Name => "HeadTimeEnqSetMemExtraEcc_2bErrInterruptMask",
      RegMem => "RegField",
      Description => "When this bit is set, ECC 2b Error indication will be masked",
      Width => "1",
      Position => "48",
      Type => "Config",
      UsedBy => "SER",
      DefaultValue => "b1",
    },
    HeadTimeEnqClrMemEcc_2bErrInterruptMask => { #Structure Type: RegField;
      Name => "HeadTimeEnqClrMemEcc_2bErrInterruptMask",
      RegMem => "RegField",
      Description => "When this bit is set, ECC 2b Error indication will be masked",
      Width => "1",
      Position => "49",
      Type => "Config",
      UsedBy => "SER",
      DefaultValue => "b1",
    },
    HeadTimeEnqClrMemExtraEcc_2bErrInterruptMask => { #Structure Type: RegField;
      Name => "HeadTimeEnqClrMemExtraEcc_2bErrInterruptMask",
      RegMem => "RegField",
      Description => "When this bit is set, ECC 2b Error indication will be masked",
      Width => "1",
      Position => "50",
      Type => "Config",
      UsedBy => "SER",
      DefaultValue => "b1",
    },
    IsAgingSetMemEcc_2bErrInterruptMask => { #Structure Type: RegField;
      Name => "IsAgingSetMemEcc_2bErrInterruptMask",
      RegMem => "RegField",
      Description => "When this bit is set, ECC 2b Error indication will be masked",
      Width => "1",
      Position => "51",
      Type => "Config",
      UsedBy => "SER",
      DefaultValue => "b1",
    },
    IsAgingClrMemEcc_2bErrInterruptMask => { #Structure Type: RegField;
      Name => "IsAgingClrMemEcc_2bErrInterruptMask",
      RegMem => "RegField",
      Description => "When this bit is set, ECC 2b Error indication will be masked",
      Width => "1",
      Position => "52",
      Type => "Config",
      UsedBy => "SER",
      DefaultValue => "b1",
    },
    AdmissionResultDramEcc_2bErrInterruptMask => { #Structure Type: RegField;
      Name => "AdmissionResultDramEcc_2bErrInterruptMask",
      RegMem => "RegField",
      Description => "When this bit is set, ECC 2b Error indication will be masked",
      Width => "1",
      Position => "53",
      Type => "Config",
      UsedBy => "SER",
      DefaultValue => "b1",
    },
    WredRegionEcc_2bErrInterruptMask => { #Structure Type: RegField;
      Name => "WredRegionEcc_2bErrInterruptMask",
      RegMem => "RegField",
      Description => "When this bit is set, ECC 2b Error indication will be masked",
      Width => "1",
      Position => "54",
      Type => "Config",
      UsedBy => "SER",
      DefaultValue => "b1",
    },
  },

  Ecc_1bErrInitiateRegister => { #Structure Type: Reg; Skip Register;
    Name => "Ecc_1bErrInitiateRegister",
    RegMem => "Reg",
    Address => "30",
    Description => "ECC 1b Error Initiator Register",
    Width => "55",
    Type => "Config",
    rdrqsnEcc_1bErrInitiate => { #Structure Type: RegField;
      Name => "rdrqsnEcc_1bErrInitiate",
      RegMem => "RegField",
      Description => "When this bit is set, ECC 1b Error will be initiated",
      Width => "1",
      Position => "0",
      Type => "Config",
      UsedBy => "MEM",
      DefaultValue => "b0",
    },
    rdsnEcc_1bErrInitiate => { #Structure Type: RegField;
      Name => "rdsnEcc_1bErrInitiate",
      RegMem => "RegField",
      Description => "When this bit is set, ECC 1b Error will be initiated",
      Width => "1",
      Position => "1",
      Type => "Config",
      UsedBy => "MEM",
      DefaultValue => "b0",
    },
    rdbcEcc_1bErrInitiate => { #Structure Type: RegField;
      Name => "rdbcEcc_1bErrInitiate",
      RegMem => "RegField",
      Description => "When this bit is set, ECC 1b Error will be initiated",
      Width => "1",
      Position => "2",
      Type => "Config",
      UsedBy => "MEM",
      DefaultValue => "b0",
    },
    rdbufcntEcc_1bErrInitiate => { #Structure Type: RegField;
      Name => "rdbufcntEcc_1bErrInitiate",
      RegMem => "RegField",
      Description => "When this bit is set, ECC 1b Error will be initiated",
      Width => "1",
      Position => "3",
      Type => "Config",
      UsedBy => "MEM",
      DefaultValue => "b0",
    },
    wrrqsnEcc_1bErrInitiate => { #Structure Type: RegField;
      Name => "wrrqsnEcc_1bErrInitiate",
      RegMem => "RegField",
      Description => "When this bit is set, ECC 1b Error will be initiated",
      Width => "1",
      Position => "4",
      Type => "Config",
      UsedBy => "MEM",
      DefaultValue => "b0",
    },
    wrsnEcc_1bErrInitiate => { #Structure Type: RegField;
      Name => "wrsnEcc_1bErrInitiate",
      RegMem => "RegField",
      Description => "When this bit is set, ECC 1b Error will be initiated",
      Width => "1",
      Position => "5",
      Type => "Config",
      UsedBy => "MEM",
      DefaultValue => "b0",
    },
    wrbcEcc_1bErrInitiate => { #Structure Type: RegField;
      Name => "wrbcEcc_1bErrInitiate",
      RegMem => "RegField",
      Description => "When this bit is set, ECC 1b Error will be initiated",
      Width => "1",
      Position => "6",
      Type => "Config",
      UsedBy => "MEM",
      DefaultValue => "b0",
    },
    wrbufcntEcc_1bErrInitiate => { #Structure Type: RegField;
      Name => "wrbufcntEcc_1bErrInitiate",
      RegMem => "RegField",
      Description => "When this bit is set, ECC 1b Error will be initiated",
      Width => "1",
      Position => "7",
      Type => "Config",
      UsedBy => "MEM",
      DefaultValue => "b0",
    },
    voq2contextEcc_1bErrInitiate => { #Structure Type: RegField;
      Name => "voq2contextEcc_1bErrInitiate",
      RegMem => "RegField",
      Description => "When this bit is set, ECC 1b Error will be initiated",
      Width => "1",
      Position => "8",
      Type => "Config",
      UsedBy => "MEM",
      DefaultValue => "b0",
    },
    CandRelFifoEcc_1bErrInitiate => { #Structure Type: RegField;
      Name => "CandRelFifoEcc_1bErrInitiate",
      RegMem => "RegField",
      Description => "When this bit is set, ECC 1b Error will be initiated",
      Width => "1",
      Position => "9",
      Type => "Config",
      UsedBy => "MEM",
      DefaultValue => "b0",
    },
    InCandRelFifoSetEcc_1bErrInitiate => { #Structure Type: RegField;
      Name => "InCandRelFifoSetEcc_1bErrInitiate",
      RegMem => "RegField",
      Description => "When this bit is set, ECC 1b Error will be initiated",
      Width => "1",
      Position => "10",
      Type => "Config",
      UsedBy => "MEM",
      DefaultValue => "b0",
    },
    InCandRelFifoClrEcc_1bErrInitiate => { #Structure Type: RegField;
      Name => "InCandRelFifoClrEcc_1bErrInitiate",
      RegMem => "RegField",
      Description => "When this bit is set, ECC 1b Error will be initiated",
      Width => "1",
      Position => "11",
      Type => "Config",
      UsedBy => "MEM",
      DefaultValue => "b0",
    },
    ContextReleaseEligibleSetEcc_1bErrInitiate => { #Structure Type: RegField;
      Name => "ContextReleaseEligibleSetEcc_1bErrInitiate",
      RegMem => "RegField",
      Description => "When this bit is set, ECC 1b Error will be initiated",
      Width => "1",
      Position => "12",
      Type => "Config",
      UsedBy => "MEM",
      DefaultValue => "b0",
    },
    ContextReleaseEligibleClrEcc_1bErrInitiate => { #Structure Type: RegField;
      Name => "ContextReleaseEligibleClrEcc_1bErrInitiate",
      RegMem => "RegField",
      Description => "When this bit is set, ECC 1b Error will be initiated",
      Width => "1",
      Position => "13",
      Type => "Config",
      UsedBy => "MEM",
      DefaultValue => "b0",
    },
    ContextInDramSetEcc_1bErrInitiate => { #Structure Type: RegField;
      Name => "ContextInDramSetEcc_1bErrInitiate",
      RegMem => "RegField",
      Description => "When this bit is set, ECC 1b Error will be initiated",
      Width => "1",
      Position => "14",
      Type => "Config",
      UsedBy => "MEM",
      DefaultValue => "b0",
    },
    ContextInDramClrEcc_1bErrInitiate => { #Structure Type: RegField;
      Name => "ContextInDramClrEcc_1bErrInitiate",
      RegMem => "RegField",
      Description => "When this bit is set, ECC 1b Error will be initiated",
      Width => "1",
      Position => "15",
      Type => "Config",
      UsedBy => "MEM",
      DefaultValue => "b0",
    },
    ContextMapValidSetEcc_1bErrInitiate => { #Structure Type: RegField;
      Name => "ContextMapValidSetEcc_1bErrInitiate",
      RegMem => "RegField",
      Description => "When this bit is set, ECC 1b Error will be initiated",
      Width => "1",
      Position => "16",
      Type => "Config",
      UsedBy => "MEM",
      DefaultValue => "b0",
    },
    ContextMapValidClrEcc_1bErrInitiate => { #Structure Type: RegField;
      Name => "ContextMapValidClrEcc_1bErrInitiate",
      RegMem => "RegField",
      Description => "When this bit is set, ECC 1b Error will be initiated",
      Width => "1",
      Position => "17",
      Type => "Config",
      UsedBy => "MEM",
      DefaultValue => "b0",
    },
    contextfbmBmpEcc_1bErrInitiate => { #Structure Type: RegField;
      Name => "contextfbmBmpEcc_1bErrInitiate",
      RegMem => "RegField",
      Description => "When this bit is set, ECC 1b Error will be initiated",
      Width => "1",
      Position => "18",
      Type => "Config",
      UsedBy => "MEM",
      DefaultValue => "b0",
    },
    NewVoqSetEcc_1bErrInitiate => { #Structure Type: RegField;
      Name => "NewVoqSetEcc_1bErrInitiate",
      RegMem => "RegField",
      Description => "When this bit is set, ECC 1b Error will be initiated",
      Width => "1",
      Position => "19",
      Type => "Config",
      UsedBy => "MEM",
      DefaultValue => "b0",
    },
    NewVoqClrEcc_1bErrInitiate => { #Structure Type: RegField;
      Name => "NewVoqClrEcc_1bErrInitiate",
      RegMem => "RegField",
      Description => "When this bit is set, ECC 1b Error will be initiated",
      Width => "1",
      Position => "20",
      Type => "Config",
      UsedBy => "MEM",
      DefaultValue => "b0",
    },
    voqPropertiesEcc_1bErrInitiate => { #Structure Type: RegField;
      Name => "voqPropertiesEcc_1bErrInitiate",
      RegMem => "RegField",
      Description => "When this bit is set, ECC 1b Error will be initiated",
      Width => "1",
      Position => "21",
      Type => "Config",
      UsedBy => "MEM",
      DefaultValue => "b0",
    },
    staticMappingEcc_1bErrInitiate => { #Structure Type: RegField;
      Name => "staticMappingEcc_1bErrInitiate",
      RegMem => "RegField",
      Description => "When this bit is set, ECC 1b Error will be initiated",
      Width => "1",
      Position => "22",
      Type => "Config",
      UsedBy => "MEM",
      DefaultValue => "b0",
    },
    context_allocate_set_masterEcc_1bErrInitiate => { #Structure Type: RegField;
      Name => "context_allocate_set_masterEcc_1bErrInitiate",
      RegMem => "RegField",
      Description => "When this bit is set, ECC 1b Error will be initiated",
      Width => "1",
      Position => "23",
      Type => "Config",
      UsedBy => "MEM",
      DefaultValue => "b0",
    },
    context_allocate_set_slaveEcc_1bErrInitiate => { #Structure Type: RegField;
      Name => "context_allocate_set_slaveEcc_1bErrInitiate",
      RegMem => "RegField",
      Description => "When this bit is set, ECC 1b Error will be initiated",
      Width => "1",
      Position => "24",
      Type => "Config",
      UsedBy => "MEM",
      DefaultValue => "b0",
    },
    context_allocate_clr_masterEcc_1bErrInitiate => { #Structure Type: RegField;
      Name => "context_allocate_clr_masterEcc_1bErrInitiate",
      RegMem => "RegField",
      Description => "When this bit is set, ECC 1b Error will be initiated",
      Width => "1",
      Position => "25",
      Type => "Config",
      UsedBy => "MEM",
      DefaultValue => "b0",
    },
    context_allocate_clr_slaveEcc_1bErrInitiate => { #Structure Type: RegField;
      Name => "context_allocate_clr_slaveEcc_1bErrInitiate",
      RegMem => "RegField",
      Description => "When this bit is set, ECC 1b Error will be initiated",
      Width => "1",
      Position => "26",
      Type => "Config",
      UsedBy => "MEM",
      DefaultValue => "b0",
    },
    context_allocate_grant_setEcc_1bErrInitiate => { #Structure Type: RegField;
      Name => "context_allocate_grant_setEcc_1bErrInitiate",
      RegMem => "RegField",
      Description => "When this bit is set, ECC 1b Error will be initiated",
      Width => "1",
      Position => "27",
      Type => "Config",
      UsedBy => "MEM",
      DefaultValue => "b0",
    },
    context_allocate_grant_clrEcc_1bErrInitiate => { #Structure Type: RegField;
      Name => "context_allocate_grant_clrEcc_1bErrInitiate",
      RegMem => "RegField",
      Description => "When this bit is set, ECC 1b Error will be initiated",
      Width => "1",
      Position => "28",
      Type => "Config",
      UsedBy => "MEM",
      DefaultValue => "b0",
    },
    Context2voqEcc_1bErrInitiate => { #Structure Type: RegField;
      Name => "Context2voqEcc_1bErrInitiate",
      RegMem => "RegField",
      Description => "When this bit is set, ECC 1b Error will be initiated",
      Width => "1",
      Position => "29",
      Type => "Config",
      UsedBy => "MEM",
      DefaultValue => "b0",
    },
    RqmFreeFifoEcc_1bErrInitiate => { #Structure Type: RegField;
      Name => "RqmFreeFifoEcc_1bErrInitiate",
      RegMem => "RegField",
      Description => "When this bit is set, ECC 1b Error will be initiated",
      Width => "1",
      Position => "30",
      Type => "Config",
      UsedBy => "MEM",
      DefaultValue => "b0",
    },
    voqcgmProfileEcc_1bErrInitiate => { #Structure Type: RegField;
      Name => "voqcgmProfileEcc_1bErrInitiate",
      RegMem => "RegField",
      Description => "When this bit is set, ECC 1b Error will be initiated",
      Width => "1",
      Position => "31",
      Type => "Config",
      UsedBy => "MEM",
      DefaultValue => "b0",
    },
    DramCgmProfileEcc_1bErrInitiate => { #Structure Type: RegField;
      Name => "DramCgmProfileEcc_1bErrInitiate",
      RegMem => "RegField",
      Description => "When this bit is set, ECC 1b Error will be initiated",
      Width => "1",
      Position => "32",
      Type => "Config",
      UsedBy => "MEM",
      DefaultValue => "b0",
    },
    BuffersConsumptionLutForEnqEcc_1bErrInitiate => { #Structure Type: RegField;
      Name => "BuffersConsumptionLutForEnqEcc_1bErrInitiate",
      RegMem => "RegField",
      Description => "When this bit is set, ECC 1b Error will be initiated",
      Width => "1",
      Position => "33",
      Type => "Config",
      UsedBy => "MEM",
      DefaultValue => "b0",
    },
    PdConsumptionLutForEnqEcc_1bErrInitiate => { #Structure Type: RegField;
      Name => "PdConsumptionLutForEnqEcc_1bErrInitiate",
      RegMem => "RegField",
      Description => "When this bit is set, ECC 1b Error will be initiated",
      Width => "1",
      Position => "34",
      Type => "Config",
      UsedBy => "MEM",
      DefaultValue => "b0",
    },
    VoqEnqRptSizeForEnqEcc_1bErrInitiate => { #Structure Type: RegField;
      Name => "VoqEnqRptSizeForEnqEcc_1bErrInitiate",
      RegMem => "RegField",
      Description => "When this bit is set, ECC 1b Error will be initiated",
      Width => "1",
      Position => "35",
      Type => "Config",
      UsedBy => "MEM",
      DefaultValue => "b0",
    },
    VoqDeqRptSizeForEnqEcc_1bErrInitiate => { #Structure Type: RegField;
      Name => "VoqDeqRptSizeForEnqEcc_1bErrInitiate",
      RegMem => "RegField",
      Description => "When this bit is set, ECC 1b Error will be initiated",
      Width => "1",
      Position => "36",
      Type => "Config",
      UsedBy => "MEM",
      DefaultValue => "b0",
    },
    VoqEnqRptSizeForDeqEcc_1bErrInitiate => { #Structure Type: RegField;
      Name => "VoqEnqRptSizeForDeqEcc_1bErrInitiate",
      RegMem => "RegField",
      Description => "When this bit is set, ECC 1b Error will be initiated",
      Width => "1",
      Position => "37",
      Type => "Config",
      UsedBy => "MEM",
      DefaultValue => "b0",
    },
    VoqDeqRptSizeForDeqEcc_1bErrInitiate => { #Structure Type: RegField;
      Name => "VoqDeqRptSizeForDeqEcc_1bErrInitiate",
      RegMem => "RegField",
      Description => "When this bit is set, ECC 1b Error will be initiated",
      Width => "1",
      Position => "38",
      Type => "Config",
      UsedBy => "MEM",
      DefaultValue => "b0",
    },
    LastRptEnqSetMemEcc_1bErrInitiate => { #Structure Type: RegField;
      Name => "LastRptEnqSetMemEcc_1bErrInitiate",
      RegMem => "RegField",
      Description => "When this bit is set, ECC 1b Error will be initiated",
      Width => "1",
      Position => "39",
      Type => "Config",
      UsedBy => "MEM",
      DefaultValue => "b0",
    },
    LastRptEnqSetMemExtraEcc_1bErrInitiate => { #Structure Type: RegField;
      Name => "LastRptEnqSetMemExtraEcc_1bErrInitiate",
      RegMem => "RegField",
      Description => "When this bit is set, ECC 1b Error will be initiated",
      Width => "1",
      Position => "40",
      Type => "Config",
      UsedBy => "MEM",
      DefaultValue => "b0",
    },
    LastRptEnqClrMemEcc_1bErrInitiate => { #Structure Type: RegField;
      Name => "LastRptEnqClrMemEcc_1bErrInitiate",
      RegMem => "RegField",
      Description => "When this bit is set, ECC 1b Error will be initiated",
      Width => "1",
      Position => "41",
      Type => "Config",
      UsedBy => "MEM",
      DefaultValue => "b0",
    },
    LastRptEnqClrMemExtraEcc_1bErrInitiate => { #Structure Type: RegField;
      Name => "LastRptEnqClrMemExtraEcc_1bErrInitiate",
      RegMem => "RegField",
      Description => "When this bit is set, ECC 1b Error will be initiated",
      Width => "1",
      Position => "42",
      Type => "Config",
      UsedBy => "MEM",
      DefaultValue => "b0",
    },
    VoqTenqHeadEnqEcc_1bErrInitiate => { #Structure Type: RegField;
      Name => "VoqTenqHeadEnqEcc_1bErrInitiate",
      RegMem => "RegField",
      Description => "When this bit is set, ECC 1b Error will be initiated",
      Width => "1",
      Position => "43",
      Type => "Config",
      UsedBy => "MEM",
      DefaultValue => "b0",
    },
    VoqTenqHeadRdEcc_1bErrInitiate => { #Structure Type: RegField;
      Name => "VoqTenqHeadRdEcc_1bErrInitiate",
      RegMem => "RegField",
      Description => "When this bit is set, ECC 1b Error will be initiated",
      Width => "1",
      Position => "44",
      Type => "Config",
      UsedBy => "MEM",
      DefaultValue => "b0",
    },
    VoqTenqHeadMsbEnqEcc_1bErrInitiate => { #Structure Type: RegField;
      Name => "VoqTenqHeadMsbEnqEcc_1bErrInitiate",
      RegMem => "RegField",
      Description => "When this bit is set, ECC 1b Error will be initiated",
      Width => "1",
      Position => "45",
      Type => "Config",
      UsedBy => "MEM",
      DefaultValue => "b0",
    },
    VoqTenqHeadMsbRdEcc_1bErrInitiate => { #Structure Type: RegField;
      Name => "VoqTenqHeadMsbRdEcc_1bErrInitiate",
      RegMem => "RegField",
      Description => "When this bit is set, ECC 1b Error will be initiated",
      Width => "1",
      Position => "46",
      Type => "Config",
      UsedBy => "MEM",
      DefaultValue => "b0",
    },
    HeadTimeEnqSetMemEcc_1bErrInitiate => { #Structure Type: RegField;
      Name => "HeadTimeEnqSetMemEcc_1bErrInitiate",
      RegMem => "RegField",
      Description => "When this bit is set, ECC 1b Error will be initiated",
      Width => "1",
      Position => "47",
      Type => "Config",
      UsedBy => "MEM",
      DefaultValue => "b0",
    },
    HeadTimeEnqSetMemExtraEcc_1bErrInitiate => { #Structure Type: RegField;
      Name => "HeadTimeEnqSetMemExtraEcc_1bErrInitiate",
      RegMem => "RegField",
      Description => "When this bit is set, ECC 1b Error will be initiated",
      Width => "1",
      Position => "48",
      Type => "Config",
      UsedBy => "MEM",
      DefaultValue => "b0",
    },
    HeadTimeEnqClrMemEcc_1bErrInitiate => { #Structure Type: RegField;
      Name => "HeadTimeEnqClrMemEcc_1bErrInitiate",
      RegMem => "RegField",
      Description => "When this bit is set, ECC 1b Error will be initiated",
      Width => "1",
      Position => "49",
      Type => "Config",
      UsedBy => "MEM",
      DefaultValue => "b0",
    },
    HeadTimeEnqClrMemExtraEcc_1bErrInitiate => { #Structure Type: RegField;
      Name => "HeadTimeEnqClrMemExtraEcc_1bErrInitiate",
      RegMem => "RegField",
      Description => "When this bit is set, ECC 1b Error will be initiated",
      Width => "1",
      Position => "50",
      Type => "Config",
      UsedBy => "MEM",
      DefaultValue => "b0",
    },
    IsAgingSetMemEcc_1bErrInitiate => { #Structure Type: RegField;
      Name => "IsAgingSetMemEcc_1bErrInitiate",
      RegMem => "RegField",
      Description => "When this bit is set, ECC 1b Error will be initiated",
      Width => "1",
      Position => "51",
      Type => "Config",
      UsedBy => "MEM",
      DefaultValue => "b0",
    },
    IsAgingClrMemEcc_1bErrInitiate => { #Structure Type: RegField;
      Name => "IsAgingClrMemEcc_1bErrInitiate",
      RegMem => "RegField",
      Description => "When this bit is set, ECC 1b Error will be initiated",
      Width => "1",
      Position => "52",
      Type => "Config",
      UsedBy => "MEM",
      DefaultValue => "b0",
    },
    AdmissionResultDramEcc_1bErrInitiate => { #Structure Type: RegField;
      Name => "AdmissionResultDramEcc_1bErrInitiate",
      RegMem => "RegField",
      Description => "When this bit is set, ECC 1b Error will be initiated",
      Width => "1",
      Position => "53",
      Type => "Config",
      UsedBy => "MEM",
      DefaultValue => "b0",
    },
    WredRegionEcc_1bErrInitiate => { #Structure Type: RegField;
      Name => "WredRegionEcc_1bErrInitiate",
      RegMem => "RegField",
      Description => "When this bit is set, ECC 1b Error will be initiated",
      Width => "1",
      Position => "54",
      Type => "Config",
      UsedBy => "MEM",
      DefaultValue => "b0",
    },
  },
  Ecc_2bErrInitiateRegister => { #Structure Type: Reg; Skip Register;
    Name => "Ecc_2bErrInitiateRegister",
    RegMem => "Reg",
    Address => "31",
    Description => "ECC 2b Error Initiator Register",
    Width => "55",
    Type => "Config",
    rdrqsnEcc_2bErrInitiate => { #Structure Type: RegField;
      Name => "rdrqsnEcc_2bErrInitiate",
      RegMem => "RegField",
      Description => "When this bit is set, ECC 2b Error will be initiated",
      Width => "1",
      Position => "0",
      Type => "Config",
      UsedBy => "MEM",
      DefaultValue => "b0",
    },
    rdsnEcc_2bErrInitiate => { #Structure Type: RegField;
      Name => "rdsnEcc_2bErrInitiate",
      RegMem => "RegField",
      Description => "When this bit is set, ECC 2b Error will be initiated",
      Width => "1",
      Position => "1",
      Type => "Config",
      UsedBy => "MEM",
      DefaultValue => "b0",
    },
    rdbcEcc_2bErrInitiate => { #Structure Type: RegField;
      Name => "rdbcEcc_2bErrInitiate",
      RegMem => "RegField",
      Description => "When this bit is set, ECC 2b Error will be initiated",
      Width => "1",
      Position => "2",
      Type => "Config",
      UsedBy => "MEM",
      DefaultValue => "b0",
    },
    rdbufcntEcc_2bErrInitiate => { #Structure Type: RegField;
      Name => "rdbufcntEcc_2bErrInitiate",
      RegMem => "RegField",
      Description => "When this bit is set, ECC 2b Error will be initiated",
      Width => "1",
      Position => "3",
      Type => "Config",
      UsedBy => "MEM",
      DefaultValue => "b0",
    },
    wrrqsnEcc_2bErrInitiate => { #Structure Type: RegField;
      Name => "wrrqsnEcc_2bErrInitiate",
      RegMem => "RegField",
      Description => "When this bit is set, ECC 2b Error will be initiated",
      Width => "1",
      Position => "4",
      Type => "Config",
      UsedBy => "MEM",
      DefaultValue => "b0",
    },
    wrsnEcc_2bErrInitiate => { #Structure Type: RegField;
      Name => "wrsnEcc_2bErrInitiate",
      RegMem => "RegField",
      Description => "When this bit is set, ECC 2b Error will be initiated",
      Width => "1",
      Position => "5",
      Type => "Config",
      UsedBy => "MEM",
      DefaultValue => "b0",
    },
    wrbcEcc_2bErrInitiate => { #Structure Type: RegField;
      Name => "wrbcEcc_2bErrInitiate",
      RegMem => "RegField",
      Description => "When this bit is set, ECC 2b Error will be initiated",
      Width => "1",
      Position => "6",
      Type => "Config",
      UsedBy => "MEM",
      DefaultValue => "b0",
    },
    wrbufcntEcc_2bErrInitiate => { #Structure Type: RegField;
      Name => "wrbufcntEcc_2bErrInitiate",
      RegMem => "RegField",
      Description => "When this bit is set, ECC 2b Error will be initiated",
      Width => "1",
      Position => "7",
      Type => "Config",
      UsedBy => "MEM",
      DefaultValue => "b0",
    },
    voq2contextEcc_2bErrInitiate => { #Structure Type: RegField;
      Name => "voq2contextEcc_2bErrInitiate",
      RegMem => "RegField",
      Description => "When this bit is set, ECC 2b Error will be initiated",
      Width => "1",
      Position => "8",
      Type => "Config",
      UsedBy => "MEM",
      DefaultValue => "b0",
    },
    CandRelFifoEcc_2bErrInitiate => { #Structure Type: RegField;
      Name => "CandRelFifoEcc_2bErrInitiate",
      RegMem => "RegField",
      Description => "When this bit is set, ECC 2b Error will be initiated",
      Width => "1",
      Position => "9",
      Type => "Config",
      UsedBy => "MEM",
      DefaultValue => "b0",
    },
    InCandRelFifoSetEcc_2bErrInitiate => { #Structure Type: RegField;
      Name => "InCandRelFifoSetEcc_2bErrInitiate",
      RegMem => "RegField",
      Description => "When this bit is set, ECC 2b Error will be initiated",
      Width => "1",
      Position => "10",
      Type => "Config",
      UsedBy => "MEM",
      DefaultValue => "b0",
    },
    InCandRelFifoClrEcc_2bErrInitiate => { #Structure Type: RegField;
      Name => "InCandRelFifoClrEcc_2bErrInitiate",
      RegMem => "RegField",
      Description => "When this bit is set, ECC 2b Error will be initiated",
      Width => "1",
      Position => "11",
      Type => "Config",
      UsedBy => "MEM",
      DefaultValue => "b0",
    },
    ContextReleaseEligibleSetEcc_2bErrInitiate => { #Structure Type: RegField;
      Name => "ContextReleaseEligibleSetEcc_2bErrInitiate",
      RegMem => "RegField",
      Description => "When this bit is set, ECC 2b Error will be initiated",
      Width => "1",
      Position => "12",
      Type => "Config",
      UsedBy => "MEM",
      DefaultValue => "b0",
    },
    ContextReleaseEligibleClrEcc_2bErrInitiate => { #Structure Type: RegField;
      Name => "ContextReleaseEligibleClrEcc_2bErrInitiate",
      RegMem => "RegField",
      Description => "When this bit is set, ECC 2b Error will be initiated",
      Width => "1",
      Position => "13",
      Type => "Config",
      UsedBy => "MEM",
      DefaultValue => "b0",
    },
    ContextInDramSetEcc_2bErrInitiate => { #Structure Type: RegField;
      Name => "ContextInDramSetEcc_2bErrInitiate",
      RegMem => "RegField",
      Description => "When this bit is set, ECC 2b Error will be initiated",
      Width => "1",
      Position => "14",
      Type => "Config",
      UsedBy => "MEM",
      DefaultValue => "b0",
    },
    ContextInDramClrEcc_2bErrInitiate => { #Structure Type: RegField;
      Name => "ContextInDramClrEcc_2bErrInitiate",
      RegMem => "RegField",
      Description => "When this bit is set, ECC 2b Error will be initiated",
      Width => "1",
      Position => "15",
      Type => "Config",
      UsedBy => "MEM",
      DefaultValue => "b0",
    },
    ContextMapValidSetEcc_2bErrInitiate => { #Structure Type: RegField;
      Name => "ContextMapValidSetEcc_2bErrInitiate",
      RegMem => "RegField",
      Description => "When this bit is set, ECC 2b Error will be initiated",
      Width => "1",
      Position => "16",
      Type => "Config",
      UsedBy => "MEM",
      DefaultValue => "b0",
    },
    ContextMapValidClrEcc_2bErrInitiate => { #Structure Type: RegField;
      Name => "ContextMapValidClrEcc_2bErrInitiate",
      RegMem => "RegField",
      Description => "When this bit is set, ECC 2b Error will be initiated",
      Width => "1",
      Position => "17",
      Type => "Config",
      UsedBy => "MEM",
      DefaultValue => "b0",
    },
    contextfbmBmpEcc_2bErrInitiate => { #Structure Type: RegField;
      Name => "contextfbmBmpEcc_2bErrInitiate",
      RegMem => "RegField",
      Description => "When this bit is set, ECC 2b Error will be initiated",
      Width => "1",
      Position => "18",
      Type => "Config",
      UsedBy => "MEM",
      DefaultValue => "b0",
    },
    NewVoqSetEcc_2bErrInitiate => { #Structure Type: RegField;
      Name => "NewVoqSetEcc_2bErrInitiate",
      RegMem => "RegField",
      Description => "When this bit is set, ECC 2b Error will be initiated",
      Width => "1",
      Position => "19",
      Type => "Config",
      UsedBy => "MEM",
      DefaultValue => "b0",
    },
    NewVoqClrEcc_2bErrInitiate => { #Structure Type: RegField;
      Name => "NewVoqClrEcc_2bErrInitiate",
      RegMem => "RegField",
      Description => "When this bit is set, ECC 2b Error will be initiated",
      Width => "1",
      Position => "20",
      Type => "Config",
      UsedBy => "MEM",
      DefaultValue => "b0",
    },
    voqPropertiesEcc_2bErrInitiate => { #Structure Type: RegField;
      Name => "voqPropertiesEcc_2bErrInitiate",
      RegMem => "RegField",
      Description => "When this bit is set, ECC 2b Error will be initiated",
      Width => "1",
      Position => "21",
      Type => "Config",
      UsedBy => "MEM",
      DefaultValue => "b0",
    },
    staticMappingEcc_2bErrInitiate => { #Structure Type: RegField;
      Name => "staticMappingEcc_2bErrInitiate",
      RegMem => "RegField",
      Description => "When this bit is set, ECC 2b Error will be initiated",
      Width => "1",
      Position => "22",
      Type => "Config",
      UsedBy => "MEM",
      DefaultValue => "b0",
    },
    context_allocate_set_masterEcc_2bErrInitiate => { #Structure Type: RegField;
      Name => "context_allocate_set_masterEcc_2bErrInitiate",
      RegMem => "RegField",
      Description => "When this bit is set, ECC 2b Error will be initiated",
      Width => "1",
      Position => "23",
      Type => "Config",
      UsedBy => "MEM",
      DefaultValue => "b0",
    },
    context_allocate_set_slaveEcc_2bErrInitiate => { #Structure Type: RegField;
      Name => "context_allocate_set_slaveEcc_2bErrInitiate",
      RegMem => "RegField",
      Description => "When this bit is set, ECC 2b Error will be initiated",
      Width => "1",
      Position => "24",
      Type => "Config",
      UsedBy => "MEM",
      DefaultValue => "b0",
    },
    context_allocate_clr_masterEcc_2bErrInitiate => { #Structure Type: RegField;
      Name => "context_allocate_clr_masterEcc_2bErrInitiate",
      RegMem => "RegField",
      Description => "When this bit is set, ECC 2b Error will be initiated",
      Width => "1",
      Position => "25",
      Type => "Config",
      UsedBy => "MEM",
      DefaultValue => "b0",
    },
    context_allocate_clr_slaveEcc_2bErrInitiate => { #Structure Type: RegField;
      Name => "context_allocate_clr_slaveEcc_2bErrInitiate",
      RegMem => "RegField",
      Description => "When this bit is set, ECC 2b Error will be initiated",
      Width => "1",
      Position => "26",
      Type => "Config",
      UsedBy => "MEM",
      DefaultValue => "b0",
    },
    context_allocate_grant_setEcc_2bErrInitiate => { #Structure Type: RegField;
      Name => "context_allocate_grant_setEcc_2bErrInitiate",
      RegMem => "RegField",
      Description => "When this bit is set, ECC 2b Error will be initiated",
      Width => "1",
      Position => "27",
      Type => "Config",
      UsedBy => "MEM",
      DefaultValue => "b0",
    },
    context_allocate_grant_clrEcc_2bErrInitiate => { #Structure Type: RegField;
      Name => "context_allocate_grant_clrEcc_2bErrInitiate",
      RegMem => "RegField",
      Description => "When this bit is set, ECC 2b Error will be initiated",
      Width => "1",
      Position => "28",
      Type => "Config",
      UsedBy => "MEM",
      DefaultValue => "b0",
    },
    Context2voqEcc_2bErrInitiate => { #Structure Type: RegField;
      Name => "Context2voqEcc_2bErrInitiate",
      RegMem => "RegField",
      Description => "When this bit is set, ECC 2b Error will be initiated",
      Width => "1",
      Position => "29",
      Type => "Config",
      UsedBy => "MEM",
      DefaultValue => "b0",
    },
    RqmFreeFifoEcc_2bErrInitiate => { #Structure Type: RegField;
      Name => "RqmFreeFifoEcc_2bErrInitiate",
      RegMem => "RegField",
      Description => "When this bit is set, ECC 2b Error will be initiated",
      Width => "1",
      Position => "30",
      Type => "Config",
      UsedBy => "MEM",
      DefaultValue => "b0",
    },
    voqcgmProfileEcc_2bErrInitiate => { #Structure Type: RegField;
      Name => "voqcgmProfileEcc_2bErrInitiate",
      RegMem => "RegField",
      Description => "When this bit is set, ECC 2b Error will be initiated",
      Width => "1",
      Position => "31",
      Type => "Config",
      UsedBy => "MEM",
      DefaultValue => "b0",
    },
    DramCgmProfileEcc_2bErrInitiate => { #Structure Type: RegField;
      Name => "DramCgmProfileEcc_2bErrInitiate",
      RegMem => "RegField",
      Description => "When this bit is set, ECC 2b Error will be initiated",
      Width => "1",
      Position => "32",
      Type => "Config",
      UsedBy => "MEM",
      DefaultValue => "b0",
    },
    BuffersConsumptionLutForEnqEcc_2bErrInitiate => { #Structure Type: RegField;
      Name => "BuffersConsumptionLutForEnqEcc_2bErrInitiate",
      RegMem => "RegField",
      Description => "When this bit is set, ECC 2b Error will be initiated",
      Width => "1",
      Position => "33",
      Type => "Config",
      UsedBy => "MEM",
      DefaultValue => "b0",
    },
    PdConsumptionLutForEnqEcc_2bErrInitiate => { #Structure Type: RegField;
      Name => "PdConsumptionLutForEnqEcc_2bErrInitiate",
      RegMem => "RegField",
      Description => "When this bit is set, ECC 2b Error will be initiated",
      Width => "1",
      Position => "34",
      Type => "Config",
      UsedBy => "MEM",
      DefaultValue => "b0",
    },
    VoqEnqRptSizeForEnqEcc_2bErrInitiate => { #Structure Type: RegField;
      Name => "VoqEnqRptSizeForEnqEcc_2bErrInitiate",
      RegMem => "RegField",
      Description => "When this bit is set, ECC 2b Error will be initiated",
      Width => "1",
      Position => "35",
      Type => "Config",
      UsedBy => "MEM",
      DefaultValue => "b0",
    },
    VoqDeqRptSizeForEnqEcc_2bErrInitiate => { #Structure Type: RegField;
      Name => "VoqDeqRptSizeForEnqEcc_2bErrInitiate",
      RegMem => "RegField",
      Description => "When this bit is set, ECC 2b Error will be initiated",
      Width => "1",
      Position => "36",
      Type => "Config",
      UsedBy => "MEM",
      DefaultValue => "b0",
    },
    VoqEnqRptSizeForDeqEcc_2bErrInitiate => { #Structure Type: RegField;
      Name => "VoqEnqRptSizeForDeqEcc_2bErrInitiate",
      RegMem => "RegField",
      Description => "When this bit is set, ECC 2b Error will be initiated",
      Width => "1",
      Position => "37",
      Type => "Config",
      UsedBy => "MEM",
      DefaultValue => "b0",
    },
    VoqDeqRptSizeForDeqEcc_2bErrInitiate => { #Structure Type: RegField;
      Name => "VoqDeqRptSizeForDeqEcc_2bErrInitiate",
      RegMem => "RegField",
      Description => "When this bit is set, ECC 2b Error will be initiated",
      Width => "1",
      Position => "38",
      Type => "Config",
      UsedBy => "MEM",
      DefaultValue => "b0",
    },
    LastRptEnqSetMemEcc_2bErrInitiate => { #Structure Type: RegField;
      Name => "LastRptEnqSetMemEcc_2bErrInitiate",
      RegMem => "RegField",
      Description => "When this bit is set, ECC 2b Error will be initiated",
      Width => "1",
      Position => "39",
      Type => "Config",
      UsedBy => "MEM",
      DefaultValue => "b0",
    },
    LastRptEnqSetMemExtraEcc_2bErrInitiate => { #Structure Type: RegField;
      Name => "LastRptEnqSetMemExtraEcc_2bErrInitiate",
      RegMem => "RegField",
      Description => "When this bit is set, ECC 2b Error will be initiated",
      Width => "1",
      Position => "40",
      Type => "Config",
      UsedBy => "MEM",
      DefaultValue => "b0",
    },
    LastRptEnqClrMemEcc_2bErrInitiate => { #Structure Type: RegField;
      Name => "LastRptEnqClrMemEcc_2bErrInitiate",
      RegMem => "RegField",
      Description => "When this bit is set, ECC 2b Error will be initiated",
      Width => "1",
      Position => "41",
      Type => "Config",
      UsedBy => "MEM",
      DefaultValue => "b0",
    },
    LastRptEnqClrMemExtraEcc_2bErrInitiate => { #Structure Type: RegField;
      Name => "LastRptEnqClrMemExtraEcc_2bErrInitiate",
      RegMem => "RegField",
      Description => "When this bit is set, ECC 2b Error will be initiated",
      Width => "1",
      Position => "42",
      Type => "Config",
      UsedBy => "MEM",
      DefaultValue => "b0",
    },
    VoqTenqHeadEnqEcc_2bErrInitiate => { #Structure Type: RegField;
      Name => "VoqTenqHeadEnqEcc_2bErrInitiate",
      RegMem => "RegField",
      Description => "When this bit is set, ECC 2b Error will be initiated",
      Width => "1",
      Position => "43",
      Type => "Config",
      UsedBy => "MEM",
      DefaultValue => "b0",
    },
    VoqTenqHeadRdEcc_2bErrInitiate => { #Structure Type: RegField;
      Name => "VoqTenqHeadRdEcc_2bErrInitiate",
      RegMem => "RegField",
      Description => "When this bit is set, ECC 2b Error will be initiated",
      Width => "1",
      Position => "44",
      Type => "Config",
      UsedBy => "MEM",
      DefaultValue => "b0",
    },
    VoqTenqHeadMsbEnqEcc_2bErrInitiate => { #Structure Type: RegField;
      Name => "VoqTenqHeadMsbEnqEcc_2bErrInitiate",
      RegMem => "RegField",
      Description => "When this bit is set, ECC 2b Error will be initiated",
      Width => "1",
      Position => "45",
      Type => "Config",
      UsedBy => "MEM",
      DefaultValue => "b0",
    },
    VoqTenqHeadMsbRdEcc_2bErrInitiate => { #Structure Type: RegField;
      Name => "VoqTenqHeadMsbRdEcc_2bErrInitiate",
      RegMem => "RegField",
      Description => "When this bit is set, ECC 2b Error will be initiated",
      Width => "1",
      Position => "46",
      Type => "Config",
      UsedBy => "MEM",
      DefaultValue => "b0",
    },
    HeadTimeEnqSetMemEcc_2bErrInitiate => { #Structure Type: RegField;
      Name => "HeadTimeEnqSetMemEcc_2bErrInitiate",
      RegMem => "RegField",
      Description => "When this bit is set, ECC 2b Error will be initiated",
      Width => "1",
      Position => "47",
      Type => "Config",
      UsedBy => "MEM",
      DefaultValue => "b0",
    },
    HeadTimeEnqSetMemExtraEcc_2bErrInitiate => { #Structure Type: RegField;
      Name => "HeadTimeEnqSetMemExtraEcc_2bErrInitiate",
      RegMem => "RegField",
      Description => "When this bit is set, ECC 2b Error will be initiated",
      Width => "1",
      Position => "48",
      Type => "Config",
      UsedBy => "MEM",
      DefaultValue => "b0",
    },
    HeadTimeEnqClrMemEcc_2bErrInitiate => { #Structure Type: RegField;
      Name => "HeadTimeEnqClrMemEcc_2bErrInitiate",
      RegMem => "RegField",
      Description => "When this bit is set, ECC 2b Error will be initiated",
      Width => "1",
      Position => "49",
      Type => "Config",
      UsedBy => "MEM",
      DefaultValue => "b0",
    },
    HeadTimeEnqClrMemExtraEcc_2bErrInitiate => { #Structure Type: RegField;
      Name => "HeadTimeEnqClrMemExtraEcc_2bErrInitiate",
      RegMem => "RegField",
      Description => "When this bit is set, ECC 2b Error will be initiated",
      Width => "1",
      Position => "50",
      Type => "Config",
      UsedBy => "MEM",
      DefaultValue => "b0",
    },
    IsAgingSetMemEcc_2bErrInitiate => { #Structure Type: RegField;
      Name => "IsAgingSetMemEcc_2bErrInitiate",
      RegMem => "RegField",
      Description => "When this bit is set, ECC 2b Error will be initiated",
      Width => "1",
      Position => "51",
      Type => "Config",
      UsedBy => "MEM",
      DefaultValue => "b0",
    },
    IsAgingClrMemEcc_2bErrInitiate => { #Structure Type: RegField;
      Name => "IsAgingClrMemEcc_2bErrInitiate",
      RegMem => "RegField",
      Description => "When this bit is set, ECC 2b Error will be initiated",
      Width => "1",
      Position => "52",
      Type => "Config",
      UsedBy => "MEM",
      DefaultValue => "b0",
    },
    AdmissionResultDramEcc_2bErrInitiate => { #Structure Type: RegField;
      Name => "AdmissionResultDramEcc_2bErrInitiate",
      RegMem => "RegField",
      Description => "When this bit is set, ECC 2b Error will be initiated",
      Width => "1",
      Position => "53",
      Type => "Config",
      UsedBy => "MEM",
      DefaultValue => "b0",
    },
    WredRegionEcc_2bErrInitiate => { #Structure Type: RegField;
      Name => "WredRegionEcc_2bErrInitiate",
      RegMem => "RegField",
      Description => "When this bit is set, ECC 2b Error will be initiated",
      Width => "1",
      Position => "54",
      Type => "Config",
      UsedBy => "MEM",
      DefaultValue => "b0",
    },
  },
  MemProtectErrStatus => { #Structure Type: Reg; Skip Register;
    Name => "MemProtectErrStatus",
    RegMem => "Reg",
    Address => "33",
    Description => "Memory SER protected error status",
    Width => "55",
    Type => "ReadOnly",
    rdrqsnErrInt => { #Structure Type: RegField;
      Name => "rdrqsnErrInt",
      RegMem => "RegField",
      Description => "When this bit is set, SER Error occured",
      Width => "1",
      Position => "0",
      Type => "Status",
      UsedBy => "SER",
    },
    rdsnErrInt => { #Structure Type: RegField;
      Name => "rdsnErrInt",
      RegMem => "RegField",
      Description => "When this bit is set, SER Error occured",
      Width => "1",
      Position => "1",
      Type => "Status",
      UsedBy => "SER",
    },
    rdbcErrInt => { #Structure Type: RegField;
      Name => "rdbcErrInt",
      RegMem => "RegField",
      Description => "When this bit is set, SER Error occured",
      Width => "1",
      Position => "2",
      Type => "Status",
      UsedBy => "SER",
    },
    rdbufcntErrInt => { #Structure Type: RegField;
      Name => "rdbufcntErrInt",
      RegMem => "RegField",
      Description => "When this bit is set, SER Error occured",
      Width => "1",
      Position => "3",
      Type => "Status",
      UsedBy => "SER",
    },
    wrrqsnErrInt => { #Structure Type: RegField;
      Name => "wrrqsnErrInt",
      RegMem => "RegField",
      Description => "When this bit is set, SER Error occured",
      Width => "1",
      Position => "4",
      Type => "Status",
      UsedBy => "SER",
    },
    wrsnErrInt => { #Structure Type: RegField;
      Name => "wrsnErrInt",
      RegMem => "RegField",
      Description => "When this bit is set, SER Error occured",
      Width => "1",
      Position => "5",
      Type => "Status",
      UsedBy => "SER",
    },
    wrbcErrInt => { #Structure Type: RegField;
      Name => "wrbcErrInt",
      RegMem => "RegField",
      Description => "When this bit is set, SER Error occured",
      Width => "1",
      Position => "6",
      Type => "Status",
      UsedBy => "SER",
    },
    wrbufcntErrInt => { #Structure Type: RegField;
      Name => "wrbufcntErrInt",
      RegMem => "RegField",
      Description => "When this bit is set, SER Error occured",
      Width => "1",
      Position => "7",
      Type => "Status",
      UsedBy => "SER",
    },
    voq2contextErrInt => { #Structure Type: RegField;
      Name => "voq2contextErrInt",
      RegMem => "RegField",
      Description => "When this bit is set, SER Error occured",
      Width => "1",
      Position => "8",
      Type => "Status",
      UsedBy => "SER",
    },
    CandRelFifoErrInt => { #Structure Type: RegField;
      Name => "CandRelFifoErrInt",
      RegMem => "RegField",
      Description => "When this bit is set, SER Error occured",
      Width => "1",
      Position => "9",
      Type => "Status",
      UsedBy => "SER",
    },
    InCandRelFifoSetErrInt => { #Structure Type: RegField;
      Name => "InCandRelFifoSetErrInt",
      RegMem => "RegField",
      Description => "When this bit is set, SER Error occured",
      Width => "1",
      Position => "10",
      Type => "Status",
      UsedBy => "SER",
    },
    InCandRelFifoClrErrInt => { #Structure Type: RegField;
      Name => "InCandRelFifoClrErrInt",
      RegMem => "RegField",
      Description => "When this bit is set, SER Error occured",
      Width => "1",
      Position => "11",
      Type => "Status",
      UsedBy => "SER",
    },
    ContextReleaseEligibleSetErrInt => { #Structure Type: RegField;
      Name => "ContextReleaseEligibleSetErrInt",
      RegMem => "RegField",
      Description => "When this bit is set, SER Error occured",
      Width => "1",
      Position => "12",
      Type => "Status",
      UsedBy => "SER",
    },
    ContextReleaseEligibleClrErrInt => { #Structure Type: RegField;
      Name => "ContextReleaseEligibleClrErrInt",
      RegMem => "RegField",
      Description => "When this bit is set, SER Error occured",
      Width => "1",
      Position => "13",
      Type => "Status",
      UsedBy => "SER",
    },
    ContextInDramSetErrInt => { #Structure Type: RegField;
      Name => "ContextInDramSetErrInt",
      RegMem => "RegField",
      Description => "When this bit is set, SER Error occured",
      Width => "1",
      Position => "14",
      Type => "Status",
      UsedBy => "SER",
    },
    ContextInDramClrErrInt => { #Structure Type: RegField;
      Name => "ContextInDramClrErrInt",
      RegMem => "RegField",
      Description => "When this bit is set, SER Error occured",
      Width => "1",
      Position => "15",
      Type => "Status",
      UsedBy => "SER",
    },
    ContextMapValidSetErrInt => { #Structure Type: RegField;
      Name => "ContextMapValidSetErrInt",
      RegMem => "RegField",
      Description => "When this bit is set, SER Error occured",
      Width => "1",
      Position => "16",
      Type => "Status",
      UsedBy => "SER",
    },
    ContextMapValidClrErrInt => { #Structure Type: RegField;
      Name => "ContextMapValidClrErrInt",
      RegMem => "RegField",
      Description => "When this bit is set, SER Error occured",
      Width => "1",
      Position => "17",
      Type => "Status",
      UsedBy => "SER",
    },
    contextfbmBmpErrInt => { #Structure Type: RegField;
      Name => "contextfbmBmpErrInt",
      RegMem => "RegField",
      Description => "When this bit is set, SER Error occured",
      Width => "1",
      Position => "18",
      Type => "Status",
      UsedBy => "SER",
    },
    NewVoqSetErrInt => { #Structure Type: RegField;
      Name => "NewVoqSetErrInt",
      RegMem => "RegField",
      Description => "When this bit is set, SER Error occured",
      Width => "1",
      Position => "19",
      Type => "Status",
      UsedBy => "SER",
    },
    NewVoqClrErrInt => { #Structure Type: RegField;
      Name => "NewVoqClrErrInt",
      RegMem => "RegField",
      Description => "When this bit is set, SER Error occured",
      Width => "1",
      Position => "20",
      Type => "Status",
      UsedBy => "SER",
    },
    voqPropertiesErrInt => { #Structure Type: RegField;
      Name => "voqPropertiesErrInt",
      RegMem => "RegField",
      Description => "When this bit is set, SER Error occured",
      Width => "1",
      Position => "21",
      Type => "Status",
      UsedBy => "SER",
    },
    staticMappingErrInt => { #Structure Type: RegField;
      Name => "staticMappingErrInt",
      RegMem => "RegField",
      Description => "When this bit is set, SER Error occured",
      Width => "1",
      Position => "22",
      Type => "Status",
      UsedBy => "SER",
    },
    context_allocate_set_masterErrInt => { #Structure Type: RegField;
      Name => "context_allocate_set_masterErrInt",
      RegMem => "RegField",
      Description => "When this bit is set, SER Error occured",
      Width => "1",
      Position => "23",
      Type => "Status",
      UsedBy => "SER",
    },
    context_allocate_set_slaveErrInt => { #Structure Type: RegField;
      Name => "context_allocate_set_slaveErrInt",
      RegMem => "RegField",
      Description => "When this bit is set, SER Error occured",
      Width => "1",
      Position => "24",
      Type => "Status",
      UsedBy => "SER",
    },
    context_allocate_clr_masterErrInt => { #Structure Type: RegField;
      Name => "context_allocate_clr_masterErrInt",
      RegMem => "RegField",
      Description => "When this bit is set, SER Error occured",
      Width => "1",
      Position => "25",
      Type => "Status",
      UsedBy => "SER",
    },
    context_allocate_clr_slaveErrInt => { #Structure Type: RegField;
      Name => "context_allocate_clr_slaveErrInt",
      RegMem => "RegField",
      Description => "When this bit is set, SER Error occured",
      Width => "1",
      Position => "26",
      Type => "Status",
      UsedBy => "SER",
    },
    context_allocate_grant_setErrInt => { #Structure Type: RegField;
      Name => "context_allocate_grant_setErrInt",
      RegMem => "RegField",
      Description => "When this bit is set, SER Error occured",
      Width => "1",
      Position => "27",
      Type => "Status",
      UsedBy => "SER",
    },
    context_allocate_grant_clrErrInt => { #Structure Type: RegField;
      Name => "context_allocate_grant_clrErrInt",
      RegMem => "RegField",
      Description => "When this bit is set, SER Error occured",
      Width => "1",
      Position => "28",
      Type => "Status",
      UsedBy => "SER",
    },
    Context2voqErrInt => { #Structure Type: RegField;
      Name => "Context2voqErrInt",
      RegMem => "RegField",
      Description => "When this bit is set, SER Error occured",
      Width => "1",
      Position => "29",
      Type => "Status",
      UsedBy => "SER",
    },
    RqmFreeFifoErrInt => { #Structure Type: RegField;
      Name => "RqmFreeFifoErrInt",
      RegMem => "RegField",
      Description => "When this bit is set, SER Error occured",
      Width => "1",
      Position => "30",
      Type => "Status",
      UsedBy => "SER",
    },
    voqcgmProfileErrInt => { #Structure Type: RegField;
      Name => "voqcgmProfileErrInt",
      RegMem => "RegField",
      Description => "When this bit is set, SER Error occured",
      Width => "1",
      Position => "31",
      Type => "Status",
      UsedBy => "SER",
    },
    DramCgmProfileErrInt => { #Structure Type: RegField;
      Name => "DramCgmProfileErrInt",
      RegMem => "RegField",
      Description => "When this bit is set, SER Error occured",
      Width => "1",
      Position => "32",
      Type => "Status",
      UsedBy => "SER",
    },
    BuffersConsumptionLutForEnqErrInt => { #Structure Type: RegField;
      Name => "BuffersConsumptionLutForEnqErrInt",
      RegMem => "RegField",
      Description => "When this bit is set, SER Error occured",
      Width => "1",
      Position => "33",
      Type => "Status",
      UsedBy => "SER",
    },
    PdConsumptionLutForEnqErrInt => { #Structure Type: RegField;
      Name => "PdConsumptionLutForEnqErrInt",
      RegMem => "RegField",
      Description => "When this bit is set, SER Error occured",
      Width => "1",
      Position => "34",
      Type => "Status",
      UsedBy => "SER",
    },
    VoqEnqRptSizeForEnqErrInt => { #Structure Type: RegField;
      Name => "VoqEnqRptSizeForEnqErrInt",
      RegMem => "RegField",
      Description => "When this bit is set, SER Error occured",
      Width => "1",
      Position => "35",
      Type => "Status",
      UsedBy => "SER",
    },
    VoqDeqRptSizeForEnqErrInt => { #Structure Type: RegField;
      Name => "VoqDeqRptSizeForEnqErrInt",
      RegMem => "RegField",
      Description => "When this bit is set, SER Error occured",
      Width => "1",
      Position => "36",
      Type => "Status",
      UsedBy => "SER",
    },
    VoqEnqRptSizeForDeqErrInt => { #Structure Type: RegField;
      Name => "VoqEnqRptSizeForDeqErrInt",
      RegMem => "RegField",
      Description => "When this bit is set, SER Error occured",
      Width => "1",
      Position => "37",
      Type => "Status",
      UsedBy => "SER",
    },
    VoqDeqRptSizeForDeqErrInt => { #Structure Type: RegField;
      Name => "VoqDeqRptSizeForDeqErrInt",
      RegMem => "RegField",
      Description => "When this bit is set, SER Error occured",
      Width => "1",
      Position => "38",
      Type => "Status",
      UsedBy => "SER",
    },
    LastRptEnqSetMemErrInt => { #Structure Type: RegField;
      Name => "LastRptEnqSetMemErrInt",
      RegMem => "RegField",
      Description => "When this bit is set, SER Error occured",
      Width => "1",
      Position => "39",
      Type => "Status",
      UsedBy => "SER",
    },
    LastRptEnqSetMemExtraErrInt => { #Structure Type: RegField;
      Name => "LastRptEnqSetMemExtraErrInt",
      RegMem => "RegField",
      Description => "When this bit is set, SER Error occured",
      Width => "1",
      Position => "40",
      Type => "Status",
      UsedBy => "SER",
    },
    LastRptEnqClrMemErrInt => { #Structure Type: RegField;
      Name => "LastRptEnqClrMemErrInt",
      RegMem => "RegField",
      Description => "When this bit is set, SER Error occured",
      Width => "1",
      Position => "41",
      Type => "Status",
      UsedBy => "SER",
    },
    LastRptEnqClrMemExtraErrInt => { #Structure Type: RegField;
      Name => "LastRptEnqClrMemExtraErrInt",
      RegMem => "RegField",
      Description => "When this bit is set, SER Error occured",
      Width => "1",
      Position => "42",
      Type => "Status",
      UsedBy => "SER",
    },
    VoqTenqHeadEnqErrInt => { #Structure Type: RegField;
      Name => "VoqTenqHeadEnqErrInt",
      RegMem => "RegField",
      Description => "When this bit is set, SER Error occured",
      Width => "1",
      Position => "43",
      Type => "Status",
      UsedBy => "SER",
    },
    VoqTenqHeadRdErrInt => { #Structure Type: RegField;
      Name => "VoqTenqHeadRdErrInt",
      RegMem => "RegField",
      Description => "When this bit is set, SER Error occured",
      Width => "1",
      Position => "44",
      Type => "Status",
      UsedBy => "SER",
    },
    VoqTenqHeadMsbEnqErrInt => { #Structure Type: RegField;
      Name => "VoqTenqHeadMsbEnqErrInt",
      RegMem => "RegField",
      Description => "When this bit is set, SER Error occured",
      Width => "1",
      Position => "45",
      Type => "Status",
      UsedBy => "SER",
    },
    VoqTenqHeadMsbRdErrInt => { #Structure Type: RegField;
      Name => "VoqTenqHeadMsbRdErrInt",
      RegMem => "RegField",
      Description => "When this bit is set, SER Error occured",
      Width => "1",
      Position => "46",
      Type => "Status",
      UsedBy => "SER",
    },
    HeadTimeEnqSetMemErrInt => { #Structure Type: RegField;
      Name => "HeadTimeEnqSetMemErrInt",
      RegMem => "RegField",
      Description => "When this bit is set, SER Error occured",
      Width => "1",
      Position => "47",
      Type => "Status",
      UsedBy => "SER",
    },
    HeadTimeEnqSetMemExtraErrInt => { #Structure Type: RegField;
      Name => "HeadTimeEnqSetMemExtraErrInt",
      RegMem => "RegField",
      Description => "When this bit is set, SER Error occured",
      Width => "1",
      Position => "48",
      Type => "Status",
      UsedBy => "SER",
    },
    HeadTimeEnqClrMemErrInt => { #Structure Type: RegField;
      Name => "HeadTimeEnqClrMemErrInt",
      RegMem => "RegField",
      Description => "When this bit is set, SER Error occured",
      Width => "1",
      Position => "49",
      Type => "Status",
      UsedBy => "SER",
    },
    HeadTimeEnqClrMemExtraErrInt => { #Structure Type: RegField;
      Name => "HeadTimeEnqClrMemExtraErrInt",
      RegMem => "RegField",
      Description => "When this bit is set, SER Error occured",
      Width => "1",
      Position => "50",
      Type => "Status",
      UsedBy => "SER",
    },
    IsAgingSetMemErrInt => { #Structure Type: RegField;
      Name => "IsAgingSetMemErrInt",
      RegMem => "RegField",
      Description => "When this bit is set, SER Error occured",
      Width => "1",
      Position => "51",
      Type => "Status",
      UsedBy => "SER",
    },
    IsAgingClrMemErrInt => { #Structure Type: RegField;
      Name => "IsAgingClrMemErrInt",
      RegMem => "RegField",
      Description => "When this bit is set, SER Error occured",
      Width => "1",
      Position => "52",
      Type => "Status",
      UsedBy => "SER",
    },
    AdmissionResultDramErrInt => { #Structure Type: RegField;
      Name => "AdmissionResultDramErrInt",
      RegMem => "RegField",
      Description => "When this bit is set, SER Error occured",
      Width => "1",
      Position => "53",
      Type => "Status",
      UsedBy => "SER",
    },
    WredRegionErrInt => { #Structure Type: RegField;
      Name => "WredRegionErrInt",
      RegMem => "RegField",
      Description => "When this bit is set, SER Error occured",
      Width => "1",
      Position => "54",
      Type => "Status",
      UsedBy => "SER",
    },
  },
  SelectedSerErrorInfo => { #Structure Type: Reg; Skip Register;
    Name => "SelectedSerErrorInfo",
    RegMem => "Reg",
    Address => "34",
    Description => "Address and Type of SER error of selected memory",
    Width => "17",
    Type => "ReadOnly",
    MemErrAddr => { #Structure Type: RegField;
      Name => "MemErrAddr",
      RegMem => "RegField",
      Description => "Address of SER error of selected memory",
      Width => "15",
      Position => "14:0",
      Type => "Status",
      UsedBy => "SER",
    },
    MemErrType => { #Structure Type: RegField;
      Name => "MemErrType",
      RegMem => "RegField",
      Description => "0 = ECC 1b, 1 = ECC 2b, 2 = Parity",
      Width => "2",
      Position => "16:15",
      Type => "Status",
      UsedBy => "SER",
    },
  },
  SerErrorDebugConfiguration => { #Structure Type: Reg; Skip Register;
    Name => "SerErrorDebugConfiguration",
    RegMem => "Reg",
    Address => "35",
    Description => "Address and Type of SER error of selected memory",
    Width => "7",
    Type => "Config",
    ErroneousMemorySelector => { #Structure Type: RegField;
      Name => "ErroneousMemorySelector",
      RegMem => "RegField",
      Description => "Selects which memory error address and error type to set on the status register",
      Width => "6",
      Position => "5:0",
      Type => "Config",
      UsedBy => "SER",
      DefaultValue => "b0",
    },
    ResetMemoryErrors => { #Structure Type: RegField;
      Name => "ResetMemoryErrors",
      RegMem => "RegField",
      Description => "When set to 1 - all the memory SER errors are reset. Need to set back to 0 to resume error recording",
      Width => "1",
      Position => "6",
      Type => "Config",
      UsedBy => "SER",
      DefaultValue => "b0",
    },
  },
  Ecc_1bErrDebug => { #Structure Type: Reg; Skip Register;
    Name => "Ecc_1bErrDebug",
    RegMem => "Reg",
    Address => "36",
    Description => "ECC 1b Error Counter",
    Width => "16",
    Type => "ReadOnly",
    Ecc_1bErrCounter => { #Structure Type: RegField;
      Name => "Ecc_1bErrCounter",
      RegMem => "RegField",
      Description => "Counts number of ECC 1b errors",
      Width => "16",
      Position => "15:0",
      Type => "Counter",
      UsedBy => "SER",
      AdditionalInfo => "CounterIncrWidth=1",
    },
  },
  Ecc_2bErrDebug => { #Structure Type: Reg; Skip Register;
    Name => "Ecc_2bErrDebug",
    RegMem => "Reg",
    Address => "37",
    Description => "ECC 2b Error Counter",
    Width => "16",
    Type => "ReadOnly",
    Ecc_2bErrCounter => { #Structure Type: RegField;
      Name => "Ecc_2bErrCounter",
      RegMem => "RegField",
      Description => "Counts number of ECC 2b errors",
      Width => "16",
      Position => "15:0",
      Type => "Counter",
      UsedBy => "SER",
      AdditionalInfo => "CounterIncrWidth=1",
    },
  },
  MbistPassStatus => { #Structure Type: Reg; Skip Register;
    Name => "MbistPassStatus",
    RegMem => "Reg",
    Address => "39",
    Description => "MBIST pass status",
    Width => "164",
    Type => "ReadOnly",
    BistDonePassOut => { #Structure Type: RegField;
      Name => "BistDonePassOut",
      RegMem => "RegField",
      Description => "When this bit is set, MBIST passed",
      Width => "164",
      Position => "163:0",
      Type => "Status",
      UsedBy => "MEM",
    },
  },
  MbistFailStatus => { #Structure Type: Reg; Skip Register;
    Name => "MbistFailStatus",
    RegMem => "Reg",
    Address => "3A",
    Description => "MBIST fail status",
    Width => "164",
    Type => "ReadOnly",
    BistDoneFailOut => { #Structure Type: RegField;
      Name => "BistDoneFailOut",
      RegMem => "RegField",
      Description => "When this bit is set, MBIST failed",
      Width => "164",
      Position => "163:0",
      Type => "Status",
      UsedBy => "MEM",
    },
  },

  CounterTimer => { #Structure Type: Reg; Skip Register;
    Name => "CounterTimer",
    RegMem => "Reg",
    Address => "40",
    Description => "Defines Counter Timer parameters",
    Width => "33", # Excel Formula: =calc_reg_width(E8:E9,F9)
    Type => "Config",
    CounterTimerEnable => { #Structure Type: RegField;
      Name => "CounterTimerEnable",
      RegMem => "RegField",
      Description => "If set, Counter Timer will applied for the counters, otherwise the counters are free running",
      Width => "1",
      Position => "0", # Excel Formula: =calc_position(F7,E8,TRUE)
      Type => "Config",
      UsedBy => "CIF",
      DefaultValue => "b0",
    },
    CounterTimerCycle => { #Structure Type: RegField;
      Name => "CounterTimerCycle",
      RegMem => "RegField",
      Description => "When activated, CounterTimer will count for CounterTimerCycle",
      Width => "32",
      Position => "32:1", # Excel Formula: =calc_position(F8,E9)
      Type => "Config",
      UsedBy => "CIF",
      DefaultValue => "h3B9ACA00",
    },
  },
  CounterTimerTriggerReg => { #Structure Type: Reg; Skip Register;
    Name => "CounterTimerTriggerReg",
    RegMem => "Reg",
    Address => "41", # Excel Formula: =calc_reg_address(C7,A7,G7)
    Description => "Activates Counter Timer",
    Width => "1", # Excel Formula: =calc_reg_width(E11:E11,F11)
    Type => "External",
    UsedBy => "CIF",
    CounterTimerTrigger => { #Structure Type: RegField;
      Name => "CounterTimerTrigger",
      RegMem => "RegField",
      Description => "When activated, CounterTimer will count for CounterTimerCycle",
      Width => "1",
      Position => "0", # Excel Formula: =calc_position(F10,E11,TRUE)
      Type => "External",
      DefaultValue => "b0",
    },
  },
  MemoryAccessTimeout => { #Structure Type: Reg; Skip Register;
    Name => "MemoryAccessTimeout",
    RegMem => "Reg",
    Address => "42", # Excel Formula: =calc_reg_address(C10,A10,G10)
    Description => "Defines parameters for memory access timer expiry",
    Width => "38", # Excel Formula: =calc_reg_width(E13:E15,F15)
    Type => "Config",
    BubbleCounterThr => { #Structure Type: RegField;
      Name => "BubbleCounterThr",
      RegMem => "RegField",
      Description => "When BubbleCounterThr clocks passed from CIF memory access without grant, Bubble Request signal raised towards the block ",
      Width => "16",
      Position => "15:0", # Excel Formula: =calc_position(F12,E13,TRUE)
      Type => "Config",
      UsedBy => "CIF",
      DefaultValue => "d256",
    },
    TimeoutCounterThr => { #Structure Type: RegField;
      Name => "TimeoutCounterThr",
      RegMem => "RegField",
      Description => "When TimeoutCounterThr clocks passed from CIF memory access without grant, the access is terminated with error ",
      Width => "16",
      Position => "31:16", # Excel Formula: =calc_position(F13,E14)
      Type => "Config",
      UsedBy => "CIF",
      DefaultValue => "d4096",
    },
    AnsWindowCounterThr => { #Structure Type: RegField;
      Name => "AnsWindowCounterThr",
      RegMem => "RegField",
      Description => "When memory access is terminated because of  TimeoutCounterThr, the CIF waits AnsWindowCounterThr clocks for access termination",
      Width => "6",
      Position => "37:32", # Excel Formula: =calc_position(F14,E15)
      Type => "Config",
      UsedBy => "CIF",
      DefaultValue => "d16",
    },
  },
  BroadcastConfigReg => { #Structure Type: Reg; Skip Register;
    Name => "BroadcastConfigReg",
    RegMem => "Reg",
    Address => "43", # Excel Formula: =calc_reg_address(C12,A12,G12)
    Description => "Config Top broadcast parameters",
    Width => "12", # Excel Formula: =calc_reg_width(E17:E17,F17)
    Type => "Config",
    BroadcastId => { #Structure Type: RegField;
      Name => "BroadcastId",
      RegMem => "RegField",
      Description => "Broadcast ID used by Config Top protocol for broadcast messages",
      Width => "12",
      Position => "11:0", # Excel Formula: =calc_position(F16,E17,TRUE)
      Type => "Config",
      UsedBy => "CIF",
      DefaultValue => "hFFF",
    },
  },
  MemoryProtBypass => { #Structure Type: Reg; Skip Register;
    Name => "MemoryProtBypass",
    RegMem => "Reg",
    Address => "44", # Excel Formula: =calc_reg_address(C16,A16,G16)
    Description => "Bypass for ECC/Parity, used for debug",
    Width => "3", # Excel Formula: =calc_reg_width(E19:E21,F21)
    Type => "Config",
    DisableEcc => { #Structure Type: RegField;
      Name => "DisableEcc",
      RegMem => "RegField",
      Description => "If set, ECC fix is bypassed and is taken from payload",
      Width => "1",
      Position => "0", # Excel Formula: =calc_position(F18,E19,TRUE)
      Type => "Config",
      UsedBy => "MEM",
      DefaultValue => "b0",
    },
    CifProtGenBypass => { #Structure Type: RegField;
      Name => "CifProtGenBypass",
      RegMem => "RegField",
      Description => "If set, ECC/Parity generation is bypassed and is taken from payload for CIF access",
      Width => "1",
      Position => "1", # Excel Formula: =calc_position(F19,E20)
      Type => "Config",
      UsedBy => "MEM",
      DefaultValue => "b0",
    },
    CifProtFixBypass => { #Structure Type: RegField;
      Name => "CifProtFixBypass",
      RegMem => "RegField",
      Description => "If set, ECC/Parity fix is bypassed and original ECC/Parity is forwarded towards the CIF",
      Width => "1",
      Position => "2", # Excel Formula: =calc_position(F20,E21)
      Type => "Config",
      UsedBy => "MEM",
      DefaultValue => "b0",
    },
  },
  SoftResetConfiguration => { #Structure Type: Reg; Skip Register;
    Name => "SoftResetConfiguration",
    RegMem => "Reg",
    Address => "45", # Excel Formula: =calc_reg_address(C18,A18,G18)
    Description => "Soft Reset Configuration for the block",
    Width => "1", # Excel Formula: =calc_reg_width(E23:E23,F23)
    Type => "Config",
    SoftRstn => { #Structure Type: RegField;
      Name => "SoftRstn",
      RegMem => "RegField",
      Description => "Triggers soft reset signal for the block, active low register",
      Width => "1",
      Position => "0", # Excel Formula: =calc_position(F22,E23,TRUE)
      Type => "Config",
      UsedBy => "CIF",
      DefaultValue => "b0",
    },
  },
  MbistConfiguration => { #Structure Type: Reg; Skip Register;
    Name => "MbistConfiguration",
    RegMem => "Reg",
    Address => "46", # Excel Formula: =calc_reg_address(C22,A22,G22)
    Description => "MBIST Configuration for the block",
    Width => "3", # Excel Formula: =calc_reg_width(E25:E27,F27)
    Type => "Config",
    CoreBistRprMode => { #Structure Type: RegField;
      Name => "CoreBistRprMode",
      RegMem => "RegField",
      Description => "Used by MBIST logic",
      Width => "1",
      Position => "0", # Excel Formula: =calc_position(F24,E25,TRUE)
      Type => "Config",
      UsedBy => "MEM",
      DefaultValue => "b0",
    },
    CoreBistRun => { #Structure Type: RegField;
      Name => "CoreBistRun",
      RegMem => "RegField",
      Description => "Used by MBIST logic",
      Width => "1",
      Position => "1", # Excel Formula: =calc_position(F25,E26)
      Type => "Config",
      UsedBy => "MEM",
      DefaultValue => "b0",
    },
    CoreBistPtrnFill => { #Structure Type: RegField;
      Name => "CoreBistPtrnFill",
      RegMem => "RegField",
      Description => "Used by MBIST logic",
      Width => "1",
      Position => "2", # Excel Formula: =calc_position(F26,E27)
      Type => "Config",
      UsedBy => "MEM",
      DefaultValue => "b0",
    },
  },
  PowerDownConfiguration => { #Structure Type: Reg; Skip Register;
    Name => "PowerDownConfiguration",
    RegMem => "Reg",
    Address => "47", # Excel Formula: =calc_reg_address(C24,A24,G24)
    Description => "Power Down Configuration for the block",
    Width => "1", # Excel Formula: =calc_reg_width(E29:E29,F29)
    Type => "Config",
    PowerDown => { #Structure Type: RegField;
      Name => "PowerDown",
      RegMem => "RegField",
      Description => "If set, disables the clock of the block",
      Width => "1",
      Position => "0", # Excel Formula: =calc_position(F28,E29,TRUE)
      Type => "Config",
      UsedBy => "CIF",
      DefaultValue => "b0",
      Comments => "Default value should always be 0",
    },
  },
  SpareReg => { #Structure Type: Reg; Skip Register;
    Name => "SpareReg",
    RegMem => "Reg",
    Address => "48", # Excel Formula: =calc_reg_address(C28,A28,G28)
    Description => "Power Down Configuration for the block",
    Width => "128", # Excel Formula: =calc_reg_width(E31:E31,F31)
    Type => "Config",
    SpareRegister => { #Structure Type: RegField;
      Name => "SpareRegister",
      RegMem => "RegField",
      Description => "If set, disables the clock of the block",
      Width => "128",
      Position => "127:0", # Excel Formula: =calc_position(F30,E31,TRUE)
      Type => "Config",
      UsedBy => "CIF",
      DefaultValue => "hffffffffffffffff",
    },
  },
  PmroCtrl => { #Structure Type: Reg; Skip Register;
    Name => "PmroCtrl",
    RegMem => "Reg",
    Address => "49", # Excel Formula: =calc_reg_address(C30,A30,G30)
    Width => "39", # Excel Formula: =calc_reg_width(E33:E37,F37)
    Type => "Config",
    PmroExecute => { #Structure Type: RegField;
      Name => "PmroExecute",
      RegMem => "RegField",
      Description => "0->1: execute pmro command.",
      Width => "1",
      Position => "0", # Excel Formula: =calc_position(F32,E33,TRUE)
      Type => "Config",
      UsedBy => "pmro",
      DefaultValue => "d0",
    },
    PmroCmd => { #Structure Type: RegField;
      Name => "PmroCmd",
      RegMem => "RegField",
      Description => "Pmro command to execute:
0: reset.
1: write.
2: read.
3: invalid.",
      Width => "2",
      Position => "2:1", # Excel Formula: =calc_position(F33,E34)
      Type => "Config",
      UsedBy => "pmro",
      DefaultValue => "d0",
    },
    PmroSbusReset => { #Structure Type: RegField;
      Name => "PmroSbusReset",
      RegMem => "RegField",
      Description => "Reset pmro sbus chain. Need to set to 0 before starting access to pmro registers.",
      Width => "1",
      Position => "3", # Excel Formula: =calc_position(F34,E35)
      Type => "Config",
      UsedBy => "pmro",
      DefaultValue => "d1",
    },
    PmroAddr => { #Structure Type: RegField;
      Name => "PmroAddr",
      RegMem => "RegField",
      Description => "PMRO register address:
0 - control register, 8b, def: 0x0.
1 - SVT Configuration Register, 16b, def: 0xFFFF.
2 - LVT Configuration Register, 16b, def: 0xFFFF.
3 - ULVT Configuration Register, 16b, def: 0xFFFF.
4 - Interconnect Configuration Register, 16b, def: 0xFFFF.
5 - Reference Clock Counter Register, 24b, def: 0xFFF000.
6 - Oscillator Counter Register, 24b, def: 0x000000.
7 - SBus ID register, read as 0x0B.
Set to '0' on reset command.",
      Width => "3",
      Position => "6:4", # Excel Formula: =calc_position(F35,E36)
      Type => "Config",
      UsedBy => "pmro",
      DefaultValue => "d1",
    },
    PmroData => { #Structure Type: RegField;
      Name => "PmroData",
      RegMem => "RegField",
      Description => "PMRO data, set to 0x0 on reset and read command.",
      Width => "32",
      Position => "38:7", # Excel Formula: =calc_position(F36,E37)
      Type => "Config",
      UsedBy => "pmro",
      DefaultValue => "d1",
    },
  },
  PmroStatus => { #Structure Type: Reg; Skip Register;
    Name => "PmroStatus",
    RegMem => "Reg",
    Address => "4A", # Excel Formula: =calc_reg_address(C32,A32,G32)
    Width => "34", # Excel Formula: =calc_reg_width(E39:E41,F41)
    Type => "ReadOnly",
    PmroRdata => { #Structure Type: RegField;
      Name => "PmroRdata",
      RegMem => "RegField",
      Description => "Read data from pmro. Valid when PmroFinish=1 and PmroFailed=0.",
      Width => "32",
      Position => "31:0", # Excel Formula: =calc_position(F38,E39,TRUE)
      Type => "Capture",
      UsedBy => "pmro",
    },
    PmroFailed => { #Structure Type: RegField;
      Name => "PmroFailed",
      RegMem => "RegField",
      Description => "Pmro command failed. Valid only when PmroFinish=1.",
      Width => "1",
      Position => "32", # Excel Formula: =calc_position(F39,E40)
      Type => "Capture",
      UsedBy => "pmro",
    },
    PmroFinish => { #Structure Type: RegField;
      Name => "PmroFinish",
      RegMem => "RegField",
      Description => "Pmro command finished.",
      Width => "1",
      Position => "33", # Excel Formula: =calc_position(F40,E41)
      Type => "Event",
      UsedBy => "pmro",
    },
  },
  MirrorBusConfReg => { #Structure Type: Reg; Skip Register;
    Name => "MirrorBusConfReg",
    RegMem => "Reg",
    Address => "4B", # Excel Formula: =calc_reg_address(C38,A38,G38)
    Description => "aaa",
    Width => "11", # Excel Formula: =calc_reg_width(E43:E44,F44)
    Type => "Config",
    MirrorBusEn => { #Structure Type: RegField;
      Name => "MirrorBusEn",
      RegMem => "RegField",
      Description => "aaa",
      Width => "1",
      Position => "0", # Excel Formula: =calc_position(F42,E43,TRUE)
      Type => "Config",
      UsedBy => "BLOCK",
      DefaultValue => "h0",
    },
    MirrorBusSel => { #Structure Type: RegField;
      Name => "MirrorBusSel",
      RegMem => "RegField",
      Description => "aaa",
      Width => "10",
      Position => "10:1", # Excel Formula: =calc_position(F43,E44)
      Type => "Config",
      UsedBy => "BLOCK",
      DefaultValue => "h0",
    },
  },
  MirrorBusStatus => { #Structure Type: Reg; Skip Register;
    Name => "MirrorBusStatus",
    RegMem => "Reg",
    Address => "4C", # Excel Formula: =calc_reg_address(C42,A42,G42)
    Description => "aaa",
    Width => "32", # Excel Formula: =calc_reg_width(E46:E46,F46)
    Type => "ReadOnly",
    MirrorBus => { #Structure Type: RegField;
      Name => "MirrorBus",
      RegMem => "RegField",
      Description => "aaa",
      Width => "32",
      Position => "31:0", # Excel Formula: =calc_position(F45,E46,TRUE)
      Type => "Status",
      UsedBy => "BLOCK",
    },
  },
  DeviceTimeOffsetCfg => { #Structure Type: Reg; Skip Register;
    Name => "DeviceTimeOffsetCfg",
    RegMem => "Reg",
    Address => "4D", # Excel Formula: =calc_reg_address(C45,A45,G45)
    Description => "Define time offset configuration",
    Width => "10", # Excel Formula: =calc_reg_width(E48:E48,F48)
    Type => "Config",
    DeviceTimeOffset => { #Structure Type: RegField;
      Name => "DeviceTimeOffset",
      RegMem => "RegField",
      Description => "Define time offset",
      Width => "10",
      Position => "9:0", # Excel Formula: =calc_position(F47,E48,TRUE)
      Type => "Config",
      UsedBy => "CIF",
      DefaultValue => "h0",
    },
  },
  GeneralInterruptRegister => { #Structure Type: Reg;
    Name => "GeneralInterruptRegister",
    RegMem => "Reg",
    Address => "100",
    Description => "Interrupt",
    Width => "7", # Excel Formula: =calc_reg_width(E8:E14,F14)
    Type => "Interrupt",
    RdReqFifoOveflow => { #Structure Type: RegField;
      Name => "RdReqFifoOveflow",
      RegMem => "RegField",
      Description => "Overflow of the read request fifo in the read queue manager ",
      Width => "1",
      Position => "0", # Excel Formula: =calc_position(F7,E8,TRUE)
      Type => "Interrupt",
      UsedBy => "RQM",
    },
    DeqReqFifoOverflow => { #Structure Type: RegField;
      Name => "DeqReqFifoOverflow",
      RegMem => "RegField",
      Description => "Overflow of the dequeue request fifo in the read queue manager ",
      Width => "1",
      Position => "1", # Excel Formula: =calc_position(F8,E9)
      Type => "Interrupt",
      UsedBy => "RQM",
    },
    InFifoOverflow => { #Structure Type: RegField;
      Name => "InFifoOverflow",
      RegMem => "RegField",
      Description => "Overflow of the input fifo in the write queue manager",
      Width => "1",
      Position => "2", # Excel Formula: =calc_position(F9,E10)
      Type => "Interrupt",
      UsedBy => "WQM",
    },
    dram_release_fifo_overflow => { #Structure Type: RegField;
      Name => "dram_release_fifo_overflow",
      RegMem => "RegField",
      Description => "overflow of the dram context release fifo",
      Width => "1",
      Position => "3", # Excel Formula: =calc_position(F10,E11)
      Type => "Interrupt",
      UsedBy => "cmap",
    },
    ics_return_fifo_overflow => { #Structure Type: RegField;
      Name => "ics_return_fifo_overflow",
      RegMem => "RegField",
      Description => "overflow of the dynamic ontext allocation context return fifo",
      Width => "1",
      Position => "4", # Excel Formula: =calc_position(F11,E12)
      Type => "Interrupt",
      UsedBy => "cmap",
    },
    cpu_return_fifo_overflow => { #Structure Type: RegField;
      Name => "cpu_return_fifo_overflow",
      RegMem => "RegField",
      Description => "Overflow in the dynamic context allocation machine - CPU returned a context while the fifo was full",
      Width => "1",
      Position => "5", # Excel Formula: =calc_position(F12,E13)
      Type => "Interrupt",
      UsedBy => "cmap",
    },
    back_to_tail_fifo_overflow => { #Structure Type: RegField;
      Name => "back_to_tail_fifo_overflow",
      RegMem => "RegField",
      Description => "overflow of the back-to-tail fifo in the dynamic ontext allocation machine",
      Width => "1",
      Position => "6", # Excel Formula: =calc_position(F13,E14)
      Type => "Interrupt",
      UsedBy => "cmap",
    },
  },
  GeneralInterruptRegisterMask => { #Structure Type: Reg; Skip Register;
    Name => "GeneralInterruptRegisterMask",
    RegMem => "Reg",
    Address => "101",
    Description => "This register masks GeneralInterruptRegister interrupt register",
    Width => "7", # Excel Formula: =calc_reg_width(E8:E14,F14)
    Type => "InterruptMask",
    RdReqFifoOveflowMask => { #Structure Type: RegField;
      Name => "RdReqFifoOveflowMask",
      RegMem => "RegField",
      Description => "This field masks RdReqFifoOveflow interrupt",
      Width => "1",
      Position => "0", # Excel Formula: =calc_position(F7,E8,TRUE)
      Type => "InterruptMask",
      UsedBy => "",
      DefaultValue => "b1",
    },
    DeqReqFifoOverflowMask => { #Structure Type: RegField;
      Name => "DeqReqFifoOverflowMask",
      RegMem => "RegField",
      Description => "This field masks DeqReqFifoOverflow interrupt",
      Width => "1",
      Position => "1", # Excel Formula: =calc_position(F8,E9)
      Type => "InterruptMask",
      UsedBy => "",
      DefaultValue => "b1",
    },
    InFifoOverflowMask => { #Structure Type: RegField;
      Name => "InFifoOverflowMask",
      RegMem => "RegField",
      Description => "This field masks InFifoOverflow interrupt",
      Width => "1",
      Position => "2", # Excel Formula: =calc_position(F9,E10)
      Type => "InterruptMask",
      UsedBy => "",
      DefaultValue => "b1",
    },
    dram_release_fifo_overflowMask => { #Structure Type: RegField;
      Name => "dram_release_fifo_overflowMask",
      RegMem => "RegField",
      Description => "This field masks dram_release_fifo_overflow interrupt",
      Width => "1",
      Position => "3", # Excel Formula: =calc_position(F10,E11)
      Type => "InterruptMask",
      UsedBy => "",
      DefaultValue => "b1",
    },
    ics_return_fifo_overflowMask => { #Structure Type: RegField;
      Name => "ics_return_fifo_overflowMask",
      RegMem => "RegField",
      Description => "This field masks ics_return_fifo_overflow interrupt",
      Width => "1",
      Position => "4", # Excel Formula: =calc_position(F11,E12)
      Type => "InterruptMask",
      UsedBy => "",
      DefaultValue => "b1",
    },
    cpu_return_fifo_overflowMask => { #Structure Type: RegField;
      Name => "cpu_return_fifo_overflowMask",
      RegMem => "RegField",
      Description => "This field masks cpu_return_fifo_overflow interrupt",
      Width => "1",
      Position => "5", # Excel Formula: =calc_position(F12,E13)
      Type => "InterruptMask",
      UsedBy => "",
      DefaultValue => "b1",
    },
    back_to_tail_fifo_overflowMask => { #Structure Type: RegField;
      Name => "back_to_tail_fifo_overflowMask",
      RegMem => "RegField",
      Description => "This field masks back_to_tail_fifo_overflow interrupt",
      Width => "1",
      Position => "6", # Excel Formula: =calc_position(F13,E14)
      Type => "InterruptMask",
      UsedBy => "",
      DefaultValue => "b1",
    },
  },
  GeneralInterruptRegisterTest => { #Structure Type: Reg; Skip Register;
    Name => "GeneralInterruptRegisterTest",
    RegMem => "Reg",
    Address => "102",
    Description => "This register tests GeneralInterruptRegister interrupt register",
    Width => "7", # Excel Formula: =calc_reg_width(E8:E14,F14)
    Type => "InterruptTest",
    RdReqFifoOveflowTest => { #Structure Type: RegField;
      Name => "RdReqFifoOveflowTest",
      RegMem => "RegField",
      Description => "This field tests RdReqFifoOveflow interrupt",
      Width => "1",
      Position => "0", # Excel Formula: =calc_position(F7,E8,TRUE)
      Type => "InterruptTest",
      UsedBy => "",
      DefaultValue => "b0",
    },
    DeqReqFifoOverflowTest => { #Structure Type: RegField;
      Name => "DeqReqFifoOverflowTest",
      RegMem => "RegField",
      Description => "This field tests DeqReqFifoOverflow interrupt",
      Width => "1",
      Position => "1", # Excel Formula: =calc_position(F8,E9)
      Type => "InterruptTest",
      UsedBy => "",
      DefaultValue => "b0",
    },
    InFifoOverflowTest => { #Structure Type: RegField;
      Name => "InFifoOverflowTest",
      RegMem => "RegField",
      Description => "This field tests InFifoOverflow interrupt",
      Width => "1",
      Position => "2", # Excel Formula: =calc_position(F9,E10)
      Type => "InterruptTest",
      UsedBy => "",
      DefaultValue => "b0",
    },
    dram_release_fifo_overflowTest => { #Structure Type: RegField;
      Name => "dram_release_fifo_overflowTest",
      RegMem => "RegField",
      Description => "This field tests dram_release_fifo_overflow interrupt",
      Width => "1",
      Position => "3", # Excel Formula: =calc_position(F10,E11)
      Type => "InterruptTest",
      UsedBy => "",
      DefaultValue => "b0",
    },
    ics_return_fifo_overflowTest => { #Structure Type: RegField;
      Name => "ics_return_fifo_overflowTest",
      RegMem => "RegField",
      Description => "This field tests ics_return_fifo_overflow interrupt",
      Width => "1",
      Position => "4", # Excel Formula: =calc_position(F11,E12)
      Type => "InterruptTest",
      UsedBy => "",
      DefaultValue => "b0",
    },
    cpu_return_fifo_overflowTest => { #Structure Type: RegField;
      Name => "cpu_return_fifo_overflowTest",
      RegMem => "RegField",
      Description => "This field tests cpu_return_fifo_overflow interrupt",
      Width => "1",
      Position => "5", # Excel Formula: =calc_position(F12,E13)
      Type => "InterruptTest",
      UsedBy => "",
      DefaultValue => "b0",
    },
    back_to_tail_fifo_overflowTest => { #Structure Type: RegField;
      Name => "back_to_tail_fifo_overflowTest",
      RegMem => "RegField",
      Description => "This field tests back_to_tail_fifo_overflow interrupt",
      Width => "1",
      Position => "6", # Excel Formula: =calc_position(F13,E14)
      Type => "InterruptTest",
      UsedBy => "",
      DefaultValue => "b0",
    },
  },
  StatusReg => { #Structure Type: Reg;
    Name => "StatusReg",
    RegMem => "Reg",
    Address => "103", # Excel Formula: =calc_reg_address(C7,A7,G7)
    Description => "Status",
    Width => "6", # Excel Formula: =calc_reg_width(E16:E16,F16)
    Type => "ReadOnly",
    InitActive => { #Structure Type: RegField;
      Name => "InitActive",
      RegMem => "RegField",
      Description => "when value is not 0 - hardware initialization process is in progress",
      Width => "6",
      Position => "5:0", # Excel Formula: =calc_position(F15,E16,TRUE)
      Type => "Status",
      UsedBy => "core",
    },
  },
  DebugCounters => { #Structure Type: Reg;
    Name => "DebugCounters",
    RegMem => "Reg",
    Address => "104", # Excel Formula: =calc_reg_address(C15,A15,G15)
    Description => "debug counters",
    Width => "140", # Excel Formula: =calc_reg_width(E18:E24,F24)
    Type => "ReadOnly",
    tsmon2pdvoqCount => { #Structure Type: RegField;
      Name => "tsmon2pdvoqCount",
      RegMem => "RegField",
      Description => "free running counter of PDs from ts monitor to PDVOQ",
      Width => "20",
      Position => "19:0", # Excel Formula: =calc_position(F17,E18,TRUE)
      Type => "Counter",
      UsedBy => "CMAP",
      AdditionalInfo => "CounterIncrWidth=1",
    },
    deleteNoContextCount => { #Structure Type: RegField;
      Name => "deleteNoContextCount",
      RegMem => "RegField",
      Description => "free running counter of PDs that were send to delete queue because there was no free context in the dynamic context allocation machine",
      Width => "20",
      Position => "39:20", # Excel Formula: =calc_position(F18,E19)
      Type => "Counter",
      UsedBy => "CMAP",
      AdditionalInfo => "CounterIncrWidth=1",
    },
    enqueueRptCount => { #Structure Type: RegField;
      Name => "enqueueRptCount",
      RegMem => "RegField",
      Description => "free running counter of enq reports",
      Width => "20",
      Position => "59:40", # Excel Formula: =calc_position(F19,E20)
      Type => "Counter",
      UsedBy => "WQM",
      AdditionalInfo => "CounterIncrWidth=1",
    },
    readReqCount => { #Structure Type: RegField;
      Name => "readReqCount",
      RegMem => "RegField",
      Description => "free running counter of read requests from the ICS",
      Width => "20",
      Position => "79:60", # Excel Formula: =calc_position(F20,E21)
      Type => "Counter",
      UsedBy => "RQM",
      AdditionalInfo => "CounterIncrWidth=1",
    },
    dequeueReqCount => { #Structure Type: RegField;
      Name => "dequeueReqCount",
      RegMem => "RegField",
      Description => "free running counter of dequeue requests from the ICS",
      Width => "20",
      Position => "99:80", # Excel Formula: =calc_position(F21,E22)
      Type => "Counter",
      UsedBy => "RQM",
      AdditionalInfo => "CounterIncrWidth=1",
    },
    dequeueReqRetransmitCount => { #Structure Type: RegField;
      Name => "dequeueReqRetransmitCount",
      RegMem => "RegField",
      Description => "free running counter of dequeue requests from the ICS with retransmit indication",
      Width => "20",
      Position => "119:100", # Excel Formula: =calc_position(F22,E23)
      Type => "Counter",
      UsedBy => "RQM",
      AdditionalInfo => "CounterIncrWidth=1",
    },
    dequeueRptCount => { #Structure Type: RegField;
      Name => "dequeueRptCount",
      RegMem => "RegField",
      Description => "free running counter of dequeue reports ",
      Width => "20",
      Position => "139:120", # Excel Formula: =calc_position(F23,E24)
      Type => "Counter",
      UsedBy => "RQM",
      AdditionalInfo => "CounterIncrWidth=1",
    },
  },
  FifosDebugReg => { #Structure Type: Reg;
    Name => "FifosDebugReg",
    RegMem => "Reg",
    Address => "105", # Excel Formula: =calc_reg_address(C17,A17,G17)
    Width => "74", # Excel Formula: =calc_reg_width(E26:E35,F35)
    Type => "ReadOnly",
    RdReqFifoStat => { #Structure Type: RegField;
      Name => "RdReqFifoStat",
      RegMem => "RegField",
      Description => "number of used entries in the read request fifo in the read queue manager",
      Width => "5",
      Position => "4:0", # Excel Formula: =calc_position(F25,E26,TRUE)
      Type => "Status",
      UsedBy => "RQM",
      Comments => "NEED TO FIX TO 6 bit - spyglass too late to fix",
    },
    DeqReqFifoStat => { #Structure Type: RegField;
      Name => "DeqReqFifoStat",
      RegMem => "RegField",
      Description => "number of used entries in the dequeue request fifo in the read queue manager",
      Width => "6",
      Position => "10:5", # Excel Formula: =calc_position(F26,E27)
      Type => "Status",
      UsedBy => "RQM",
    },
    InFifoStat => { #Structure Type: RegField;
      Name => "InFifoStat",
      RegMem => "RegField",
      Description => "number of used entries in the input  fifo in the write queue manager",
      Width => "6",
      Position => "16:11", # Excel Formula: =calc_position(F27,E28)
      Type => "Status",
      UsedBy => "WQM",
    },
    dram_release_fifo_stat => { #Structure Type: RegField;
      Name => "dram_release_fifo_stat",
      RegMem => "RegField",
      Description => "number of used entries in the dram release  fifo in the dynamic context allocation machine",
      Width => "6",
      Position => "22:17", # Excel Formula: =calc_position(F28,E29)
      Type => "Status",
      UsedBy => "CMAP",
    },
    ics_return_fifo_stat => { #Structure Type: RegField;
      Name => "ics_return_fifo_stat",
      RegMem => "RegField",
      Description => "number of used entries in the ICS return fifo in the dynamic context allocation machine",
      Width => "6",
      Position => "28:23", # Excel Formula: =calc_position(F29,E30)
      Type => "Status",
      UsedBy => "CMAP",
    },
    cpu_return_fifo_stat => { #Structure Type: RegField;
      Name => "cpu_return_fifo_stat",
      RegMem => "RegField",
      Description => "number of used entries in the CPU return fifo in the dynamic context allocation machine",
      Width => "3",
      Position => "31:29", # Excel Formula: =calc_position(F30,E31)
      Type => "Status",
      UsedBy => "CMAP",
    },
    back_to_tail_fifo_stat => { #Structure Type: RegField;
      Name => "back_to_tail_fifo_stat",
      RegMem => "RegField",
      Description => "number of used entries in the back-to-tail fifo in the dynamic context allocation machine",
      Width => "5",
      Position => "36:32", # Excel Formula: =calc_position(F31,E32)
      Type => "Status",
      UsedBy => "CMAP",
    },
    deleteContextQsize => { #Structure Type: RegField;
      Name => "deleteContextQsize",
      RegMem => "RegField",
      Description => "Unused - tied to 0",
      Width => "14", # Excel Formula: =calc_field_width_define("QSIZE_PKT_WIDTH")
      Position => "50:37", # Excel Formula: =calc_position(F32,E33)
      Type => "Status",
      UsedBy => "RQM",
    },
    tsmon2pdvoqCbrStatus => { #Structure Type: RegField;
      Name => "tsmon2pdvoqCbrStatus",
      RegMem => "RegField",
      Description => "status of the tsmon2pdvoq CBR",
      Width => "6",
      Position => "56:51", # Excel Formula: =calc_position(F33,E34)
      Type => "Status",
      UsedBy => "top",
    },
    TotalPdsInSlice => { #Structure Type: RegField;
      Name => "TotalPdsInSlice",
      RegMem => "RegField",
      Description => "Total number of PDs in the slice. Increment every enqueue, decrement every dequeue and write fail",
      Width => "17",
      Position => "73:57", # Excel Formula: =calc_position(F34,E35)
      Type => "Status",
      UsedBy => "top",
    },
  },
  CmapThReg => { #Structure Type: Reg;
    Name => "CmapThReg",
    RegMem => "Reg",
    Address => "106", # Excel Formula: =calc_reg_address(C25,A25,G25)
    Description => "Status",
    Width => "96", # Excel Formula: =calc_reg_width(E37:E41,F41)
    Type => "Config",
    ContextPoolLowTh => { #Structure Type: RegField;
      Name => "ContextPoolLowTh",
      RegMem => "RegField",
      Description => "if context pool size smaller than this value start popping from the release fifo",
      Width => "12",
      Position => "11:0", # Excel Formula: =calc_position(F36,E37,TRUE)
      Type => "Config",
      UsedBy => "CMAP",
      DefaultValue => "d1000",
    },
    ContextPoolRetTh => { #Structure Type: RegField;
      Name => "ContextPoolRetTh",
      RegMem => "RegField",
      Description => "if context pool size smaller than this value - enable return of context to the pool",
      Width => "12",
      Position => "23:12", # Excel Formula: =calc_position(F37,E38)
      Type => "Config",
      UsedBy => "CMAP",
      DefaultValue => "d1000",
    },
    ReleaseFifoHighTh => { #Structure Type: RegField;
      Name => "ReleaseFifoHighTh",
      RegMem => "RegField",
      Description => "If release cintext fifo size is greater than this value start popping from release fifo",
      Width => "11",
      Position => "34:24", # Excel Formula: =calc_position(F38,E39)
      Type => "Config",
      UsedBy => "CMAP",
      DefaultValue => "d1000",
    },
    TotalFreeBuf => { #Structure Type: RegField;
      Name => "TotalFreeBuf",
      RegMem => "RegField",
      Description => "Total number of free buffers in the context allocation free buffer manager",
      Width => "13", # Excel Formula: =calc_field_width_define("CONTEXT_WIDTH") +1
      Position => "47:35", # Excel Formula: =calc_position(F39,E40)
      Type => "Config",
      UsedBy => "CMAP",
      DefaultValue => "d3071",
    },
    NotEmptyEntry => { #Structure Type: RegField;
      Name => "NotEmptyEntry",
      RegMem => "RegField",
      Description => "Per entry of contextfbmBmp : '1' -this entry contains at least one free buffer",
      Width => "48", # Excel Formula: =K123
      Position => "95:48", # Excel Formula: =calc_position(F40,E41)
      Type => "Config",
      UsedBy => "CMAP",
      DefaultValue => "hFFFF_FFFF_FFFF",
    },
  },
  SliceModeReg => { #Structure Type: Reg;
    Name => "SliceModeReg",
    RegMem => "Reg",
    Address => "107", # Excel Formula: =calc_reg_address(C36,A36,G36)
    Width => "4", # Excel Formula: =calc_reg_width(E43:E43,F43)
    Type => "Config",
    SliceMode => { #Structure Type: RegField;
      Name => "SliceMode",
      RegMem => "RegField",
      Description => "0  // Linecard mode CRF TS network slice
1  // Linecard mode CRF SN network slice
2  // Linecard mode CRF TS fabric slice
3  // Linecard mode CRF SN fabric slice
4  // TOR mode network slice
5  // TOR mode fabric slice
6  // FE mode with TS
7  // FE mode with SN
8  // Stand alone device
9  // DRAM slice",
      Width => "4",
      Position => "3:0", # Excel Formula: =calc_position(F42,E43,TRUE)
      Type => "Config",
      UsedBy => "ALL",
      DefaultValue => "d0",
    },
  },
  AlmostFullConf => { #Structure Type: Reg;
    Name => "AlmostFullConf",
    RegMem => "Reg",
    Address => "108", # Excel Formula: =calc_reg_address(C42,A42,G42)
    Description => "almost full configurations. ",
    Width => "52", # Excel Formula: =calc_reg_width(E45:E54,F54)
    Type => "Config",
    rqm2em_alm_full_cfg => { #Structure Type: RegField;
      Name => "rqm2em_alm_full_cfg",
      RegMem => "RegField",
      Description => "Almost full configuration for the fifo between the read queue manager and the exact match cores
This field was used for tuning parameters during the design phase. The value of this field is optimized for the current silicon, thus the user is not expected to change its value unless instructed by Cisco Systems, Inc.",
      Width => "6",
      Position => "5:0", # Excel Formula: =calc_position(F44,E45,TRUE)
      Type => "Config",
      UsedBy => "RQM",
      DefaultValue => "d10",
    },
    release_alm_full_cfg => { #Structure Type: RegField;
      Name => "release_alm_full_cfg",
      RegMem => "RegField",
      Description => "Almost full configuration of the candidates release fifo in the dynamic context allocation machine. it determines the point where the machine tries to return old contexts to the pool
This field was used for tuning parameters during the design phase. The value of this field is optimized for the current silicon, thus the user is not expected to change its value unless instructed by Cisco Systems, Inc.",
      Width => "5",
      Position => "10:6", # Excel Formula: =calc_position(F45,E46)
      Type => "Config",
      UsedBy => "CMAP",
      DefaultValue => "d10",
    },
    dram_release_alm_full_cfg => { #Structure Type: RegField;
      Name => "dram_release_alm_full_cfg",
      RegMem => "RegField",
      Description => "Almost full configuration of the dram release fifo in the dynamic context allocation machine. when this fifo becomes full the ICS delays the return of contexts from the dram.
This field was used for tuning parameters during the design phase. The value of this field is optimized for the current silicon, thus the user is not expected to change its value unless instructed by Cisco Systems, Inc.",
      Width => "5",
      Position => "15:11", # Excel Formula: =calc_position(F46,E47)
      Type => "Config",
      UsedBy => "CMAP",
      DefaultValue => "d8",
    },
    ics_release_alm_full_cfg => { #Structure Type: RegField;
      Name => "ics_release_alm_full_cfg",
      RegMem => "RegField",
      Description => "Almost full configuration of the ICS release fifo in the dynamic context allocation machine.
This field was used for tuning parameters during the design phase. The value of this field is optimized for the current silicon, thus the user is not expected to change its value unless instructed by Cisco Systems, Inc.",
      Width => "5",
      Position => "20:16", # Excel Formula: =calc_position(F47,E48)
      Type => "Config",
      UsedBy => "CMAP",
      DefaultValue => "d8",
    },
    back_to_tail_alm_full_cfg => { #Structure Type: RegField;
      Name => "back_to_tail_alm_full_cfg",
      RegMem => "RegField",
      Description => "almost full configuration of the back-to-tail fifo in the dynamic context allocation machine.
This field was used for tuning parameters during the design phase. The value of this field is optimized for the current silicon, thus the user is not expected to change its value unless instructed by Cisco Systems, Inc.",
      Width => "4",
      Position => "24:21", # Excel Formula: =calc_position(F48,E49)
      Type => "Config",
      UsedBy => "CMAP",
      DefaultValue => "d4",
    },
    rqm_del_deq_alm_full_cfg => { #Structure Type: RegField;
      Name => "rqm_del_deq_alm_full_cfg",
      RegMem => "RegField",
      Description => "almost full configuration of the delete dequeue fifo in the read queue manager.
This field was used for tuning parameters during the design phase. The value of this field is optimized for the current silicon, thus the user is not expected to change its value unless instructed by Cisco Systems, Inc.",
      Width => "5",
      Position => "29:25", # Excel Formula: =calc_position(F49,E50)
      Type => "Config",
      UsedBy => "RQM",
      DefaultValue => "d8",
    },
    rqm_deq_req_alm_full_cfg => { #Structure Type: RegField;
      Name => "rqm_deq_req_alm_full_cfg",
      RegMem => "RegField",
      Description => "almost full configuration of the dequeue request fifo in the read queue manager.
This field was used for tuning parameters during the design phase. The value of this field is optimized for the current silicon, thus the user is not expected to change its value unless instructed by Cisco Systems, Inc.",
      Width => "6",
      Position => "35:30", # Excel Formula: =calc_position(F50,E51)
      Type => "Config",
      UsedBy => "RQM",
      DefaultValue => "d5",
    },
    rqm_rd_req_alm_full_cfg => { #Structure Type: RegField;
      Name => "rqm_rd_req_alm_full_cfg",
      RegMem => "RegField",
      Description => "almost full configuration of the read request fifo in the read queue manager.
This field was used for tuning parameters during the design phase. The value of this field is optimized for the current silicon, thus the user is not expected to change its value unless instructed by Cisco Systems, Inc.",
      Width => "5",
      Position => "40:36", # Excel Formula: =calc_position(F51,E52)
      Type => "Config",
      UsedBy => "RQM",
      DefaultValue => "d15",
    },
    wqm_input_alm_full_cfg => { #Structure Type: RegField;
      Name => "wqm_input_alm_full_cfg",
      RegMem => "RegField",
      Description => "almost full configuration of the input fifo in the write queue manager.
This field was used for tuning parameters during the design phase. The value of this field is optimized for the current silicon, thus the user is not expected to change its value unless instructed by Cisco Systems, Inc.",
      Width => "6",
      Position => "46:41", # Excel Formula: =calc_position(F52,E53)
      Type => "Config",
      UsedBy => "WQM",
      DefaultValue => "d26",
    },
    wqm_cbt_alm_full_cfg => { #Structure Type: RegField;
      Name => "wqm_cbt_alm_full_cfg",
      RegMem => "RegField",
      Description => "almost full configuration of the CBT between the write queue manager in the slice and the top logic.
This field was used for tuning parameters during the design phase. The value of this field is optimized for the current silicon, thus the user is not expected to change its value unless instructed by Cisco Systems, Inc.",
      Width => "5",
      Position => "51:47", # Excel Formula: =calc_position(F53,E54)
      Type => "Config",
      UsedBy => "WQM",
      DefaultValue => "d2",
    },
  },
  GeneralConf => { #Structure Type: Reg;
    Name => "GeneralConf",
    RegMem => "Reg",
    Address => "109", # Excel Formula: =calc_reg_address(C44,A44,G44)
    Width => "2", # Excel Formula: =calc_reg_width(E56:E57,F57)
    Type => "Config",
    IgnoreCgm => { #Structure Type: RegField;
      Name => "IgnoreCgm",
      RegMem => "RegField",
      Description => "1- ignore voq-cgm slice recommandations (for debug)
This field was used for tuning parameters during the design phase. The value of this field is optimized for the current silicon, thus the user is not expected to change its value unless instructed by Cisco Systems, Inc.",
      Width => "1",
      Position => "0", # Excel Formula: =calc_position(F55,E56,TRUE)
      Type => "Config",
      UsedBy => "ALL",
      DefaultValue => "b0",
    },
    UcdvDiscardEn => { #Structure Type: RegField;
      Name => "UcdvDiscardEn",
      RegMem => "RegField",
      Description => "1 - enable the ucdv discard manipulation
This field was used for tuning parameters during the design phase. The value of this field is optimized for the current silicon, thus the user is not expected to change its value unless instructed by Cisco Systems, Inc.",
      Width => "1",
      Position => "1", # Excel Formula: =calc_position(F56,E57)
      Type => "Config",
      UsedBy => "UCDV",
      DefaultValue => "b1",
    },
  },
  CompensationPerIfg => { #Structure Type: Reg;
    Name => "CompensationPerIfg",
    RegMem => "Reg",
    Address => "10A", # Excel Formula: =calc_reg_address(C55,A55,G55)
    Width => "79", # Excel Formula: =calc_reg_width(E59:E62,F62)
    Type => "Config",
    IfgPerSourceIf => { #Structure Type: RegField;
      Name => "IfgPerSourceIf",
      RegMem => "RegField",
      Description => "bitmap addressed by PD.source-if[7:2] ;
'0' - IFG0 ; '1' - IFG1",
      Width => "64",
      Position => "63:0", # Excel Formula: =calc_position(F58,E59,TRUE)
      Type => "Config",
      UsedBy => "ALL",
      DefaultValue => "b0",
    },
    Ifg0Compensation => { #Structure Type: RegField;
      Name => "Ifg0Compensation",
      RegMem => "RegField",
      Description => "Compensation size if the source of ther PD is IFG0; Two's complement value",
      Width => "7", # Excel Formula: =calc_field_width_define("IFG_COMPENSATION_WIDTH")
      Position => "70:64", # Excel Formula: =calc_position(F59,E60)
      Type => "Config",
      UsedBy => "ALL",
      DefaultValue => "d10",
    },
    Ifg1Compensation => { #Structure Type: RegField;
      Name => "Ifg1Compensation",
      RegMem => "RegField",
      Description => "Compensation size if the source of ther PD is IFG1; Two's complement value",
      Width => "7", # Excel Formula: =calc_field_width_define("IFG_COMPENSATION_WIDTH")
      Position => "77:71", # Excel Formula: =calc_position(F60,E61)
      Type => "Config",
      UsedBy => "ALL",
      DefaultValue => "d20",
    },
    FabricSlice => { #Structure Type: RegField;
      Name => "FabricSlice",
      RegMem => "RegField",
      Description => "1' - fabric slice - thus dunt perform compensation
'0' -non fabric slice - thus perform compensation",
      Width => "1",
      Position => "78", # Excel Formula: =calc_position(F61,E62)
      Type => "Config",
      UsedBy => "ALL",
      DefaultValue => "d0",
    },
  },
  DynamicMappingConf => { #Structure Type: Reg;
    Name => "DynamicMappingConf",
    RegMem => "Reg",
    Address => "10B", # Excel Formula: =calc_reg_address(C58,A58,G58)
    Width => "89", # Excel Formula: =calc_reg_width(E64:E67,F67)
    Type => "Config",
    DynamicMappingTh0 => { #Structure Type: RegField;
      Name => "DynamicMappingTh0",
      RegMem => "RegField",
      Description => "If DynamicMappingProfile == 1 and free_pool_size < DynamicMappingTh0 dont map this VOQ to a context (drop all PDs of this VOQ)
This field was used for tuning parameters during the design phase. The value of this field is optimized for the current silicon, thus the user is not expected to change its value unless instructed by Cisco Systems, Inc.",
      Width => "12", # Excel Formula: =calc_field_width_define("CONTEXT_WIDTH")
      Position => "11:0", # Excel Formula: =calc_position(F63,E64,TRUE)
      Type => "Config",
      UsedBy => "CMAP",
      DefaultValue => "d1000",
    },
    DynamicMappingTh1 => { #Structure Type: RegField;
      Name => "DynamicMappingTh1",
      RegMem => "RegField",
      Description => "If DynamicMappingProfile == 2 and free_pool_size < DynamicMappingTh1 dont map this VOQ to a context (drop all PDs of this VOQ)
This field was used for tuning parameters during the design phase. The value of this field is optimized for the current silicon, thus the user is not expected to change its value unless instructed by Cisco Systems, Inc.",
      Width => "12", # Excel Formula: =calc_field_width_define("CONTEXT_WIDTH")
      Position => "23:12", # Excel Formula: =calc_position(F64,E65)
      Type => "Config",
      UsedBy => "CMAP",
      DefaultValue => "d500",
    },
    DynamicMappingProfile => { #Structure Type: RegField;
      Name => "DynamicMappingProfile",
      RegMem => "RegField",
      Description => "2 bit per profile 
if DynamicMappingProfile == 0 then drop the PD only if there is no avaliable context
if DynamicMappingProfile == 1 then drop the PD if the used buffer count > Th0
if DynamicMappingProfile == 2 then drop the PD if the used buffer count > Th1
This field was used for tuning parameters during the design phase. The value of this field is optimized for the current silicon, thus the user is not expected to change its value unless instructed by Cisco Systems, Inc.",
      Width => "64", # Excel Formula: =2*calc_field_width_define("VOQ_CGM_NUM_OF_PROFILES")
      Position => "87:24", # Excel Formula: =calc_position(F65,E66)
      Type => "Config",
      UsedBy => "CMAP",
      DefaultValue => "d0",
    },
    ChickenContextReleaseEn => { #Structure Type: RegField;
      Name => "ChickenContextReleaseEn",
      RegMem => "RegField",
      Description => "If '1' try to release every context by a counter
This field was used for tuning parameters during the design phase. The value of this field is optimized for the current silicon, thus the user is not expected to change its value unless instructed by Cisco Systems, Inc.",
      Width => "1",
      Position => "88", # Excel Formula: =calc_position(F66,E67)
      Type => "Config",
      UsedBy => "CMAP",
      DefaultValue => "d0",
    },
  },
  CpuReturnContext => { #Structure Type: Reg;
    Name => "CpuReturnContext",
    RegMem => "Reg",
    Address => "10C", # Excel Formula: =calc_reg_address(C63,A63,G63)
    Description => "CPU return context to the dynamic context allocation machine. One use is in case of aged out queue.",
    Width => "12", # Excel Formula: =calc_reg_width(E69:E69,F69)
    Type => "External",
    UsedBy => "CMAP",
    AdditionalInfo => "ExternalBackdoorWriteEnable",
    ReturnContext => { #Structure Type: RegField;
      Name => "ReturnContext",
      RegMem => "RegField",
      Width => "12", # Excel Formula: =calc_field_width_define("CONTEXT_WIDTH")
      Position => "11:0", # Excel Formula: =calc_position(F68,E69,TRUE)
      Type => "External",
    },
  },
  CpuReturnContextStatus => { #Structure Type: Reg;
    Name => "CpuReturnContextStatus",
    RegMem => "Reg",
    Address => "10D", # Excel Formula: =calc_reg_address(C68,A68,G68)
    Description => "CPU may/may-not return context to the dynamic context allocation machine. One use is in case of aged out queue.",
    Width => "1", # Excel Formula: =calc_reg_width(E71:E71,F71)
    Type => "ReadOnly",
    ReturnReady => { #Structure Type: RegField;
      Name => "ReturnReady",
      RegMem => "RegField",
      Description => "1' - ready - CPU may return a context",
      Width => "1",
      Position => "0", # Excel Formula: =calc_position(F70,E71,TRUE)
      Type => "Status",
      UsedBy => "CMAP",
    },
  },
  Profile2SliceProfile0 => { #Structure Type: Reg; ArrayLength: 16; ArrayIndex: 0; ArrayLocationInName: 21;
    Name => "Profile2SliceProfile[16]",
    RegMem => "Reg",
    Address => "10E", # Excel Formula: =calc_reg_address(C70,A70,G70)
    Description => "Reserve - Unused",
    Width => "3", # Excel Formula: =calc_reg_width(E73:E73,F73)
    Type => "Config",
    DocName => "CgmReservedReg",
    AdditionalInfo => "PackArrayToBus",
    ArrayLength => "16",
    ArrayIndex => "0",
    CGMProfile0 => { #Structure Type: RegField; ArrayLength: 16; ArrayIndex: 0; ArrayLocationInName: 11;
      Name => "CGMProfile[n]",
      RegMem => "RegField",
      Description => "Reserve - Unused",
      Width => "3",
      Position => "2:0", # Excel Formula: =calc_position(F72,E73,TRUE)
      Type => "Config",
      UsedBy => "Voq_CGM",
      DefaultValue => "h0",
      DocName => "CgmReservedField",
    },
  },
  Profile2SliceProfile1 => { #Structure Type: Reg; ArrayLength: 16; ArrayIndex: 1; ArrayLocationInName: 21;
    Name => "Profile2SliceProfile[16]",
    RegMem => "Reg",
    Address => "10F",
    Description => "Reserve - Unused",
    Width => "3", # Excel Formula: =calc_reg_width(E73:E73,F73)
    Type => "Config",
    DocName => "CgmReservedReg",
    AdditionalInfo => "PackArrayToBus",
    ArrayLength => "16",
    ArrayIndex => "1",
    CGMProfile1 => { #Structure Type: RegField; ArrayLength: 16; ArrayIndex: 1; ArrayLocationInName: 11;
      Name => "CGMProfile[n]",
      RegMem => "RegField",
      Description => "Reserve - Unused",
      Width => "3",
      Position => "2:0", # Excel Formula: =calc_position(F72,E73,TRUE)
      Type => "Config",
      UsedBy => "Voq_CGM",
      DefaultValue => "h0",
      DocName => "CgmReservedField",
    },
  },
  Profile2SliceProfile2 => { #Structure Type: Reg; ArrayLength: 16; ArrayIndex: 2; ArrayLocationInName: 21;
    Name => "Profile2SliceProfile[16]",
    RegMem => "Reg",
    Address => "110",
    Description => "Reserve - Unused",
    Width => "3", # Excel Formula: =calc_reg_width(E73:E73,F73)
    Type => "Config",
    DocName => "CgmReservedReg",
    AdditionalInfo => "PackArrayToBus",
    ArrayLength => "16",
    ArrayIndex => "2",
    CGMProfile2 => { #Structure Type: RegField; ArrayLength: 16; ArrayIndex: 2; ArrayLocationInName: 11;
      Name => "CGMProfile[n]",
      RegMem => "RegField",
      Description => "Reserve - Unused",
      Width => "3",
      Position => "2:0", # Excel Formula: =calc_position(F72,E73,TRUE)
      Type => "Config",
      UsedBy => "Voq_CGM",
      DefaultValue => "h0",
      DocName => "CgmReservedField",
    },
  },
  Profile2SliceProfile3 => { #Structure Type: Reg; ArrayLength: 16; ArrayIndex: 3; ArrayLocationInName: 21;
    Name => "Profile2SliceProfile[16]",
    RegMem => "Reg",
    Address => "111",
    Description => "Reserve - Unused",
    Width => "3", # Excel Formula: =calc_reg_width(E73:E73,F73)
    Type => "Config",
    DocName => "CgmReservedReg",
    AdditionalInfo => "PackArrayToBus",
    ArrayLength => "16",
    ArrayIndex => "3",
    CGMProfile3 => { #Structure Type: RegField; ArrayLength: 16; ArrayIndex: 3; ArrayLocationInName: 11;
      Name => "CGMProfile[n]",
      RegMem => "RegField",
      Description => "Reserve - Unused",
      Width => "3",
      Position => "2:0", # Excel Formula: =calc_position(F72,E73,TRUE)
      Type => "Config",
      UsedBy => "Voq_CGM",
      DefaultValue => "h0",
      DocName => "CgmReservedField",
    },
  },
  Profile2SliceProfile4 => { #Structure Type: Reg; ArrayLength: 16; ArrayIndex: 4; ArrayLocationInName: 21;
    Name => "Profile2SliceProfile[16]",
    RegMem => "Reg",
    Address => "112",
    Description => "Reserve - Unused",
    Width => "3", # Excel Formula: =calc_reg_width(E73:E73,F73)
    Type => "Config",
    DocName => "CgmReservedReg",
    AdditionalInfo => "PackArrayToBus",
    ArrayLength => "16",
    ArrayIndex => "4",
    CGMProfile4 => { #Structure Type: RegField; ArrayLength: 16; ArrayIndex: 4; ArrayLocationInName: 11;
      Name => "CGMProfile[n]",
      RegMem => "RegField",
      Description => "Reserve - Unused",
      Width => "3",
      Position => "2:0", # Excel Formula: =calc_position(F72,E73,TRUE)
      Type => "Config",
      UsedBy => "Voq_CGM",
      DefaultValue => "h0",
      DocName => "CgmReservedField",
    },
  },
  Profile2SliceProfile5 => { #Structure Type: Reg; ArrayLength: 16; ArrayIndex: 5; ArrayLocationInName: 21;
    Name => "Profile2SliceProfile[16]",
    RegMem => "Reg",
    Address => "113",
    Description => "Reserve - Unused",
    Width => "3", # Excel Formula: =calc_reg_width(E73:E73,F73)
    Type => "Config",
    DocName => "CgmReservedReg",
    AdditionalInfo => "PackArrayToBus",
    ArrayLength => "16",
    ArrayIndex => "5",
    CGMProfile5 => { #Structure Type: RegField; ArrayLength: 16; ArrayIndex: 5; ArrayLocationInName: 11;
      Name => "CGMProfile[n]",
      RegMem => "RegField",
      Description => "Reserve - Unused",
      Width => "3",
      Position => "2:0", # Excel Formula: =calc_position(F72,E73,TRUE)
      Type => "Config",
      UsedBy => "Voq_CGM",
      DefaultValue => "h0",
      DocName => "CgmReservedField",
    },
  },
  Profile2SliceProfile6 => { #Structure Type: Reg; ArrayLength: 16; ArrayIndex: 6; ArrayLocationInName: 21;
    Name => "Profile2SliceProfile[16]",
    RegMem => "Reg",
    Address => "114",
    Description => "Reserve - Unused",
    Width => "3", # Excel Formula: =calc_reg_width(E73:E73,F73)
    Type => "Config",
    DocName => "CgmReservedReg",
    AdditionalInfo => "PackArrayToBus",
    ArrayLength => "16",
    ArrayIndex => "6",
    CGMProfile6 => { #Structure Type: RegField; ArrayLength: 16; ArrayIndex: 6; ArrayLocationInName: 11;
      Name => "CGMProfile[n]",
      RegMem => "RegField",
      Description => "Reserve - Unused",
      Width => "3",
      Position => "2:0", # Excel Formula: =calc_position(F72,E73,TRUE)
      Type => "Config",
      UsedBy => "Voq_CGM",
      DefaultValue => "h0",
      DocName => "CgmReservedField",
    },
  },
  Profile2SliceProfile7 => { #Structure Type: Reg; ArrayLength: 16; ArrayIndex: 7; ArrayLocationInName: 21;
    Name => "Profile2SliceProfile[16]",
    RegMem => "Reg",
    Address => "115",
    Description => "Reserve - Unused",
    Width => "3", # Excel Formula: =calc_reg_width(E73:E73,F73)
    Type => "Config",
    DocName => "CgmReservedReg",
    AdditionalInfo => "PackArrayToBus",
    ArrayLength => "16",
    ArrayIndex => "7",
    CGMProfile7 => { #Structure Type: RegField; ArrayLength: 16; ArrayIndex: 7; ArrayLocationInName: 11;
      Name => "CGMProfile[n]",
      RegMem => "RegField",
      Description => "Reserve - Unused",
      Width => "3",
      Position => "2:0", # Excel Formula: =calc_position(F72,E73,TRUE)
      Type => "Config",
      UsedBy => "Voq_CGM",
      DefaultValue => "h0",
      DocName => "CgmReservedField",
    },
  },
  Profile2SliceProfile8 => { #Structure Type: Reg; ArrayLength: 16; ArrayIndex: 8; ArrayLocationInName: 21;
    Name => "Profile2SliceProfile[16]",
    RegMem => "Reg",
    Address => "116",
    Description => "Reserve - Unused",
    Width => "3", # Excel Formula: =calc_reg_width(E73:E73,F73)
    Type => "Config",
    DocName => "CgmReservedReg",
    AdditionalInfo => "PackArrayToBus",
    ArrayLength => "16",
    ArrayIndex => "8",
    CGMProfile8 => { #Structure Type: RegField; ArrayLength: 16; ArrayIndex: 8; ArrayLocationInName: 11;
      Name => "CGMProfile[n]",
      RegMem => "RegField",
      Description => "Reserve - Unused",
      Width => "3",
      Position => "2:0", # Excel Formula: =calc_position(F72,E73,TRUE)
      Type => "Config",
      UsedBy => "Voq_CGM",
      DefaultValue => "h0",
      DocName => "CgmReservedField",
    },
  },
  Profile2SliceProfile9 => { #Structure Type: Reg; ArrayLength: 16; ArrayIndex: 9; ArrayLocationInName: 21;
    Name => "Profile2SliceProfile[16]",
    RegMem => "Reg",
    Address => "117",
    Description => "Reserve - Unused",
    Width => "3", # Excel Formula: =calc_reg_width(E73:E73,F73)
    Type => "Config",
    DocName => "CgmReservedReg",
    AdditionalInfo => "PackArrayToBus",
    ArrayLength => "16",
    ArrayIndex => "9",
    CGMProfile9 => { #Structure Type: RegField; ArrayLength: 16; ArrayIndex: 9; ArrayLocationInName: 11;
      Name => "CGMProfile[n]",
      RegMem => "RegField",
      Description => "Reserve - Unused",
      Width => "3",
      Position => "2:0", # Excel Formula: =calc_position(F72,E73,TRUE)
      Type => "Config",
      UsedBy => "Voq_CGM",
      DefaultValue => "h0",
      DocName => "CgmReservedField",
    },
  },
  Profile2SliceProfile10 => { #Structure Type: Reg; ArrayLength: 16; ArrayIndex: 10; ArrayLocationInName: 21;
    Name => "Profile2SliceProfile[16]",
    RegMem => "Reg",
    Address => "118",
    Description => "Reserve - Unused",
    Width => "3", # Excel Formula: =calc_reg_width(E73:E73,F73)
    Type => "Config",
    DocName => "CgmReservedReg",
    AdditionalInfo => "PackArrayToBus",
    ArrayLength => "16",
    ArrayIndex => "10",
    CGMProfile10 => { #Structure Type: RegField; ArrayLength: 16; ArrayIndex: 10; ArrayLocationInName: 11;
      Name => "CGMProfile[n]",
      RegMem => "RegField",
      Description => "Reserve - Unused",
      Width => "3",
      Position => "2:0", # Excel Formula: =calc_position(F72,E73,TRUE)
      Type => "Config",
      UsedBy => "Voq_CGM",
      DefaultValue => "h0",
      DocName => "CgmReservedField",
    },
  },
  Profile2SliceProfile11 => { #Structure Type: Reg; ArrayLength: 16; ArrayIndex: 11; ArrayLocationInName: 21;
    Name => "Profile2SliceProfile[16]",
    RegMem => "Reg",
    Address => "119",
    Description => "Reserve - Unused",
    Width => "3", # Excel Formula: =calc_reg_width(E73:E73,F73)
    Type => "Config",
    DocName => "CgmReservedReg",
    AdditionalInfo => "PackArrayToBus",
    ArrayLength => "16",
    ArrayIndex => "11",
    CGMProfile11 => { #Structure Type: RegField; ArrayLength: 16; ArrayIndex: 11; ArrayLocationInName: 11;
      Name => "CGMProfile[n]",
      RegMem => "RegField",
      Description => "Reserve - Unused",
      Width => "3",
      Position => "2:0", # Excel Formula: =calc_position(F72,E73,TRUE)
      Type => "Config",
      UsedBy => "Voq_CGM",
      DefaultValue => "h0",
      DocName => "CgmReservedField",
    },
  },
  Profile2SliceProfile12 => { #Structure Type: Reg; ArrayLength: 16; ArrayIndex: 12; ArrayLocationInName: 21;
    Name => "Profile2SliceProfile[16]",
    RegMem => "Reg",
    Address => "11A",
    Description => "Reserve - Unused",
    Width => "3", # Excel Formula: =calc_reg_width(E73:E73,F73)
    Type => "Config",
    DocName => "CgmReservedReg",
    AdditionalInfo => "PackArrayToBus",
    ArrayLength => "16",
    ArrayIndex => "12",
    CGMProfile12 => { #Structure Type: RegField; ArrayLength: 16; ArrayIndex: 12; ArrayLocationInName: 11;
      Name => "CGMProfile[n]",
      RegMem => "RegField",
      Description => "Reserve - Unused",
      Width => "3",
      Position => "2:0", # Excel Formula: =calc_position(F72,E73,TRUE)
      Type => "Config",
      UsedBy => "Voq_CGM",
      DefaultValue => "h0",
      DocName => "CgmReservedField",
    },
  },
  Profile2SliceProfile13 => { #Structure Type: Reg; ArrayLength: 16; ArrayIndex: 13; ArrayLocationInName: 21;
    Name => "Profile2SliceProfile[16]",
    RegMem => "Reg",
    Address => "11B",
    Description => "Reserve - Unused",
    Width => "3", # Excel Formula: =calc_reg_width(E73:E73,F73)
    Type => "Config",
    DocName => "CgmReservedReg",
    AdditionalInfo => "PackArrayToBus",
    ArrayLength => "16",
    ArrayIndex => "13",
    CGMProfile13 => { #Structure Type: RegField; ArrayLength: 16; ArrayIndex: 13; ArrayLocationInName: 11;
      Name => "CGMProfile[n]",
      RegMem => "RegField",
      Description => "Reserve - Unused",
      Width => "3",
      Position => "2:0", # Excel Formula: =calc_position(F72,E73,TRUE)
      Type => "Config",
      UsedBy => "Voq_CGM",
      DefaultValue => "h0",
      DocName => "CgmReservedField",
    },
  },
  Profile2SliceProfile14 => { #Structure Type: Reg; ArrayLength: 16; ArrayIndex: 14; ArrayLocationInName: 21;
    Name => "Profile2SliceProfile[16]",
    RegMem => "Reg",
    Address => "11C",
    Description => "Reserve - Unused",
    Width => "3", # Excel Formula: =calc_reg_width(E73:E73,F73)
    Type => "Config",
    DocName => "CgmReservedReg",
    AdditionalInfo => "PackArrayToBus",
    ArrayLength => "16",
    ArrayIndex => "14",
    CGMProfile14 => { #Structure Type: RegField; ArrayLength: 16; ArrayIndex: 14; ArrayLocationInName: 11;
      Name => "CGMProfile[n]",
      RegMem => "RegField",
      Description => "Reserve - Unused",
      Width => "3",
      Position => "2:0", # Excel Formula: =calc_position(F72,E73,TRUE)
      Type => "Config",
      UsedBy => "Voq_CGM",
      DefaultValue => "h0",
      DocName => "CgmReservedField",
    },
  },
  Profile2SliceProfile15 => { #Structure Type: Reg; ArrayLength: 16; ArrayIndex: 15; ArrayLocationInName: 21;
    Name => "Profile2SliceProfile[16]",
    RegMem => "Reg",
    Address => "11D",
    Description => "Reserve - Unused",
    Width => "3", # Excel Formula: =calc_reg_width(E73:E73,F73)
    Type => "Config",
    DocName => "CgmReservedReg",
    AdditionalInfo => "PackArrayToBus",
    ArrayLength => "16",
    ArrayIndex => "15",
    CGMProfile15 => { #Structure Type: RegField; ArrayLength: 16; ArrayIndex: 15; ArrayLocationInName: 11;
      Name => "CGMProfile[n]",
      RegMem => "RegField",
      Description => "Reserve - Unused",
      Width => "3",
      Position => "2:0", # Excel Formula: =calc_position(F72,E73,TRUE)
      Type => "Config",
      UsedBy => "Voq_CGM",
      DefaultValue => "h0",
      DocName => "CgmReservedField",
    },
  },
  DeleteQueueCounterId => { #Structure Type: Reg;
    Name => "DeleteQueueCounterId",
    RegMem => "Reg",
    Address => "11E", # Excel Formula: =calc_reg_address(C72,A72,G72)
    Description => "See field's description",
    Width => "3", # Excel Formula: =calc_reg_width(E75:E75,F75)
    Type => "Config",
    DocName => "DeleteQueueCounterId",
    DeleteCounterId => { #Structure Type: RegField;
      Name => "DeleteCounterId",
      RegMem => "RegField",
      Description => "PD Counter ID for delete queue.
Selects which PD counter accounts for the delete queue.
Default is to not count delete PDs in any counter.",
      Width => "3", # Excel Formula: =calc_field_width_define("VOQ_CGM_COUNTER_NUM_WIDTH")
      Position => "2:0", # Excel Formula: =calc_position(F74,E75,TRUE)
      Type => "Config",
      UsedBy => "Voq_CGM",
      DefaultValue => "h4",
      DocName => "DeleteCounterId",
    },
  },
  SliceCGMProfile0 => { #Structure Type: Reg; ArrayLength: 32; ArrayIndex: 0; ArrayLocationInName: 16;
    Name => "SliceCGMProfile[32]",
    RegMem => "Reg",
    Address => "11F", # Excel Formula: =calc_reg_address(C74,A74,G74)
    Description => "CGM Global Configs",
    Width => "3", # Excel Formula: =calc_reg_width(E77:E77,F77)
    Type => "Config",
    DocName => "SliceCgmProfile",
    AdditionalInfo => "PackArrayToBus",
    ArrayLength => "32",
    ArrayIndex => "0",
    CounterId0 => { #Structure Type: RegField; ArrayLength: 32; ArrayIndex: 0; ArrayLocationInName: 10;
      Name => "CounterId[n]",
      RegMem => "RegField",
      Description => "Map CGM profile to PD counter.
Values :
0 - 3 : counter ID
4 : Do not count
5-7 : Unused",
      Width => "3", # Excel Formula: =calc_field_width_define("VOQ_CGM_COUNTER_NUM_WIDTH")
      Position => "2:0", # Excel Formula: =calc_position(F76,E77,TRUE)
      Type => "Config",
      UsedBy => "Voq_CGM",
      DefaultValue => "h0",
      DocName => "CounterId",
      Comments => "VOQ_CGM_COUNTER_UC  = d0
VOQ_CGM_COUNTER_MC = d1
VOQ_CGM_COUNTER_MS_UC = d2
VOQ_CGM_COUNTER_MS_MC = d3
VOQ_CGM_COUNTER_IGNORE = d4",
    },
  },
  SliceCGMProfile1 => { #Structure Type: Reg; ArrayLength: 32; ArrayIndex: 1; ArrayLocationInName: 16;
    Name => "SliceCGMProfile[32]",
    RegMem => "Reg",
    Address => "120",
    Description => "CGM Global Configs",
    Width => "3", # Excel Formula: =calc_reg_width(E77:E77,F77)
    Type => "Config",
    DocName => "SliceCgmProfile",
    AdditionalInfo => "PackArrayToBus",
    ArrayLength => "32",
    ArrayIndex => "1",
    CounterId1 => { #Structure Type: RegField; ArrayLength: 32; ArrayIndex: 1; ArrayLocationInName: 10;
      Name => "CounterId[n]",
      RegMem => "RegField",
      Description => "Map CGM profile to PD counter.
Values :
0 - 3 : counter ID
4 : Do not count
5-7 : Unused",
      Width => "3", # Excel Formula: =calc_field_width_define("VOQ_CGM_COUNTER_NUM_WIDTH")
      Position => "2:0", # Excel Formula: =calc_position(F76,E77,TRUE)
      Type => "Config",
      UsedBy => "Voq_CGM",
      DefaultValue => "h0",
      DocName => "CounterId",
      Comments => "VOQ_CGM_COUNTER_UC  = d0
VOQ_CGM_COUNTER_MC = d1
VOQ_CGM_COUNTER_MS_UC = d2
VOQ_CGM_COUNTER_MS_MC = d3
VOQ_CGM_COUNTER_IGNORE = d4",
    },
  },
  SliceCGMProfile2 => { #Structure Type: Reg; ArrayLength: 32; ArrayIndex: 2; ArrayLocationInName: 16;
    Name => "SliceCGMProfile[32]",
    RegMem => "Reg",
    Address => "121",
    Description => "CGM Global Configs",
    Width => "3", # Excel Formula: =calc_reg_width(E77:E77,F77)
    Type => "Config",
    DocName => "SliceCgmProfile",
    AdditionalInfo => "PackArrayToBus",
    ArrayLength => "32",
    ArrayIndex => "2",
    CounterId2 => { #Structure Type: RegField; ArrayLength: 32; ArrayIndex: 2; ArrayLocationInName: 10;
      Name => "CounterId[n]",
      RegMem => "RegField",
      Description => "Map CGM profile to PD counter.
Values :
0 - 3 : counter ID
4 : Do not count
5-7 : Unused",
      Width => "3", # Excel Formula: =calc_field_width_define("VOQ_CGM_COUNTER_NUM_WIDTH")
      Position => "2:0", # Excel Formula: =calc_position(F76,E77,TRUE)
      Type => "Config",
      UsedBy => "Voq_CGM",
      DefaultValue => "h0",
      DocName => "CounterId",
      Comments => "VOQ_CGM_COUNTER_UC  = d0
VOQ_CGM_COUNTER_MC = d1
VOQ_CGM_COUNTER_MS_UC = d2
VOQ_CGM_COUNTER_MS_MC = d3
VOQ_CGM_COUNTER_IGNORE = d4",
    },
  },
  SliceCGMProfile3 => { #Structure Type: Reg; ArrayLength: 32; ArrayIndex: 3; ArrayLocationInName: 16;
    Name => "SliceCGMProfile[32]",
    RegMem => "Reg",
    Address => "122",
    Description => "CGM Global Configs",
    Width => "3", # Excel Formula: =calc_reg_width(E77:E77,F77)
    Type => "Config",
    DocName => "SliceCgmProfile",
    AdditionalInfo => "PackArrayToBus",
    ArrayLength => "32",
    ArrayIndex => "3",
    CounterId3 => { #Structure Type: RegField; ArrayLength: 32; ArrayIndex: 3; ArrayLocationInName: 10;
      Name => "CounterId[n]",
      RegMem => "RegField",
      Description => "Map CGM profile to PD counter.
Values :
0 - 3 : counter ID
4 : Do not count
5-7 : Unused",
      Width => "3", # Excel Formula: =calc_field_width_define("VOQ_CGM_COUNTER_NUM_WIDTH")
      Position => "2:0", # Excel Formula: =calc_position(F76,E77,TRUE)
      Type => "Config",
      UsedBy => "Voq_CGM",
      DefaultValue => "h0",
      DocName => "CounterId",
      Comments => "VOQ_CGM_COUNTER_UC  = d0
VOQ_CGM_COUNTER_MC = d1
VOQ_CGM_COUNTER_MS_UC = d2
VOQ_CGM_COUNTER_MS_MC = d3
VOQ_CGM_COUNTER_IGNORE = d4",
    },
  },
  SliceCGMProfile4 => { #Structure Type: Reg; ArrayLength: 32; ArrayIndex: 4; ArrayLocationInName: 16;
    Name => "SliceCGMProfile[32]",
    RegMem => "Reg",
    Address => "123",
    Description => "CGM Global Configs",
    Width => "3", # Excel Formula: =calc_reg_width(E77:E77,F77)
    Type => "Config",
    DocName => "SliceCgmProfile",
    AdditionalInfo => "PackArrayToBus",
    ArrayLength => "32",
    ArrayIndex => "4",
    CounterId4 => { #Structure Type: RegField; ArrayLength: 32; ArrayIndex: 4; ArrayLocationInName: 10;
      Name => "CounterId[n]",
      RegMem => "RegField",
      Description => "Map CGM profile to PD counter.
Values :
0 - 3 : counter ID
4 : Do not count
5-7 : Unused",
      Width => "3", # Excel Formula: =calc_field_width_define("VOQ_CGM_COUNTER_NUM_WIDTH")
      Position => "2:0", # Excel Formula: =calc_position(F76,E77,TRUE)
      Type => "Config",
      UsedBy => "Voq_CGM",
      DefaultValue => "h0",
      DocName => "CounterId",
      Comments => "VOQ_CGM_COUNTER_UC  = d0
VOQ_CGM_COUNTER_MC = d1
VOQ_CGM_COUNTER_MS_UC = d2
VOQ_CGM_COUNTER_MS_MC = d3
VOQ_CGM_COUNTER_IGNORE = d4",
    },
  },
  SliceCGMProfile5 => { #Structure Type: Reg; ArrayLength: 32; ArrayIndex: 5; ArrayLocationInName: 16;
    Name => "SliceCGMProfile[32]",
    RegMem => "Reg",
    Address => "124",
    Description => "CGM Global Configs",
    Width => "3", # Excel Formula: =calc_reg_width(E77:E77,F77)
    Type => "Config",
    DocName => "SliceCgmProfile",
    AdditionalInfo => "PackArrayToBus",
    ArrayLength => "32",
    ArrayIndex => "5",
    CounterId5 => { #Structure Type: RegField; ArrayLength: 32; ArrayIndex: 5; ArrayLocationInName: 10;
      Name => "CounterId[n]",
      RegMem => "RegField",
      Description => "Map CGM profile to PD counter.
Values :
0 - 3 : counter ID
4 : Do not count
5-7 : Unused",
      Width => "3", # Excel Formula: =calc_field_width_define("VOQ_CGM_COUNTER_NUM_WIDTH")
      Position => "2:0", # Excel Formula: =calc_position(F76,E77,TRUE)
      Type => "Config",
      UsedBy => "Voq_CGM",
      DefaultValue => "h0",
      DocName => "CounterId",
      Comments => "VOQ_CGM_COUNTER_UC  = d0
VOQ_CGM_COUNTER_MC = d1
VOQ_CGM_COUNTER_MS_UC = d2
VOQ_CGM_COUNTER_MS_MC = d3
VOQ_CGM_COUNTER_IGNORE = d4",
    },
  },
  SliceCGMProfile6 => { #Structure Type: Reg; ArrayLength: 32; ArrayIndex: 6; ArrayLocationInName: 16;
    Name => "SliceCGMProfile[32]",
    RegMem => "Reg",
    Address => "125",
    Description => "CGM Global Configs",
    Width => "3", # Excel Formula: =calc_reg_width(E77:E77,F77)
    Type => "Config",
    DocName => "SliceCgmProfile",
    AdditionalInfo => "PackArrayToBus",
    ArrayLength => "32",
    ArrayIndex => "6",
    CounterId6 => { #Structure Type: RegField; ArrayLength: 32; ArrayIndex: 6; ArrayLocationInName: 10;
      Name => "CounterId[n]",
      RegMem => "RegField",
      Description => "Map CGM profile to PD counter.
Values :
0 - 3 : counter ID
4 : Do not count
5-7 : Unused",
      Width => "3", # Excel Formula: =calc_field_width_define("VOQ_CGM_COUNTER_NUM_WIDTH")
      Position => "2:0", # Excel Formula: =calc_position(F76,E77,TRUE)
      Type => "Config",
      UsedBy => "Voq_CGM",
      DefaultValue => "h0",
      DocName => "CounterId",
      Comments => "VOQ_CGM_COUNTER_UC  = d0
VOQ_CGM_COUNTER_MC = d1
VOQ_CGM_COUNTER_MS_UC = d2
VOQ_CGM_COUNTER_MS_MC = d3
VOQ_CGM_COUNTER_IGNORE = d4",
    },
  },
  SliceCGMProfile7 => { #Structure Type: Reg; ArrayLength: 32; ArrayIndex: 7; ArrayLocationInName: 16;
    Name => "SliceCGMProfile[32]",
    RegMem => "Reg",
    Address => "126",
    Description => "CGM Global Configs",
    Width => "3", # Excel Formula: =calc_reg_width(E77:E77,F77)
    Type => "Config",
    DocName => "SliceCgmProfile",
    AdditionalInfo => "PackArrayToBus",
    ArrayLength => "32",
    ArrayIndex => "7",
    CounterId7 => { #Structure Type: RegField; ArrayLength: 32; ArrayIndex: 7; ArrayLocationInName: 10;
      Name => "CounterId[n]",
      RegMem => "RegField",
      Description => "Map CGM profile to PD counter.
Values :
0 - 3 : counter ID
4 : Do not count
5-7 : Unused",
      Width => "3", # Excel Formula: =calc_field_width_define("VOQ_CGM_COUNTER_NUM_WIDTH")
      Position => "2:0", # Excel Formula: =calc_position(F76,E77,TRUE)
      Type => "Config",
      UsedBy => "Voq_CGM",
      DefaultValue => "h0",
      DocName => "CounterId",
      Comments => "VOQ_CGM_COUNTER_UC  = d0
VOQ_CGM_COUNTER_MC = d1
VOQ_CGM_COUNTER_MS_UC = d2
VOQ_CGM_COUNTER_MS_MC = d3
VOQ_CGM_COUNTER_IGNORE = d4",
    },
  },
  SliceCGMProfile8 => { #Structure Type: Reg; ArrayLength: 32; ArrayIndex: 8; ArrayLocationInName: 16;
    Name => "SliceCGMProfile[32]",
    RegMem => "Reg",
    Address => "127",
    Description => "CGM Global Configs",
    Width => "3", # Excel Formula: =calc_reg_width(E77:E77,F77)
    Type => "Config",
    DocName => "SliceCgmProfile",
    AdditionalInfo => "PackArrayToBus",
    ArrayLength => "32",
    ArrayIndex => "8",
    CounterId8 => { #Structure Type: RegField; ArrayLength: 32; ArrayIndex: 8; ArrayLocationInName: 10;
      Name => "CounterId[n]",
      RegMem => "RegField",
      Description => "Map CGM profile to PD counter.
Values :
0 - 3 : counter ID
4 : Do not count
5-7 : Unused",
      Width => "3", # Excel Formula: =calc_field_width_define("VOQ_CGM_COUNTER_NUM_WIDTH")
      Position => "2:0", # Excel Formula: =calc_position(F76,E77,TRUE)
      Type => "Config",
      UsedBy => "Voq_CGM",
      DefaultValue => "h0",
      DocName => "CounterId",
      Comments => "VOQ_CGM_COUNTER_UC  = d0
VOQ_CGM_COUNTER_MC = d1
VOQ_CGM_COUNTER_MS_UC = d2
VOQ_CGM_COUNTER_MS_MC = d3
VOQ_CGM_COUNTER_IGNORE = d4",
    },
  },
  SliceCGMProfile9 => { #Structure Type: Reg; ArrayLength: 32; ArrayIndex: 9; ArrayLocationInName: 16;
    Name => "SliceCGMProfile[32]",
    RegMem => "Reg",
    Address => "128",
    Description => "CGM Global Configs",
    Width => "3", # Excel Formula: =calc_reg_width(E77:E77,F77)
    Type => "Config",
    DocName => "SliceCgmProfile",
    AdditionalInfo => "PackArrayToBus",
    ArrayLength => "32",
    ArrayIndex => "9",
    CounterId9 => { #Structure Type: RegField; ArrayLength: 32; ArrayIndex: 9; ArrayLocationInName: 10;
      Name => "CounterId[n]",
      RegMem => "RegField",
      Description => "Map CGM profile to PD counter.
Values :
0 - 3 : counter ID
4 : Do not count
5-7 : Unused",
      Width => "3", # Excel Formula: =calc_field_width_define("VOQ_CGM_COUNTER_NUM_WIDTH")
      Position => "2:0", # Excel Formula: =calc_position(F76,E77,TRUE)
      Type => "Config",
      UsedBy => "Voq_CGM",
      DefaultValue => "h0",
      DocName => "CounterId",
      Comments => "VOQ_CGM_COUNTER_UC  = d0
VOQ_CGM_COUNTER_MC = d1
VOQ_CGM_COUNTER_MS_UC = d2
VOQ_CGM_COUNTER_MS_MC = d3
VOQ_CGM_COUNTER_IGNORE = d4",
    },
  },
  SliceCGMProfile10 => { #Structure Type: Reg; ArrayLength: 32; ArrayIndex: 10; ArrayLocationInName: 16;
    Name => "SliceCGMProfile[32]",
    RegMem => "Reg",
    Address => "129",
    Description => "CGM Global Configs",
    Width => "3", # Excel Formula: =calc_reg_width(E77:E77,F77)
    Type => "Config",
    DocName => "SliceCgmProfile",
    AdditionalInfo => "PackArrayToBus",
    ArrayLength => "32",
    ArrayIndex => "10",
    CounterId10 => { #Structure Type: RegField; ArrayLength: 32; ArrayIndex: 10; ArrayLocationInName: 10;
      Name => "CounterId[n]",
      RegMem => "RegField",
      Description => "Map CGM profile to PD counter.
Values :
0 - 3 : counter ID
4 : Do not count
5-7 : Unused",
      Width => "3", # Excel Formula: =calc_field_width_define("VOQ_CGM_COUNTER_NUM_WIDTH")
      Position => "2:0", # Excel Formula: =calc_position(F76,E77,TRUE)
      Type => "Config",
      UsedBy => "Voq_CGM",
      DefaultValue => "h0",
      DocName => "CounterId",
      Comments => "VOQ_CGM_COUNTER_UC  = d0
VOQ_CGM_COUNTER_MC = d1
VOQ_CGM_COUNTER_MS_UC = d2
VOQ_CGM_COUNTER_MS_MC = d3
VOQ_CGM_COUNTER_IGNORE = d4",
    },
  },
  SliceCGMProfile11 => { #Structure Type: Reg; ArrayLength: 32; ArrayIndex: 11; ArrayLocationInName: 16;
    Name => "SliceCGMProfile[32]",
    RegMem => "Reg",
    Address => "12A",
    Description => "CGM Global Configs",
    Width => "3", # Excel Formula: =calc_reg_width(E77:E77,F77)
    Type => "Config",
    DocName => "SliceCgmProfile",
    AdditionalInfo => "PackArrayToBus",
    ArrayLength => "32",
    ArrayIndex => "11",
    CounterId11 => { #Structure Type: RegField; ArrayLength: 32; ArrayIndex: 11; ArrayLocationInName: 10;
      Name => "CounterId[n]",
      RegMem => "RegField",
      Description => "Map CGM profile to PD counter.
Values :
0 - 3 : counter ID
4 : Do not count
5-7 : Unused",
      Width => "3", # Excel Formula: =calc_field_width_define("VOQ_CGM_COUNTER_NUM_WIDTH")
      Position => "2:0", # Excel Formula: =calc_position(F76,E77,TRUE)
      Type => "Config",
      UsedBy => "Voq_CGM",
      DefaultValue => "h0",
      DocName => "CounterId",
      Comments => "VOQ_CGM_COUNTER_UC  = d0
VOQ_CGM_COUNTER_MC = d1
VOQ_CGM_COUNTER_MS_UC = d2
VOQ_CGM_COUNTER_MS_MC = d3
VOQ_CGM_COUNTER_IGNORE = d4",
    },
  },
  SliceCGMProfile12 => { #Structure Type: Reg; ArrayLength: 32; ArrayIndex: 12; ArrayLocationInName: 16;
    Name => "SliceCGMProfile[32]",
    RegMem => "Reg",
    Address => "12B",
    Description => "CGM Global Configs",
    Width => "3", # Excel Formula: =calc_reg_width(E77:E77,F77)
    Type => "Config",
    DocName => "SliceCgmProfile",
    AdditionalInfo => "PackArrayToBus",
    ArrayLength => "32",
    ArrayIndex => "12",
    CounterId12 => { #Structure Type: RegField; ArrayLength: 32; ArrayIndex: 12; ArrayLocationInName: 10;
      Name => "CounterId[n]",
      RegMem => "RegField",
      Description => "Map CGM profile to PD counter.
Values :
0 - 3 : counter ID
4 : Do not count
5-7 : Unused",
      Width => "3", # Excel Formula: =calc_field_width_define("VOQ_CGM_COUNTER_NUM_WIDTH")
      Position => "2:0", # Excel Formula: =calc_position(F76,E77,TRUE)
      Type => "Config",
      UsedBy => "Voq_CGM",
      DefaultValue => "h0",
      DocName => "CounterId",
      Comments => "VOQ_CGM_COUNTER_UC  = d0
VOQ_CGM_COUNTER_MC = d1
VOQ_CGM_COUNTER_MS_UC = d2
VOQ_CGM_COUNTER_MS_MC = d3
VOQ_CGM_COUNTER_IGNORE = d4",
    },
  },
  SliceCGMProfile13 => { #Structure Type: Reg; ArrayLength: 32; ArrayIndex: 13; ArrayLocationInName: 16;
    Name => "SliceCGMProfile[32]",
    RegMem => "Reg",
    Address => "12C",
    Description => "CGM Global Configs",
    Width => "3", # Excel Formula: =calc_reg_width(E77:E77,F77)
    Type => "Config",
    DocName => "SliceCgmProfile",
    AdditionalInfo => "PackArrayToBus",
    ArrayLength => "32",
    ArrayIndex => "13",
    CounterId13 => { #Structure Type: RegField; ArrayLength: 32; ArrayIndex: 13; ArrayLocationInName: 10;
      Name => "CounterId[n]",
      RegMem => "RegField",
      Description => "Map CGM profile to PD counter.
Values :
0 - 3 : counter ID
4 : Do not count
5-7 : Unused",
      Width => "3", # Excel Formula: =calc_field_width_define("VOQ_CGM_COUNTER_NUM_WIDTH")
      Position => "2:0", # Excel Formula: =calc_position(F76,E77,TRUE)
      Type => "Config",
      UsedBy => "Voq_CGM",
      DefaultValue => "h0",
      DocName => "CounterId",
      Comments => "VOQ_CGM_COUNTER_UC  = d0
VOQ_CGM_COUNTER_MC = d1
VOQ_CGM_COUNTER_MS_UC = d2
VOQ_CGM_COUNTER_MS_MC = d3
VOQ_CGM_COUNTER_IGNORE = d4",
    },
  },
  SliceCGMProfile14 => { #Structure Type: Reg; ArrayLength: 32; ArrayIndex: 14; ArrayLocationInName: 16;
    Name => "SliceCGMProfile[32]",
    RegMem => "Reg",
    Address => "12D",
    Description => "CGM Global Configs",
    Width => "3", # Excel Formula: =calc_reg_width(E77:E77,F77)
    Type => "Config",
    DocName => "SliceCgmProfile",
    AdditionalInfo => "PackArrayToBus",
    ArrayLength => "32",
    ArrayIndex => "14",
    CounterId14 => { #Structure Type: RegField; ArrayLength: 32; ArrayIndex: 14; ArrayLocationInName: 10;
      Name => "CounterId[n]",
      RegMem => "RegField",
      Description => "Map CGM profile to PD counter.
Values :
0 - 3 : counter ID
4 : Do not count
5-7 : Unused",
      Width => "3", # Excel Formula: =calc_field_width_define("VOQ_CGM_COUNTER_NUM_WIDTH")
      Position => "2:0", # Excel Formula: =calc_position(F76,E77,TRUE)
      Type => "Config",
      UsedBy => "Voq_CGM",
      DefaultValue => "h0",
      DocName => "CounterId",
      Comments => "VOQ_CGM_COUNTER_UC  = d0
VOQ_CGM_COUNTER_MC = d1
VOQ_CGM_COUNTER_MS_UC = d2
VOQ_CGM_COUNTER_MS_MC = d3
VOQ_CGM_COUNTER_IGNORE = d4",
    },
  },
  SliceCGMProfile15 => { #Structure Type: Reg; ArrayLength: 32; ArrayIndex: 15; ArrayLocationInName: 16;
    Name => "SliceCGMProfile[32]",
    RegMem => "Reg",
    Address => "12E",
    Description => "CGM Global Configs",
    Width => "3", # Excel Formula: =calc_reg_width(E77:E77,F77)
    Type => "Config",
    DocName => "SliceCgmProfile",
    AdditionalInfo => "PackArrayToBus",
    ArrayLength => "32",
    ArrayIndex => "15",
    CounterId15 => { #Structure Type: RegField; ArrayLength: 32; ArrayIndex: 15; ArrayLocationInName: 10;
      Name => "CounterId[n]",
      RegMem => "RegField",
      Description => "Map CGM profile to PD counter.
Values :
0 - 3 : counter ID
4 : Do not count
5-7 : Unused",
      Width => "3", # Excel Formula: =calc_field_width_define("VOQ_CGM_COUNTER_NUM_WIDTH")
      Position => "2:0", # Excel Formula: =calc_position(F76,E77,TRUE)
      Type => "Config",
      UsedBy => "Voq_CGM",
      DefaultValue => "h0",
      DocName => "CounterId",
      Comments => "VOQ_CGM_COUNTER_UC  = d0
VOQ_CGM_COUNTER_MC = d1
VOQ_CGM_COUNTER_MS_UC = d2
VOQ_CGM_COUNTER_MS_MC = d3
VOQ_CGM_COUNTER_IGNORE = d4",
    },
  },
  SliceCGMProfile16 => { #Structure Type: Reg; ArrayLength: 32; ArrayIndex: 16; ArrayLocationInName: 16;
    Name => "SliceCGMProfile[32]",
    RegMem => "Reg",
    Address => "12F",
    Description => "CGM Global Configs",
    Width => "3", # Excel Formula: =calc_reg_width(E77:E77,F77)
    Type => "Config",
    DocName => "SliceCgmProfile",
    AdditionalInfo => "PackArrayToBus",
    ArrayLength => "32",
    ArrayIndex => "16",
    CounterId16 => { #Structure Type: RegField; ArrayLength: 32; ArrayIndex: 16; ArrayLocationInName: 10;
      Name => "CounterId[n]",
      RegMem => "RegField",
      Description => "Map CGM profile to PD counter.
Values :
0 - 3 : counter ID
4 : Do not count
5-7 : Unused",
      Width => "3", # Excel Formula: =calc_field_width_define("VOQ_CGM_COUNTER_NUM_WIDTH")
      Position => "2:0", # Excel Formula: =calc_position(F76,E77,TRUE)
      Type => "Config",
      UsedBy => "Voq_CGM",
      DefaultValue => "h0",
      DocName => "CounterId",
      Comments => "VOQ_CGM_COUNTER_UC  = d0
VOQ_CGM_COUNTER_MC = d1
VOQ_CGM_COUNTER_MS_UC = d2
VOQ_CGM_COUNTER_MS_MC = d3
VOQ_CGM_COUNTER_IGNORE = d4",
    },
  },
  SliceCGMProfile17 => { #Structure Type: Reg; ArrayLength: 32; ArrayIndex: 17; ArrayLocationInName: 16;
    Name => "SliceCGMProfile[32]",
    RegMem => "Reg",
    Address => "130",
    Description => "CGM Global Configs",
    Width => "3", # Excel Formula: =calc_reg_width(E77:E77,F77)
    Type => "Config",
    DocName => "SliceCgmProfile",
    AdditionalInfo => "PackArrayToBus",
    ArrayLength => "32",
    ArrayIndex => "17",
    CounterId17 => { #Structure Type: RegField; ArrayLength: 32; ArrayIndex: 17; ArrayLocationInName: 10;
      Name => "CounterId[n]",
      RegMem => "RegField",
      Description => "Map CGM profile to PD counter.
Values :
0 - 3 : counter ID
4 : Do not count
5-7 : Unused",
      Width => "3", # Excel Formula: =calc_field_width_define("VOQ_CGM_COUNTER_NUM_WIDTH")
      Position => "2:0", # Excel Formula: =calc_position(F76,E77,TRUE)
      Type => "Config",
      UsedBy => "Voq_CGM",
      DefaultValue => "h0",
      DocName => "CounterId",
      Comments => "VOQ_CGM_COUNTER_UC  = d0
VOQ_CGM_COUNTER_MC = d1
VOQ_CGM_COUNTER_MS_UC = d2
VOQ_CGM_COUNTER_MS_MC = d3
VOQ_CGM_COUNTER_IGNORE = d4",
    },
  },
  SliceCGMProfile18 => { #Structure Type: Reg; ArrayLength: 32; ArrayIndex: 18; ArrayLocationInName: 16;
    Name => "SliceCGMProfile[32]",
    RegMem => "Reg",
    Address => "131",
    Description => "CGM Global Configs",
    Width => "3", # Excel Formula: =calc_reg_width(E77:E77,F77)
    Type => "Config",
    DocName => "SliceCgmProfile",
    AdditionalInfo => "PackArrayToBus",
    ArrayLength => "32",
    ArrayIndex => "18",
    CounterId18 => { #Structure Type: RegField; ArrayLength: 32; ArrayIndex: 18; ArrayLocationInName: 10;
      Name => "CounterId[n]",
      RegMem => "RegField",
      Description => "Map CGM profile to PD counter.
Values :
0 - 3 : counter ID
4 : Do not count
5-7 : Unused",
      Width => "3", # Excel Formula: =calc_field_width_define("VOQ_CGM_COUNTER_NUM_WIDTH")
      Position => "2:0", # Excel Formula: =calc_position(F76,E77,TRUE)
      Type => "Config",
      UsedBy => "Voq_CGM",
      DefaultValue => "h0",
      DocName => "CounterId",
      Comments => "VOQ_CGM_COUNTER_UC  = d0
VOQ_CGM_COUNTER_MC = d1
VOQ_CGM_COUNTER_MS_UC = d2
VOQ_CGM_COUNTER_MS_MC = d3
VOQ_CGM_COUNTER_IGNORE = d4",
    },
  },
  SliceCGMProfile19 => { #Structure Type: Reg; ArrayLength: 32; ArrayIndex: 19; ArrayLocationInName: 16;
    Name => "SliceCGMProfile[32]",
    RegMem => "Reg",
    Address => "132",
    Description => "CGM Global Configs",
    Width => "3", # Excel Formula: =calc_reg_width(E77:E77,F77)
    Type => "Config",
    DocName => "SliceCgmProfile",
    AdditionalInfo => "PackArrayToBus",
    ArrayLength => "32",
    ArrayIndex => "19",
    CounterId19 => { #Structure Type: RegField; ArrayLength: 32; ArrayIndex: 19; ArrayLocationInName: 10;
      Name => "CounterId[n]",
      RegMem => "RegField",
      Description => "Map CGM profile to PD counter.
Values :
0 - 3 : counter ID
4 : Do not count
5-7 : Unused",
      Width => "3", # Excel Formula: =calc_field_width_define("VOQ_CGM_COUNTER_NUM_WIDTH")
      Position => "2:0", # Excel Formula: =calc_position(F76,E77,TRUE)
      Type => "Config",
      UsedBy => "Voq_CGM",
      DefaultValue => "h0",
      DocName => "CounterId",
      Comments => "VOQ_CGM_COUNTER_UC  = d0
VOQ_CGM_COUNTER_MC = d1
VOQ_CGM_COUNTER_MS_UC = d2
VOQ_CGM_COUNTER_MS_MC = d3
VOQ_CGM_COUNTER_IGNORE = d4",
    },
  },
  SliceCGMProfile20 => { #Structure Type: Reg; ArrayLength: 32; ArrayIndex: 20; ArrayLocationInName: 16;
    Name => "SliceCGMProfile[32]",
    RegMem => "Reg",
    Address => "133",
    Description => "CGM Global Configs",
    Width => "3", # Excel Formula: =calc_reg_width(E77:E77,F77)
    Type => "Config",
    DocName => "SliceCgmProfile",
    AdditionalInfo => "PackArrayToBus",
    ArrayLength => "32",
    ArrayIndex => "20",
    CounterId20 => { #Structure Type: RegField; ArrayLength: 32; ArrayIndex: 20; ArrayLocationInName: 10;
      Name => "CounterId[n]",
      RegMem => "RegField",
      Description => "Map CGM profile to PD counter.
Values :
0 - 3 : counter ID
4 : Do not count
5-7 : Unused",
      Width => "3", # Excel Formula: =calc_field_width_define("VOQ_CGM_COUNTER_NUM_WIDTH")
      Position => "2:0", # Excel Formula: =calc_position(F76,E77,TRUE)
      Type => "Config",
      UsedBy => "Voq_CGM",
      DefaultValue => "h0",
      DocName => "CounterId",
      Comments => "VOQ_CGM_COUNTER_UC  = d0
VOQ_CGM_COUNTER_MC = d1
VOQ_CGM_COUNTER_MS_UC = d2
VOQ_CGM_COUNTER_MS_MC = d3
VOQ_CGM_COUNTER_IGNORE = d4",
    },
  },
  SliceCGMProfile21 => { #Structure Type: Reg; ArrayLength: 32; ArrayIndex: 21; ArrayLocationInName: 16;
    Name => "SliceCGMProfile[32]",
    RegMem => "Reg",
    Address => "134",
    Description => "CGM Global Configs",
    Width => "3", # Excel Formula: =calc_reg_width(E77:E77,F77)
    Type => "Config",
    DocName => "SliceCgmProfile",
    AdditionalInfo => "PackArrayToBus",
    ArrayLength => "32",
    ArrayIndex => "21",
    CounterId21 => { #Structure Type: RegField; ArrayLength: 32; ArrayIndex: 21; ArrayLocationInName: 10;
      Name => "CounterId[n]",
      RegMem => "RegField",
      Description => "Map CGM profile to PD counter.
Values :
0 - 3 : counter ID
4 : Do not count
5-7 : Unused",
      Width => "3", # Excel Formula: =calc_field_width_define("VOQ_CGM_COUNTER_NUM_WIDTH")
      Position => "2:0", # Excel Formula: =calc_position(F76,E77,TRUE)
      Type => "Config",
      UsedBy => "Voq_CGM",
      DefaultValue => "h0",
      DocName => "CounterId",
      Comments => "VOQ_CGM_COUNTER_UC  = d0
VOQ_CGM_COUNTER_MC = d1
VOQ_CGM_COUNTER_MS_UC = d2
VOQ_CGM_COUNTER_MS_MC = d3
VOQ_CGM_COUNTER_IGNORE = d4",
    },
  },
  SliceCGMProfile22 => { #Structure Type: Reg; ArrayLength: 32; ArrayIndex: 22; ArrayLocationInName: 16;
    Name => "SliceCGMProfile[32]",
    RegMem => "Reg",
    Address => "135",
    Description => "CGM Global Configs",
    Width => "3", # Excel Formula: =calc_reg_width(E77:E77,F77)
    Type => "Config",
    DocName => "SliceCgmProfile",
    AdditionalInfo => "PackArrayToBus",
    ArrayLength => "32",
    ArrayIndex => "22",
    CounterId22 => { #Structure Type: RegField; ArrayLength: 32; ArrayIndex: 22; ArrayLocationInName: 10;
      Name => "CounterId[n]",
      RegMem => "RegField",
      Description => "Map CGM profile to PD counter.
Values :
0 - 3 : counter ID
4 : Do not count
5-7 : Unused",
      Width => "3", # Excel Formula: =calc_field_width_define("VOQ_CGM_COUNTER_NUM_WIDTH")
      Position => "2:0", # Excel Formula: =calc_position(F76,E77,TRUE)
      Type => "Config",
      UsedBy => "Voq_CGM",
      DefaultValue => "h0",
      DocName => "CounterId",
      Comments => "VOQ_CGM_COUNTER_UC  = d0
VOQ_CGM_COUNTER_MC = d1
VOQ_CGM_COUNTER_MS_UC = d2
VOQ_CGM_COUNTER_MS_MC = d3
VOQ_CGM_COUNTER_IGNORE = d4",
    },
  },
  SliceCGMProfile23 => { #Structure Type: Reg; ArrayLength: 32; ArrayIndex: 23; ArrayLocationInName: 16;
    Name => "SliceCGMProfile[32]",
    RegMem => "Reg",
    Address => "136",
    Description => "CGM Global Configs",
    Width => "3", # Excel Formula: =calc_reg_width(E77:E77,F77)
    Type => "Config",
    DocName => "SliceCgmProfile",
    AdditionalInfo => "PackArrayToBus",
    ArrayLength => "32",
    ArrayIndex => "23",
    CounterId23 => { #Structure Type: RegField; ArrayLength: 32; ArrayIndex: 23; ArrayLocationInName: 10;
      Name => "CounterId[n]",
      RegMem => "RegField",
      Description => "Map CGM profile to PD counter.
Values :
0 - 3 : counter ID
4 : Do not count
5-7 : Unused",
      Width => "3", # Excel Formula: =calc_field_width_define("VOQ_CGM_COUNTER_NUM_WIDTH")
      Position => "2:0", # Excel Formula: =calc_position(F76,E77,TRUE)
      Type => "Config",
      UsedBy => "Voq_CGM",
      DefaultValue => "h0",
      DocName => "CounterId",
      Comments => "VOQ_CGM_COUNTER_UC  = d0
VOQ_CGM_COUNTER_MC = d1
VOQ_CGM_COUNTER_MS_UC = d2
VOQ_CGM_COUNTER_MS_MC = d3
VOQ_CGM_COUNTER_IGNORE = d4",
    },
  },
  SliceCGMProfile24 => { #Structure Type: Reg; ArrayLength: 32; ArrayIndex: 24; ArrayLocationInName: 16;
    Name => "SliceCGMProfile[32]",
    RegMem => "Reg",
    Address => "137",
    Description => "CGM Global Configs",
    Width => "3", # Excel Formula: =calc_reg_width(E77:E77,F77)
    Type => "Config",
    DocName => "SliceCgmProfile",
    AdditionalInfo => "PackArrayToBus",
    ArrayLength => "32",
    ArrayIndex => "24",
    CounterId24 => { #Structure Type: RegField; ArrayLength: 32; ArrayIndex: 24; ArrayLocationInName: 10;
      Name => "CounterId[n]",
      RegMem => "RegField",
      Description => "Map CGM profile to PD counter.
Values :
0 - 3 : counter ID
4 : Do not count
5-7 : Unused",
      Width => "3", # Excel Formula: =calc_field_width_define("VOQ_CGM_COUNTER_NUM_WIDTH")
      Position => "2:0", # Excel Formula: =calc_position(F76,E77,TRUE)
      Type => "Config",
      UsedBy => "Voq_CGM",
      DefaultValue => "h0",
      DocName => "CounterId",
      Comments => "VOQ_CGM_COUNTER_UC  = d0
VOQ_CGM_COUNTER_MC = d1
VOQ_CGM_COUNTER_MS_UC = d2
VOQ_CGM_COUNTER_MS_MC = d3
VOQ_CGM_COUNTER_IGNORE = d4",
    },
  },
  SliceCGMProfile25 => { #Structure Type: Reg; ArrayLength: 32; ArrayIndex: 25; ArrayLocationInName: 16;
    Name => "SliceCGMProfile[32]",
    RegMem => "Reg",
    Address => "138",
    Description => "CGM Global Configs",
    Width => "3", # Excel Formula: =calc_reg_width(E77:E77,F77)
    Type => "Config",
    DocName => "SliceCgmProfile",
    AdditionalInfo => "PackArrayToBus",
    ArrayLength => "32",
    ArrayIndex => "25",
    CounterId25 => { #Structure Type: RegField; ArrayLength: 32; ArrayIndex: 25; ArrayLocationInName: 10;
      Name => "CounterId[n]",
      RegMem => "RegField",
      Description => "Map CGM profile to PD counter.
Values :
0 - 3 : counter ID
4 : Do not count
5-7 : Unused",
      Width => "3", # Excel Formula: =calc_field_width_define("VOQ_CGM_COUNTER_NUM_WIDTH")
      Position => "2:0", # Excel Formula: =calc_position(F76,E77,TRUE)
      Type => "Config",
      UsedBy => "Voq_CGM",
      DefaultValue => "h0",
      DocName => "CounterId",
      Comments => "VOQ_CGM_COUNTER_UC  = d0
VOQ_CGM_COUNTER_MC = d1
VOQ_CGM_COUNTER_MS_UC = d2
VOQ_CGM_COUNTER_MS_MC = d3
VOQ_CGM_COUNTER_IGNORE = d4",
    },
  },
  SliceCGMProfile26 => { #Structure Type: Reg; ArrayLength: 32; ArrayIndex: 26; ArrayLocationInName: 16;
    Name => "SliceCGMProfile[32]",
    RegMem => "Reg",
    Address => "139",
    Description => "CGM Global Configs",
    Width => "3", # Excel Formula: =calc_reg_width(E77:E77,F77)
    Type => "Config",
    DocName => "SliceCgmProfile",
    AdditionalInfo => "PackArrayToBus",
    ArrayLength => "32",
    ArrayIndex => "26",
    CounterId26 => { #Structure Type: RegField; ArrayLength: 32; ArrayIndex: 26; ArrayLocationInName: 10;
      Name => "CounterId[n]",
      RegMem => "RegField",
      Description => "Map CGM profile to PD counter.
Values :
0 - 3 : counter ID
4 : Do not count
5-7 : Unused",
      Width => "3", # Excel Formula: =calc_field_width_define("VOQ_CGM_COUNTER_NUM_WIDTH")
      Position => "2:0", # Excel Formula: =calc_position(F76,E77,TRUE)
      Type => "Config",
      UsedBy => "Voq_CGM",
      DefaultValue => "h0",
      DocName => "CounterId",
      Comments => "VOQ_CGM_COUNTER_UC  = d0
VOQ_CGM_COUNTER_MC = d1
VOQ_CGM_COUNTER_MS_UC = d2
VOQ_CGM_COUNTER_MS_MC = d3
VOQ_CGM_COUNTER_IGNORE = d4",
    },
  },
  SliceCGMProfile27 => { #Structure Type: Reg; ArrayLength: 32; ArrayIndex: 27; ArrayLocationInName: 16;
    Name => "SliceCGMProfile[32]",
    RegMem => "Reg",
    Address => "13A",
    Description => "CGM Global Configs",
    Width => "3", # Excel Formula: =calc_reg_width(E77:E77,F77)
    Type => "Config",
    DocName => "SliceCgmProfile",
    AdditionalInfo => "PackArrayToBus",
    ArrayLength => "32",
    ArrayIndex => "27",
    CounterId27 => { #Structure Type: RegField; ArrayLength: 32; ArrayIndex: 27; ArrayLocationInName: 10;
      Name => "CounterId[n]",
      RegMem => "RegField",
      Description => "Map CGM profile to PD counter.
Values :
0 - 3 : counter ID
4 : Do not count
5-7 : Unused",
      Width => "3", # Excel Formula: =calc_field_width_define("VOQ_CGM_COUNTER_NUM_WIDTH")
      Position => "2:0", # Excel Formula: =calc_position(F76,E77,TRUE)
      Type => "Config",
      UsedBy => "Voq_CGM",
      DefaultValue => "h0",
      DocName => "CounterId",
      Comments => "VOQ_CGM_COUNTER_UC  = d0
VOQ_CGM_COUNTER_MC = d1
VOQ_CGM_COUNTER_MS_UC = d2
VOQ_CGM_COUNTER_MS_MC = d3
VOQ_CGM_COUNTER_IGNORE = d4",
    },
  },
  SliceCGMProfile28 => { #Structure Type: Reg; ArrayLength: 32; ArrayIndex: 28; ArrayLocationInName: 16;
    Name => "SliceCGMProfile[32]",
    RegMem => "Reg",
    Address => "13B",
    Description => "CGM Global Configs",
    Width => "3", # Excel Formula: =calc_reg_width(E77:E77,F77)
    Type => "Config",
    DocName => "SliceCgmProfile",
    AdditionalInfo => "PackArrayToBus",
    ArrayLength => "32",
    ArrayIndex => "28",
    CounterId28 => { #Structure Type: RegField; ArrayLength: 32; ArrayIndex: 28; ArrayLocationInName: 10;
      Name => "CounterId[n]",
      RegMem => "RegField",
      Description => "Map CGM profile to PD counter.
Values :
0 - 3 : counter ID
4 : Do not count
5-7 : Unused",
      Width => "3", # Excel Formula: =calc_field_width_define("VOQ_CGM_COUNTER_NUM_WIDTH")
      Position => "2:0", # Excel Formula: =calc_position(F76,E77,TRUE)
      Type => "Config",
      UsedBy => "Voq_CGM",
      DefaultValue => "h0",
      DocName => "CounterId",
      Comments => "VOQ_CGM_COUNTER_UC  = d0
VOQ_CGM_COUNTER_MC = d1
VOQ_CGM_COUNTER_MS_UC = d2
VOQ_CGM_COUNTER_MS_MC = d3
VOQ_CGM_COUNTER_IGNORE = d4",
    },
  },
  SliceCGMProfile29 => { #Structure Type: Reg; ArrayLength: 32; ArrayIndex: 29; ArrayLocationInName: 16;
    Name => "SliceCGMProfile[32]",
    RegMem => "Reg",
    Address => "13C",
    Description => "CGM Global Configs",
    Width => "3", # Excel Formula: =calc_reg_width(E77:E77,F77)
    Type => "Config",
    DocName => "SliceCgmProfile",
    AdditionalInfo => "PackArrayToBus",
    ArrayLength => "32",
    ArrayIndex => "29",
    CounterId29 => { #Structure Type: RegField; ArrayLength: 32; ArrayIndex: 29; ArrayLocationInName: 10;
      Name => "CounterId[n]",
      RegMem => "RegField",
      Description => "Map CGM profile to PD counter.
Values :
0 - 3 : counter ID
4 : Do not count
5-7 : Unused",
      Width => "3", # Excel Formula: =calc_field_width_define("VOQ_CGM_COUNTER_NUM_WIDTH")
      Position => "2:0", # Excel Formula: =calc_position(F76,E77,TRUE)
      Type => "Config",
      UsedBy => "Voq_CGM",
      DefaultValue => "h0",
      DocName => "CounterId",
      Comments => "VOQ_CGM_COUNTER_UC  = d0
VOQ_CGM_COUNTER_MC = d1
VOQ_CGM_COUNTER_MS_UC = d2
VOQ_CGM_COUNTER_MS_MC = d3
VOQ_CGM_COUNTER_IGNORE = d4",
    },
  },
  SliceCGMProfile30 => { #Structure Type: Reg; ArrayLength: 32; ArrayIndex: 30; ArrayLocationInName: 16;
    Name => "SliceCGMProfile[32]",
    RegMem => "Reg",
    Address => "13D",
    Description => "CGM Global Configs",
    Width => "3", # Excel Formula: =calc_reg_width(E77:E77,F77)
    Type => "Config",
    DocName => "SliceCgmProfile",
    AdditionalInfo => "PackArrayToBus",
    ArrayLength => "32",
    ArrayIndex => "30",
    CounterId30 => { #Structure Type: RegField; ArrayLength: 32; ArrayIndex: 30; ArrayLocationInName: 10;
      Name => "CounterId[n]",
      RegMem => "RegField",
      Description => "Map CGM profile to PD counter.
Values :
0 - 3 : counter ID
4 : Do not count
5-7 : Unused",
      Width => "3", # Excel Formula: =calc_field_width_define("VOQ_CGM_COUNTER_NUM_WIDTH")
      Position => "2:0", # Excel Formula: =calc_position(F76,E77,TRUE)
      Type => "Config",
      UsedBy => "Voq_CGM",
      DefaultValue => "h0",
      DocName => "CounterId",
      Comments => "VOQ_CGM_COUNTER_UC  = d0
VOQ_CGM_COUNTER_MC = d1
VOQ_CGM_COUNTER_MS_UC = d2
VOQ_CGM_COUNTER_MS_MC = d3
VOQ_CGM_COUNTER_IGNORE = d4",
    },
  },
  SliceCGMProfile31 => { #Structure Type: Reg; ArrayLength: 32; ArrayIndex: 31; ArrayLocationInName: 16;
    Name => "SliceCGMProfile[32]",
    RegMem => "Reg",
    Address => "13E",
    Description => "CGM Global Configs",
    Width => "3", # Excel Formula: =calc_reg_width(E77:E77,F77)
    Type => "Config",
    DocName => "SliceCgmProfile",
    AdditionalInfo => "PackArrayToBus",
    ArrayLength => "32",
    ArrayIndex => "31",
    CounterId31 => { #Structure Type: RegField; ArrayLength: 32; ArrayIndex: 31; ArrayLocationInName: 10;
      Name => "CounterId[n]",
      RegMem => "RegField",
      Description => "Map CGM profile to PD counter.
Values :
0 - 3 : counter ID
4 : Do not count
5-7 : Unused",
      Width => "3", # Excel Formula: =calc_field_width_define("VOQ_CGM_COUNTER_NUM_WIDTH")
      Position => "2:0", # Excel Formula: =calc_position(F76,E77,TRUE)
      Type => "Config",
      UsedBy => "Voq_CGM",
      DefaultValue => "h0",
      DocName => "CounterId",
      Comments => "VOQ_CGM_COUNTER_UC  = d0
VOQ_CGM_COUNTER_MC = d1
VOQ_CGM_COUNTER_MS_UC = d2
VOQ_CGM_COUNTER_MS_MC = d3
VOQ_CGM_COUNTER_IGNORE = d4",
    },
  },
  BuffersConsumptionLutForDeq0 => { #Structure Type: Reg; ArrayLength: 128; ArrayIndex: 0; ArrayLocationInName: 28;
    Name => "BuffersConsumptionLutForDeq[128]",
    RegMem => "Reg",
    Address => "13F", # Excel Formula: =calc_reg_address(C76,A76,G76)
    Description => "LUT for dequeue marking in VOQ-CGM based on Buffer Consumption.
Index in Array is {Profile,BufferAvailableLevel}
Profile is 5 bits
BufferAvailableLevel is quantized to 2 bits.",
    Width => "8", # Excel Formula: =calc_reg_width(E79:E79,F79)
    Type => "Config",
    AdditionalInfo => "PackArrayToBus",
    Comments => "VOQ_CGM
CGM Deq Marking logic implemented in FF.
Address is {VOQ_PROFILE,Buffer_pool_available_level}
5 + 2 = 7
Buffer_voq_size_level selects offset out of 8.",
    ArrayLength => "128",
    ArrayIndex => "0",
    DeqBufferCongestionMark0 => { #Structure Type: RegField; ArrayLength: 128; ArrayIndex: 0; ArrayLocationInName: 24;
      Name => "DeqBufferCongestionMark[n]",
      RegMem => "RegField",
      Description => "Fill level of VOQ in buffers selects between the 8 values for a given {Profile,BufferAvailableLevel} pair.
The MSB is mark indication in case of most full.
The LSB is mark indication in case of most empty.",
      Width => "8",
      Position => "7:0", # Excel Formula: =calc_position(F78,E79,TRUE)
      Type => "Config",
      UsedBy => "CGM_deq",
      DefaultValue => "h0",
    },
  },
  BuffersConsumptionLutForDeq1 => { #Structure Type: Reg; ArrayLength: 128; ArrayIndex: 1; ArrayLocationInName: 28;
    Name => "BuffersConsumptionLutForDeq[128]",
    RegMem => "Reg",
    Address => "140",
    Description => "LUT for dequeue marking in VOQ-CGM based on Buffer Consumption.
Index in Array is {Profile,BufferAvailableLevel}
Profile is 5 bits
BufferAvailableLevel is quantized to 2 bits.",
    Width => "8", # Excel Formula: =calc_reg_width(E79:E79,F79)
    Type => "Config",
    AdditionalInfo => "PackArrayToBus",
    Comments => "VOQ_CGM
CGM Deq Marking logic implemented in FF.
Address is {VOQ_PROFILE,Buffer_pool_available_level}
5 + 2 = 7
Buffer_voq_size_level selects offset out of 8.",
    ArrayLength => "128",
    ArrayIndex => "1",
    DeqBufferCongestionMark1 => { #Structure Type: RegField; ArrayLength: 128; ArrayIndex: 1; ArrayLocationInName: 24;
      Name => "DeqBufferCongestionMark[n]",
      RegMem => "RegField",
      Description => "Fill level of VOQ in buffers selects between the 8 values for a given {Profile,BufferAvailableLevel} pair.
The MSB is mark indication in case of most full.
The LSB is mark indication in case of most empty.",
      Width => "8",
      Position => "7:0", # Excel Formula: =calc_position(F78,E79,TRUE)
      Type => "Config",
      UsedBy => "CGM_deq",
      DefaultValue => "h0",
    },
  },
  BuffersConsumptionLutForDeq2 => { #Structure Type: Reg; ArrayLength: 128; ArrayIndex: 2; ArrayLocationInName: 28;
    Name => "BuffersConsumptionLutForDeq[128]",
    RegMem => "Reg",
    Address => "141",
    Description => "LUT for dequeue marking in VOQ-CGM based on Buffer Consumption.
Index in Array is {Profile,BufferAvailableLevel}
Profile is 5 bits
BufferAvailableLevel is quantized to 2 bits.",
    Width => "8", # Excel Formula: =calc_reg_width(E79:E79,F79)
    Type => "Config",
    AdditionalInfo => "PackArrayToBus",
    Comments => "VOQ_CGM
CGM Deq Marking logic implemented in FF.
Address is {VOQ_PROFILE,Buffer_pool_available_level}
5 + 2 = 7
Buffer_voq_size_level selects offset out of 8.",
    ArrayLength => "128",
    ArrayIndex => "2",
    DeqBufferCongestionMark2 => { #Structure Type: RegField; ArrayLength: 128; ArrayIndex: 2; ArrayLocationInName: 24;
      Name => "DeqBufferCongestionMark[n]",
      RegMem => "RegField",
      Description => "Fill level of VOQ in buffers selects between the 8 values for a given {Profile,BufferAvailableLevel} pair.
The MSB is mark indication in case of most full.
The LSB is mark indication in case of most empty.",
      Width => "8",
      Position => "7:0", # Excel Formula: =calc_position(F78,E79,TRUE)
      Type => "Config",
      UsedBy => "CGM_deq",
      DefaultValue => "h0",
    },
  },
  BuffersConsumptionLutForDeq3 => { #Structure Type: Reg; ArrayLength: 128; ArrayIndex: 3; ArrayLocationInName: 28;
    Name => "BuffersConsumptionLutForDeq[128]",
    RegMem => "Reg",
    Address => "142",
    Description => "LUT for dequeue marking in VOQ-CGM based on Buffer Consumption.
Index in Array is {Profile,BufferAvailableLevel}
Profile is 5 bits
BufferAvailableLevel is quantized to 2 bits.",
    Width => "8", # Excel Formula: =calc_reg_width(E79:E79,F79)
    Type => "Config",
    AdditionalInfo => "PackArrayToBus",
    Comments => "VOQ_CGM
CGM Deq Marking logic implemented in FF.
Address is {VOQ_PROFILE,Buffer_pool_available_level}
5 + 2 = 7
Buffer_voq_size_level selects offset out of 8.",
    ArrayLength => "128",
    ArrayIndex => "3",
    DeqBufferCongestionMark3 => { #Structure Type: RegField; ArrayLength: 128; ArrayIndex: 3; ArrayLocationInName: 24;
      Name => "DeqBufferCongestionMark[n]",
      RegMem => "RegField",
      Description => "Fill level of VOQ in buffers selects between the 8 values for a given {Profile,BufferAvailableLevel} pair.
The MSB is mark indication in case of most full.
The LSB is mark indication in case of most empty.",
      Width => "8",
      Position => "7:0", # Excel Formula: =calc_position(F78,E79,TRUE)
      Type => "Config",
      UsedBy => "CGM_deq",
      DefaultValue => "h0",
    },
  },
  BuffersConsumptionLutForDeq4 => { #Structure Type: Reg; ArrayLength: 128; ArrayIndex: 4; ArrayLocationInName: 28;
    Name => "BuffersConsumptionLutForDeq[128]",
    RegMem => "Reg",
    Address => "143",
    Description => "LUT for dequeue marking in VOQ-CGM based on Buffer Consumption.
Index in Array is {Profile,BufferAvailableLevel}
Profile is 5 bits
BufferAvailableLevel is quantized to 2 bits.",
    Width => "8", # Excel Formula: =calc_reg_width(E79:E79,F79)
    Type => "Config",
    AdditionalInfo => "PackArrayToBus",
    Comments => "VOQ_CGM
CGM Deq Marking logic implemented in FF.
Address is {VOQ_PROFILE,Buffer_pool_available_level}
5 + 2 = 7
Buffer_voq_size_level selects offset out of 8.",
    ArrayLength => "128",
    ArrayIndex => "4",
    DeqBufferCongestionMark4 => { #Structure Type: RegField; ArrayLength: 128; ArrayIndex: 4; ArrayLocationInName: 24;
      Name => "DeqBufferCongestionMark[n]",
      RegMem => "RegField",
      Description => "Fill level of VOQ in buffers selects between the 8 values for a given {Profile,BufferAvailableLevel} pair.
The MSB is mark indication in case of most full.
The LSB is mark indication in case of most empty.",
      Width => "8",
      Position => "7:0", # Excel Formula: =calc_position(F78,E79,TRUE)
      Type => "Config",
      UsedBy => "CGM_deq",
      DefaultValue => "h0",
    },
  },
  BuffersConsumptionLutForDeq5 => { #Structure Type: Reg; ArrayLength: 128; ArrayIndex: 5; ArrayLocationInName: 28;
    Name => "BuffersConsumptionLutForDeq[128]",
    RegMem => "Reg",
    Address => "144",
    Description => "LUT for dequeue marking in VOQ-CGM based on Buffer Consumption.
Index in Array is {Profile,BufferAvailableLevel}
Profile is 5 bits
BufferAvailableLevel is quantized to 2 bits.",
    Width => "8", # Excel Formula: =calc_reg_width(E79:E79,F79)
    Type => "Config",
    AdditionalInfo => "PackArrayToBus",
    Comments => "VOQ_CGM
CGM Deq Marking logic implemented in FF.
Address is {VOQ_PROFILE,Buffer_pool_available_level}
5 + 2 = 7
Buffer_voq_size_level selects offset out of 8.",
    ArrayLength => "128",
    ArrayIndex => "5",
    DeqBufferCongestionMark5 => { #Structure Type: RegField; ArrayLength: 128; ArrayIndex: 5; ArrayLocationInName: 24;
      Name => "DeqBufferCongestionMark[n]",
      RegMem => "RegField",
      Description => "Fill level of VOQ in buffers selects between the 8 values for a given {Profile,BufferAvailableLevel} pair.
The MSB is mark indication in case of most full.
The LSB is mark indication in case of most empty.",
      Width => "8",
      Position => "7:0", # Excel Formula: =calc_position(F78,E79,TRUE)
      Type => "Config",
      UsedBy => "CGM_deq",
      DefaultValue => "h0",
    },
  },
  BuffersConsumptionLutForDeq6 => { #Structure Type: Reg; ArrayLength: 128; ArrayIndex: 6; ArrayLocationInName: 28;
    Name => "BuffersConsumptionLutForDeq[128]",
    RegMem => "Reg",
    Address => "145",
    Description => "LUT for dequeue marking in VOQ-CGM based on Buffer Consumption.
Index in Array is {Profile,BufferAvailableLevel}
Profile is 5 bits
BufferAvailableLevel is quantized to 2 bits.",
    Width => "8", # Excel Formula: =calc_reg_width(E79:E79,F79)
    Type => "Config",
    AdditionalInfo => "PackArrayToBus",
    Comments => "VOQ_CGM
CGM Deq Marking logic implemented in FF.
Address is {VOQ_PROFILE,Buffer_pool_available_level}
5 + 2 = 7
Buffer_voq_size_level selects offset out of 8.",
    ArrayLength => "128",
    ArrayIndex => "6",
    DeqBufferCongestionMark6 => { #Structure Type: RegField; ArrayLength: 128; ArrayIndex: 6; ArrayLocationInName: 24;
      Name => "DeqBufferCongestionMark[n]",
      RegMem => "RegField",
      Description => "Fill level of VOQ in buffers selects between the 8 values for a given {Profile,BufferAvailableLevel} pair.
The MSB is mark indication in case of most full.
The LSB is mark indication in case of most empty.",
      Width => "8",
      Position => "7:0", # Excel Formula: =calc_position(F78,E79,TRUE)
      Type => "Config",
      UsedBy => "CGM_deq",
      DefaultValue => "h0",
    },
  },
  BuffersConsumptionLutForDeq7 => { #Structure Type: Reg; ArrayLength: 128; ArrayIndex: 7; ArrayLocationInName: 28;
    Name => "BuffersConsumptionLutForDeq[128]",
    RegMem => "Reg",
    Address => "146",
    Description => "LUT for dequeue marking in VOQ-CGM based on Buffer Consumption.
Index in Array is {Profile,BufferAvailableLevel}
Profile is 5 bits
BufferAvailableLevel is quantized to 2 bits.",
    Width => "8", # Excel Formula: =calc_reg_width(E79:E79,F79)
    Type => "Config",
    AdditionalInfo => "PackArrayToBus",
    Comments => "VOQ_CGM
CGM Deq Marking logic implemented in FF.
Address is {VOQ_PROFILE,Buffer_pool_available_level}
5 + 2 = 7
Buffer_voq_size_level selects offset out of 8.",
    ArrayLength => "128",
    ArrayIndex => "7",
    DeqBufferCongestionMark7 => { #Structure Type: RegField; ArrayLength: 128; ArrayIndex: 7; ArrayLocationInName: 24;
      Name => "DeqBufferCongestionMark[n]",
      RegMem => "RegField",
      Description => "Fill level of VOQ in buffers selects between the 8 values for a given {Profile,BufferAvailableLevel} pair.
The MSB is mark indication in case of most full.
The LSB is mark indication in case of most empty.",
      Width => "8",
      Position => "7:0", # Excel Formula: =calc_position(F78,E79,TRUE)
      Type => "Config",
      UsedBy => "CGM_deq",
      DefaultValue => "h0",
    },
  },
  BuffersConsumptionLutForDeq8 => { #Structure Type: Reg; ArrayLength: 128; ArrayIndex: 8; ArrayLocationInName: 28;
    Name => "BuffersConsumptionLutForDeq[128]",
    RegMem => "Reg",
    Address => "147",
    Description => "LUT for dequeue marking in VOQ-CGM based on Buffer Consumption.
Index in Array is {Profile,BufferAvailableLevel}
Profile is 5 bits
BufferAvailableLevel is quantized to 2 bits.",
    Width => "8", # Excel Formula: =calc_reg_width(E79:E79,F79)
    Type => "Config",
    AdditionalInfo => "PackArrayToBus",
    Comments => "VOQ_CGM
CGM Deq Marking logic implemented in FF.
Address is {VOQ_PROFILE,Buffer_pool_available_level}
5 + 2 = 7
Buffer_voq_size_level selects offset out of 8.",
    ArrayLength => "128",
    ArrayIndex => "8",
    DeqBufferCongestionMark8 => { #Structure Type: RegField; ArrayLength: 128; ArrayIndex: 8; ArrayLocationInName: 24;
      Name => "DeqBufferCongestionMark[n]",
      RegMem => "RegField",
      Description => "Fill level of VOQ in buffers selects between the 8 values for a given {Profile,BufferAvailableLevel} pair.
The MSB is mark indication in case of most full.
The LSB is mark indication in case of most empty.",
      Width => "8",
      Position => "7:0", # Excel Formula: =calc_position(F78,E79,TRUE)
      Type => "Config",
      UsedBy => "CGM_deq",
      DefaultValue => "h0",
    },
  },
  BuffersConsumptionLutForDeq9 => { #Structure Type: Reg; ArrayLength: 128; ArrayIndex: 9; ArrayLocationInName: 28;
    Name => "BuffersConsumptionLutForDeq[128]",
    RegMem => "Reg",
    Address => "148",
    Description => "LUT for dequeue marking in VOQ-CGM based on Buffer Consumption.
Index in Array is {Profile,BufferAvailableLevel}
Profile is 5 bits
BufferAvailableLevel is quantized to 2 bits.",
    Width => "8", # Excel Formula: =calc_reg_width(E79:E79,F79)
    Type => "Config",
    AdditionalInfo => "PackArrayToBus",
    Comments => "VOQ_CGM
CGM Deq Marking logic implemented in FF.
Address is {VOQ_PROFILE,Buffer_pool_available_level}
5 + 2 = 7
Buffer_voq_size_level selects offset out of 8.",
    ArrayLength => "128",
    ArrayIndex => "9",
    DeqBufferCongestionMark9 => { #Structure Type: RegField; ArrayLength: 128; ArrayIndex: 9; ArrayLocationInName: 24;
      Name => "DeqBufferCongestionMark[n]",
      RegMem => "RegField",
      Description => "Fill level of VOQ in buffers selects between the 8 values for a given {Profile,BufferAvailableLevel} pair.
The MSB is mark indication in case of most full.
The LSB is mark indication in case of most empty.",
      Width => "8",
      Position => "7:0", # Excel Formula: =calc_position(F78,E79,TRUE)
      Type => "Config",
      UsedBy => "CGM_deq",
      DefaultValue => "h0",
    },
  },
  BuffersConsumptionLutForDeq10 => { #Structure Type: Reg; ArrayLength: 128; ArrayIndex: 10; ArrayLocationInName: 28;
    Name => "BuffersConsumptionLutForDeq[128]",
    RegMem => "Reg",
    Address => "149",
    Description => "LUT for dequeue marking in VOQ-CGM based on Buffer Consumption.
Index in Array is {Profile,BufferAvailableLevel}
Profile is 5 bits
BufferAvailableLevel is quantized to 2 bits.",
    Width => "8", # Excel Formula: =calc_reg_width(E79:E79,F79)
    Type => "Config",
    AdditionalInfo => "PackArrayToBus",
    Comments => "VOQ_CGM
CGM Deq Marking logic implemented in FF.
Address is {VOQ_PROFILE,Buffer_pool_available_level}
5 + 2 = 7
Buffer_voq_size_level selects offset out of 8.",
    ArrayLength => "128",
    ArrayIndex => "10",
    DeqBufferCongestionMark10 => { #Structure Type: RegField; ArrayLength: 128; ArrayIndex: 10; ArrayLocationInName: 24;
      Name => "DeqBufferCongestionMark[n]",
      RegMem => "RegField",
      Description => "Fill level of VOQ in buffers selects between the 8 values for a given {Profile,BufferAvailableLevel} pair.
The MSB is mark indication in case of most full.
The LSB is mark indication in case of most empty.",
      Width => "8",
      Position => "7:0", # Excel Formula: =calc_position(F78,E79,TRUE)
      Type => "Config",
      UsedBy => "CGM_deq",
      DefaultValue => "h0",
    },
  },
  BuffersConsumptionLutForDeq11 => { #Structure Type: Reg; ArrayLength: 128; ArrayIndex: 11; ArrayLocationInName: 28;
    Name => "BuffersConsumptionLutForDeq[128]",
    RegMem => "Reg",
    Address => "14A",
    Description => "LUT for dequeue marking in VOQ-CGM based on Buffer Consumption.
Index in Array is {Profile,BufferAvailableLevel}
Profile is 5 bits
BufferAvailableLevel is quantized to 2 bits.",
    Width => "8", # Excel Formula: =calc_reg_width(E79:E79,F79)
    Type => "Config",
    AdditionalInfo => "PackArrayToBus",
    Comments => "VOQ_CGM
CGM Deq Marking logic implemented in FF.
Address is {VOQ_PROFILE,Buffer_pool_available_level}
5 + 2 = 7
Buffer_voq_size_level selects offset out of 8.",
    ArrayLength => "128",
    ArrayIndex => "11",
    DeqBufferCongestionMark11 => { #Structure Type: RegField; ArrayLength: 128; ArrayIndex: 11; ArrayLocationInName: 24;
      Name => "DeqBufferCongestionMark[n]",
      RegMem => "RegField",
      Description => "Fill level of VOQ in buffers selects between the 8 values for a given {Profile,BufferAvailableLevel} pair.
The MSB is mark indication in case of most full.
The LSB is mark indication in case of most empty.",
      Width => "8",
      Position => "7:0", # Excel Formula: =calc_position(F78,E79,TRUE)
      Type => "Config",
      UsedBy => "CGM_deq",
      DefaultValue => "h0",
    },
  },
  BuffersConsumptionLutForDeq12 => { #Structure Type: Reg; ArrayLength: 128; ArrayIndex: 12; ArrayLocationInName: 28;
    Name => "BuffersConsumptionLutForDeq[128]",
    RegMem => "Reg",
    Address => "14B",
    Description => "LUT for dequeue marking in VOQ-CGM based on Buffer Consumption.
Index in Array is {Profile,BufferAvailableLevel}
Profile is 5 bits
BufferAvailableLevel is quantized to 2 bits.",
    Width => "8", # Excel Formula: =calc_reg_width(E79:E79,F79)
    Type => "Config",
    AdditionalInfo => "PackArrayToBus",
    Comments => "VOQ_CGM
CGM Deq Marking logic implemented in FF.
Address is {VOQ_PROFILE,Buffer_pool_available_level}
5 + 2 = 7
Buffer_voq_size_level selects offset out of 8.",
    ArrayLength => "128",
    ArrayIndex => "12",
    DeqBufferCongestionMark12 => { #Structure Type: RegField; ArrayLength: 128; ArrayIndex: 12; ArrayLocationInName: 24;
      Name => "DeqBufferCongestionMark[n]",
      RegMem => "RegField",
      Description => "Fill level of VOQ in buffers selects between the 8 values for a given {Profile,BufferAvailableLevel} pair.
The MSB is mark indication in case of most full.
The LSB is mark indication in case of most empty.",
      Width => "8",
      Position => "7:0", # Excel Formula: =calc_position(F78,E79,TRUE)
      Type => "Config",
      UsedBy => "CGM_deq",
      DefaultValue => "h0",
    },
  },
  BuffersConsumptionLutForDeq13 => { #Structure Type: Reg; ArrayLength: 128; ArrayIndex: 13; ArrayLocationInName: 28;
    Name => "BuffersConsumptionLutForDeq[128]",
    RegMem => "Reg",
    Address => "14C",
    Description => "LUT for dequeue marking in VOQ-CGM based on Buffer Consumption.
Index in Array is {Profile,BufferAvailableLevel}
Profile is 5 bits
BufferAvailableLevel is quantized to 2 bits.",
    Width => "8", # Excel Formula: =calc_reg_width(E79:E79,F79)
    Type => "Config",
    AdditionalInfo => "PackArrayToBus",
    Comments => "VOQ_CGM
CGM Deq Marking logic implemented in FF.
Address is {VOQ_PROFILE,Buffer_pool_available_level}
5 + 2 = 7
Buffer_voq_size_level selects offset out of 8.",
    ArrayLength => "128",
    ArrayIndex => "13",
    DeqBufferCongestionMark13 => { #Structure Type: RegField; ArrayLength: 128; ArrayIndex: 13; ArrayLocationInName: 24;
      Name => "DeqBufferCongestionMark[n]",
      RegMem => "RegField",
      Description => "Fill level of VOQ in buffers selects between the 8 values for a given {Profile,BufferAvailableLevel} pair.
The MSB is mark indication in case of most full.
The LSB is mark indication in case of most empty.",
      Width => "8",
      Position => "7:0", # Excel Formula: =calc_position(F78,E79,TRUE)
      Type => "Config",
      UsedBy => "CGM_deq",
      DefaultValue => "h0",
    },
  },
  BuffersConsumptionLutForDeq14 => { #Structure Type: Reg; ArrayLength: 128; ArrayIndex: 14; ArrayLocationInName: 28;
    Name => "BuffersConsumptionLutForDeq[128]",
    RegMem => "Reg",
    Address => "14D",
    Description => "LUT for dequeue marking in VOQ-CGM based on Buffer Consumption.
Index in Array is {Profile,BufferAvailableLevel}
Profile is 5 bits
BufferAvailableLevel is quantized to 2 bits.",
    Width => "8", # Excel Formula: =calc_reg_width(E79:E79,F79)
    Type => "Config",
    AdditionalInfo => "PackArrayToBus",
    Comments => "VOQ_CGM
CGM Deq Marking logic implemented in FF.
Address is {VOQ_PROFILE,Buffer_pool_available_level}
5 + 2 = 7
Buffer_voq_size_level selects offset out of 8.",
    ArrayLength => "128",
    ArrayIndex => "14",
    DeqBufferCongestionMark14 => { #Structure Type: RegField; ArrayLength: 128; ArrayIndex: 14; ArrayLocationInName: 24;
      Name => "DeqBufferCongestionMark[n]",
      RegMem => "RegField",
      Description => "Fill level of VOQ in buffers selects between the 8 values for a given {Profile,BufferAvailableLevel} pair.
The MSB is mark indication in case of most full.
The LSB is mark indication in case of most empty.",
      Width => "8",
      Position => "7:0", # Excel Formula: =calc_position(F78,E79,TRUE)
      Type => "Config",
      UsedBy => "CGM_deq",
      DefaultValue => "h0",
    },
  },
  BuffersConsumptionLutForDeq15 => { #Structure Type: Reg; ArrayLength: 128; ArrayIndex: 15; ArrayLocationInName: 28;
    Name => "BuffersConsumptionLutForDeq[128]",
    RegMem => "Reg",
    Address => "14E",
    Description => "LUT for dequeue marking in VOQ-CGM based on Buffer Consumption.
Index in Array is {Profile,BufferAvailableLevel}
Profile is 5 bits
BufferAvailableLevel is quantized to 2 bits.",
    Width => "8", # Excel Formula: =calc_reg_width(E79:E79,F79)
    Type => "Config",
    AdditionalInfo => "PackArrayToBus",
    Comments => "VOQ_CGM
CGM Deq Marking logic implemented in FF.
Address is {VOQ_PROFILE,Buffer_pool_available_level}
5 + 2 = 7
Buffer_voq_size_level selects offset out of 8.",
    ArrayLength => "128",
    ArrayIndex => "15",
    DeqBufferCongestionMark15 => { #Structure Type: RegField; ArrayLength: 128; ArrayIndex: 15; ArrayLocationInName: 24;
      Name => "DeqBufferCongestionMark[n]",
      RegMem => "RegField",
      Description => "Fill level of VOQ in buffers selects between the 8 values for a given {Profile,BufferAvailableLevel} pair.
The MSB is mark indication in case of most full.
The LSB is mark indication in case of most empty.",
      Width => "8",
      Position => "7:0", # Excel Formula: =calc_position(F78,E79,TRUE)
      Type => "Config",
      UsedBy => "CGM_deq",
      DefaultValue => "h0",
    },
  },
  BuffersConsumptionLutForDeq16 => { #Structure Type: Reg; ArrayLength: 128; ArrayIndex: 16; ArrayLocationInName: 28;
    Name => "BuffersConsumptionLutForDeq[128]",
    RegMem => "Reg",
    Address => "14F",
    Description => "LUT for dequeue marking in VOQ-CGM based on Buffer Consumption.
Index in Array is {Profile,BufferAvailableLevel}
Profile is 5 bits
BufferAvailableLevel is quantized to 2 bits.",
    Width => "8", # Excel Formula: =calc_reg_width(E79:E79,F79)
    Type => "Config",
    AdditionalInfo => "PackArrayToBus",
    Comments => "VOQ_CGM
CGM Deq Marking logic implemented in FF.
Address is {VOQ_PROFILE,Buffer_pool_available_level}
5 + 2 = 7
Buffer_voq_size_level selects offset out of 8.",
    ArrayLength => "128",
    ArrayIndex => "16",
    DeqBufferCongestionMark16 => { #Structure Type: RegField; ArrayLength: 128; ArrayIndex: 16; ArrayLocationInName: 24;
      Name => "DeqBufferCongestionMark[n]",
      RegMem => "RegField",
      Description => "Fill level of VOQ in buffers selects between the 8 values for a given {Profile,BufferAvailableLevel} pair.
The MSB is mark indication in case of most full.
The LSB is mark indication in case of most empty.",
      Width => "8",
      Position => "7:0", # Excel Formula: =calc_position(F78,E79,TRUE)
      Type => "Config",
      UsedBy => "CGM_deq",
      DefaultValue => "h0",
    },
  },
  BuffersConsumptionLutForDeq17 => { #Structure Type: Reg; ArrayLength: 128; ArrayIndex: 17; ArrayLocationInName: 28;
    Name => "BuffersConsumptionLutForDeq[128]",
    RegMem => "Reg",
    Address => "150",
    Description => "LUT for dequeue marking in VOQ-CGM based on Buffer Consumption.
Index in Array is {Profile,BufferAvailableLevel}
Profile is 5 bits
BufferAvailableLevel is quantized to 2 bits.",
    Width => "8", # Excel Formula: =calc_reg_width(E79:E79,F79)
    Type => "Config",
    AdditionalInfo => "PackArrayToBus",
    Comments => "VOQ_CGM
CGM Deq Marking logic implemented in FF.
Address is {VOQ_PROFILE,Buffer_pool_available_level}
5 + 2 = 7
Buffer_voq_size_level selects offset out of 8.",
    ArrayLength => "128",
    ArrayIndex => "17",
    DeqBufferCongestionMark17 => { #Structure Type: RegField; ArrayLength: 128; ArrayIndex: 17; ArrayLocationInName: 24;
      Name => "DeqBufferCongestionMark[n]",
      RegMem => "RegField",
      Description => "Fill level of VOQ in buffers selects between the 8 values for a given {Profile,BufferAvailableLevel} pair.
The MSB is mark indication in case of most full.
The LSB is mark indication in case of most empty.",
      Width => "8",
      Position => "7:0", # Excel Formula: =calc_position(F78,E79,TRUE)
      Type => "Config",
      UsedBy => "CGM_deq",
      DefaultValue => "h0",
    },
  },
  BuffersConsumptionLutForDeq18 => { #Structure Type: Reg; ArrayLength: 128; ArrayIndex: 18; ArrayLocationInName: 28;
    Name => "BuffersConsumptionLutForDeq[128]",
    RegMem => "Reg",
    Address => "151",
    Description => "LUT for dequeue marking in VOQ-CGM based on Buffer Consumption.
Index in Array is {Profile,BufferAvailableLevel}
Profile is 5 bits
BufferAvailableLevel is quantized to 2 bits.",
    Width => "8", # Excel Formula: =calc_reg_width(E79:E79,F79)
    Type => "Config",
    AdditionalInfo => "PackArrayToBus",
    Comments => "VOQ_CGM
CGM Deq Marking logic implemented in FF.
Address is {VOQ_PROFILE,Buffer_pool_available_level}
5 + 2 = 7
Buffer_voq_size_level selects offset out of 8.",
    ArrayLength => "128",
    ArrayIndex => "18",
    DeqBufferCongestionMark18 => { #Structure Type: RegField; ArrayLength: 128; ArrayIndex: 18; ArrayLocationInName: 24;
      Name => "DeqBufferCongestionMark[n]",
      RegMem => "RegField",
      Description => "Fill level of VOQ in buffers selects between the 8 values for a given {Profile,BufferAvailableLevel} pair.
The MSB is mark indication in case of most full.
The LSB is mark indication in case of most empty.",
      Width => "8",
      Position => "7:0", # Excel Formula: =calc_position(F78,E79,TRUE)
      Type => "Config",
      UsedBy => "CGM_deq",
      DefaultValue => "h0",
    },
  },
  BuffersConsumptionLutForDeq19 => { #Structure Type: Reg; ArrayLength: 128; ArrayIndex: 19; ArrayLocationInName: 28;
    Name => "BuffersConsumptionLutForDeq[128]",
    RegMem => "Reg",
    Address => "152",
    Description => "LUT for dequeue marking in VOQ-CGM based on Buffer Consumption.
Index in Array is {Profile,BufferAvailableLevel}
Profile is 5 bits
BufferAvailableLevel is quantized to 2 bits.",
    Width => "8", # Excel Formula: =calc_reg_width(E79:E79,F79)
    Type => "Config",
    AdditionalInfo => "PackArrayToBus",
    Comments => "VOQ_CGM
CGM Deq Marking logic implemented in FF.
Address is {VOQ_PROFILE,Buffer_pool_available_level}
5 + 2 = 7
Buffer_voq_size_level selects offset out of 8.",
    ArrayLength => "128",
    ArrayIndex => "19",
    DeqBufferCongestionMark19 => { #Structure Type: RegField; ArrayLength: 128; ArrayIndex: 19; ArrayLocationInName: 24;
      Name => "DeqBufferCongestionMark[n]",
      RegMem => "RegField",
      Description => "Fill level of VOQ in buffers selects between the 8 values for a given {Profile,BufferAvailableLevel} pair.
The MSB is mark indication in case of most full.
The LSB is mark indication in case of most empty.",
      Width => "8",
      Position => "7:0", # Excel Formula: =calc_position(F78,E79,TRUE)
      Type => "Config",
      UsedBy => "CGM_deq",
      DefaultValue => "h0",
    },
  },
  BuffersConsumptionLutForDeq20 => { #Structure Type: Reg; ArrayLength: 128; ArrayIndex: 20; ArrayLocationInName: 28;
    Name => "BuffersConsumptionLutForDeq[128]",
    RegMem => "Reg",
    Address => "153",
    Description => "LUT for dequeue marking in VOQ-CGM based on Buffer Consumption.
Index in Array is {Profile,BufferAvailableLevel}
Profile is 5 bits
BufferAvailableLevel is quantized to 2 bits.",
    Width => "8", # Excel Formula: =calc_reg_width(E79:E79,F79)
    Type => "Config",
    AdditionalInfo => "PackArrayToBus",
    Comments => "VOQ_CGM
CGM Deq Marking logic implemented in FF.
Address is {VOQ_PROFILE,Buffer_pool_available_level}
5 + 2 = 7
Buffer_voq_size_level selects offset out of 8.",
    ArrayLength => "128",
    ArrayIndex => "20",
    DeqBufferCongestionMark20 => { #Structure Type: RegField; ArrayLength: 128; ArrayIndex: 20; ArrayLocationInName: 24;
      Name => "DeqBufferCongestionMark[n]",
      RegMem => "RegField",
      Description => "Fill level of VOQ in buffers selects between the 8 values for a given {Profile,BufferAvailableLevel} pair.
The MSB is mark indication in case of most full.
The LSB is mark indication in case of most empty.",
      Width => "8",
      Position => "7:0", # Excel Formula: =calc_position(F78,E79,TRUE)
      Type => "Config",
      UsedBy => "CGM_deq",
      DefaultValue => "h0",
    },
  },
  BuffersConsumptionLutForDeq21 => { #Structure Type: Reg; ArrayLength: 128; ArrayIndex: 21; ArrayLocationInName: 28;
    Name => "BuffersConsumptionLutForDeq[128]",
    RegMem => "Reg",
    Address => "154",
    Description => "LUT for dequeue marking in VOQ-CGM based on Buffer Consumption.
Index in Array is {Profile,BufferAvailableLevel}
Profile is 5 bits
BufferAvailableLevel is quantized to 2 bits.",
    Width => "8", # Excel Formula: =calc_reg_width(E79:E79,F79)
    Type => "Config",
    AdditionalInfo => "PackArrayToBus",
    Comments => "VOQ_CGM
CGM Deq Marking logic implemented in FF.
Address is {VOQ_PROFILE,Buffer_pool_available_level}
5 + 2 = 7
Buffer_voq_size_level selects offset out of 8.",
    ArrayLength => "128",
    ArrayIndex => "21",
    DeqBufferCongestionMark21 => { #Structure Type: RegField; ArrayLength: 128; ArrayIndex: 21; ArrayLocationInName: 24;
      Name => "DeqBufferCongestionMark[n]",
      RegMem => "RegField",
      Description => "Fill level of VOQ in buffers selects between the 8 values for a given {Profile,BufferAvailableLevel} pair.
The MSB is mark indication in case of most full.
The LSB is mark indication in case of most empty.",
      Width => "8",
      Position => "7:0", # Excel Formula: =calc_position(F78,E79,TRUE)
      Type => "Config",
      UsedBy => "CGM_deq",
      DefaultValue => "h0",
    },
  },
  BuffersConsumptionLutForDeq22 => { #Structure Type: Reg; ArrayLength: 128; ArrayIndex: 22; ArrayLocationInName: 28;
    Name => "BuffersConsumptionLutForDeq[128]",
    RegMem => "Reg",
    Address => "155",
    Description => "LUT for dequeue marking in VOQ-CGM based on Buffer Consumption.
Index in Array is {Profile,BufferAvailableLevel}
Profile is 5 bits
BufferAvailableLevel is quantized to 2 bits.",
    Width => "8", # Excel Formula: =calc_reg_width(E79:E79,F79)
    Type => "Config",
    AdditionalInfo => "PackArrayToBus",
    Comments => "VOQ_CGM
CGM Deq Marking logic implemented in FF.
Address is {VOQ_PROFILE,Buffer_pool_available_level}
5 + 2 = 7
Buffer_voq_size_level selects offset out of 8.",
    ArrayLength => "128",
    ArrayIndex => "22",
    DeqBufferCongestionMark22 => { #Structure Type: RegField; ArrayLength: 128; ArrayIndex: 22; ArrayLocationInName: 24;
      Name => "DeqBufferCongestionMark[n]",
      RegMem => "RegField",
      Description => "Fill level of VOQ in buffers selects between the 8 values for a given {Profile,BufferAvailableLevel} pair.
The MSB is mark indication in case of most full.
The LSB is mark indication in case of most empty.",
      Width => "8",
      Position => "7:0", # Excel Formula: =calc_position(F78,E79,TRUE)
      Type => "Config",
      UsedBy => "CGM_deq",
      DefaultValue => "h0",
    },
  },
  BuffersConsumptionLutForDeq23 => { #Structure Type: Reg; ArrayLength: 128; ArrayIndex: 23; ArrayLocationInName: 28;
    Name => "BuffersConsumptionLutForDeq[128]",
    RegMem => "Reg",
    Address => "156",
    Description => "LUT for dequeue marking in VOQ-CGM based on Buffer Consumption.
Index in Array is {Profile,BufferAvailableLevel}
Profile is 5 bits
BufferAvailableLevel is quantized to 2 bits.",
    Width => "8", # Excel Formula: =calc_reg_width(E79:E79,F79)
    Type => "Config",
    AdditionalInfo => "PackArrayToBus",
    Comments => "VOQ_CGM
CGM Deq Marking logic implemented in FF.
Address is {VOQ_PROFILE,Buffer_pool_available_level}
5 + 2 = 7
Buffer_voq_size_level selects offset out of 8.",
    ArrayLength => "128",
    ArrayIndex => "23",
    DeqBufferCongestionMark23 => { #Structure Type: RegField; ArrayLength: 128; ArrayIndex: 23; ArrayLocationInName: 24;
      Name => "DeqBufferCongestionMark[n]",
      RegMem => "RegField",
      Description => "Fill level of VOQ in buffers selects between the 8 values for a given {Profile,BufferAvailableLevel} pair.
The MSB is mark indication in case of most full.
The LSB is mark indication in case of most empty.",
      Width => "8",
      Position => "7:0", # Excel Formula: =calc_position(F78,E79,TRUE)
      Type => "Config",
      UsedBy => "CGM_deq",
      DefaultValue => "h0",
    },
  },
  BuffersConsumptionLutForDeq24 => { #Structure Type: Reg; ArrayLength: 128; ArrayIndex: 24; ArrayLocationInName: 28;
    Name => "BuffersConsumptionLutForDeq[128]",
    RegMem => "Reg",
    Address => "157",
    Description => "LUT for dequeue marking in VOQ-CGM based on Buffer Consumption.
Index in Array is {Profile,BufferAvailableLevel}
Profile is 5 bits
BufferAvailableLevel is quantized to 2 bits.",
    Width => "8", # Excel Formula: =calc_reg_width(E79:E79,F79)
    Type => "Config",
    AdditionalInfo => "PackArrayToBus",
    Comments => "VOQ_CGM
CGM Deq Marking logic implemented in FF.
Address is {VOQ_PROFILE,Buffer_pool_available_level}
5 + 2 = 7
Buffer_voq_size_level selects offset out of 8.",
    ArrayLength => "128",
    ArrayIndex => "24",
    DeqBufferCongestionMark24 => { #Structure Type: RegField; ArrayLength: 128; ArrayIndex: 24; ArrayLocationInName: 24;
      Name => "DeqBufferCongestionMark[n]",
      RegMem => "RegField",
      Description => "Fill level of VOQ in buffers selects between the 8 values for a given {Profile,BufferAvailableLevel} pair.
The MSB is mark indication in case of most full.
The LSB is mark indication in case of most empty.",
      Width => "8",
      Position => "7:0", # Excel Formula: =calc_position(F78,E79,TRUE)
      Type => "Config",
      UsedBy => "CGM_deq",
      DefaultValue => "h0",
    },
  },
  BuffersConsumptionLutForDeq25 => { #Structure Type: Reg; ArrayLength: 128; ArrayIndex: 25; ArrayLocationInName: 28;
    Name => "BuffersConsumptionLutForDeq[128]",
    RegMem => "Reg",
    Address => "158",
    Description => "LUT for dequeue marking in VOQ-CGM based on Buffer Consumption.
Index in Array is {Profile,BufferAvailableLevel}
Profile is 5 bits
BufferAvailableLevel is quantized to 2 bits.",
    Width => "8", # Excel Formula: =calc_reg_width(E79:E79,F79)
    Type => "Config",
    AdditionalInfo => "PackArrayToBus",
    Comments => "VOQ_CGM
CGM Deq Marking logic implemented in FF.
Address is {VOQ_PROFILE,Buffer_pool_available_level}
5 + 2 = 7
Buffer_voq_size_level selects offset out of 8.",
    ArrayLength => "128",
    ArrayIndex => "25",
    DeqBufferCongestionMark25 => { #Structure Type: RegField; ArrayLength: 128; ArrayIndex: 25; ArrayLocationInName: 24;
      Name => "DeqBufferCongestionMark[n]",
      RegMem => "RegField",
      Description => "Fill level of VOQ in buffers selects between the 8 values for a given {Profile,BufferAvailableLevel} pair.
The MSB is mark indication in case of most full.
The LSB is mark indication in case of most empty.",
      Width => "8",
      Position => "7:0", # Excel Formula: =calc_position(F78,E79,TRUE)
      Type => "Config",
      UsedBy => "CGM_deq",
      DefaultValue => "h0",
    },
  },
  BuffersConsumptionLutForDeq26 => { #Structure Type: Reg; ArrayLength: 128; ArrayIndex: 26; ArrayLocationInName: 28;
    Name => "BuffersConsumptionLutForDeq[128]",
    RegMem => "Reg",
    Address => "159",
    Description => "LUT for dequeue marking in VOQ-CGM based on Buffer Consumption.
Index in Array is {Profile,BufferAvailableLevel}
Profile is 5 bits
BufferAvailableLevel is quantized to 2 bits.",
    Width => "8", # Excel Formula: =calc_reg_width(E79:E79,F79)
    Type => "Config",
    AdditionalInfo => "PackArrayToBus",
    Comments => "VOQ_CGM
CGM Deq Marking logic implemented in FF.
Address is {VOQ_PROFILE,Buffer_pool_available_level}
5 + 2 = 7
Buffer_voq_size_level selects offset out of 8.",
    ArrayLength => "128",
    ArrayIndex => "26",
    DeqBufferCongestionMark26 => { #Structure Type: RegField; ArrayLength: 128; ArrayIndex: 26; ArrayLocationInName: 24;
      Name => "DeqBufferCongestionMark[n]",
      RegMem => "RegField",
      Description => "Fill level of VOQ in buffers selects between the 8 values for a given {Profile,BufferAvailableLevel} pair.
The MSB is mark indication in case of most full.
The LSB is mark indication in case of most empty.",
      Width => "8",
      Position => "7:0", # Excel Formula: =calc_position(F78,E79,TRUE)
      Type => "Config",
      UsedBy => "CGM_deq",
      DefaultValue => "h0",
    },
  },
  BuffersConsumptionLutForDeq27 => { #Structure Type: Reg; ArrayLength: 128; ArrayIndex: 27; ArrayLocationInName: 28;
    Name => "BuffersConsumptionLutForDeq[128]",
    RegMem => "Reg",
    Address => "15A",
    Description => "LUT for dequeue marking in VOQ-CGM based on Buffer Consumption.
Index in Array is {Profile,BufferAvailableLevel}
Profile is 5 bits
BufferAvailableLevel is quantized to 2 bits.",
    Width => "8", # Excel Formula: =calc_reg_width(E79:E79,F79)
    Type => "Config",
    AdditionalInfo => "PackArrayToBus",
    Comments => "VOQ_CGM
CGM Deq Marking logic implemented in FF.
Address is {VOQ_PROFILE,Buffer_pool_available_level}
5 + 2 = 7
Buffer_voq_size_level selects offset out of 8.",
    ArrayLength => "128",
    ArrayIndex => "27",
    DeqBufferCongestionMark27 => { #Structure Type: RegField; ArrayLength: 128; ArrayIndex: 27; ArrayLocationInName: 24;
      Name => "DeqBufferCongestionMark[n]",
      RegMem => "RegField",
      Description => "Fill level of VOQ in buffers selects between the 8 values for a given {Profile,BufferAvailableLevel} pair.
The MSB is mark indication in case of most full.
The LSB is mark indication in case of most empty.",
      Width => "8",
      Position => "7:0", # Excel Formula: =calc_position(F78,E79,TRUE)
      Type => "Config",
      UsedBy => "CGM_deq",
      DefaultValue => "h0",
    },
  },
  BuffersConsumptionLutForDeq28 => { #Structure Type: Reg; ArrayLength: 128; ArrayIndex: 28; ArrayLocationInName: 28;
    Name => "BuffersConsumptionLutForDeq[128]",
    RegMem => "Reg",
    Address => "15B",
    Description => "LUT for dequeue marking in VOQ-CGM based on Buffer Consumption.
Index in Array is {Profile,BufferAvailableLevel}
Profile is 5 bits
BufferAvailableLevel is quantized to 2 bits.",
    Width => "8", # Excel Formula: =calc_reg_width(E79:E79,F79)
    Type => "Config",
    AdditionalInfo => "PackArrayToBus",
    Comments => "VOQ_CGM
CGM Deq Marking logic implemented in FF.
Address is {VOQ_PROFILE,Buffer_pool_available_level}
5 + 2 = 7
Buffer_voq_size_level selects offset out of 8.",
    ArrayLength => "128",
    ArrayIndex => "28",
    DeqBufferCongestionMark28 => { #Structure Type: RegField; ArrayLength: 128; ArrayIndex: 28; ArrayLocationInName: 24;
      Name => "DeqBufferCongestionMark[n]",
      RegMem => "RegField",
      Description => "Fill level of VOQ in buffers selects between the 8 values for a given {Profile,BufferAvailableLevel} pair.
The MSB is mark indication in case of most full.
The LSB is mark indication in case of most empty.",
      Width => "8",
      Position => "7:0", # Excel Formula: =calc_position(F78,E79,TRUE)
      Type => "Config",
      UsedBy => "CGM_deq",
      DefaultValue => "h0",
    },
  },
  BuffersConsumptionLutForDeq29 => { #Structure Type: Reg; ArrayLength: 128; ArrayIndex: 29; ArrayLocationInName: 28;
    Name => "BuffersConsumptionLutForDeq[128]",
    RegMem => "Reg",
    Address => "15C",
    Description => "LUT for dequeue marking in VOQ-CGM based on Buffer Consumption.
Index in Array is {Profile,BufferAvailableLevel}
Profile is 5 bits
BufferAvailableLevel is quantized to 2 bits.",
    Width => "8", # Excel Formula: =calc_reg_width(E79:E79,F79)
    Type => "Config",
    AdditionalInfo => "PackArrayToBus",
    Comments => "VOQ_CGM
CGM Deq Marking logic implemented in FF.
Address is {VOQ_PROFILE,Buffer_pool_available_level}
5 + 2 = 7
Buffer_voq_size_level selects offset out of 8.",
    ArrayLength => "128",
    ArrayIndex => "29",
    DeqBufferCongestionMark29 => { #Structure Type: RegField; ArrayLength: 128; ArrayIndex: 29; ArrayLocationInName: 24;
      Name => "DeqBufferCongestionMark[n]",
      RegMem => "RegField",
      Description => "Fill level of VOQ in buffers selects between the 8 values for a given {Profile,BufferAvailableLevel} pair.
The MSB is mark indication in case of most full.
The LSB is mark indication in case of most empty.",
      Width => "8",
      Position => "7:0", # Excel Formula: =calc_position(F78,E79,TRUE)
      Type => "Config",
      UsedBy => "CGM_deq",
      DefaultValue => "h0",
    },
  },
  BuffersConsumptionLutForDeq30 => { #Structure Type: Reg; ArrayLength: 128; ArrayIndex: 30; ArrayLocationInName: 28;
    Name => "BuffersConsumptionLutForDeq[128]",
    RegMem => "Reg",
    Address => "15D",
    Description => "LUT for dequeue marking in VOQ-CGM based on Buffer Consumption.
Index in Array is {Profile,BufferAvailableLevel}
Profile is 5 bits
BufferAvailableLevel is quantized to 2 bits.",
    Width => "8", # Excel Formula: =calc_reg_width(E79:E79,F79)
    Type => "Config",
    AdditionalInfo => "PackArrayToBus",
    Comments => "VOQ_CGM
CGM Deq Marking logic implemented in FF.
Address is {VOQ_PROFILE,Buffer_pool_available_level}
5 + 2 = 7
Buffer_voq_size_level selects offset out of 8.",
    ArrayLength => "128",
    ArrayIndex => "30",
    DeqBufferCongestionMark30 => { #Structure Type: RegField; ArrayLength: 128; ArrayIndex: 30; ArrayLocationInName: 24;
      Name => "DeqBufferCongestionMark[n]",
      RegMem => "RegField",
      Description => "Fill level of VOQ in buffers selects between the 8 values for a given {Profile,BufferAvailableLevel} pair.
The MSB is mark indication in case of most full.
The LSB is mark indication in case of most empty.",
      Width => "8",
      Position => "7:0", # Excel Formula: =calc_position(F78,E79,TRUE)
      Type => "Config",
      UsedBy => "CGM_deq",
      DefaultValue => "h0",
    },
  },
  BuffersConsumptionLutForDeq31 => { #Structure Type: Reg; ArrayLength: 128; ArrayIndex: 31; ArrayLocationInName: 28;
    Name => "BuffersConsumptionLutForDeq[128]",
    RegMem => "Reg",
    Address => "15E",
    Description => "LUT for dequeue marking in VOQ-CGM based on Buffer Consumption.
Index in Array is {Profile,BufferAvailableLevel}
Profile is 5 bits
BufferAvailableLevel is quantized to 2 bits.",
    Width => "8", # Excel Formula: =calc_reg_width(E79:E79,F79)
    Type => "Config",
    AdditionalInfo => "PackArrayToBus",
    Comments => "VOQ_CGM
CGM Deq Marking logic implemented in FF.
Address is {VOQ_PROFILE,Buffer_pool_available_level}
5 + 2 = 7
Buffer_voq_size_level selects offset out of 8.",
    ArrayLength => "128",
    ArrayIndex => "31",
    DeqBufferCongestionMark31 => { #Structure Type: RegField; ArrayLength: 128; ArrayIndex: 31; ArrayLocationInName: 24;
      Name => "DeqBufferCongestionMark[n]",
      RegMem => "RegField",
      Description => "Fill level of VOQ in buffers selects between the 8 values for a given {Profile,BufferAvailableLevel} pair.
The MSB is mark indication in case of most full.
The LSB is mark indication in case of most empty.",
      Width => "8",
      Position => "7:0", # Excel Formula: =calc_position(F78,E79,TRUE)
      Type => "Config",
      UsedBy => "CGM_deq",
      DefaultValue => "h0",
    },
  },
  BuffersConsumptionLutForDeq32 => { #Structure Type: Reg; ArrayLength: 128; ArrayIndex: 32; ArrayLocationInName: 28;
    Name => "BuffersConsumptionLutForDeq[128]",
    RegMem => "Reg",
    Address => "15F",
    Description => "LUT for dequeue marking in VOQ-CGM based on Buffer Consumption.
Index in Array is {Profile,BufferAvailableLevel}
Profile is 5 bits
BufferAvailableLevel is quantized to 2 bits.",
    Width => "8", # Excel Formula: =calc_reg_width(E79:E79,F79)
    Type => "Config",
    AdditionalInfo => "PackArrayToBus",
    Comments => "VOQ_CGM
CGM Deq Marking logic implemented in FF.
Address is {VOQ_PROFILE,Buffer_pool_available_level}
5 + 2 = 7
Buffer_voq_size_level selects offset out of 8.",
    ArrayLength => "128",
    ArrayIndex => "32",
    DeqBufferCongestionMark32 => { #Structure Type: RegField; ArrayLength: 128; ArrayIndex: 32; ArrayLocationInName: 24;
      Name => "DeqBufferCongestionMark[n]",
      RegMem => "RegField",
      Description => "Fill level of VOQ in buffers selects between the 8 values for a given {Profile,BufferAvailableLevel} pair.
The MSB is mark indication in case of most full.
The LSB is mark indication in case of most empty.",
      Width => "8",
      Position => "7:0", # Excel Formula: =calc_position(F78,E79,TRUE)
      Type => "Config",
      UsedBy => "CGM_deq",
      DefaultValue => "h0",
    },
  },
  BuffersConsumptionLutForDeq33 => { #Structure Type: Reg; ArrayLength: 128; ArrayIndex: 33; ArrayLocationInName: 28;
    Name => "BuffersConsumptionLutForDeq[128]",
    RegMem => "Reg",
    Address => "160",
    Description => "LUT for dequeue marking in VOQ-CGM based on Buffer Consumption.
Index in Array is {Profile,BufferAvailableLevel}
Profile is 5 bits
BufferAvailableLevel is quantized to 2 bits.",
    Width => "8", # Excel Formula: =calc_reg_width(E79:E79,F79)
    Type => "Config",
    AdditionalInfo => "PackArrayToBus",
    Comments => "VOQ_CGM
CGM Deq Marking logic implemented in FF.
Address is {VOQ_PROFILE,Buffer_pool_available_level}
5 + 2 = 7
Buffer_voq_size_level selects offset out of 8.",
    ArrayLength => "128",
    ArrayIndex => "33",
    DeqBufferCongestionMark33 => { #Structure Type: RegField; ArrayLength: 128; ArrayIndex: 33; ArrayLocationInName: 24;
      Name => "DeqBufferCongestionMark[n]",
      RegMem => "RegField",
      Description => "Fill level of VOQ in buffers selects between the 8 values for a given {Profile,BufferAvailableLevel} pair.
The MSB is mark indication in case of most full.
The LSB is mark indication in case of most empty.",
      Width => "8",
      Position => "7:0", # Excel Formula: =calc_position(F78,E79,TRUE)
      Type => "Config",
      UsedBy => "CGM_deq",
      DefaultValue => "h0",
    },
  },
  BuffersConsumptionLutForDeq34 => { #Structure Type: Reg; ArrayLength: 128; ArrayIndex: 34; ArrayLocationInName: 28;
    Name => "BuffersConsumptionLutForDeq[128]",
    RegMem => "Reg",
    Address => "161",
    Description => "LUT for dequeue marking in VOQ-CGM based on Buffer Consumption.
Index in Array is {Profile,BufferAvailableLevel}
Profile is 5 bits
BufferAvailableLevel is quantized to 2 bits.",
    Width => "8", # Excel Formula: =calc_reg_width(E79:E79,F79)
    Type => "Config",
    AdditionalInfo => "PackArrayToBus",
    Comments => "VOQ_CGM
CGM Deq Marking logic implemented in FF.
Address is {VOQ_PROFILE,Buffer_pool_available_level}
5 + 2 = 7
Buffer_voq_size_level selects offset out of 8.",
    ArrayLength => "128",
    ArrayIndex => "34",
    DeqBufferCongestionMark34 => { #Structure Type: RegField; ArrayLength: 128; ArrayIndex: 34; ArrayLocationInName: 24;
      Name => "DeqBufferCongestionMark[n]",
      RegMem => "RegField",
      Description => "Fill level of VOQ in buffers selects between the 8 values for a given {Profile,BufferAvailableLevel} pair.
The MSB is mark indication in case of most full.
The LSB is mark indication in case of most empty.",
      Width => "8",
      Position => "7:0", # Excel Formula: =calc_position(F78,E79,TRUE)
      Type => "Config",
      UsedBy => "CGM_deq",
      DefaultValue => "h0",
    },
  },
  BuffersConsumptionLutForDeq35 => { #Structure Type: Reg; ArrayLength: 128; ArrayIndex: 35; ArrayLocationInName: 28;
    Name => "BuffersConsumptionLutForDeq[128]",
    RegMem => "Reg",
    Address => "162",
    Description => "LUT for dequeue marking in VOQ-CGM based on Buffer Consumption.
Index in Array is {Profile,BufferAvailableLevel}
Profile is 5 bits
BufferAvailableLevel is quantized to 2 bits.",
    Width => "8", # Excel Formula: =calc_reg_width(E79:E79,F79)
    Type => "Config",
    AdditionalInfo => "PackArrayToBus",
    Comments => "VOQ_CGM
CGM Deq Marking logic implemented in FF.
Address is {VOQ_PROFILE,Buffer_pool_available_level}
5 + 2 = 7
Buffer_voq_size_level selects offset out of 8.",
    ArrayLength => "128",
    ArrayIndex => "35",
    DeqBufferCongestionMark35 => { #Structure Type: RegField; ArrayLength: 128; ArrayIndex: 35; ArrayLocationInName: 24;
      Name => "DeqBufferCongestionMark[n]",
      RegMem => "RegField",
      Description => "Fill level of VOQ in buffers selects between the 8 values for a given {Profile,BufferAvailableLevel} pair.
The MSB is mark indication in case of most full.
The LSB is mark indication in case of most empty.",
      Width => "8",
      Position => "7:0", # Excel Formula: =calc_position(F78,E79,TRUE)
      Type => "Config",
      UsedBy => "CGM_deq",
      DefaultValue => "h0",
    },
  },
  BuffersConsumptionLutForDeq36 => { #Structure Type: Reg; ArrayLength: 128; ArrayIndex: 36; ArrayLocationInName: 28;
    Name => "BuffersConsumptionLutForDeq[128]",
    RegMem => "Reg",
    Address => "163",
    Description => "LUT for dequeue marking in VOQ-CGM based on Buffer Consumption.
Index in Array is {Profile,BufferAvailableLevel}
Profile is 5 bits
BufferAvailableLevel is quantized to 2 bits.",
    Width => "8", # Excel Formula: =calc_reg_width(E79:E79,F79)
    Type => "Config",
    AdditionalInfo => "PackArrayToBus",
    Comments => "VOQ_CGM
CGM Deq Marking logic implemented in FF.
Address is {VOQ_PROFILE,Buffer_pool_available_level}
5 + 2 = 7
Buffer_voq_size_level selects offset out of 8.",
    ArrayLength => "128",
    ArrayIndex => "36",
    DeqBufferCongestionMark36 => { #Structure Type: RegField; ArrayLength: 128; ArrayIndex: 36; ArrayLocationInName: 24;
      Name => "DeqBufferCongestionMark[n]",
      RegMem => "RegField",
      Description => "Fill level of VOQ in buffers selects between the 8 values for a given {Profile,BufferAvailableLevel} pair.
The MSB is mark indication in case of most full.
The LSB is mark indication in case of most empty.",
      Width => "8",
      Position => "7:0", # Excel Formula: =calc_position(F78,E79,TRUE)
      Type => "Config",
      UsedBy => "CGM_deq",
      DefaultValue => "h0",
    },
  },
  BuffersConsumptionLutForDeq37 => { #Structure Type: Reg; ArrayLength: 128; ArrayIndex: 37; ArrayLocationInName: 28;
    Name => "BuffersConsumptionLutForDeq[128]",
    RegMem => "Reg",
    Address => "164",
    Description => "LUT for dequeue marking in VOQ-CGM based on Buffer Consumption.
Index in Array is {Profile,BufferAvailableLevel}
Profile is 5 bits
BufferAvailableLevel is quantized to 2 bits.",
    Width => "8", # Excel Formula: =calc_reg_width(E79:E79,F79)
    Type => "Config",
    AdditionalInfo => "PackArrayToBus",
    Comments => "VOQ_CGM
CGM Deq Marking logic implemented in FF.
Address is {VOQ_PROFILE,Buffer_pool_available_level}
5 + 2 = 7
Buffer_voq_size_level selects offset out of 8.",
    ArrayLength => "128",
    ArrayIndex => "37",
    DeqBufferCongestionMark37 => { #Structure Type: RegField; ArrayLength: 128; ArrayIndex: 37; ArrayLocationInName: 24;
      Name => "DeqBufferCongestionMark[n]",
      RegMem => "RegField",
      Description => "Fill level of VOQ in buffers selects between the 8 values for a given {Profile,BufferAvailableLevel} pair.
The MSB is mark indication in case of most full.
The LSB is mark indication in case of most empty.",
      Width => "8",
      Position => "7:0", # Excel Formula: =calc_position(F78,E79,TRUE)
      Type => "Config",
      UsedBy => "CGM_deq",
      DefaultValue => "h0",
    },
  },
  BuffersConsumptionLutForDeq38 => { #Structure Type: Reg; ArrayLength: 128; ArrayIndex: 38; ArrayLocationInName: 28;
    Name => "BuffersConsumptionLutForDeq[128]",
    RegMem => "Reg",
    Address => "165",
    Description => "LUT for dequeue marking in VOQ-CGM based on Buffer Consumption.
Index in Array is {Profile,BufferAvailableLevel}
Profile is 5 bits
BufferAvailableLevel is quantized to 2 bits.",
    Width => "8", # Excel Formula: =calc_reg_width(E79:E79,F79)
    Type => "Config",
    AdditionalInfo => "PackArrayToBus",
    Comments => "VOQ_CGM
CGM Deq Marking logic implemented in FF.
Address is {VOQ_PROFILE,Buffer_pool_available_level}
5 + 2 = 7
Buffer_voq_size_level selects offset out of 8.",
    ArrayLength => "128",
    ArrayIndex => "38",
    DeqBufferCongestionMark38 => { #Structure Type: RegField; ArrayLength: 128; ArrayIndex: 38; ArrayLocationInName: 24;
      Name => "DeqBufferCongestionMark[n]",
      RegMem => "RegField",
      Description => "Fill level of VOQ in buffers selects between the 8 values for a given {Profile,BufferAvailableLevel} pair.
The MSB is mark indication in case of most full.
The LSB is mark indication in case of most empty.",
      Width => "8",
      Position => "7:0", # Excel Formula: =calc_position(F78,E79,TRUE)
      Type => "Config",
      UsedBy => "CGM_deq",
      DefaultValue => "h0",
    },
  },
  BuffersConsumptionLutForDeq39 => { #Structure Type: Reg; ArrayLength: 128; ArrayIndex: 39; ArrayLocationInName: 28;
    Name => "BuffersConsumptionLutForDeq[128]",
    RegMem => "Reg",
    Address => "166",
    Description => "LUT for dequeue marking in VOQ-CGM based on Buffer Consumption.
Index in Array is {Profile,BufferAvailableLevel}
Profile is 5 bits
BufferAvailableLevel is quantized to 2 bits.",
    Width => "8", # Excel Formula: =calc_reg_width(E79:E79,F79)
    Type => "Config",
    AdditionalInfo => "PackArrayToBus",
    Comments => "VOQ_CGM
CGM Deq Marking logic implemented in FF.
Address is {VOQ_PROFILE,Buffer_pool_available_level}
5 + 2 = 7
Buffer_voq_size_level selects offset out of 8.",
    ArrayLength => "128",
    ArrayIndex => "39",
    DeqBufferCongestionMark39 => { #Structure Type: RegField; ArrayLength: 128; ArrayIndex: 39; ArrayLocationInName: 24;
      Name => "DeqBufferCongestionMark[n]",
      RegMem => "RegField",
      Description => "Fill level of VOQ in buffers selects between the 8 values for a given {Profile,BufferAvailableLevel} pair.
The MSB is mark indication in case of most full.
The LSB is mark indication in case of most empty.",
      Width => "8",
      Position => "7:0", # Excel Formula: =calc_position(F78,E79,TRUE)
      Type => "Config",
      UsedBy => "CGM_deq",
      DefaultValue => "h0",
    },
  },
  BuffersConsumptionLutForDeq40 => { #Structure Type: Reg; ArrayLength: 128; ArrayIndex: 40; ArrayLocationInName: 28;
    Name => "BuffersConsumptionLutForDeq[128]",
    RegMem => "Reg",
    Address => "167",
    Description => "LUT for dequeue marking in VOQ-CGM based on Buffer Consumption.
Index in Array is {Profile,BufferAvailableLevel}
Profile is 5 bits
BufferAvailableLevel is quantized to 2 bits.",
    Width => "8", # Excel Formula: =calc_reg_width(E79:E79,F79)
    Type => "Config",
    AdditionalInfo => "PackArrayToBus",
    Comments => "VOQ_CGM
CGM Deq Marking logic implemented in FF.
Address is {VOQ_PROFILE,Buffer_pool_available_level}
5 + 2 = 7
Buffer_voq_size_level selects offset out of 8.",
    ArrayLength => "128",
    ArrayIndex => "40",
    DeqBufferCongestionMark40 => { #Structure Type: RegField; ArrayLength: 128; ArrayIndex: 40; ArrayLocationInName: 24;
      Name => "DeqBufferCongestionMark[n]",
      RegMem => "RegField",
      Description => "Fill level of VOQ in buffers selects between the 8 values for a given {Profile,BufferAvailableLevel} pair.
The MSB is mark indication in case of most full.
The LSB is mark indication in case of most empty.",
      Width => "8",
      Position => "7:0", # Excel Formula: =calc_position(F78,E79,TRUE)
      Type => "Config",
      UsedBy => "CGM_deq",
      DefaultValue => "h0",
    },
  },
  BuffersConsumptionLutForDeq41 => { #Structure Type: Reg; ArrayLength: 128; ArrayIndex: 41; ArrayLocationInName: 28;
    Name => "BuffersConsumptionLutForDeq[128]",
    RegMem => "Reg",
    Address => "168",
    Description => "LUT for dequeue marking in VOQ-CGM based on Buffer Consumption.
Index in Array is {Profile,BufferAvailableLevel}
Profile is 5 bits
BufferAvailableLevel is quantized to 2 bits.",
    Width => "8", # Excel Formula: =calc_reg_width(E79:E79,F79)
    Type => "Config",
    AdditionalInfo => "PackArrayToBus",
    Comments => "VOQ_CGM
CGM Deq Marking logic implemented in FF.
Address is {VOQ_PROFILE,Buffer_pool_available_level}
5 + 2 = 7
Buffer_voq_size_level selects offset out of 8.",
    ArrayLength => "128",
    ArrayIndex => "41",
    DeqBufferCongestionMark41 => { #Structure Type: RegField; ArrayLength: 128; ArrayIndex: 41; ArrayLocationInName: 24;
      Name => "DeqBufferCongestionMark[n]",
      RegMem => "RegField",
      Description => "Fill level of VOQ in buffers selects between the 8 values for a given {Profile,BufferAvailableLevel} pair.
The MSB is mark indication in case of most full.
The LSB is mark indication in case of most empty.",
      Width => "8",
      Position => "7:0", # Excel Formula: =calc_position(F78,E79,TRUE)
      Type => "Config",
      UsedBy => "CGM_deq",
      DefaultValue => "h0",
    },
  },
  BuffersConsumptionLutForDeq42 => { #Structure Type: Reg; ArrayLength: 128; ArrayIndex: 42; ArrayLocationInName: 28;
    Name => "BuffersConsumptionLutForDeq[128]",
    RegMem => "Reg",
    Address => "169",
    Description => "LUT for dequeue marking in VOQ-CGM based on Buffer Consumption.
Index in Array is {Profile,BufferAvailableLevel}
Profile is 5 bits
BufferAvailableLevel is quantized to 2 bits.",
    Width => "8", # Excel Formula: =calc_reg_width(E79:E79,F79)
    Type => "Config",
    AdditionalInfo => "PackArrayToBus",
    Comments => "VOQ_CGM
CGM Deq Marking logic implemented in FF.
Address is {VOQ_PROFILE,Buffer_pool_available_level}
5 + 2 = 7
Buffer_voq_size_level selects offset out of 8.",
    ArrayLength => "128",
    ArrayIndex => "42",
    DeqBufferCongestionMark42 => { #Structure Type: RegField; ArrayLength: 128; ArrayIndex: 42; ArrayLocationInName: 24;
      Name => "DeqBufferCongestionMark[n]",
      RegMem => "RegField",
      Description => "Fill level of VOQ in buffers selects between the 8 values for a given {Profile,BufferAvailableLevel} pair.
The MSB is mark indication in case of most full.
The LSB is mark indication in case of most empty.",
      Width => "8",
      Position => "7:0", # Excel Formula: =calc_position(F78,E79,TRUE)
      Type => "Config",
      UsedBy => "CGM_deq",
      DefaultValue => "h0",
    },
  },
  BuffersConsumptionLutForDeq43 => { #Structure Type: Reg; ArrayLength: 128; ArrayIndex: 43; ArrayLocationInName: 28;
    Name => "BuffersConsumptionLutForDeq[128]",
    RegMem => "Reg",
    Address => "16A",
    Description => "LUT for dequeue marking in VOQ-CGM based on Buffer Consumption.
Index in Array is {Profile,BufferAvailableLevel}
Profile is 5 bits
BufferAvailableLevel is quantized to 2 bits.",
    Width => "8", # Excel Formula: =calc_reg_width(E79:E79,F79)
    Type => "Config",
    AdditionalInfo => "PackArrayToBus",
    Comments => "VOQ_CGM
CGM Deq Marking logic implemented in FF.
Address is {VOQ_PROFILE,Buffer_pool_available_level}
5 + 2 = 7
Buffer_voq_size_level selects offset out of 8.",
    ArrayLength => "128",
    ArrayIndex => "43",
    DeqBufferCongestionMark43 => { #Structure Type: RegField; ArrayLength: 128; ArrayIndex: 43; ArrayLocationInName: 24;
      Name => "DeqBufferCongestionMark[n]",
      RegMem => "RegField",
      Description => "Fill level of VOQ in buffers selects between the 8 values for a given {Profile,BufferAvailableLevel} pair.
The MSB is mark indication in case of most full.
The LSB is mark indication in case of most empty.",
      Width => "8",
      Position => "7:0", # Excel Formula: =calc_position(F78,E79,TRUE)
      Type => "Config",
      UsedBy => "CGM_deq",
      DefaultValue => "h0",
    },
  },
  BuffersConsumptionLutForDeq44 => { #Structure Type: Reg; ArrayLength: 128; ArrayIndex: 44; ArrayLocationInName: 28;
    Name => "BuffersConsumptionLutForDeq[128]",
    RegMem => "Reg",
    Address => "16B",
    Description => "LUT for dequeue marking in VOQ-CGM based on Buffer Consumption.
Index in Array is {Profile,BufferAvailableLevel}
Profile is 5 bits
BufferAvailableLevel is quantized to 2 bits.",
    Width => "8", # Excel Formula: =calc_reg_width(E79:E79,F79)
    Type => "Config",
    AdditionalInfo => "PackArrayToBus",
    Comments => "VOQ_CGM
CGM Deq Marking logic implemented in FF.
Address is {VOQ_PROFILE,Buffer_pool_available_level}
5 + 2 = 7
Buffer_voq_size_level selects offset out of 8.",
    ArrayLength => "128",
    ArrayIndex => "44",
    DeqBufferCongestionMark44 => { #Structure Type: RegField; ArrayLength: 128; ArrayIndex: 44; ArrayLocationInName: 24;
      Name => "DeqBufferCongestionMark[n]",
      RegMem => "RegField",
      Description => "Fill level of VOQ in buffers selects between the 8 values for a given {Profile,BufferAvailableLevel} pair.
The MSB is mark indication in case of most full.
The LSB is mark indication in case of most empty.",
      Width => "8",
      Position => "7:0", # Excel Formula: =calc_position(F78,E79,TRUE)
      Type => "Config",
      UsedBy => "CGM_deq",
      DefaultValue => "h0",
    },
  },
  BuffersConsumptionLutForDeq45 => { #Structure Type: Reg; ArrayLength: 128; ArrayIndex: 45; ArrayLocationInName: 28;
    Name => "BuffersConsumptionLutForDeq[128]",
    RegMem => "Reg",
    Address => "16C",
    Description => "LUT for dequeue marking in VOQ-CGM based on Buffer Consumption.
Index in Array is {Profile,BufferAvailableLevel}
Profile is 5 bits
BufferAvailableLevel is quantized to 2 bits.",
    Width => "8", # Excel Formula: =calc_reg_width(E79:E79,F79)
    Type => "Config",
    AdditionalInfo => "PackArrayToBus",
    Comments => "VOQ_CGM
CGM Deq Marking logic implemented in FF.
Address is {VOQ_PROFILE,Buffer_pool_available_level}
5 + 2 = 7
Buffer_voq_size_level selects offset out of 8.",
    ArrayLength => "128",
    ArrayIndex => "45",
    DeqBufferCongestionMark45 => { #Structure Type: RegField; ArrayLength: 128; ArrayIndex: 45; ArrayLocationInName: 24;
      Name => "DeqBufferCongestionMark[n]",
      RegMem => "RegField",
      Description => "Fill level of VOQ in buffers selects between the 8 values for a given {Profile,BufferAvailableLevel} pair.
The MSB is mark indication in case of most full.
The LSB is mark indication in case of most empty.",
      Width => "8",
      Position => "7:0", # Excel Formula: =calc_position(F78,E79,TRUE)
      Type => "Config",
      UsedBy => "CGM_deq",
      DefaultValue => "h0",
    },
  },
  BuffersConsumptionLutForDeq46 => { #Structure Type: Reg; ArrayLength: 128; ArrayIndex: 46; ArrayLocationInName: 28;
    Name => "BuffersConsumptionLutForDeq[128]",
    RegMem => "Reg",
    Address => "16D",
    Description => "LUT for dequeue marking in VOQ-CGM based on Buffer Consumption.
Index in Array is {Profile,BufferAvailableLevel}
Profile is 5 bits
BufferAvailableLevel is quantized to 2 bits.",
    Width => "8", # Excel Formula: =calc_reg_width(E79:E79,F79)
    Type => "Config",
    AdditionalInfo => "PackArrayToBus",
    Comments => "VOQ_CGM
CGM Deq Marking logic implemented in FF.
Address is {VOQ_PROFILE,Buffer_pool_available_level}
5 + 2 = 7
Buffer_voq_size_level selects offset out of 8.",
    ArrayLength => "128",
    ArrayIndex => "46",
    DeqBufferCongestionMark46 => { #Structure Type: RegField; ArrayLength: 128; ArrayIndex: 46; ArrayLocationInName: 24;
      Name => "DeqBufferCongestionMark[n]",
      RegMem => "RegField",
      Description => "Fill level of VOQ in buffers selects between the 8 values for a given {Profile,BufferAvailableLevel} pair.
The MSB is mark indication in case of most full.
The LSB is mark indication in case of most empty.",
      Width => "8",
      Position => "7:0", # Excel Formula: =calc_position(F78,E79,TRUE)
      Type => "Config",
      UsedBy => "CGM_deq",
      DefaultValue => "h0",
    },
  },
  BuffersConsumptionLutForDeq47 => { #Structure Type: Reg; ArrayLength: 128; ArrayIndex: 47; ArrayLocationInName: 28;
    Name => "BuffersConsumptionLutForDeq[128]",
    RegMem => "Reg",
    Address => "16E",
    Description => "LUT for dequeue marking in VOQ-CGM based on Buffer Consumption.
Index in Array is {Profile,BufferAvailableLevel}
Profile is 5 bits
BufferAvailableLevel is quantized to 2 bits.",
    Width => "8", # Excel Formula: =calc_reg_width(E79:E79,F79)
    Type => "Config",
    AdditionalInfo => "PackArrayToBus",
    Comments => "VOQ_CGM
CGM Deq Marking logic implemented in FF.
Address is {VOQ_PROFILE,Buffer_pool_available_level}
5 + 2 = 7
Buffer_voq_size_level selects offset out of 8.",
    ArrayLength => "128",
    ArrayIndex => "47",
    DeqBufferCongestionMark47 => { #Structure Type: RegField; ArrayLength: 128; ArrayIndex: 47; ArrayLocationInName: 24;
      Name => "DeqBufferCongestionMark[n]",
      RegMem => "RegField",
      Description => "Fill level of VOQ in buffers selects between the 8 values for a given {Profile,BufferAvailableLevel} pair.
The MSB is mark indication in case of most full.
The LSB is mark indication in case of most empty.",
      Width => "8",
      Position => "7:0", # Excel Formula: =calc_position(F78,E79,TRUE)
      Type => "Config",
      UsedBy => "CGM_deq",
      DefaultValue => "h0",
    },
  },
  BuffersConsumptionLutForDeq48 => { #Structure Type: Reg; ArrayLength: 128; ArrayIndex: 48; ArrayLocationInName: 28;
    Name => "BuffersConsumptionLutForDeq[128]",
    RegMem => "Reg",
    Address => "16F",
    Description => "LUT for dequeue marking in VOQ-CGM based on Buffer Consumption.
Index in Array is {Profile,BufferAvailableLevel}
Profile is 5 bits
BufferAvailableLevel is quantized to 2 bits.",
    Width => "8", # Excel Formula: =calc_reg_width(E79:E79,F79)
    Type => "Config",
    AdditionalInfo => "PackArrayToBus",
    Comments => "VOQ_CGM
CGM Deq Marking logic implemented in FF.
Address is {VOQ_PROFILE,Buffer_pool_available_level}
5 + 2 = 7
Buffer_voq_size_level selects offset out of 8.",
    ArrayLength => "128",
    ArrayIndex => "48",
    DeqBufferCongestionMark48 => { #Structure Type: RegField; ArrayLength: 128; ArrayIndex: 48; ArrayLocationInName: 24;
      Name => "DeqBufferCongestionMark[n]",
      RegMem => "RegField",
      Description => "Fill level of VOQ in buffers selects between the 8 values for a given {Profile,BufferAvailableLevel} pair.
The MSB is mark indication in case of most full.
The LSB is mark indication in case of most empty.",
      Width => "8",
      Position => "7:0", # Excel Formula: =calc_position(F78,E79,TRUE)
      Type => "Config",
      UsedBy => "CGM_deq",
      DefaultValue => "h0",
    },
  },
  BuffersConsumptionLutForDeq49 => { #Structure Type: Reg; ArrayLength: 128; ArrayIndex: 49; ArrayLocationInName: 28;
    Name => "BuffersConsumptionLutForDeq[128]",
    RegMem => "Reg",
    Address => "170",
    Description => "LUT for dequeue marking in VOQ-CGM based on Buffer Consumption.
Index in Array is {Profile,BufferAvailableLevel}
Profile is 5 bits
BufferAvailableLevel is quantized to 2 bits.",
    Width => "8", # Excel Formula: =calc_reg_width(E79:E79,F79)
    Type => "Config",
    AdditionalInfo => "PackArrayToBus",
    Comments => "VOQ_CGM
CGM Deq Marking logic implemented in FF.
Address is {VOQ_PROFILE,Buffer_pool_available_level}
5 + 2 = 7
Buffer_voq_size_level selects offset out of 8.",
    ArrayLength => "128",
    ArrayIndex => "49",
    DeqBufferCongestionMark49 => { #Structure Type: RegField; ArrayLength: 128; ArrayIndex: 49; ArrayLocationInName: 24;
      Name => "DeqBufferCongestionMark[n]",
      RegMem => "RegField",
      Description => "Fill level of VOQ in buffers selects between the 8 values for a given {Profile,BufferAvailableLevel} pair.
The MSB is mark indication in case of most full.
The LSB is mark indication in case of most empty.",
      Width => "8",
      Position => "7:0", # Excel Formula: =calc_position(F78,E79,TRUE)
      Type => "Config",
      UsedBy => "CGM_deq",
      DefaultValue => "h0",
    },
  },
  BuffersConsumptionLutForDeq50 => { #Structure Type: Reg; ArrayLength: 128; ArrayIndex: 50; ArrayLocationInName: 28;
    Name => "BuffersConsumptionLutForDeq[128]",
    RegMem => "Reg",
    Address => "171",
    Description => "LUT for dequeue marking in VOQ-CGM based on Buffer Consumption.
Index in Array is {Profile,BufferAvailableLevel}
Profile is 5 bits
BufferAvailableLevel is quantized to 2 bits.",
    Width => "8", # Excel Formula: =calc_reg_width(E79:E79,F79)
    Type => "Config",
    AdditionalInfo => "PackArrayToBus",
    Comments => "VOQ_CGM
CGM Deq Marking logic implemented in FF.
Address is {VOQ_PROFILE,Buffer_pool_available_level}
5 + 2 = 7
Buffer_voq_size_level selects offset out of 8.",
    ArrayLength => "128",
    ArrayIndex => "50",
    DeqBufferCongestionMark50 => { #Structure Type: RegField; ArrayLength: 128; ArrayIndex: 50; ArrayLocationInName: 24;
      Name => "DeqBufferCongestionMark[n]",
      RegMem => "RegField",
      Description => "Fill level of VOQ in buffers selects between the 8 values for a given {Profile,BufferAvailableLevel} pair.
The MSB is mark indication in case of most full.
The LSB is mark indication in case of most empty.",
      Width => "8",
      Position => "7:0", # Excel Formula: =calc_position(F78,E79,TRUE)
      Type => "Config",
      UsedBy => "CGM_deq",
      DefaultValue => "h0",
    },
  },
  BuffersConsumptionLutForDeq51 => { #Structure Type: Reg; ArrayLength: 128; ArrayIndex: 51; ArrayLocationInName: 28;
    Name => "BuffersConsumptionLutForDeq[128]",
    RegMem => "Reg",
    Address => "172",
    Description => "LUT for dequeue marking in VOQ-CGM based on Buffer Consumption.
Index in Array is {Profile,BufferAvailableLevel}
Profile is 5 bits
BufferAvailableLevel is quantized to 2 bits.",
    Width => "8", # Excel Formula: =calc_reg_width(E79:E79,F79)
    Type => "Config",
    AdditionalInfo => "PackArrayToBus",
    Comments => "VOQ_CGM
CGM Deq Marking logic implemented in FF.
Address is {VOQ_PROFILE,Buffer_pool_available_level}
5 + 2 = 7
Buffer_voq_size_level selects offset out of 8.",
    ArrayLength => "128",
    ArrayIndex => "51",
    DeqBufferCongestionMark51 => { #Structure Type: RegField; ArrayLength: 128; ArrayIndex: 51; ArrayLocationInName: 24;
      Name => "DeqBufferCongestionMark[n]",
      RegMem => "RegField",
      Description => "Fill level of VOQ in buffers selects between the 8 values for a given {Profile,BufferAvailableLevel} pair.
The MSB is mark indication in case of most full.
The LSB is mark indication in case of most empty.",
      Width => "8",
      Position => "7:0", # Excel Formula: =calc_position(F78,E79,TRUE)
      Type => "Config",
      UsedBy => "CGM_deq",
      DefaultValue => "h0",
    },
  },
  BuffersConsumptionLutForDeq52 => { #Structure Type: Reg; ArrayLength: 128; ArrayIndex: 52; ArrayLocationInName: 28;
    Name => "BuffersConsumptionLutForDeq[128]",
    RegMem => "Reg",
    Address => "173",
    Description => "LUT for dequeue marking in VOQ-CGM based on Buffer Consumption.
Index in Array is {Profile,BufferAvailableLevel}
Profile is 5 bits
BufferAvailableLevel is quantized to 2 bits.",
    Width => "8", # Excel Formula: =calc_reg_width(E79:E79,F79)
    Type => "Config",
    AdditionalInfo => "PackArrayToBus",
    Comments => "VOQ_CGM
CGM Deq Marking logic implemented in FF.
Address is {VOQ_PROFILE,Buffer_pool_available_level}
5 + 2 = 7
Buffer_voq_size_level selects offset out of 8.",
    ArrayLength => "128",
    ArrayIndex => "52",
    DeqBufferCongestionMark52 => { #Structure Type: RegField; ArrayLength: 128; ArrayIndex: 52; ArrayLocationInName: 24;
      Name => "DeqBufferCongestionMark[n]",
      RegMem => "RegField",
      Description => "Fill level of VOQ in buffers selects between the 8 values for a given {Profile,BufferAvailableLevel} pair.
The MSB is mark indication in case of most full.
The LSB is mark indication in case of most empty.",
      Width => "8",
      Position => "7:0", # Excel Formula: =calc_position(F78,E79,TRUE)
      Type => "Config",
      UsedBy => "CGM_deq",
      DefaultValue => "h0",
    },
  },
  BuffersConsumptionLutForDeq53 => { #Structure Type: Reg; ArrayLength: 128; ArrayIndex: 53; ArrayLocationInName: 28;
    Name => "BuffersConsumptionLutForDeq[128]",
    RegMem => "Reg",
    Address => "174",
    Description => "LUT for dequeue marking in VOQ-CGM based on Buffer Consumption.
Index in Array is {Profile,BufferAvailableLevel}
Profile is 5 bits
BufferAvailableLevel is quantized to 2 bits.",
    Width => "8", # Excel Formula: =calc_reg_width(E79:E79,F79)
    Type => "Config",
    AdditionalInfo => "PackArrayToBus",
    Comments => "VOQ_CGM
CGM Deq Marking logic implemented in FF.
Address is {VOQ_PROFILE,Buffer_pool_available_level}
5 + 2 = 7
Buffer_voq_size_level selects offset out of 8.",
    ArrayLength => "128",
    ArrayIndex => "53",
    DeqBufferCongestionMark53 => { #Structure Type: RegField; ArrayLength: 128; ArrayIndex: 53; ArrayLocationInName: 24;
      Name => "DeqBufferCongestionMark[n]",
      RegMem => "RegField",
      Description => "Fill level of VOQ in buffers selects between the 8 values for a given {Profile,BufferAvailableLevel} pair.
The MSB is mark indication in case of most full.
The LSB is mark indication in case of most empty.",
      Width => "8",
      Position => "7:0", # Excel Formula: =calc_position(F78,E79,TRUE)
      Type => "Config",
      UsedBy => "CGM_deq",
      DefaultValue => "h0",
    },
  },
  BuffersConsumptionLutForDeq54 => { #Structure Type: Reg; ArrayLength: 128; ArrayIndex: 54; ArrayLocationInName: 28;
    Name => "BuffersConsumptionLutForDeq[128]",
    RegMem => "Reg",
    Address => "175",
    Description => "LUT for dequeue marking in VOQ-CGM based on Buffer Consumption.
Index in Array is {Profile,BufferAvailableLevel}
Profile is 5 bits
BufferAvailableLevel is quantized to 2 bits.",
    Width => "8", # Excel Formula: =calc_reg_width(E79:E79,F79)
    Type => "Config",
    AdditionalInfo => "PackArrayToBus",
    Comments => "VOQ_CGM
CGM Deq Marking logic implemented in FF.
Address is {VOQ_PROFILE,Buffer_pool_available_level}
5 + 2 = 7
Buffer_voq_size_level selects offset out of 8.",
    ArrayLength => "128",
    ArrayIndex => "54",
    DeqBufferCongestionMark54 => { #Structure Type: RegField; ArrayLength: 128; ArrayIndex: 54; ArrayLocationInName: 24;
      Name => "DeqBufferCongestionMark[n]",
      RegMem => "RegField",
      Description => "Fill level of VOQ in buffers selects between the 8 values for a given {Profile,BufferAvailableLevel} pair.
The MSB is mark indication in case of most full.
The LSB is mark indication in case of most empty.",
      Width => "8",
      Position => "7:0", # Excel Formula: =calc_position(F78,E79,TRUE)
      Type => "Config",
      UsedBy => "CGM_deq",
      DefaultValue => "h0",
    },
  },
  BuffersConsumptionLutForDeq55 => { #Structure Type: Reg; ArrayLength: 128; ArrayIndex: 55; ArrayLocationInName: 28;
    Name => "BuffersConsumptionLutForDeq[128]",
    RegMem => "Reg",
    Address => "176",
    Description => "LUT for dequeue marking in VOQ-CGM based on Buffer Consumption.
Index in Array is {Profile,BufferAvailableLevel}
Profile is 5 bits
BufferAvailableLevel is quantized to 2 bits.",
    Width => "8", # Excel Formula: =calc_reg_width(E79:E79,F79)
    Type => "Config",
    AdditionalInfo => "PackArrayToBus",
    Comments => "VOQ_CGM
CGM Deq Marking logic implemented in FF.
Address is {VOQ_PROFILE,Buffer_pool_available_level}
5 + 2 = 7
Buffer_voq_size_level selects offset out of 8.",
    ArrayLength => "128",
    ArrayIndex => "55",
    DeqBufferCongestionMark55 => { #Structure Type: RegField; ArrayLength: 128; ArrayIndex: 55; ArrayLocationInName: 24;
      Name => "DeqBufferCongestionMark[n]",
      RegMem => "RegField",
      Description => "Fill level of VOQ in buffers selects between the 8 values for a given {Profile,BufferAvailableLevel} pair.
The MSB is mark indication in case of most full.
The LSB is mark indication in case of most empty.",
      Width => "8",
      Position => "7:0", # Excel Formula: =calc_position(F78,E79,TRUE)
      Type => "Config",
      UsedBy => "CGM_deq",
      DefaultValue => "h0",
    },
  },
  BuffersConsumptionLutForDeq56 => { #Structure Type: Reg; ArrayLength: 128; ArrayIndex: 56; ArrayLocationInName: 28;
    Name => "BuffersConsumptionLutForDeq[128]",
    RegMem => "Reg",
    Address => "177",
    Description => "LUT for dequeue marking in VOQ-CGM based on Buffer Consumption.
Index in Array is {Profile,BufferAvailableLevel}
Profile is 5 bits
BufferAvailableLevel is quantized to 2 bits.",
    Width => "8", # Excel Formula: =calc_reg_width(E79:E79,F79)
    Type => "Config",
    AdditionalInfo => "PackArrayToBus",
    Comments => "VOQ_CGM
CGM Deq Marking logic implemented in FF.
Address is {VOQ_PROFILE,Buffer_pool_available_level}
5 + 2 = 7
Buffer_voq_size_level selects offset out of 8.",
    ArrayLength => "128",
    ArrayIndex => "56",
    DeqBufferCongestionMark56 => { #Structure Type: RegField; ArrayLength: 128; ArrayIndex: 56; ArrayLocationInName: 24;
      Name => "DeqBufferCongestionMark[n]",
      RegMem => "RegField",
      Description => "Fill level of VOQ in buffers selects between the 8 values for a given {Profile,BufferAvailableLevel} pair.
The MSB is mark indication in case of most full.
The LSB is mark indication in case of most empty.",
      Width => "8",
      Position => "7:0", # Excel Formula: =calc_position(F78,E79,TRUE)
      Type => "Config",
      UsedBy => "CGM_deq",
      DefaultValue => "h0",
    },
  },
  BuffersConsumptionLutForDeq57 => { #Structure Type: Reg; ArrayLength: 128; ArrayIndex: 57; ArrayLocationInName: 28;
    Name => "BuffersConsumptionLutForDeq[128]",
    RegMem => "Reg",
    Address => "178",
    Description => "LUT for dequeue marking in VOQ-CGM based on Buffer Consumption.
Index in Array is {Profile,BufferAvailableLevel}
Profile is 5 bits
BufferAvailableLevel is quantized to 2 bits.",
    Width => "8", # Excel Formula: =calc_reg_width(E79:E79,F79)
    Type => "Config",
    AdditionalInfo => "PackArrayToBus",
    Comments => "VOQ_CGM
CGM Deq Marking logic implemented in FF.
Address is {VOQ_PROFILE,Buffer_pool_available_level}
5 + 2 = 7
Buffer_voq_size_level selects offset out of 8.",
    ArrayLength => "128",
    ArrayIndex => "57",
    DeqBufferCongestionMark57 => { #Structure Type: RegField; ArrayLength: 128; ArrayIndex: 57; ArrayLocationInName: 24;
      Name => "DeqBufferCongestionMark[n]",
      RegMem => "RegField",
      Description => "Fill level of VOQ in buffers selects between the 8 values for a given {Profile,BufferAvailableLevel} pair.
The MSB is mark indication in case of most full.
The LSB is mark indication in case of most empty.",
      Width => "8",
      Position => "7:0", # Excel Formula: =calc_position(F78,E79,TRUE)
      Type => "Config",
      UsedBy => "CGM_deq",
      DefaultValue => "h0",
    },
  },
  BuffersConsumptionLutForDeq58 => { #Structure Type: Reg; ArrayLength: 128; ArrayIndex: 58; ArrayLocationInName: 28;
    Name => "BuffersConsumptionLutForDeq[128]",
    RegMem => "Reg",
    Address => "179",
    Description => "LUT for dequeue marking in VOQ-CGM based on Buffer Consumption.
Index in Array is {Profile,BufferAvailableLevel}
Profile is 5 bits
BufferAvailableLevel is quantized to 2 bits.",
    Width => "8", # Excel Formula: =calc_reg_width(E79:E79,F79)
    Type => "Config",
    AdditionalInfo => "PackArrayToBus",
    Comments => "VOQ_CGM
CGM Deq Marking logic implemented in FF.
Address is {VOQ_PROFILE,Buffer_pool_available_level}
5 + 2 = 7
Buffer_voq_size_level selects offset out of 8.",
    ArrayLength => "128",
    ArrayIndex => "58",
    DeqBufferCongestionMark58 => { #Structure Type: RegField; ArrayLength: 128; ArrayIndex: 58; ArrayLocationInName: 24;
      Name => "DeqBufferCongestionMark[n]",
      RegMem => "RegField",
      Description => "Fill level of VOQ in buffers selects between the 8 values for a given {Profile,BufferAvailableLevel} pair.
The MSB is mark indication in case of most full.
The LSB is mark indication in case of most empty.",
      Width => "8",
      Position => "7:0", # Excel Formula: =calc_position(F78,E79,TRUE)
      Type => "Config",
      UsedBy => "CGM_deq",
      DefaultValue => "h0",
    },
  },
  BuffersConsumptionLutForDeq59 => { #Structure Type: Reg; ArrayLength: 128; ArrayIndex: 59; ArrayLocationInName: 28;
    Name => "BuffersConsumptionLutForDeq[128]",
    RegMem => "Reg",
    Address => "17A",
    Description => "LUT for dequeue marking in VOQ-CGM based on Buffer Consumption.
Index in Array is {Profile,BufferAvailableLevel}
Profile is 5 bits
BufferAvailableLevel is quantized to 2 bits.",
    Width => "8", # Excel Formula: =calc_reg_width(E79:E79,F79)
    Type => "Config",
    AdditionalInfo => "PackArrayToBus",
    Comments => "VOQ_CGM
CGM Deq Marking logic implemented in FF.
Address is {VOQ_PROFILE,Buffer_pool_available_level}
5 + 2 = 7
Buffer_voq_size_level selects offset out of 8.",
    ArrayLength => "128",
    ArrayIndex => "59",
    DeqBufferCongestionMark59 => { #Structure Type: RegField; ArrayLength: 128; ArrayIndex: 59; ArrayLocationInName: 24;
      Name => "DeqBufferCongestionMark[n]",
      RegMem => "RegField",
      Description => "Fill level of VOQ in buffers selects between the 8 values for a given {Profile,BufferAvailableLevel} pair.
The MSB is mark indication in case of most full.
The LSB is mark indication in case of most empty.",
      Width => "8",
      Position => "7:0", # Excel Formula: =calc_position(F78,E79,TRUE)
      Type => "Config",
      UsedBy => "CGM_deq",
      DefaultValue => "h0",
    },
  },
  BuffersConsumptionLutForDeq60 => { #Structure Type: Reg; ArrayLength: 128; ArrayIndex: 60; ArrayLocationInName: 28;
    Name => "BuffersConsumptionLutForDeq[128]",
    RegMem => "Reg",
    Address => "17B",
    Description => "LUT for dequeue marking in VOQ-CGM based on Buffer Consumption.
Index in Array is {Profile,BufferAvailableLevel}
Profile is 5 bits
BufferAvailableLevel is quantized to 2 bits.",
    Width => "8", # Excel Formula: =calc_reg_width(E79:E79,F79)
    Type => "Config",
    AdditionalInfo => "PackArrayToBus",
    Comments => "VOQ_CGM
CGM Deq Marking logic implemented in FF.
Address is {VOQ_PROFILE,Buffer_pool_available_level}
5 + 2 = 7
Buffer_voq_size_level selects offset out of 8.",
    ArrayLength => "128",
    ArrayIndex => "60",
    DeqBufferCongestionMark60 => { #Structure Type: RegField; ArrayLength: 128; ArrayIndex: 60; ArrayLocationInName: 24;
      Name => "DeqBufferCongestionMark[n]",
      RegMem => "RegField",
      Description => "Fill level of VOQ in buffers selects between the 8 values for a given {Profile,BufferAvailableLevel} pair.
The MSB is mark indication in case of most full.
The LSB is mark indication in case of most empty.",
      Width => "8",
      Position => "7:0", # Excel Formula: =calc_position(F78,E79,TRUE)
      Type => "Config",
      UsedBy => "CGM_deq",
      DefaultValue => "h0",
    },
  },
  BuffersConsumptionLutForDeq61 => { #Structure Type: Reg; ArrayLength: 128; ArrayIndex: 61; ArrayLocationInName: 28;
    Name => "BuffersConsumptionLutForDeq[128]",
    RegMem => "Reg",
    Address => "17C",
    Description => "LUT for dequeue marking in VOQ-CGM based on Buffer Consumption.
Index in Array is {Profile,BufferAvailableLevel}
Profile is 5 bits
BufferAvailableLevel is quantized to 2 bits.",
    Width => "8", # Excel Formula: =calc_reg_width(E79:E79,F79)
    Type => "Config",
    AdditionalInfo => "PackArrayToBus",
    Comments => "VOQ_CGM
CGM Deq Marking logic implemented in FF.
Address is {VOQ_PROFILE,Buffer_pool_available_level}
5 + 2 = 7
Buffer_voq_size_level selects offset out of 8.",
    ArrayLength => "128",
    ArrayIndex => "61",
    DeqBufferCongestionMark61 => { #Structure Type: RegField; ArrayLength: 128; ArrayIndex: 61; ArrayLocationInName: 24;
      Name => "DeqBufferCongestionMark[n]",
      RegMem => "RegField",
      Description => "Fill level of VOQ in buffers selects between the 8 values for a given {Profile,BufferAvailableLevel} pair.
The MSB is mark indication in case of most full.
The LSB is mark indication in case of most empty.",
      Width => "8",
      Position => "7:0", # Excel Formula: =calc_position(F78,E79,TRUE)
      Type => "Config",
      UsedBy => "CGM_deq",
      DefaultValue => "h0",
    },
  },
  BuffersConsumptionLutForDeq62 => { #Structure Type: Reg; ArrayLength: 128; ArrayIndex: 62; ArrayLocationInName: 28;
    Name => "BuffersConsumptionLutForDeq[128]",
    RegMem => "Reg",
    Address => "17D",
    Description => "LUT for dequeue marking in VOQ-CGM based on Buffer Consumption.
Index in Array is {Profile,BufferAvailableLevel}
Profile is 5 bits
BufferAvailableLevel is quantized to 2 bits.",
    Width => "8", # Excel Formula: =calc_reg_width(E79:E79,F79)
    Type => "Config",
    AdditionalInfo => "PackArrayToBus",
    Comments => "VOQ_CGM
CGM Deq Marking logic implemented in FF.
Address is {VOQ_PROFILE,Buffer_pool_available_level}
5 + 2 = 7
Buffer_voq_size_level selects offset out of 8.",
    ArrayLength => "128",
    ArrayIndex => "62",
    DeqBufferCongestionMark62 => { #Structure Type: RegField; ArrayLength: 128; ArrayIndex: 62; ArrayLocationInName: 24;
      Name => "DeqBufferCongestionMark[n]",
      RegMem => "RegField",
      Description => "Fill level of VOQ in buffers selects between the 8 values for a given {Profile,BufferAvailableLevel} pair.
The MSB is mark indication in case of most full.
The LSB is mark indication in case of most empty.",
      Width => "8",
      Position => "7:0", # Excel Formula: =calc_position(F78,E79,TRUE)
      Type => "Config",
      UsedBy => "CGM_deq",
      DefaultValue => "h0",
    },
  },
  BuffersConsumptionLutForDeq63 => { #Structure Type: Reg; ArrayLength: 128; ArrayIndex: 63; ArrayLocationInName: 28;
    Name => "BuffersConsumptionLutForDeq[128]",
    RegMem => "Reg",
    Address => "17E",
    Description => "LUT for dequeue marking in VOQ-CGM based on Buffer Consumption.
Index in Array is {Profile,BufferAvailableLevel}
Profile is 5 bits
BufferAvailableLevel is quantized to 2 bits.",
    Width => "8", # Excel Formula: =calc_reg_width(E79:E79,F79)
    Type => "Config",
    AdditionalInfo => "PackArrayToBus",
    Comments => "VOQ_CGM
CGM Deq Marking logic implemented in FF.
Address is {VOQ_PROFILE,Buffer_pool_available_level}
5 + 2 = 7
Buffer_voq_size_level selects offset out of 8.",
    ArrayLength => "128",
    ArrayIndex => "63",
    DeqBufferCongestionMark63 => { #Structure Type: RegField; ArrayLength: 128; ArrayIndex: 63; ArrayLocationInName: 24;
      Name => "DeqBufferCongestionMark[n]",
      RegMem => "RegField",
      Description => "Fill level of VOQ in buffers selects between the 8 values for a given {Profile,BufferAvailableLevel} pair.
The MSB is mark indication in case of most full.
The LSB is mark indication in case of most empty.",
      Width => "8",
      Position => "7:0", # Excel Formula: =calc_position(F78,E79,TRUE)
      Type => "Config",
      UsedBy => "CGM_deq",
      DefaultValue => "h0",
    },
  },
  BuffersConsumptionLutForDeq64 => { #Structure Type: Reg; ArrayLength: 128; ArrayIndex: 64; ArrayLocationInName: 28;
    Name => "BuffersConsumptionLutForDeq[128]",
    RegMem => "Reg",
    Address => "17F",
    Description => "LUT for dequeue marking in VOQ-CGM based on Buffer Consumption.
Index in Array is {Profile,BufferAvailableLevel}
Profile is 5 bits
BufferAvailableLevel is quantized to 2 bits.",
    Width => "8", # Excel Formula: =calc_reg_width(E79:E79,F79)
    Type => "Config",
    AdditionalInfo => "PackArrayToBus",
    Comments => "VOQ_CGM
CGM Deq Marking logic implemented in FF.
Address is {VOQ_PROFILE,Buffer_pool_available_level}
5 + 2 = 7
Buffer_voq_size_level selects offset out of 8.",
    ArrayLength => "128",
    ArrayIndex => "64",
    DeqBufferCongestionMark64 => { #Structure Type: RegField; ArrayLength: 128; ArrayIndex: 64; ArrayLocationInName: 24;
      Name => "DeqBufferCongestionMark[n]",
      RegMem => "RegField",
      Description => "Fill level of VOQ in buffers selects between the 8 values for a given {Profile,BufferAvailableLevel} pair.
The MSB is mark indication in case of most full.
The LSB is mark indication in case of most empty.",
      Width => "8",
      Position => "7:0", # Excel Formula: =calc_position(F78,E79,TRUE)
      Type => "Config",
      UsedBy => "CGM_deq",
      DefaultValue => "h0",
    },
  },
  BuffersConsumptionLutForDeq65 => { #Structure Type: Reg; ArrayLength: 128; ArrayIndex: 65; ArrayLocationInName: 28;
    Name => "BuffersConsumptionLutForDeq[128]",
    RegMem => "Reg",
    Address => "180",
    Description => "LUT for dequeue marking in VOQ-CGM based on Buffer Consumption.
Index in Array is {Profile,BufferAvailableLevel}
Profile is 5 bits
BufferAvailableLevel is quantized to 2 bits.",
    Width => "8", # Excel Formula: =calc_reg_width(E79:E79,F79)
    Type => "Config",
    AdditionalInfo => "PackArrayToBus",
    Comments => "VOQ_CGM
CGM Deq Marking logic implemented in FF.
Address is {VOQ_PROFILE,Buffer_pool_available_level}
5 + 2 = 7
Buffer_voq_size_level selects offset out of 8.",
    ArrayLength => "128",
    ArrayIndex => "65",
    DeqBufferCongestionMark65 => { #Structure Type: RegField; ArrayLength: 128; ArrayIndex: 65; ArrayLocationInName: 24;
      Name => "DeqBufferCongestionMark[n]",
      RegMem => "RegField",
      Description => "Fill level of VOQ in buffers selects between the 8 values for a given {Profile,BufferAvailableLevel} pair.
The MSB is mark indication in case of most full.
The LSB is mark indication in case of most empty.",
      Width => "8",
      Position => "7:0", # Excel Formula: =calc_position(F78,E79,TRUE)
      Type => "Config",
      UsedBy => "CGM_deq",
      DefaultValue => "h0",
    },
  },
  BuffersConsumptionLutForDeq66 => { #Structure Type: Reg; ArrayLength: 128; ArrayIndex: 66; ArrayLocationInName: 28;
    Name => "BuffersConsumptionLutForDeq[128]",
    RegMem => "Reg",
    Address => "181",
    Description => "LUT for dequeue marking in VOQ-CGM based on Buffer Consumption.
Index in Array is {Profile,BufferAvailableLevel}
Profile is 5 bits
BufferAvailableLevel is quantized to 2 bits.",
    Width => "8", # Excel Formula: =calc_reg_width(E79:E79,F79)
    Type => "Config",
    AdditionalInfo => "PackArrayToBus",
    Comments => "VOQ_CGM
CGM Deq Marking logic implemented in FF.
Address is {VOQ_PROFILE,Buffer_pool_available_level}
5 + 2 = 7
Buffer_voq_size_level selects offset out of 8.",
    ArrayLength => "128",
    ArrayIndex => "66",
    DeqBufferCongestionMark66 => { #Structure Type: RegField; ArrayLength: 128; ArrayIndex: 66; ArrayLocationInName: 24;
      Name => "DeqBufferCongestionMark[n]",
      RegMem => "RegField",
      Description => "Fill level of VOQ in buffers selects between the 8 values for a given {Profile,BufferAvailableLevel} pair.
The MSB is mark indication in case of most full.
The LSB is mark indication in case of most empty.",
      Width => "8",
      Position => "7:0", # Excel Formula: =calc_position(F78,E79,TRUE)
      Type => "Config",
      UsedBy => "CGM_deq",
      DefaultValue => "h0",
    },
  },
  BuffersConsumptionLutForDeq67 => { #Structure Type: Reg; ArrayLength: 128; ArrayIndex: 67; ArrayLocationInName: 28;
    Name => "BuffersConsumptionLutForDeq[128]",
    RegMem => "Reg",
    Address => "182",
    Description => "LUT for dequeue marking in VOQ-CGM based on Buffer Consumption.
Index in Array is {Profile,BufferAvailableLevel}
Profile is 5 bits
BufferAvailableLevel is quantized to 2 bits.",
    Width => "8", # Excel Formula: =calc_reg_width(E79:E79,F79)
    Type => "Config",
    AdditionalInfo => "PackArrayToBus",
    Comments => "VOQ_CGM
CGM Deq Marking logic implemented in FF.
Address is {VOQ_PROFILE,Buffer_pool_available_level}
5 + 2 = 7
Buffer_voq_size_level selects offset out of 8.",
    ArrayLength => "128",
    ArrayIndex => "67",
    DeqBufferCongestionMark67 => { #Structure Type: RegField; ArrayLength: 128; ArrayIndex: 67; ArrayLocationInName: 24;
      Name => "DeqBufferCongestionMark[n]",
      RegMem => "RegField",
      Description => "Fill level of VOQ in buffers selects between the 8 values for a given {Profile,BufferAvailableLevel} pair.
The MSB is mark indication in case of most full.
The LSB is mark indication in case of most empty.",
      Width => "8",
      Position => "7:0", # Excel Formula: =calc_position(F78,E79,TRUE)
      Type => "Config",
      UsedBy => "CGM_deq",
      DefaultValue => "h0",
    },
  },
  BuffersConsumptionLutForDeq68 => { #Structure Type: Reg; ArrayLength: 128; ArrayIndex: 68; ArrayLocationInName: 28;
    Name => "BuffersConsumptionLutForDeq[128]",
    RegMem => "Reg",
    Address => "183",
    Description => "LUT for dequeue marking in VOQ-CGM based on Buffer Consumption.
Index in Array is {Profile,BufferAvailableLevel}
Profile is 5 bits
BufferAvailableLevel is quantized to 2 bits.",
    Width => "8", # Excel Formula: =calc_reg_width(E79:E79,F79)
    Type => "Config",
    AdditionalInfo => "PackArrayToBus",
    Comments => "VOQ_CGM
CGM Deq Marking logic implemented in FF.
Address is {VOQ_PROFILE,Buffer_pool_available_level}
5 + 2 = 7
Buffer_voq_size_level selects offset out of 8.",
    ArrayLength => "128",
    ArrayIndex => "68",
    DeqBufferCongestionMark68 => { #Structure Type: RegField; ArrayLength: 128; ArrayIndex: 68; ArrayLocationInName: 24;
      Name => "DeqBufferCongestionMark[n]",
      RegMem => "RegField",
      Description => "Fill level of VOQ in buffers selects between the 8 values for a given {Profile,BufferAvailableLevel} pair.
The MSB is mark indication in case of most full.
The LSB is mark indication in case of most empty.",
      Width => "8",
      Position => "7:0", # Excel Formula: =calc_position(F78,E79,TRUE)
      Type => "Config",
      UsedBy => "CGM_deq",
      DefaultValue => "h0",
    },
  },
  BuffersConsumptionLutForDeq69 => { #Structure Type: Reg; ArrayLength: 128; ArrayIndex: 69; ArrayLocationInName: 28;
    Name => "BuffersConsumptionLutForDeq[128]",
    RegMem => "Reg",
    Address => "184",
    Description => "LUT for dequeue marking in VOQ-CGM based on Buffer Consumption.
Index in Array is {Profile,BufferAvailableLevel}
Profile is 5 bits
BufferAvailableLevel is quantized to 2 bits.",
    Width => "8", # Excel Formula: =calc_reg_width(E79:E79,F79)
    Type => "Config",
    AdditionalInfo => "PackArrayToBus",
    Comments => "VOQ_CGM
CGM Deq Marking logic implemented in FF.
Address is {VOQ_PROFILE,Buffer_pool_available_level}
5 + 2 = 7
Buffer_voq_size_level selects offset out of 8.",
    ArrayLength => "128",
    ArrayIndex => "69",
    DeqBufferCongestionMark69 => { #Structure Type: RegField; ArrayLength: 128; ArrayIndex: 69; ArrayLocationInName: 24;
      Name => "DeqBufferCongestionMark[n]",
      RegMem => "RegField",
      Description => "Fill level of VOQ in buffers selects between the 8 values for a given {Profile,BufferAvailableLevel} pair.
The MSB is mark indication in case of most full.
The LSB is mark indication in case of most empty.",
      Width => "8",
      Position => "7:0", # Excel Formula: =calc_position(F78,E79,TRUE)
      Type => "Config",
      UsedBy => "CGM_deq",
      DefaultValue => "h0",
    },
  },
  BuffersConsumptionLutForDeq70 => { #Structure Type: Reg; ArrayLength: 128; ArrayIndex: 70; ArrayLocationInName: 28;
    Name => "BuffersConsumptionLutForDeq[128]",
    RegMem => "Reg",
    Address => "185",
    Description => "LUT for dequeue marking in VOQ-CGM based on Buffer Consumption.
Index in Array is {Profile,BufferAvailableLevel}
Profile is 5 bits
BufferAvailableLevel is quantized to 2 bits.",
    Width => "8", # Excel Formula: =calc_reg_width(E79:E79,F79)
    Type => "Config",
    AdditionalInfo => "PackArrayToBus",
    Comments => "VOQ_CGM
CGM Deq Marking logic implemented in FF.
Address is {VOQ_PROFILE,Buffer_pool_available_level}
5 + 2 = 7
Buffer_voq_size_level selects offset out of 8.",
    ArrayLength => "128",
    ArrayIndex => "70",
    DeqBufferCongestionMark70 => { #Structure Type: RegField; ArrayLength: 128; ArrayIndex: 70; ArrayLocationInName: 24;
      Name => "DeqBufferCongestionMark[n]",
      RegMem => "RegField",
      Description => "Fill level of VOQ in buffers selects between the 8 values for a given {Profile,BufferAvailableLevel} pair.
The MSB is mark indication in case of most full.
The LSB is mark indication in case of most empty.",
      Width => "8",
      Position => "7:0", # Excel Formula: =calc_position(F78,E79,TRUE)
      Type => "Config",
      UsedBy => "CGM_deq",
      DefaultValue => "h0",
    },
  },
  BuffersConsumptionLutForDeq71 => { #Structure Type: Reg; ArrayLength: 128; ArrayIndex: 71; ArrayLocationInName: 28;
    Name => "BuffersConsumptionLutForDeq[128]",
    RegMem => "Reg",
    Address => "186",
    Description => "LUT for dequeue marking in VOQ-CGM based on Buffer Consumption.
Index in Array is {Profile,BufferAvailableLevel}
Profile is 5 bits
BufferAvailableLevel is quantized to 2 bits.",
    Width => "8", # Excel Formula: =calc_reg_width(E79:E79,F79)
    Type => "Config",
    AdditionalInfo => "PackArrayToBus",
    Comments => "VOQ_CGM
CGM Deq Marking logic implemented in FF.
Address is {VOQ_PROFILE,Buffer_pool_available_level}
5 + 2 = 7
Buffer_voq_size_level selects offset out of 8.",
    ArrayLength => "128",
    ArrayIndex => "71",
    DeqBufferCongestionMark71 => { #Structure Type: RegField; ArrayLength: 128; ArrayIndex: 71; ArrayLocationInName: 24;
      Name => "DeqBufferCongestionMark[n]",
      RegMem => "RegField",
      Description => "Fill level of VOQ in buffers selects between the 8 values for a given {Profile,BufferAvailableLevel} pair.
The MSB is mark indication in case of most full.
The LSB is mark indication in case of most empty.",
      Width => "8",
      Position => "7:0", # Excel Formula: =calc_position(F78,E79,TRUE)
      Type => "Config",
      UsedBy => "CGM_deq",
      DefaultValue => "h0",
    },
  },
  BuffersConsumptionLutForDeq72 => { #Structure Type: Reg; ArrayLength: 128; ArrayIndex: 72; ArrayLocationInName: 28;
    Name => "BuffersConsumptionLutForDeq[128]",
    RegMem => "Reg",
    Address => "187",
    Description => "LUT for dequeue marking in VOQ-CGM based on Buffer Consumption.
Index in Array is {Profile,BufferAvailableLevel}
Profile is 5 bits
BufferAvailableLevel is quantized to 2 bits.",
    Width => "8", # Excel Formula: =calc_reg_width(E79:E79,F79)
    Type => "Config",
    AdditionalInfo => "PackArrayToBus",
    Comments => "VOQ_CGM
CGM Deq Marking logic implemented in FF.
Address is {VOQ_PROFILE,Buffer_pool_available_level}
5 + 2 = 7
Buffer_voq_size_level selects offset out of 8.",
    ArrayLength => "128",
    ArrayIndex => "72",
    DeqBufferCongestionMark72 => { #Structure Type: RegField; ArrayLength: 128; ArrayIndex: 72; ArrayLocationInName: 24;
      Name => "DeqBufferCongestionMark[n]",
      RegMem => "RegField",
      Description => "Fill level of VOQ in buffers selects between the 8 values for a given {Profile,BufferAvailableLevel} pair.
The MSB is mark indication in case of most full.
The LSB is mark indication in case of most empty.",
      Width => "8",
      Position => "7:0", # Excel Formula: =calc_position(F78,E79,TRUE)
      Type => "Config",
      UsedBy => "CGM_deq",
      DefaultValue => "h0",
    },
  },
  BuffersConsumptionLutForDeq73 => { #Structure Type: Reg; ArrayLength: 128; ArrayIndex: 73; ArrayLocationInName: 28;
    Name => "BuffersConsumptionLutForDeq[128]",
    RegMem => "Reg",
    Address => "188",
    Description => "LUT for dequeue marking in VOQ-CGM based on Buffer Consumption.
Index in Array is {Profile,BufferAvailableLevel}
Profile is 5 bits
BufferAvailableLevel is quantized to 2 bits.",
    Width => "8", # Excel Formula: =calc_reg_width(E79:E79,F79)
    Type => "Config",
    AdditionalInfo => "PackArrayToBus",
    Comments => "VOQ_CGM
CGM Deq Marking logic implemented in FF.
Address is {VOQ_PROFILE,Buffer_pool_available_level}
5 + 2 = 7
Buffer_voq_size_level selects offset out of 8.",
    ArrayLength => "128",
    ArrayIndex => "73",
    DeqBufferCongestionMark73 => { #Structure Type: RegField; ArrayLength: 128; ArrayIndex: 73; ArrayLocationInName: 24;
      Name => "DeqBufferCongestionMark[n]",
      RegMem => "RegField",
      Description => "Fill level of VOQ in buffers selects between the 8 values for a given {Profile,BufferAvailableLevel} pair.
The MSB is mark indication in case of most full.
The LSB is mark indication in case of most empty.",
      Width => "8",
      Position => "7:0", # Excel Formula: =calc_position(F78,E79,TRUE)
      Type => "Config",
      UsedBy => "CGM_deq",
      DefaultValue => "h0",
    },
  },
  BuffersConsumptionLutForDeq74 => { #Structure Type: Reg; ArrayLength: 128; ArrayIndex: 74; ArrayLocationInName: 28;
    Name => "BuffersConsumptionLutForDeq[128]",
    RegMem => "Reg",
    Address => "189",
    Description => "LUT for dequeue marking in VOQ-CGM based on Buffer Consumption.
Index in Array is {Profile,BufferAvailableLevel}
Profile is 5 bits
BufferAvailableLevel is quantized to 2 bits.",
    Width => "8", # Excel Formula: =calc_reg_width(E79:E79,F79)
    Type => "Config",
    AdditionalInfo => "PackArrayToBus",
    Comments => "VOQ_CGM
CGM Deq Marking logic implemented in FF.
Address is {VOQ_PROFILE,Buffer_pool_available_level}
5 + 2 = 7
Buffer_voq_size_level selects offset out of 8.",
    ArrayLength => "128",
    ArrayIndex => "74",
    DeqBufferCongestionMark74 => { #Structure Type: RegField; ArrayLength: 128; ArrayIndex: 74; ArrayLocationInName: 24;
      Name => "DeqBufferCongestionMark[n]",
      RegMem => "RegField",
      Description => "Fill level of VOQ in buffers selects between the 8 values for a given {Profile,BufferAvailableLevel} pair.
The MSB is mark indication in case of most full.
The LSB is mark indication in case of most empty.",
      Width => "8",
      Position => "7:0", # Excel Formula: =calc_position(F78,E79,TRUE)
      Type => "Config",
      UsedBy => "CGM_deq",
      DefaultValue => "h0",
    },
  },
  BuffersConsumptionLutForDeq75 => { #Structure Type: Reg; ArrayLength: 128; ArrayIndex: 75; ArrayLocationInName: 28;
    Name => "BuffersConsumptionLutForDeq[128]",
    RegMem => "Reg",
    Address => "18A",
    Description => "LUT for dequeue marking in VOQ-CGM based on Buffer Consumption.
Index in Array is {Profile,BufferAvailableLevel}
Profile is 5 bits
BufferAvailableLevel is quantized to 2 bits.",
    Width => "8", # Excel Formula: =calc_reg_width(E79:E79,F79)
    Type => "Config",
    AdditionalInfo => "PackArrayToBus",
    Comments => "VOQ_CGM
CGM Deq Marking logic implemented in FF.
Address is {VOQ_PROFILE,Buffer_pool_available_level}
5 + 2 = 7
Buffer_voq_size_level selects offset out of 8.",
    ArrayLength => "128",
    ArrayIndex => "75",
    DeqBufferCongestionMark75 => { #Structure Type: RegField; ArrayLength: 128; ArrayIndex: 75; ArrayLocationInName: 24;
      Name => "DeqBufferCongestionMark[n]",
      RegMem => "RegField",
      Description => "Fill level of VOQ in buffers selects between the 8 values for a given {Profile,BufferAvailableLevel} pair.
The MSB is mark indication in case of most full.
The LSB is mark indication in case of most empty.",
      Width => "8",
      Position => "7:0", # Excel Formula: =calc_position(F78,E79,TRUE)
      Type => "Config",
      UsedBy => "CGM_deq",
      DefaultValue => "h0",
    },
  },
  BuffersConsumptionLutForDeq76 => { #Structure Type: Reg; ArrayLength: 128; ArrayIndex: 76; ArrayLocationInName: 28;
    Name => "BuffersConsumptionLutForDeq[128]",
    RegMem => "Reg",
    Address => "18B",
    Description => "LUT for dequeue marking in VOQ-CGM based on Buffer Consumption.
Index in Array is {Profile,BufferAvailableLevel}
Profile is 5 bits
BufferAvailableLevel is quantized to 2 bits.",
    Width => "8", # Excel Formula: =calc_reg_width(E79:E79,F79)
    Type => "Config",
    AdditionalInfo => "PackArrayToBus",
    Comments => "VOQ_CGM
CGM Deq Marking logic implemented in FF.
Address is {VOQ_PROFILE,Buffer_pool_available_level}
5 + 2 = 7
Buffer_voq_size_level selects offset out of 8.",
    ArrayLength => "128",
    ArrayIndex => "76",
    DeqBufferCongestionMark76 => { #Structure Type: RegField; ArrayLength: 128; ArrayIndex: 76; ArrayLocationInName: 24;
      Name => "DeqBufferCongestionMark[n]",
      RegMem => "RegField",
      Description => "Fill level of VOQ in buffers selects between the 8 values for a given {Profile,BufferAvailableLevel} pair.
The MSB is mark indication in case of most full.
The LSB is mark indication in case of most empty.",
      Width => "8",
      Position => "7:0", # Excel Formula: =calc_position(F78,E79,TRUE)
      Type => "Config",
      UsedBy => "CGM_deq",
      DefaultValue => "h0",
    },
  },
  BuffersConsumptionLutForDeq77 => { #Structure Type: Reg; ArrayLength: 128; ArrayIndex: 77; ArrayLocationInName: 28;
    Name => "BuffersConsumptionLutForDeq[128]",
    RegMem => "Reg",
    Address => "18C",
    Description => "LUT for dequeue marking in VOQ-CGM based on Buffer Consumption.
Index in Array is {Profile,BufferAvailableLevel}
Profile is 5 bits
BufferAvailableLevel is quantized to 2 bits.",
    Width => "8", # Excel Formula: =calc_reg_width(E79:E79,F79)
    Type => "Config",
    AdditionalInfo => "PackArrayToBus",
    Comments => "VOQ_CGM
CGM Deq Marking logic implemented in FF.
Address is {VOQ_PROFILE,Buffer_pool_available_level}
5 + 2 = 7
Buffer_voq_size_level selects offset out of 8.",
    ArrayLength => "128",
    ArrayIndex => "77",
    DeqBufferCongestionMark77 => { #Structure Type: RegField; ArrayLength: 128; ArrayIndex: 77; ArrayLocationInName: 24;
      Name => "DeqBufferCongestionMark[n]",
      RegMem => "RegField",
      Description => "Fill level of VOQ in buffers selects between the 8 values for a given {Profile,BufferAvailableLevel} pair.
The MSB is mark indication in case of most full.
The LSB is mark indication in case of most empty.",
      Width => "8",
      Position => "7:0", # Excel Formula: =calc_position(F78,E79,TRUE)
      Type => "Config",
      UsedBy => "CGM_deq",
      DefaultValue => "h0",
    },
  },
  BuffersConsumptionLutForDeq78 => { #Structure Type: Reg; ArrayLength: 128; ArrayIndex: 78; ArrayLocationInName: 28;
    Name => "BuffersConsumptionLutForDeq[128]",
    RegMem => "Reg",
    Address => "18D",
    Description => "LUT for dequeue marking in VOQ-CGM based on Buffer Consumption.
Index in Array is {Profile,BufferAvailableLevel}
Profile is 5 bits
BufferAvailableLevel is quantized to 2 bits.",
    Width => "8", # Excel Formula: =calc_reg_width(E79:E79,F79)
    Type => "Config",
    AdditionalInfo => "PackArrayToBus",
    Comments => "VOQ_CGM
CGM Deq Marking logic implemented in FF.
Address is {VOQ_PROFILE,Buffer_pool_available_level}
5 + 2 = 7
Buffer_voq_size_level selects offset out of 8.",
    ArrayLength => "128",
    ArrayIndex => "78",
    DeqBufferCongestionMark78 => { #Structure Type: RegField; ArrayLength: 128; ArrayIndex: 78; ArrayLocationInName: 24;
      Name => "DeqBufferCongestionMark[n]",
      RegMem => "RegField",
      Description => "Fill level of VOQ in buffers selects between the 8 values for a given {Profile,BufferAvailableLevel} pair.
The MSB is mark indication in case of most full.
The LSB is mark indication in case of most empty.",
      Width => "8",
      Position => "7:0", # Excel Formula: =calc_position(F78,E79,TRUE)
      Type => "Config",
      UsedBy => "CGM_deq",
      DefaultValue => "h0",
    },
  },
  BuffersConsumptionLutForDeq79 => { #Structure Type: Reg; ArrayLength: 128; ArrayIndex: 79; ArrayLocationInName: 28;
    Name => "BuffersConsumptionLutForDeq[128]",
    RegMem => "Reg",
    Address => "18E",
    Description => "LUT for dequeue marking in VOQ-CGM based on Buffer Consumption.
Index in Array is {Profile,BufferAvailableLevel}
Profile is 5 bits
BufferAvailableLevel is quantized to 2 bits.",
    Width => "8", # Excel Formula: =calc_reg_width(E79:E79,F79)
    Type => "Config",
    AdditionalInfo => "PackArrayToBus",
    Comments => "VOQ_CGM
CGM Deq Marking logic implemented in FF.
Address is {VOQ_PROFILE,Buffer_pool_available_level}
5 + 2 = 7
Buffer_voq_size_level selects offset out of 8.",
    ArrayLength => "128",
    ArrayIndex => "79",
    DeqBufferCongestionMark79 => { #Structure Type: RegField; ArrayLength: 128; ArrayIndex: 79; ArrayLocationInName: 24;
      Name => "DeqBufferCongestionMark[n]",
      RegMem => "RegField",
      Description => "Fill level of VOQ in buffers selects between the 8 values for a given {Profile,BufferAvailableLevel} pair.
The MSB is mark indication in case of most full.
The LSB is mark indication in case of most empty.",
      Width => "8",
      Position => "7:0", # Excel Formula: =calc_position(F78,E79,TRUE)
      Type => "Config",
      UsedBy => "CGM_deq",
      DefaultValue => "h0",
    },
  },
  BuffersConsumptionLutForDeq80 => { #Structure Type: Reg; ArrayLength: 128; ArrayIndex: 80; ArrayLocationInName: 28;
    Name => "BuffersConsumptionLutForDeq[128]",
    RegMem => "Reg",
    Address => "18F",
    Description => "LUT for dequeue marking in VOQ-CGM based on Buffer Consumption.
Index in Array is {Profile,BufferAvailableLevel}
Profile is 5 bits
BufferAvailableLevel is quantized to 2 bits.",
    Width => "8", # Excel Formula: =calc_reg_width(E79:E79,F79)
    Type => "Config",
    AdditionalInfo => "PackArrayToBus",
    Comments => "VOQ_CGM
CGM Deq Marking logic implemented in FF.
Address is {VOQ_PROFILE,Buffer_pool_available_level}
5 + 2 = 7
Buffer_voq_size_level selects offset out of 8.",
    ArrayLength => "128",
    ArrayIndex => "80",
    DeqBufferCongestionMark80 => { #Structure Type: RegField; ArrayLength: 128; ArrayIndex: 80; ArrayLocationInName: 24;
      Name => "DeqBufferCongestionMark[n]",
      RegMem => "RegField",
      Description => "Fill level of VOQ in buffers selects between the 8 values for a given {Profile,BufferAvailableLevel} pair.
The MSB is mark indication in case of most full.
The LSB is mark indication in case of most empty.",
      Width => "8",
      Position => "7:0", # Excel Formula: =calc_position(F78,E79,TRUE)
      Type => "Config",
      UsedBy => "CGM_deq",
      DefaultValue => "h0",
    },
  },
  BuffersConsumptionLutForDeq81 => { #Structure Type: Reg; ArrayLength: 128; ArrayIndex: 81; ArrayLocationInName: 28;
    Name => "BuffersConsumptionLutForDeq[128]",
    RegMem => "Reg",
    Address => "190",
    Description => "LUT for dequeue marking in VOQ-CGM based on Buffer Consumption.
Index in Array is {Profile,BufferAvailableLevel}
Profile is 5 bits
BufferAvailableLevel is quantized to 2 bits.",
    Width => "8", # Excel Formula: =calc_reg_width(E79:E79,F79)
    Type => "Config",
    AdditionalInfo => "PackArrayToBus",
    Comments => "VOQ_CGM
CGM Deq Marking logic implemented in FF.
Address is {VOQ_PROFILE,Buffer_pool_available_level}
5 + 2 = 7
Buffer_voq_size_level selects offset out of 8.",
    ArrayLength => "128",
    ArrayIndex => "81",
    DeqBufferCongestionMark81 => { #Structure Type: RegField; ArrayLength: 128; ArrayIndex: 81; ArrayLocationInName: 24;
      Name => "DeqBufferCongestionMark[n]",
      RegMem => "RegField",
      Description => "Fill level of VOQ in buffers selects between the 8 values for a given {Profile,BufferAvailableLevel} pair.
The MSB is mark indication in case of most full.
The LSB is mark indication in case of most empty.",
      Width => "8",
      Position => "7:0", # Excel Formula: =calc_position(F78,E79,TRUE)
      Type => "Config",
      UsedBy => "CGM_deq",
      DefaultValue => "h0",
    },
  },
  BuffersConsumptionLutForDeq82 => { #Structure Type: Reg; ArrayLength: 128; ArrayIndex: 82; ArrayLocationInName: 28;
    Name => "BuffersConsumptionLutForDeq[128]",
    RegMem => "Reg",
    Address => "191",
    Description => "LUT for dequeue marking in VOQ-CGM based on Buffer Consumption.
Index in Array is {Profile,BufferAvailableLevel}
Profile is 5 bits
BufferAvailableLevel is quantized to 2 bits.",
    Width => "8", # Excel Formula: =calc_reg_width(E79:E79,F79)
    Type => "Config",
    AdditionalInfo => "PackArrayToBus",
    Comments => "VOQ_CGM
CGM Deq Marking logic implemented in FF.
Address is {VOQ_PROFILE,Buffer_pool_available_level}
5 + 2 = 7
Buffer_voq_size_level selects offset out of 8.",
    ArrayLength => "128",
    ArrayIndex => "82",
    DeqBufferCongestionMark82 => { #Structure Type: RegField; ArrayLength: 128; ArrayIndex: 82; ArrayLocationInName: 24;
      Name => "DeqBufferCongestionMark[n]",
      RegMem => "RegField",
      Description => "Fill level of VOQ in buffers selects between the 8 values for a given {Profile,BufferAvailableLevel} pair.
The MSB is mark indication in case of most full.
The LSB is mark indication in case of most empty.",
      Width => "8",
      Position => "7:0", # Excel Formula: =calc_position(F78,E79,TRUE)
      Type => "Config",
      UsedBy => "CGM_deq",
      DefaultValue => "h0",
    },
  },
  BuffersConsumptionLutForDeq83 => { #Structure Type: Reg; ArrayLength: 128; ArrayIndex: 83; ArrayLocationInName: 28;
    Name => "BuffersConsumptionLutForDeq[128]",
    RegMem => "Reg",
    Address => "192",
    Description => "LUT for dequeue marking in VOQ-CGM based on Buffer Consumption.
Index in Array is {Profile,BufferAvailableLevel}
Profile is 5 bits
BufferAvailableLevel is quantized to 2 bits.",
    Width => "8", # Excel Formula: =calc_reg_width(E79:E79,F79)
    Type => "Config",
    AdditionalInfo => "PackArrayToBus",
    Comments => "VOQ_CGM
CGM Deq Marking logic implemented in FF.
Address is {VOQ_PROFILE,Buffer_pool_available_level}
5 + 2 = 7
Buffer_voq_size_level selects offset out of 8.",
    ArrayLength => "128",
    ArrayIndex => "83",
    DeqBufferCongestionMark83 => { #Structure Type: RegField; ArrayLength: 128; ArrayIndex: 83; ArrayLocationInName: 24;
      Name => "DeqBufferCongestionMark[n]",
      RegMem => "RegField",
      Description => "Fill level of VOQ in buffers selects between the 8 values for a given {Profile,BufferAvailableLevel} pair.
The MSB is mark indication in case of most full.
The LSB is mark indication in case of most empty.",
      Width => "8",
      Position => "7:0", # Excel Formula: =calc_position(F78,E79,TRUE)
      Type => "Config",
      UsedBy => "CGM_deq",
      DefaultValue => "h0",
    },
  },
  BuffersConsumptionLutForDeq84 => { #Structure Type: Reg; ArrayLength: 128; ArrayIndex: 84; ArrayLocationInName: 28;
    Name => "BuffersConsumptionLutForDeq[128]",
    RegMem => "Reg",
    Address => "193",
    Description => "LUT for dequeue marking in VOQ-CGM based on Buffer Consumption.
Index in Array is {Profile,BufferAvailableLevel}
Profile is 5 bits
BufferAvailableLevel is quantized to 2 bits.",
    Width => "8", # Excel Formula: =calc_reg_width(E79:E79,F79)
    Type => "Config",
    AdditionalInfo => "PackArrayToBus",
    Comments => "VOQ_CGM
CGM Deq Marking logic implemented in FF.
Address is {VOQ_PROFILE,Buffer_pool_available_level}
5 + 2 = 7
Buffer_voq_size_level selects offset out of 8.",
    ArrayLength => "128",
    ArrayIndex => "84",
    DeqBufferCongestionMark84 => { #Structure Type: RegField; ArrayLength: 128; ArrayIndex: 84; ArrayLocationInName: 24;
      Name => "DeqBufferCongestionMark[n]",
      RegMem => "RegField",
      Description => "Fill level of VOQ in buffers selects between the 8 values for a given {Profile,BufferAvailableLevel} pair.
The MSB is mark indication in case of most full.
The LSB is mark indication in case of most empty.",
      Width => "8",
      Position => "7:0", # Excel Formula: =calc_position(F78,E79,TRUE)
      Type => "Config",
      UsedBy => "CGM_deq",
      DefaultValue => "h0",
    },
  },
  BuffersConsumptionLutForDeq85 => { #Structure Type: Reg; ArrayLength: 128; ArrayIndex: 85; ArrayLocationInName: 28;
    Name => "BuffersConsumptionLutForDeq[128]",
    RegMem => "Reg",
    Address => "194",
    Description => "LUT for dequeue marking in VOQ-CGM based on Buffer Consumption.
Index in Array is {Profile,BufferAvailableLevel}
Profile is 5 bits
BufferAvailableLevel is quantized to 2 bits.",
    Width => "8", # Excel Formula: =calc_reg_width(E79:E79,F79)
    Type => "Config",
    AdditionalInfo => "PackArrayToBus",
    Comments => "VOQ_CGM
CGM Deq Marking logic implemented in FF.
Address is {VOQ_PROFILE,Buffer_pool_available_level}
5 + 2 = 7
Buffer_voq_size_level selects offset out of 8.",
    ArrayLength => "128",
    ArrayIndex => "85",
    DeqBufferCongestionMark85 => { #Structure Type: RegField; ArrayLength: 128; ArrayIndex: 85; ArrayLocationInName: 24;
      Name => "DeqBufferCongestionMark[n]",
      RegMem => "RegField",
      Description => "Fill level of VOQ in buffers selects between the 8 values for a given {Profile,BufferAvailableLevel} pair.
The MSB is mark indication in case of most full.
The LSB is mark indication in case of most empty.",
      Width => "8",
      Position => "7:0", # Excel Formula: =calc_position(F78,E79,TRUE)
      Type => "Config",
      UsedBy => "CGM_deq",
      DefaultValue => "h0",
    },
  },
  BuffersConsumptionLutForDeq86 => { #Structure Type: Reg; ArrayLength: 128; ArrayIndex: 86; ArrayLocationInName: 28;
    Name => "BuffersConsumptionLutForDeq[128]",
    RegMem => "Reg",
    Address => "195",
    Description => "LUT for dequeue marking in VOQ-CGM based on Buffer Consumption.
Index in Array is {Profile,BufferAvailableLevel}
Profile is 5 bits
BufferAvailableLevel is quantized to 2 bits.",
    Width => "8", # Excel Formula: =calc_reg_width(E79:E79,F79)
    Type => "Config",
    AdditionalInfo => "PackArrayToBus",
    Comments => "VOQ_CGM
CGM Deq Marking logic implemented in FF.
Address is {VOQ_PROFILE,Buffer_pool_available_level}
5 + 2 = 7
Buffer_voq_size_level selects offset out of 8.",
    ArrayLength => "128",
    ArrayIndex => "86",
    DeqBufferCongestionMark86 => { #Structure Type: RegField; ArrayLength: 128; ArrayIndex: 86; ArrayLocationInName: 24;
      Name => "DeqBufferCongestionMark[n]",
      RegMem => "RegField",
      Description => "Fill level of VOQ in buffers selects between the 8 values for a given {Profile,BufferAvailableLevel} pair.
The MSB is mark indication in case of most full.
The LSB is mark indication in case of most empty.",
      Width => "8",
      Position => "7:0", # Excel Formula: =calc_position(F78,E79,TRUE)
      Type => "Config",
      UsedBy => "CGM_deq",
      DefaultValue => "h0",
    },
  },
  BuffersConsumptionLutForDeq87 => { #Structure Type: Reg; ArrayLength: 128; ArrayIndex: 87; ArrayLocationInName: 28;
    Name => "BuffersConsumptionLutForDeq[128]",
    RegMem => "Reg",
    Address => "196",
    Description => "LUT for dequeue marking in VOQ-CGM based on Buffer Consumption.
Index in Array is {Profile,BufferAvailableLevel}
Profile is 5 bits
BufferAvailableLevel is quantized to 2 bits.",
    Width => "8", # Excel Formula: =calc_reg_width(E79:E79,F79)
    Type => "Config",
    AdditionalInfo => "PackArrayToBus",
    Comments => "VOQ_CGM
CGM Deq Marking logic implemented in FF.
Address is {VOQ_PROFILE,Buffer_pool_available_level}
5 + 2 = 7
Buffer_voq_size_level selects offset out of 8.",
    ArrayLength => "128",
    ArrayIndex => "87",
    DeqBufferCongestionMark87 => { #Structure Type: RegField; ArrayLength: 128; ArrayIndex: 87; ArrayLocationInName: 24;
      Name => "DeqBufferCongestionMark[n]",
      RegMem => "RegField",
      Description => "Fill level of VOQ in buffers selects between the 8 values for a given {Profile,BufferAvailableLevel} pair.
The MSB is mark indication in case of most full.
The LSB is mark indication in case of most empty.",
      Width => "8",
      Position => "7:0", # Excel Formula: =calc_position(F78,E79,TRUE)
      Type => "Config",
      UsedBy => "CGM_deq",
      DefaultValue => "h0",
    },
  },
  BuffersConsumptionLutForDeq88 => { #Structure Type: Reg; ArrayLength: 128; ArrayIndex: 88; ArrayLocationInName: 28;
    Name => "BuffersConsumptionLutForDeq[128]",
    RegMem => "Reg",
    Address => "197",
    Description => "LUT for dequeue marking in VOQ-CGM based on Buffer Consumption.
Index in Array is {Profile,BufferAvailableLevel}
Profile is 5 bits
BufferAvailableLevel is quantized to 2 bits.",
    Width => "8", # Excel Formula: =calc_reg_width(E79:E79,F79)
    Type => "Config",
    AdditionalInfo => "PackArrayToBus",
    Comments => "VOQ_CGM
CGM Deq Marking logic implemented in FF.
Address is {VOQ_PROFILE,Buffer_pool_available_level}
5 + 2 = 7
Buffer_voq_size_level selects offset out of 8.",
    ArrayLength => "128",
    ArrayIndex => "88",
    DeqBufferCongestionMark88 => { #Structure Type: RegField; ArrayLength: 128; ArrayIndex: 88; ArrayLocationInName: 24;
      Name => "DeqBufferCongestionMark[n]",
      RegMem => "RegField",
      Description => "Fill level of VOQ in buffers selects between the 8 values for a given {Profile,BufferAvailableLevel} pair.
The MSB is mark indication in case of most full.
The LSB is mark indication in case of most empty.",
      Width => "8",
      Position => "7:0", # Excel Formula: =calc_position(F78,E79,TRUE)
      Type => "Config",
      UsedBy => "CGM_deq",
      DefaultValue => "h0",
    },
  },
  BuffersConsumptionLutForDeq89 => { #Structure Type: Reg; ArrayLength: 128; ArrayIndex: 89; ArrayLocationInName: 28;
    Name => "BuffersConsumptionLutForDeq[128]",
    RegMem => "Reg",
    Address => "198",
    Description => "LUT for dequeue marking in VOQ-CGM based on Buffer Consumption.
Index in Array is {Profile,BufferAvailableLevel}
Profile is 5 bits
BufferAvailableLevel is quantized to 2 bits.",
    Width => "8", # Excel Formula: =calc_reg_width(E79:E79,F79)
    Type => "Config",
    AdditionalInfo => "PackArrayToBus",
    Comments => "VOQ_CGM
CGM Deq Marking logic implemented in FF.
Address is {VOQ_PROFILE,Buffer_pool_available_level}
5 + 2 = 7
Buffer_voq_size_level selects offset out of 8.",
    ArrayLength => "128",
    ArrayIndex => "89",
    DeqBufferCongestionMark89 => { #Structure Type: RegField; ArrayLength: 128; ArrayIndex: 89; ArrayLocationInName: 24;
      Name => "DeqBufferCongestionMark[n]",
      RegMem => "RegField",
      Description => "Fill level of VOQ in buffers selects between the 8 values for a given {Profile,BufferAvailableLevel} pair.
The MSB is mark indication in case of most full.
The LSB is mark indication in case of most empty.",
      Width => "8",
      Position => "7:0", # Excel Formula: =calc_position(F78,E79,TRUE)
      Type => "Config",
      UsedBy => "CGM_deq",
      DefaultValue => "h0",
    },
  },
  BuffersConsumptionLutForDeq90 => { #Structure Type: Reg; ArrayLength: 128; ArrayIndex: 90; ArrayLocationInName: 28;
    Name => "BuffersConsumptionLutForDeq[128]",
    RegMem => "Reg",
    Address => "199",
    Description => "LUT for dequeue marking in VOQ-CGM based on Buffer Consumption.
Index in Array is {Profile,BufferAvailableLevel}
Profile is 5 bits
BufferAvailableLevel is quantized to 2 bits.",
    Width => "8", # Excel Formula: =calc_reg_width(E79:E79,F79)
    Type => "Config",
    AdditionalInfo => "PackArrayToBus",
    Comments => "VOQ_CGM
CGM Deq Marking logic implemented in FF.
Address is {VOQ_PROFILE,Buffer_pool_available_level}
5 + 2 = 7
Buffer_voq_size_level selects offset out of 8.",
    ArrayLength => "128",
    ArrayIndex => "90",
    DeqBufferCongestionMark90 => { #Structure Type: RegField; ArrayLength: 128; ArrayIndex: 90; ArrayLocationInName: 24;
      Name => "DeqBufferCongestionMark[n]",
      RegMem => "RegField",
      Description => "Fill level of VOQ in buffers selects between the 8 values for a given {Profile,BufferAvailableLevel} pair.
The MSB is mark indication in case of most full.
The LSB is mark indication in case of most empty.",
      Width => "8",
      Position => "7:0", # Excel Formula: =calc_position(F78,E79,TRUE)
      Type => "Config",
      UsedBy => "CGM_deq",
      DefaultValue => "h0",
    },
  },
  BuffersConsumptionLutForDeq91 => { #Structure Type: Reg; ArrayLength: 128; ArrayIndex: 91; ArrayLocationInName: 28;
    Name => "BuffersConsumptionLutForDeq[128]",
    RegMem => "Reg",
    Address => "19A",
    Description => "LUT for dequeue marking in VOQ-CGM based on Buffer Consumption.
Index in Array is {Profile,BufferAvailableLevel}
Profile is 5 bits
BufferAvailableLevel is quantized to 2 bits.",
    Width => "8", # Excel Formula: =calc_reg_width(E79:E79,F79)
    Type => "Config",
    AdditionalInfo => "PackArrayToBus",
    Comments => "VOQ_CGM
CGM Deq Marking logic implemented in FF.
Address is {VOQ_PROFILE,Buffer_pool_available_level}
5 + 2 = 7
Buffer_voq_size_level selects offset out of 8.",
    ArrayLength => "128",
    ArrayIndex => "91",
    DeqBufferCongestionMark91 => { #Structure Type: RegField; ArrayLength: 128; ArrayIndex: 91; ArrayLocationInName: 24;
      Name => "DeqBufferCongestionMark[n]",
      RegMem => "RegField",
      Description => "Fill level of VOQ in buffers selects between the 8 values for a given {Profile,BufferAvailableLevel} pair.
The MSB is mark indication in case of most full.
The LSB is mark indication in case of most empty.",
      Width => "8",
      Position => "7:0", # Excel Formula: =calc_position(F78,E79,TRUE)
      Type => "Config",
      UsedBy => "CGM_deq",
      DefaultValue => "h0",
    },
  },
  BuffersConsumptionLutForDeq92 => { #Structure Type: Reg; ArrayLength: 128; ArrayIndex: 92; ArrayLocationInName: 28;
    Name => "BuffersConsumptionLutForDeq[128]",
    RegMem => "Reg",
    Address => "19B",
    Description => "LUT for dequeue marking in VOQ-CGM based on Buffer Consumption.
Index in Array is {Profile,BufferAvailableLevel}
Profile is 5 bits
BufferAvailableLevel is quantized to 2 bits.",
    Width => "8", # Excel Formula: =calc_reg_width(E79:E79,F79)
    Type => "Config",
    AdditionalInfo => "PackArrayToBus",
    Comments => "VOQ_CGM
CGM Deq Marking logic implemented in FF.
Address is {VOQ_PROFILE,Buffer_pool_available_level}
5 + 2 = 7
Buffer_voq_size_level selects offset out of 8.",
    ArrayLength => "128",
    ArrayIndex => "92",
    DeqBufferCongestionMark92 => { #Structure Type: RegField; ArrayLength: 128; ArrayIndex: 92; ArrayLocationInName: 24;
      Name => "DeqBufferCongestionMark[n]",
      RegMem => "RegField",
      Description => "Fill level of VOQ in buffers selects between the 8 values for a given {Profile,BufferAvailableLevel} pair.
The MSB is mark indication in case of most full.
The LSB is mark indication in case of most empty.",
      Width => "8",
      Position => "7:0", # Excel Formula: =calc_position(F78,E79,TRUE)
      Type => "Config",
      UsedBy => "CGM_deq",
      DefaultValue => "h0",
    },
  },
  BuffersConsumptionLutForDeq93 => { #Structure Type: Reg; ArrayLength: 128; ArrayIndex: 93; ArrayLocationInName: 28;
    Name => "BuffersConsumptionLutForDeq[128]",
    RegMem => "Reg",
    Address => "19C",
    Description => "LUT for dequeue marking in VOQ-CGM based on Buffer Consumption.
Index in Array is {Profile,BufferAvailableLevel}
Profile is 5 bits
BufferAvailableLevel is quantized to 2 bits.",
    Width => "8", # Excel Formula: =calc_reg_width(E79:E79,F79)
    Type => "Config",
    AdditionalInfo => "PackArrayToBus",
    Comments => "VOQ_CGM
CGM Deq Marking logic implemented in FF.
Address is {VOQ_PROFILE,Buffer_pool_available_level}
5 + 2 = 7
Buffer_voq_size_level selects offset out of 8.",
    ArrayLength => "128",
    ArrayIndex => "93",
    DeqBufferCongestionMark93 => { #Structure Type: RegField; ArrayLength: 128; ArrayIndex: 93; ArrayLocationInName: 24;
      Name => "DeqBufferCongestionMark[n]",
      RegMem => "RegField",
      Description => "Fill level of VOQ in buffers selects between the 8 values for a given {Profile,BufferAvailableLevel} pair.
The MSB is mark indication in case of most full.
The LSB is mark indication in case of most empty.",
      Width => "8",
      Position => "7:0", # Excel Formula: =calc_position(F78,E79,TRUE)
      Type => "Config",
      UsedBy => "CGM_deq",
      DefaultValue => "h0",
    },
  },
  BuffersConsumptionLutForDeq94 => { #Structure Type: Reg; ArrayLength: 128; ArrayIndex: 94; ArrayLocationInName: 28;
    Name => "BuffersConsumptionLutForDeq[128]",
    RegMem => "Reg",
    Address => "19D",
    Description => "LUT for dequeue marking in VOQ-CGM based on Buffer Consumption.
Index in Array is {Profile,BufferAvailableLevel}
Profile is 5 bits
BufferAvailableLevel is quantized to 2 bits.",
    Width => "8", # Excel Formula: =calc_reg_width(E79:E79,F79)
    Type => "Config",
    AdditionalInfo => "PackArrayToBus",
    Comments => "VOQ_CGM
CGM Deq Marking logic implemented in FF.
Address is {VOQ_PROFILE,Buffer_pool_available_level}
5 + 2 = 7
Buffer_voq_size_level selects offset out of 8.",
    ArrayLength => "128",
    ArrayIndex => "94",
    DeqBufferCongestionMark94 => { #Structure Type: RegField; ArrayLength: 128; ArrayIndex: 94; ArrayLocationInName: 24;
      Name => "DeqBufferCongestionMark[n]",
      RegMem => "RegField",
      Description => "Fill level of VOQ in buffers selects between the 8 values for a given {Profile,BufferAvailableLevel} pair.
The MSB is mark indication in case of most full.
The LSB is mark indication in case of most empty.",
      Width => "8",
      Position => "7:0", # Excel Formula: =calc_position(F78,E79,TRUE)
      Type => "Config",
      UsedBy => "CGM_deq",
      DefaultValue => "h0",
    },
  },
  BuffersConsumptionLutForDeq95 => { #Structure Type: Reg; ArrayLength: 128; ArrayIndex: 95; ArrayLocationInName: 28;
    Name => "BuffersConsumptionLutForDeq[128]",
    RegMem => "Reg",
    Address => "19E",
    Description => "LUT for dequeue marking in VOQ-CGM based on Buffer Consumption.
Index in Array is {Profile,BufferAvailableLevel}
Profile is 5 bits
BufferAvailableLevel is quantized to 2 bits.",
    Width => "8", # Excel Formula: =calc_reg_width(E79:E79,F79)
    Type => "Config",
    AdditionalInfo => "PackArrayToBus",
    Comments => "VOQ_CGM
CGM Deq Marking logic implemented in FF.
Address is {VOQ_PROFILE,Buffer_pool_available_level}
5 + 2 = 7
Buffer_voq_size_level selects offset out of 8.",
    ArrayLength => "128",
    ArrayIndex => "95",
    DeqBufferCongestionMark95 => { #Structure Type: RegField; ArrayLength: 128; ArrayIndex: 95; ArrayLocationInName: 24;
      Name => "DeqBufferCongestionMark[n]",
      RegMem => "RegField",
      Description => "Fill level of VOQ in buffers selects between the 8 values for a given {Profile,BufferAvailableLevel} pair.
The MSB is mark indication in case of most full.
The LSB is mark indication in case of most empty.",
      Width => "8",
      Position => "7:0", # Excel Formula: =calc_position(F78,E79,TRUE)
      Type => "Config",
      UsedBy => "CGM_deq",
      DefaultValue => "h0",
    },
  },
  BuffersConsumptionLutForDeq96 => { #Structure Type: Reg; ArrayLength: 128; ArrayIndex: 96; ArrayLocationInName: 28;
    Name => "BuffersConsumptionLutForDeq[128]",
    RegMem => "Reg",
    Address => "19F",
    Description => "LUT for dequeue marking in VOQ-CGM based on Buffer Consumption.
Index in Array is {Profile,BufferAvailableLevel}
Profile is 5 bits
BufferAvailableLevel is quantized to 2 bits.",
    Width => "8", # Excel Formula: =calc_reg_width(E79:E79,F79)
    Type => "Config",
    AdditionalInfo => "PackArrayToBus",
    Comments => "VOQ_CGM
CGM Deq Marking logic implemented in FF.
Address is {VOQ_PROFILE,Buffer_pool_available_level}
5 + 2 = 7
Buffer_voq_size_level selects offset out of 8.",
    ArrayLength => "128",
    ArrayIndex => "96",
    DeqBufferCongestionMark96 => { #Structure Type: RegField; ArrayLength: 128; ArrayIndex: 96; ArrayLocationInName: 24;
      Name => "DeqBufferCongestionMark[n]",
      RegMem => "RegField",
      Description => "Fill level of VOQ in buffers selects between the 8 values for a given {Profile,BufferAvailableLevel} pair.
The MSB is mark indication in case of most full.
The LSB is mark indication in case of most empty.",
      Width => "8",
      Position => "7:0", # Excel Formula: =calc_position(F78,E79,TRUE)
      Type => "Config",
      UsedBy => "CGM_deq",
      DefaultValue => "h0",
    },
  },
  BuffersConsumptionLutForDeq97 => { #Structure Type: Reg; ArrayLength: 128; ArrayIndex: 97; ArrayLocationInName: 28;
    Name => "BuffersConsumptionLutForDeq[128]",
    RegMem => "Reg",
    Address => "1A0",
    Description => "LUT for dequeue marking in VOQ-CGM based on Buffer Consumption.
Index in Array is {Profile,BufferAvailableLevel}
Profile is 5 bits
BufferAvailableLevel is quantized to 2 bits.",
    Width => "8", # Excel Formula: =calc_reg_width(E79:E79,F79)
    Type => "Config",
    AdditionalInfo => "PackArrayToBus",
    Comments => "VOQ_CGM
CGM Deq Marking logic implemented in FF.
Address is {VOQ_PROFILE,Buffer_pool_available_level}
5 + 2 = 7
Buffer_voq_size_level selects offset out of 8.",
    ArrayLength => "128",
    ArrayIndex => "97",
    DeqBufferCongestionMark97 => { #Structure Type: RegField; ArrayLength: 128; ArrayIndex: 97; ArrayLocationInName: 24;
      Name => "DeqBufferCongestionMark[n]",
      RegMem => "RegField",
      Description => "Fill level of VOQ in buffers selects between the 8 values for a given {Profile,BufferAvailableLevel} pair.
The MSB is mark indication in case of most full.
The LSB is mark indication in case of most empty.",
      Width => "8",
      Position => "7:0", # Excel Formula: =calc_position(F78,E79,TRUE)
      Type => "Config",
      UsedBy => "CGM_deq",
      DefaultValue => "h0",
    },
  },
  BuffersConsumptionLutForDeq98 => { #Structure Type: Reg; ArrayLength: 128; ArrayIndex: 98; ArrayLocationInName: 28;
    Name => "BuffersConsumptionLutForDeq[128]",
    RegMem => "Reg",
    Address => "1A1",
    Description => "LUT for dequeue marking in VOQ-CGM based on Buffer Consumption.
Index in Array is {Profile,BufferAvailableLevel}
Profile is 5 bits
BufferAvailableLevel is quantized to 2 bits.",
    Width => "8", # Excel Formula: =calc_reg_width(E79:E79,F79)
    Type => "Config",
    AdditionalInfo => "PackArrayToBus",
    Comments => "VOQ_CGM
CGM Deq Marking logic implemented in FF.
Address is {VOQ_PROFILE,Buffer_pool_available_level}
5 + 2 = 7
Buffer_voq_size_level selects offset out of 8.",
    ArrayLength => "128",
    ArrayIndex => "98",
    DeqBufferCongestionMark98 => { #Structure Type: RegField; ArrayLength: 128; ArrayIndex: 98; ArrayLocationInName: 24;
      Name => "DeqBufferCongestionMark[n]",
      RegMem => "RegField",
      Description => "Fill level of VOQ in buffers selects between the 8 values for a given {Profile,BufferAvailableLevel} pair.
The MSB is mark indication in case of most full.
The LSB is mark indication in case of most empty.",
      Width => "8",
      Position => "7:0", # Excel Formula: =calc_position(F78,E79,TRUE)
      Type => "Config",
      UsedBy => "CGM_deq",
      DefaultValue => "h0",
    },
  },
  BuffersConsumptionLutForDeq99 => { #Structure Type: Reg; ArrayLength: 128; ArrayIndex: 99; ArrayLocationInName: 28;
    Name => "BuffersConsumptionLutForDeq[128]",
    RegMem => "Reg",
    Address => "1A2",
    Description => "LUT for dequeue marking in VOQ-CGM based on Buffer Consumption.
Index in Array is {Profile,BufferAvailableLevel}
Profile is 5 bits
BufferAvailableLevel is quantized to 2 bits.",
    Width => "8", # Excel Formula: =calc_reg_width(E79:E79,F79)
    Type => "Config",
    AdditionalInfo => "PackArrayToBus",
    Comments => "VOQ_CGM
CGM Deq Marking logic implemented in FF.
Address is {VOQ_PROFILE,Buffer_pool_available_level}
5 + 2 = 7
Buffer_voq_size_level selects offset out of 8.",
    ArrayLength => "128",
    ArrayIndex => "99",
    DeqBufferCongestionMark99 => { #Structure Type: RegField; ArrayLength: 128; ArrayIndex: 99; ArrayLocationInName: 24;
      Name => "DeqBufferCongestionMark[n]",
      RegMem => "RegField",
      Description => "Fill level of VOQ in buffers selects between the 8 values for a given {Profile,BufferAvailableLevel} pair.
The MSB is mark indication in case of most full.
The LSB is mark indication in case of most empty.",
      Width => "8",
      Position => "7:0", # Excel Formula: =calc_position(F78,E79,TRUE)
      Type => "Config",
      UsedBy => "CGM_deq",
      DefaultValue => "h0",
    },
  },
  BuffersConsumptionLutForDeq100 => { #Structure Type: Reg; ArrayLength: 128; ArrayIndex: 100; ArrayLocationInName: 28;
    Name => "BuffersConsumptionLutForDeq[128]",
    RegMem => "Reg",
    Address => "1A3",
    Description => "LUT for dequeue marking in VOQ-CGM based on Buffer Consumption.
Index in Array is {Profile,BufferAvailableLevel}
Profile is 5 bits
BufferAvailableLevel is quantized to 2 bits.",
    Width => "8", # Excel Formula: =calc_reg_width(E79:E79,F79)
    Type => "Config",
    AdditionalInfo => "PackArrayToBus",
    Comments => "VOQ_CGM
CGM Deq Marking logic implemented in FF.
Address is {VOQ_PROFILE,Buffer_pool_available_level}
5 + 2 = 7
Buffer_voq_size_level selects offset out of 8.",
    ArrayLength => "128",
    ArrayIndex => "100",
    DeqBufferCongestionMark100 => { #Structure Type: RegField; ArrayLength: 128; ArrayIndex: 100; ArrayLocationInName: 24;
      Name => "DeqBufferCongestionMark[n]",
      RegMem => "RegField",
      Description => "Fill level of VOQ in buffers selects between the 8 values for a given {Profile,BufferAvailableLevel} pair.
The MSB is mark indication in case of most full.
The LSB is mark indication in case of most empty.",
      Width => "8",
      Position => "7:0", # Excel Formula: =calc_position(F78,E79,TRUE)
      Type => "Config",
      UsedBy => "CGM_deq",
      DefaultValue => "h0",
    },
  },
  BuffersConsumptionLutForDeq101 => { #Structure Type: Reg; ArrayLength: 128; ArrayIndex: 101; ArrayLocationInName: 28;
    Name => "BuffersConsumptionLutForDeq[128]",
    RegMem => "Reg",
    Address => "1A4",
    Description => "LUT for dequeue marking in VOQ-CGM based on Buffer Consumption.
Index in Array is {Profile,BufferAvailableLevel}
Profile is 5 bits
BufferAvailableLevel is quantized to 2 bits.",
    Width => "8", # Excel Formula: =calc_reg_width(E79:E79,F79)
    Type => "Config",
    AdditionalInfo => "PackArrayToBus",
    Comments => "VOQ_CGM
CGM Deq Marking logic implemented in FF.
Address is {VOQ_PROFILE,Buffer_pool_available_level}
5 + 2 = 7
Buffer_voq_size_level selects offset out of 8.",
    ArrayLength => "128",
    ArrayIndex => "101",
    DeqBufferCongestionMark101 => { #Structure Type: RegField; ArrayLength: 128; ArrayIndex: 101; ArrayLocationInName: 24;
      Name => "DeqBufferCongestionMark[n]",
      RegMem => "RegField",
      Description => "Fill level of VOQ in buffers selects between the 8 values for a given {Profile,BufferAvailableLevel} pair.
The MSB is mark indication in case of most full.
The LSB is mark indication in case of most empty.",
      Width => "8",
      Position => "7:0", # Excel Formula: =calc_position(F78,E79,TRUE)
      Type => "Config",
      UsedBy => "CGM_deq",
      DefaultValue => "h0",
    },
  },
  BuffersConsumptionLutForDeq102 => { #Structure Type: Reg; ArrayLength: 128; ArrayIndex: 102; ArrayLocationInName: 28;
    Name => "BuffersConsumptionLutForDeq[128]",
    RegMem => "Reg",
    Address => "1A5",
    Description => "LUT for dequeue marking in VOQ-CGM based on Buffer Consumption.
Index in Array is {Profile,BufferAvailableLevel}
Profile is 5 bits
BufferAvailableLevel is quantized to 2 bits.",
    Width => "8", # Excel Formula: =calc_reg_width(E79:E79,F79)
    Type => "Config",
    AdditionalInfo => "PackArrayToBus",
    Comments => "VOQ_CGM
CGM Deq Marking logic implemented in FF.
Address is {VOQ_PROFILE,Buffer_pool_available_level}
5 + 2 = 7
Buffer_voq_size_level selects offset out of 8.",
    ArrayLength => "128",
    ArrayIndex => "102",
    DeqBufferCongestionMark102 => { #Structure Type: RegField; ArrayLength: 128; ArrayIndex: 102; ArrayLocationInName: 24;
      Name => "DeqBufferCongestionMark[n]",
      RegMem => "RegField",
      Description => "Fill level of VOQ in buffers selects between the 8 values for a given {Profile,BufferAvailableLevel} pair.
The MSB is mark indication in case of most full.
The LSB is mark indication in case of most empty.",
      Width => "8",
      Position => "7:0", # Excel Formula: =calc_position(F78,E79,TRUE)
      Type => "Config",
      UsedBy => "CGM_deq",
      DefaultValue => "h0",
    },
  },
  BuffersConsumptionLutForDeq103 => { #Structure Type: Reg; ArrayLength: 128; ArrayIndex: 103; ArrayLocationInName: 28;
    Name => "BuffersConsumptionLutForDeq[128]",
    RegMem => "Reg",
    Address => "1A6",
    Description => "LUT for dequeue marking in VOQ-CGM based on Buffer Consumption.
Index in Array is {Profile,BufferAvailableLevel}
Profile is 5 bits
BufferAvailableLevel is quantized to 2 bits.",
    Width => "8", # Excel Formula: =calc_reg_width(E79:E79,F79)
    Type => "Config",
    AdditionalInfo => "PackArrayToBus",
    Comments => "VOQ_CGM
CGM Deq Marking logic implemented in FF.
Address is {VOQ_PROFILE,Buffer_pool_available_level}
5 + 2 = 7
Buffer_voq_size_level selects offset out of 8.",
    ArrayLength => "128",
    ArrayIndex => "103",
    DeqBufferCongestionMark103 => { #Structure Type: RegField; ArrayLength: 128; ArrayIndex: 103; ArrayLocationInName: 24;
      Name => "DeqBufferCongestionMark[n]",
      RegMem => "RegField",
      Description => "Fill level of VOQ in buffers selects between the 8 values for a given {Profile,BufferAvailableLevel} pair.
The MSB is mark indication in case of most full.
The LSB is mark indication in case of most empty.",
      Width => "8",
      Position => "7:0", # Excel Formula: =calc_position(F78,E79,TRUE)
      Type => "Config",
      UsedBy => "CGM_deq",
      DefaultValue => "h0",
    },
  },
  BuffersConsumptionLutForDeq104 => { #Structure Type: Reg; ArrayLength: 128; ArrayIndex: 104; ArrayLocationInName: 28;
    Name => "BuffersConsumptionLutForDeq[128]",
    RegMem => "Reg",
    Address => "1A7",
    Description => "LUT for dequeue marking in VOQ-CGM based on Buffer Consumption.
Index in Array is {Profile,BufferAvailableLevel}
Profile is 5 bits
BufferAvailableLevel is quantized to 2 bits.",
    Width => "8", # Excel Formula: =calc_reg_width(E79:E79,F79)
    Type => "Config",
    AdditionalInfo => "PackArrayToBus",
    Comments => "VOQ_CGM
CGM Deq Marking logic implemented in FF.
Address is {VOQ_PROFILE,Buffer_pool_available_level}
5 + 2 = 7
Buffer_voq_size_level selects offset out of 8.",
    ArrayLength => "128",
    ArrayIndex => "104",
    DeqBufferCongestionMark104 => { #Structure Type: RegField; ArrayLength: 128; ArrayIndex: 104; ArrayLocationInName: 24;
      Name => "DeqBufferCongestionMark[n]",
      RegMem => "RegField",
      Description => "Fill level of VOQ in buffers selects between the 8 values for a given {Profile,BufferAvailableLevel} pair.
The MSB is mark indication in case of most full.
The LSB is mark indication in case of most empty.",
      Width => "8",
      Position => "7:0", # Excel Formula: =calc_position(F78,E79,TRUE)
      Type => "Config",
      UsedBy => "CGM_deq",
      DefaultValue => "h0",
    },
  },
  BuffersConsumptionLutForDeq105 => { #Structure Type: Reg; ArrayLength: 128; ArrayIndex: 105; ArrayLocationInName: 28;
    Name => "BuffersConsumptionLutForDeq[128]",
    RegMem => "Reg",
    Address => "1A8",
    Description => "LUT for dequeue marking in VOQ-CGM based on Buffer Consumption.
Index in Array is {Profile,BufferAvailableLevel}
Profile is 5 bits
BufferAvailableLevel is quantized to 2 bits.",
    Width => "8", # Excel Formula: =calc_reg_width(E79:E79,F79)
    Type => "Config",
    AdditionalInfo => "PackArrayToBus",
    Comments => "VOQ_CGM
CGM Deq Marking logic implemented in FF.
Address is {VOQ_PROFILE,Buffer_pool_available_level}
5 + 2 = 7
Buffer_voq_size_level selects offset out of 8.",
    ArrayLength => "128",
    ArrayIndex => "105",
    DeqBufferCongestionMark105 => { #Structure Type: RegField; ArrayLength: 128; ArrayIndex: 105; ArrayLocationInName: 24;
      Name => "DeqBufferCongestionMark[n]",
      RegMem => "RegField",
      Description => "Fill level of VOQ in buffers selects between the 8 values for a given {Profile,BufferAvailableLevel} pair.
The MSB is mark indication in case of most full.
The LSB is mark indication in case of most empty.",
      Width => "8",
      Position => "7:0", # Excel Formula: =calc_position(F78,E79,TRUE)
      Type => "Config",
      UsedBy => "CGM_deq",
      DefaultValue => "h0",
    },
  },
  BuffersConsumptionLutForDeq106 => { #Structure Type: Reg; ArrayLength: 128; ArrayIndex: 106; ArrayLocationInName: 28;
    Name => "BuffersConsumptionLutForDeq[128]",
    RegMem => "Reg",
    Address => "1A9",
    Description => "LUT for dequeue marking in VOQ-CGM based on Buffer Consumption.
Index in Array is {Profile,BufferAvailableLevel}
Profile is 5 bits
BufferAvailableLevel is quantized to 2 bits.",
    Width => "8", # Excel Formula: =calc_reg_width(E79:E79,F79)
    Type => "Config",
    AdditionalInfo => "PackArrayToBus",
    Comments => "VOQ_CGM
CGM Deq Marking logic implemented in FF.
Address is {VOQ_PROFILE,Buffer_pool_available_level}
5 + 2 = 7
Buffer_voq_size_level selects offset out of 8.",
    ArrayLength => "128",
    ArrayIndex => "106",
    DeqBufferCongestionMark106 => { #Structure Type: RegField; ArrayLength: 128; ArrayIndex: 106; ArrayLocationInName: 24;
      Name => "DeqBufferCongestionMark[n]",
      RegMem => "RegField",
      Description => "Fill level of VOQ in buffers selects between the 8 values for a given {Profile,BufferAvailableLevel} pair.
The MSB is mark indication in case of most full.
The LSB is mark indication in case of most empty.",
      Width => "8",
      Position => "7:0", # Excel Formula: =calc_position(F78,E79,TRUE)
      Type => "Config",
      UsedBy => "CGM_deq",
      DefaultValue => "h0",
    },
  },
  BuffersConsumptionLutForDeq107 => { #Structure Type: Reg; ArrayLength: 128; ArrayIndex: 107; ArrayLocationInName: 28;
    Name => "BuffersConsumptionLutForDeq[128]",
    RegMem => "Reg",
    Address => "1AA",
    Description => "LUT for dequeue marking in VOQ-CGM based on Buffer Consumption.
Index in Array is {Profile,BufferAvailableLevel}
Profile is 5 bits
BufferAvailableLevel is quantized to 2 bits.",
    Width => "8", # Excel Formula: =calc_reg_width(E79:E79,F79)
    Type => "Config",
    AdditionalInfo => "PackArrayToBus",
    Comments => "VOQ_CGM
CGM Deq Marking logic implemented in FF.
Address is {VOQ_PROFILE,Buffer_pool_available_level}
5 + 2 = 7
Buffer_voq_size_level selects offset out of 8.",
    ArrayLength => "128",
    ArrayIndex => "107",
    DeqBufferCongestionMark107 => { #Structure Type: RegField; ArrayLength: 128; ArrayIndex: 107; ArrayLocationInName: 24;
      Name => "DeqBufferCongestionMark[n]",
      RegMem => "RegField",
      Description => "Fill level of VOQ in buffers selects between the 8 values for a given {Profile,BufferAvailableLevel} pair.
The MSB is mark indication in case of most full.
The LSB is mark indication in case of most empty.",
      Width => "8",
      Position => "7:0", # Excel Formula: =calc_position(F78,E79,TRUE)
      Type => "Config",
      UsedBy => "CGM_deq",
      DefaultValue => "h0",
    },
  },
  BuffersConsumptionLutForDeq108 => { #Structure Type: Reg; ArrayLength: 128; ArrayIndex: 108; ArrayLocationInName: 28;
    Name => "BuffersConsumptionLutForDeq[128]",
    RegMem => "Reg",
    Address => "1AB",
    Description => "LUT for dequeue marking in VOQ-CGM based on Buffer Consumption.
Index in Array is {Profile,BufferAvailableLevel}
Profile is 5 bits
BufferAvailableLevel is quantized to 2 bits.",
    Width => "8", # Excel Formula: =calc_reg_width(E79:E79,F79)
    Type => "Config",
    AdditionalInfo => "PackArrayToBus",
    Comments => "VOQ_CGM
CGM Deq Marking logic implemented in FF.
Address is {VOQ_PROFILE,Buffer_pool_available_level}
5 + 2 = 7
Buffer_voq_size_level selects offset out of 8.",
    ArrayLength => "128",
    ArrayIndex => "108",
    DeqBufferCongestionMark108 => { #Structure Type: RegField; ArrayLength: 128; ArrayIndex: 108; ArrayLocationInName: 24;
      Name => "DeqBufferCongestionMark[n]",
      RegMem => "RegField",
      Description => "Fill level of VOQ in buffers selects between the 8 values for a given {Profile,BufferAvailableLevel} pair.
The MSB is mark indication in case of most full.
The LSB is mark indication in case of most empty.",
      Width => "8",
      Position => "7:0", # Excel Formula: =calc_position(F78,E79,TRUE)
      Type => "Config",
      UsedBy => "CGM_deq",
      DefaultValue => "h0",
    },
  },
  BuffersConsumptionLutForDeq109 => { #Structure Type: Reg; ArrayLength: 128; ArrayIndex: 109; ArrayLocationInName: 28;
    Name => "BuffersConsumptionLutForDeq[128]",
    RegMem => "Reg",
    Address => "1AC",
    Description => "LUT for dequeue marking in VOQ-CGM based on Buffer Consumption.
Index in Array is {Profile,BufferAvailableLevel}
Profile is 5 bits
BufferAvailableLevel is quantized to 2 bits.",
    Width => "8", # Excel Formula: =calc_reg_width(E79:E79,F79)
    Type => "Config",
    AdditionalInfo => "PackArrayToBus",
    Comments => "VOQ_CGM
CGM Deq Marking logic implemented in FF.
Address is {VOQ_PROFILE,Buffer_pool_available_level}
5 + 2 = 7
Buffer_voq_size_level selects offset out of 8.",
    ArrayLength => "128",
    ArrayIndex => "109",
    DeqBufferCongestionMark109 => { #Structure Type: RegField; ArrayLength: 128; ArrayIndex: 109; ArrayLocationInName: 24;
      Name => "DeqBufferCongestionMark[n]",
      RegMem => "RegField",
      Description => "Fill level of VOQ in buffers selects between the 8 values for a given {Profile,BufferAvailableLevel} pair.
The MSB is mark indication in case of most full.
The LSB is mark indication in case of most empty.",
      Width => "8",
      Position => "7:0", # Excel Formula: =calc_position(F78,E79,TRUE)
      Type => "Config",
      UsedBy => "CGM_deq",
      DefaultValue => "h0",
    },
  },
  BuffersConsumptionLutForDeq110 => { #Structure Type: Reg; ArrayLength: 128; ArrayIndex: 110; ArrayLocationInName: 28;
    Name => "BuffersConsumptionLutForDeq[128]",
    RegMem => "Reg",
    Address => "1AD",
    Description => "LUT for dequeue marking in VOQ-CGM based on Buffer Consumption.
Index in Array is {Profile,BufferAvailableLevel}
Profile is 5 bits
BufferAvailableLevel is quantized to 2 bits.",
    Width => "8", # Excel Formula: =calc_reg_width(E79:E79,F79)
    Type => "Config",
    AdditionalInfo => "PackArrayToBus",
    Comments => "VOQ_CGM
CGM Deq Marking logic implemented in FF.
Address is {VOQ_PROFILE,Buffer_pool_available_level}
5 + 2 = 7
Buffer_voq_size_level selects offset out of 8.",
    ArrayLength => "128",
    ArrayIndex => "110",
    DeqBufferCongestionMark110 => { #Structure Type: RegField; ArrayLength: 128; ArrayIndex: 110; ArrayLocationInName: 24;
      Name => "DeqBufferCongestionMark[n]",
      RegMem => "RegField",
      Description => "Fill level of VOQ in buffers selects between the 8 values for a given {Profile,BufferAvailableLevel} pair.
The MSB is mark indication in case of most full.
The LSB is mark indication in case of most empty.",
      Width => "8",
      Position => "7:0", # Excel Formula: =calc_position(F78,E79,TRUE)
      Type => "Config",
      UsedBy => "CGM_deq",
      DefaultValue => "h0",
    },
  },
  BuffersConsumptionLutForDeq111 => { #Structure Type: Reg; ArrayLength: 128; ArrayIndex: 111; ArrayLocationInName: 28;
    Name => "BuffersConsumptionLutForDeq[128]",
    RegMem => "Reg",
    Address => "1AE",
    Description => "LUT for dequeue marking in VOQ-CGM based on Buffer Consumption.
Index in Array is {Profile,BufferAvailableLevel}
Profile is 5 bits
BufferAvailableLevel is quantized to 2 bits.",
    Width => "8", # Excel Formula: =calc_reg_width(E79:E79,F79)
    Type => "Config",
    AdditionalInfo => "PackArrayToBus",
    Comments => "VOQ_CGM
CGM Deq Marking logic implemented in FF.
Address is {VOQ_PROFILE,Buffer_pool_available_level}
5 + 2 = 7
Buffer_voq_size_level selects offset out of 8.",
    ArrayLength => "128",
    ArrayIndex => "111",
    DeqBufferCongestionMark111 => { #Structure Type: RegField; ArrayLength: 128; ArrayIndex: 111; ArrayLocationInName: 24;
      Name => "DeqBufferCongestionMark[n]",
      RegMem => "RegField",
      Description => "Fill level of VOQ in buffers selects between the 8 values for a given {Profile,BufferAvailableLevel} pair.
The MSB is mark indication in case of most full.
The LSB is mark indication in case of most empty.",
      Width => "8",
      Position => "7:0", # Excel Formula: =calc_position(F78,E79,TRUE)
      Type => "Config",
      UsedBy => "CGM_deq",
      DefaultValue => "h0",
    },
  },
  BuffersConsumptionLutForDeq112 => { #Structure Type: Reg; ArrayLength: 128; ArrayIndex: 112; ArrayLocationInName: 28;
    Name => "BuffersConsumptionLutForDeq[128]",
    RegMem => "Reg",
    Address => "1AF",
    Description => "LUT for dequeue marking in VOQ-CGM based on Buffer Consumption.
Index in Array is {Profile,BufferAvailableLevel}
Profile is 5 bits
BufferAvailableLevel is quantized to 2 bits.",
    Width => "8", # Excel Formula: =calc_reg_width(E79:E79,F79)
    Type => "Config",
    AdditionalInfo => "PackArrayToBus",
    Comments => "VOQ_CGM
CGM Deq Marking logic implemented in FF.
Address is {VOQ_PROFILE,Buffer_pool_available_level}
5 + 2 = 7
Buffer_voq_size_level selects offset out of 8.",
    ArrayLength => "128",
    ArrayIndex => "112",
    DeqBufferCongestionMark112 => { #Structure Type: RegField; ArrayLength: 128; ArrayIndex: 112; ArrayLocationInName: 24;
      Name => "DeqBufferCongestionMark[n]",
      RegMem => "RegField",
      Description => "Fill level of VOQ in buffers selects between the 8 values for a given {Profile,BufferAvailableLevel} pair.
The MSB is mark indication in case of most full.
The LSB is mark indication in case of most empty.",
      Width => "8",
      Position => "7:0", # Excel Formula: =calc_position(F78,E79,TRUE)
      Type => "Config",
      UsedBy => "CGM_deq",
      DefaultValue => "h0",
    },
  },
  BuffersConsumptionLutForDeq113 => { #Structure Type: Reg; ArrayLength: 128; ArrayIndex: 113; ArrayLocationInName: 28;
    Name => "BuffersConsumptionLutForDeq[128]",
    RegMem => "Reg",
    Address => "1B0",
    Description => "LUT for dequeue marking in VOQ-CGM based on Buffer Consumption.
Index in Array is {Profile,BufferAvailableLevel}
Profile is 5 bits
BufferAvailableLevel is quantized to 2 bits.",
    Width => "8", # Excel Formula: =calc_reg_width(E79:E79,F79)
    Type => "Config",
    AdditionalInfo => "PackArrayToBus",
    Comments => "VOQ_CGM
CGM Deq Marking logic implemented in FF.
Address is {VOQ_PROFILE,Buffer_pool_available_level}
5 + 2 = 7
Buffer_voq_size_level selects offset out of 8.",
    ArrayLength => "128",
    ArrayIndex => "113",
    DeqBufferCongestionMark113 => { #Structure Type: RegField; ArrayLength: 128; ArrayIndex: 113; ArrayLocationInName: 24;
      Name => "DeqBufferCongestionMark[n]",
      RegMem => "RegField",
      Description => "Fill level of VOQ in buffers selects between the 8 values for a given {Profile,BufferAvailableLevel} pair.
The MSB is mark indication in case of most full.
The LSB is mark indication in case of most empty.",
      Width => "8",
      Position => "7:0", # Excel Formula: =calc_position(F78,E79,TRUE)
      Type => "Config",
      UsedBy => "CGM_deq",
      DefaultValue => "h0",
    },
  },
  BuffersConsumptionLutForDeq114 => { #Structure Type: Reg; ArrayLength: 128; ArrayIndex: 114; ArrayLocationInName: 28;
    Name => "BuffersConsumptionLutForDeq[128]",
    RegMem => "Reg",
    Address => "1B1",
    Description => "LUT for dequeue marking in VOQ-CGM based on Buffer Consumption.
Index in Array is {Profile,BufferAvailableLevel}
Profile is 5 bits
BufferAvailableLevel is quantized to 2 bits.",
    Width => "8", # Excel Formula: =calc_reg_width(E79:E79,F79)
    Type => "Config",
    AdditionalInfo => "PackArrayToBus",
    Comments => "VOQ_CGM
CGM Deq Marking logic implemented in FF.
Address is {VOQ_PROFILE,Buffer_pool_available_level}
5 + 2 = 7
Buffer_voq_size_level selects offset out of 8.",
    ArrayLength => "128",
    ArrayIndex => "114",
    DeqBufferCongestionMark114 => { #Structure Type: RegField; ArrayLength: 128; ArrayIndex: 114; ArrayLocationInName: 24;
      Name => "DeqBufferCongestionMark[n]",
      RegMem => "RegField",
      Description => "Fill level of VOQ in buffers selects between the 8 values for a given {Profile,BufferAvailableLevel} pair.
The MSB is mark indication in case of most full.
The LSB is mark indication in case of most empty.",
      Width => "8",
      Position => "7:0", # Excel Formula: =calc_position(F78,E79,TRUE)
      Type => "Config",
      UsedBy => "CGM_deq",
      DefaultValue => "h0",
    },
  },
  BuffersConsumptionLutForDeq115 => { #Structure Type: Reg; ArrayLength: 128; ArrayIndex: 115; ArrayLocationInName: 28;
    Name => "BuffersConsumptionLutForDeq[128]",
    RegMem => "Reg",
    Address => "1B2",
    Description => "LUT for dequeue marking in VOQ-CGM based on Buffer Consumption.
Index in Array is {Profile,BufferAvailableLevel}
Profile is 5 bits
BufferAvailableLevel is quantized to 2 bits.",
    Width => "8", # Excel Formula: =calc_reg_width(E79:E79,F79)
    Type => "Config",
    AdditionalInfo => "PackArrayToBus",
    Comments => "VOQ_CGM
CGM Deq Marking logic implemented in FF.
Address is {VOQ_PROFILE,Buffer_pool_available_level}
5 + 2 = 7
Buffer_voq_size_level selects offset out of 8.",
    ArrayLength => "128",
    ArrayIndex => "115",
    DeqBufferCongestionMark115 => { #Structure Type: RegField; ArrayLength: 128; ArrayIndex: 115; ArrayLocationInName: 24;
      Name => "DeqBufferCongestionMark[n]",
      RegMem => "RegField",
      Description => "Fill level of VOQ in buffers selects between the 8 values for a given {Profile,BufferAvailableLevel} pair.
The MSB is mark indication in case of most full.
The LSB is mark indication in case of most empty.",
      Width => "8",
      Position => "7:0", # Excel Formula: =calc_position(F78,E79,TRUE)
      Type => "Config",
      UsedBy => "CGM_deq",
      DefaultValue => "h0",
    },
  },
  BuffersConsumptionLutForDeq116 => { #Structure Type: Reg; ArrayLength: 128; ArrayIndex: 116; ArrayLocationInName: 28;
    Name => "BuffersConsumptionLutForDeq[128]",
    RegMem => "Reg",
    Address => "1B3",
    Description => "LUT for dequeue marking in VOQ-CGM based on Buffer Consumption.
Index in Array is {Profile,BufferAvailableLevel}
Profile is 5 bits
BufferAvailableLevel is quantized to 2 bits.",
    Width => "8", # Excel Formula: =calc_reg_width(E79:E79,F79)
    Type => "Config",
    AdditionalInfo => "PackArrayToBus",
    Comments => "VOQ_CGM
CGM Deq Marking logic implemented in FF.
Address is {VOQ_PROFILE,Buffer_pool_available_level}
5 + 2 = 7
Buffer_voq_size_level selects offset out of 8.",
    ArrayLength => "128",
    ArrayIndex => "116",
    DeqBufferCongestionMark116 => { #Structure Type: RegField; ArrayLength: 128; ArrayIndex: 116; ArrayLocationInName: 24;
      Name => "DeqBufferCongestionMark[n]",
      RegMem => "RegField",
      Description => "Fill level of VOQ in buffers selects between the 8 values for a given {Profile,BufferAvailableLevel} pair.
The MSB is mark indication in case of most full.
The LSB is mark indication in case of most empty.",
      Width => "8",
      Position => "7:0", # Excel Formula: =calc_position(F78,E79,TRUE)
      Type => "Config",
      UsedBy => "CGM_deq",
      DefaultValue => "h0",
    },
  },
  BuffersConsumptionLutForDeq117 => { #Structure Type: Reg; ArrayLength: 128; ArrayIndex: 117; ArrayLocationInName: 28;
    Name => "BuffersConsumptionLutForDeq[128]",
    RegMem => "Reg",
    Address => "1B4",
    Description => "LUT for dequeue marking in VOQ-CGM based on Buffer Consumption.
Index in Array is {Profile,BufferAvailableLevel}
Profile is 5 bits
BufferAvailableLevel is quantized to 2 bits.",
    Width => "8", # Excel Formula: =calc_reg_width(E79:E79,F79)
    Type => "Config",
    AdditionalInfo => "PackArrayToBus",
    Comments => "VOQ_CGM
CGM Deq Marking logic implemented in FF.
Address is {VOQ_PROFILE,Buffer_pool_available_level}
5 + 2 = 7
Buffer_voq_size_level selects offset out of 8.",
    ArrayLength => "128",
    ArrayIndex => "117",
    DeqBufferCongestionMark117 => { #Structure Type: RegField; ArrayLength: 128; ArrayIndex: 117; ArrayLocationInName: 24;
      Name => "DeqBufferCongestionMark[n]",
      RegMem => "RegField",
      Description => "Fill level of VOQ in buffers selects between the 8 values for a given {Profile,BufferAvailableLevel} pair.
The MSB is mark indication in case of most full.
The LSB is mark indication in case of most empty.",
      Width => "8",
      Position => "7:0", # Excel Formula: =calc_position(F78,E79,TRUE)
      Type => "Config",
      UsedBy => "CGM_deq",
      DefaultValue => "h0",
    },
  },
  BuffersConsumptionLutForDeq118 => { #Structure Type: Reg; ArrayLength: 128; ArrayIndex: 118; ArrayLocationInName: 28;
    Name => "BuffersConsumptionLutForDeq[128]",
    RegMem => "Reg",
    Address => "1B5",
    Description => "LUT for dequeue marking in VOQ-CGM based on Buffer Consumption.
Index in Array is {Profile,BufferAvailableLevel}
Profile is 5 bits
BufferAvailableLevel is quantized to 2 bits.",
    Width => "8", # Excel Formula: =calc_reg_width(E79:E79,F79)
    Type => "Config",
    AdditionalInfo => "PackArrayToBus",
    Comments => "VOQ_CGM
CGM Deq Marking logic implemented in FF.
Address is {VOQ_PROFILE,Buffer_pool_available_level}
5 + 2 = 7
Buffer_voq_size_level selects offset out of 8.",
    ArrayLength => "128",
    ArrayIndex => "118",
    DeqBufferCongestionMark118 => { #Structure Type: RegField; ArrayLength: 128; ArrayIndex: 118; ArrayLocationInName: 24;
      Name => "DeqBufferCongestionMark[n]",
      RegMem => "RegField",
      Description => "Fill level of VOQ in buffers selects between the 8 values for a given {Profile,BufferAvailableLevel} pair.
The MSB is mark indication in case of most full.
The LSB is mark indication in case of most empty.",
      Width => "8",
      Position => "7:0", # Excel Formula: =calc_position(F78,E79,TRUE)
      Type => "Config",
      UsedBy => "CGM_deq",
      DefaultValue => "h0",
    },
  },
  BuffersConsumptionLutForDeq119 => { #Structure Type: Reg; ArrayLength: 128; ArrayIndex: 119; ArrayLocationInName: 28;
    Name => "BuffersConsumptionLutForDeq[128]",
    RegMem => "Reg",
    Address => "1B6",
    Description => "LUT for dequeue marking in VOQ-CGM based on Buffer Consumption.
Index in Array is {Profile,BufferAvailableLevel}
Profile is 5 bits
BufferAvailableLevel is quantized to 2 bits.",
    Width => "8", # Excel Formula: =calc_reg_width(E79:E79,F79)
    Type => "Config",
    AdditionalInfo => "PackArrayToBus",
    Comments => "VOQ_CGM
CGM Deq Marking logic implemented in FF.
Address is {VOQ_PROFILE,Buffer_pool_available_level}
5 + 2 = 7
Buffer_voq_size_level selects offset out of 8.",
    ArrayLength => "128",
    ArrayIndex => "119",
    DeqBufferCongestionMark119 => { #Structure Type: RegField; ArrayLength: 128; ArrayIndex: 119; ArrayLocationInName: 24;
      Name => "DeqBufferCongestionMark[n]",
      RegMem => "RegField",
      Description => "Fill level of VOQ in buffers selects between the 8 values for a given {Profile,BufferAvailableLevel} pair.
The MSB is mark indication in case of most full.
The LSB is mark indication in case of most empty.",
      Width => "8",
      Position => "7:0", # Excel Formula: =calc_position(F78,E79,TRUE)
      Type => "Config",
      UsedBy => "CGM_deq",
      DefaultValue => "h0",
    },
  },
  BuffersConsumptionLutForDeq120 => { #Structure Type: Reg; ArrayLength: 128; ArrayIndex: 120; ArrayLocationInName: 28;
    Name => "BuffersConsumptionLutForDeq[128]",
    RegMem => "Reg",
    Address => "1B7",
    Description => "LUT for dequeue marking in VOQ-CGM based on Buffer Consumption.
Index in Array is {Profile,BufferAvailableLevel}
Profile is 5 bits
BufferAvailableLevel is quantized to 2 bits.",
    Width => "8", # Excel Formula: =calc_reg_width(E79:E79,F79)
    Type => "Config",
    AdditionalInfo => "PackArrayToBus",
    Comments => "VOQ_CGM
CGM Deq Marking logic implemented in FF.
Address is {VOQ_PROFILE,Buffer_pool_available_level}
5 + 2 = 7
Buffer_voq_size_level selects offset out of 8.",
    ArrayLength => "128",
    ArrayIndex => "120",
    DeqBufferCongestionMark120 => { #Structure Type: RegField; ArrayLength: 128; ArrayIndex: 120; ArrayLocationInName: 24;
      Name => "DeqBufferCongestionMark[n]",
      RegMem => "RegField",
      Description => "Fill level of VOQ in buffers selects between the 8 values for a given {Profile,BufferAvailableLevel} pair.
The MSB is mark indication in case of most full.
The LSB is mark indication in case of most empty.",
      Width => "8",
      Position => "7:0", # Excel Formula: =calc_position(F78,E79,TRUE)
      Type => "Config",
      UsedBy => "CGM_deq",
      DefaultValue => "h0",
    },
  },
  BuffersConsumptionLutForDeq121 => { #Structure Type: Reg; ArrayLength: 128; ArrayIndex: 121; ArrayLocationInName: 28;
    Name => "BuffersConsumptionLutForDeq[128]",
    RegMem => "Reg",
    Address => "1B8",
    Description => "LUT for dequeue marking in VOQ-CGM based on Buffer Consumption.
Index in Array is {Profile,BufferAvailableLevel}
Profile is 5 bits
BufferAvailableLevel is quantized to 2 bits.",
    Width => "8", # Excel Formula: =calc_reg_width(E79:E79,F79)
    Type => "Config",
    AdditionalInfo => "PackArrayToBus",
    Comments => "VOQ_CGM
CGM Deq Marking logic implemented in FF.
Address is {VOQ_PROFILE,Buffer_pool_available_level}
5 + 2 = 7
Buffer_voq_size_level selects offset out of 8.",
    ArrayLength => "128",
    ArrayIndex => "121",
    DeqBufferCongestionMark121 => { #Structure Type: RegField; ArrayLength: 128; ArrayIndex: 121; ArrayLocationInName: 24;
      Name => "DeqBufferCongestionMark[n]",
      RegMem => "RegField",
      Description => "Fill level of VOQ in buffers selects between the 8 values for a given {Profile,BufferAvailableLevel} pair.
The MSB is mark indication in case of most full.
The LSB is mark indication in case of most empty.",
      Width => "8",
      Position => "7:0", # Excel Formula: =calc_position(F78,E79,TRUE)
      Type => "Config",
      UsedBy => "CGM_deq",
      DefaultValue => "h0",
    },
  },
  BuffersConsumptionLutForDeq122 => { #Structure Type: Reg; ArrayLength: 128; ArrayIndex: 122; ArrayLocationInName: 28;
    Name => "BuffersConsumptionLutForDeq[128]",
    RegMem => "Reg",
    Address => "1B9",
    Description => "LUT for dequeue marking in VOQ-CGM based on Buffer Consumption.
Index in Array is {Profile,BufferAvailableLevel}
Profile is 5 bits
BufferAvailableLevel is quantized to 2 bits.",
    Width => "8", # Excel Formula: =calc_reg_width(E79:E79,F79)
    Type => "Config",
    AdditionalInfo => "PackArrayToBus",
    Comments => "VOQ_CGM
CGM Deq Marking logic implemented in FF.
Address is {VOQ_PROFILE,Buffer_pool_available_level}
5 + 2 = 7
Buffer_voq_size_level selects offset out of 8.",
    ArrayLength => "128",
    ArrayIndex => "122",
    DeqBufferCongestionMark122 => { #Structure Type: RegField; ArrayLength: 128; ArrayIndex: 122; ArrayLocationInName: 24;
      Name => "DeqBufferCongestionMark[n]",
      RegMem => "RegField",
      Description => "Fill level of VOQ in buffers selects between the 8 values for a given {Profile,BufferAvailableLevel} pair.
The MSB is mark indication in case of most full.
The LSB is mark indication in case of most empty.",
      Width => "8",
      Position => "7:0", # Excel Formula: =calc_position(F78,E79,TRUE)
      Type => "Config",
      UsedBy => "CGM_deq",
      DefaultValue => "h0",
    },
  },
  BuffersConsumptionLutForDeq123 => { #Structure Type: Reg; ArrayLength: 128; ArrayIndex: 123; ArrayLocationInName: 28;
    Name => "BuffersConsumptionLutForDeq[128]",
    RegMem => "Reg",
    Address => "1BA",
    Description => "LUT for dequeue marking in VOQ-CGM based on Buffer Consumption.
Index in Array is {Profile,BufferAvailableLevel}
Profile is 5 bits
BufferAvailableLevel is quantized to 2 bits.",
    Width => "8", # Excel Formula: =calc_reg_width(E79:E79,F79)
    Type => "Config",
    AdditionalInfo => "PackArrayToBus",
    Comments => "VOQ_CGM
CGM Deq Marking logic implemented in FF.
Address is {VOQ_PROFILE,Buffer_pool_available_level}
5 + 2 = 7
Buffer_voq_size_level selects offset out of 8.",
    ArrayLength => "128",
    ArrayIndex => "123",
    DeqBufferCongestionMark123 => { #Structure Type: RegField; ArrayLength: 128; ArrayIndex: 123; ArrayLocationInName: 24;
      Name => "DeqBufferCongestionMark[n]",
      RegMem => "RegField",
      Description => "Fill level of VOQ in buffers selects between the 8 values for a given {Profile,BufferAvailableLevel} pair.
The MSB is mark indication in case of most full.
The LSB is mark indication in case of most empty.",
      Width => "8",
      Position => "7:0", # Excel Formula: =calc_position(F78,E79,TRUE)
      Type => "Config",
      UsedBy => "CGM_deq",
      DefaultValue => "h0",
    },
  },
  BuffersConsumptionLutForDeq124 => { #Structure Type: Reg; ArrayLength: 128; ArrayIndex: 124; ArrayLocationInName: 28;
    Name => "BuffersConsumptionLutForDeq[128]",
    RegMem => "Reg",
    Address => "1BB",
    Description => "LUT for dequeue marking in VOQ-CGM based on Buffer Consumption.
Index in Array is {Profile,BufferAvailableLevel}
Profile is 5 bits
BufferAvailableLevel is quantized to 2 bits.",
    Width => "8", # Excel Formula: =calc_reg_width(E79:E79,F79)
    Type => "Config",
    AdditionalInfo => "PackArrayToBus",
    Comments => "VOQ_CGM
CGM Deq Marking logic implemented in FF.
Address is {VOQ_PROFILE,Buffer_pool_available_level}
5 + 2 = 7
Buffer_voq_size_level selects offset out of 8.",
    ArrayLength => "128",
    ArrayIndex => "124",
    DeqBufferCongestionMark124 => { #Structure Type: RegField; ArrayLength: 128; ArrayIndex: 124; ArrayLocationInName: 24;
      Name => "DeqBufferCongestionMark[n]",
      RegMem => "RegField",
      Description => "Fill level of VOQ in buffers selects between the 8 values for a given {Profile,BufferAvailableLevel} pair.
The MSB is mark indication in case of most full.
The LSB is mark indication in case of most empty.",
      Width => "8",
      Position => "7:0", # Excel Formula: =calc_position(F78,E79,TRUE)
      Type => "Config",
      UsedBy => "CGM_deq",
      DefaultValue => "h0",
    },
  },
  BuffersConsumptionLutForDeq125 => { #Structure Type: Reg; ArrayLength: 128; ArrayIndex: 125; ArrayLocationInName: 28;
    Name => "BuffersConsumptionLutForDeq[128]",
    RegMem => "Reg",
    Address => "1BC",
    Description => "LUT for dequeue marking in VOQ-CGM based on Buffer Consumption.
Index in Array is {Profile,BufferAvailableLevel}
Profile is 5 bits
BufferAvailableLevel is quantized to 2 bits.",
    Width => "8", # Excel Formula: =calc_reg_width(E79:E79,F79)
    Type => "Config",
    AdditionalInfo => "PackArrayToBus",
    Comments => "VOQ_CGM
CGM Deq Marking logic implemented in FF.
Address is {VOQ_PROFILE,Buffer_pool_available_level}
5 + 2 = 7
Buffer_voq_size_level selects offset out of 8.",
    ArrayLength => "128",
    ArrayIndex => "125",
    DeqBufferCongestionMark125 => { #Structure Type: RegField; ArrayLength: 128; ArrayIndex: 125; ArrayLocationInName: 24;
      Name => "DeqBufferCongestionMark[n]",
      RegMem => "RegField",
      Description => "Fill level of VOQ in buffers selects between the 8 values for a given {Profile,BufferAvailableLevel} pair.
The MSB is mark indication in case of most full.
The LSB is mark indication in case of most empty.",
      Width => "8",
      Position => "7:0", # Excel Formula: =calc_position(F78,E79,TRUE)
      Type => "Config",
      UsedBy => "CGM_deq",
      DefaultValue => "h0",
    },
  },
  BuffersConsumptionLutForDeq126 => { #Structure Type: Reg; ArrayLength: 128; ArrayIndex: 126; ArrayLocationInName: 28;
    Name => "BuffersConsumptionLutForDeq[128]",
    RegMem => "Reg",
    Address => "1BD",
    Description => "LUT for dequeue marking in VOQ-CGM based on Buffer Consumption.
Index in Array is {Profile,BufferAvailableLevel}
Profile is 5 bits
BufferAvailableLevel is quantized to 2 bits.",
    Width => "8", # Excel Formula: =calc_reg_width(E79:E79,F79)
    Type => "Config",
    AdditionalInfo => "PackArrayToBus",
    Comments => "VOQ_CGM
CGM Deq Marking logic implemented in FF.
Address is {VOQ_PROFILE,Buffer_pool_available_level}
5 + 2 = 7
Buffer_voq_size_level selects offset out of 8.",
    ArrayLength => "128",
    ArrayIndex => "126",
    DeqBufferCongestionMark126 => { #Structure Type: RegField; ArrayLength: 128; ArrayIndex: 126; ArrayLocationInName: 24;
      Name => "DeqBufferCongestionMark[n]",
      RegMem => "RegField",
      Description => "Fill level of VOQ in buffers selects between the 8 values for a given {Profile,BufferAvailableLevel} pair.
The MSB is mark indication in case of most full.
The LSB is mark indication in case of most empty.",
      Width => "8",
      Position => "7:0", # Excel Formula: =calc_position(F78,E79,TRUE)
      Type => "Config",
      UsedBy => "CGM_deq",
      DefaultValue => "h0",
    },
  },
  BuffersConsumptionLutForDeq127 => { #Structure Type: Reg; ArrayLength: 128; ArrayIndex: 127; ArrayLocationInName: 28;
    Name => "BuffersConsumptionLutForDeq[128]",
    RegMem => "Reg",
    Address => "1BE",
    Description => "LUT for dequeue marking in VOQ-CGM based on Buffer Consumption.
Index in Array is {Profile,BufferAvailableLevel}
Profile is 5 bits
BufferAvailableLevel is quantized to 2 bits.",
    Width => "8", # Excel Formula: =calc_reg_width(E79:E79,F79)
    Type => "Config",
    AdditionalInfo => "PackArrayToBus",
    Comments => "VOQ_CGM
CGM Deq Marking logic implemented in FF.
Address is {VOQ_PROFILE,Buffer_pool_available_level}
5 + 2 = 7
Buffer_voq_size_level selects offset out of 8.",
    ArrayLength => "128",
    ArrayIndex => "127",
    DeqBufferCongestionMark127 => { #Structure Type: RegField; ArrayLength: 128; ArrayIndex: 127; ArrayLocationInName: 24;
      Name => "DeqBufferCongestionMark[n]",
      RegMem => "RegField",
      Description => "Fill level of VOQ in buffers selects between the 8 values for a given {Profile,BufferAvailableLevel} pair.
The MSB is mark indication in case of most full.
The LSB is mark indication in case of most empty.",
      Width => "8",
      Position => "7:0", # Excel Formula: =calc_position(F78,E79,TRUE)
      Type => "Config",
      UsedBy => "CGM_deq",
      DefaultValue => "h0",
    },
  },
  PdConsumptionLutForDeq => { #Structure Type: Reg;
    Name => "PdConsumptionLutForDeq",
    RegMem => "Reg",
    Address => "1BF", # Excel Formula: =calc_reg_address(C78,A78,G78)
    Description => "LUT for dequeue marking in VOQ-CGM based on Pd Consumption.
Decision is taken from offset {Profile,PktAvailableLevel}
Profile is 5 bits
PktAvailableLevel is quantized to 2 bits.",
    Width => "128", # Excel Formula: =calc_reg_width(E81:E81,F81)
    Type => "Config",
    DeqPktCongestionMark => { #Structure Type: RegField;
      Name => "DeqPktCongestionMark",
      RegMem => "RegField",
      Description => "Mark decision is taken from offset {Profile,PktAvailableLevel} ",
      Width => "128", # Excel Formula: =calc_field_width_define("VOQ_CGM_NUM_OF_PROFILES")*4
      Position => "127:0", # Excel Formula: =calc_position(F80,E81,TRUE)
      Type => "Config",
      UsedBy => "CGM_deq",
      DefaultValue => "h0",
    },
  },
  VoqCgmAgingMachineCnf => { #Structure Type: Reg;
    Name => "VoqCgmAgingMachineCnf",
    RegMem => "Reg",
    Address => "1C0", # Excel Formula: =calc_reg_address(C80,A80,G80)
    Description => "ConfigRegisters for aging machine",
    Width => "7", # Excel Formula: =calc_reg_width(E83:E84,F84)
    Type => "Config",
    Comments => "VOQ_CGM",
    VoqCgmAgingStartOffset => { #Structure Type: RegField;
      Name => "VoqCgmAgingStartOffset",
      RegMem => "RegField",
      Description => "Triggers the aging machine scan when local time matches this value.
Local time is in 1us or 2us depending on PDVOQ configuration
The Scan takes ~4us.
This value must allow the scan to finish before the local time wraps around.",
      Width => "6", # Excel Formula: =calc_field_width_define("VOQ_CGM_ENQ_TIME_WIDTH")-2
      Position => "5:0", # Excel Formula: =calc_position(F82,E83,TRUE)
      Type => "Config",
      UsedBy => "cgm_aging",
      DefaultValue => "d50",
    },
    VoqCgmAgingDisable => { #Structure Type: RegField;
      Name => "VoqCgmAgingDisable",
      RegMem => "RegField",
      Description => "Disable aging machine altogether",
      Width => "1",
      Position => "6", # Excel Formula: =calc_position(F83,E84)
      Type => "Config",
      UsedBy => "cgm_aging",
      DefaultValue => "h0",
    },
  },
  VoqCgmEnqTimeFifoCfg => { #Structure Type: Reg;
    Name => "VoqCgmEnqTimeFifoCfg",
    RegMem => "Reg",
    Address => "1C1", # Excel Formula: =calc_reg_address(C82,A82,G82)
    Description => "Config Register for fifo that stores the enq time of a PD between read report and Deq Cmd ",
    Width => "1", # Excel Formula: =calc_reg_width(E86:E86,F86)
    Type => "Config",
    Comments => "VOQ_CGM",
    BypassEnqTimeFifo => { #Structure Type: RegField;
      Name => "BypassEnqTimeFifo",
      RegMem => "RegField",
      Description => "Bypass Fifo",
      Width => "1",
      Position => "0", # Excel Formula: =calc_position(F85,E86,TRUE)
      Type => "Config",
      UsedBy => "voq_cgm",
      DefaultValue => "b0",
      Comments => "Chicken Bit",
    },
  },
  rdrqsn => { #Structure Type: Mem;
    Name => "rdrqsn",
    RegMem => "Mem",
    Address => "100000",
    Description => "Read request sequence number, entry per queue, each entry is initialized to the entry number. The sequence number is incremented (RMW) every read-request command and written to an old sequence number value in case the ICS asks for retransmit (on dequeue-command).",
    Width => "20", # Excel Formula: =calc_mem_width(E88:E88,M87,F88,-1)
    Type => "Dynamic",
    UsedBy => "rqm: Write ,rqm: Read",
    MemEntries => "3072", # Excel Formula: =calc_field_width_define("NUM_OF_CONTEXTS_FABRIC_SLICE")
    MemWrapper => "1R1W",
    MemProtect => "ECC",
    AdditionalInfo => "SampleReadBeforeProt=2,SampleReadAfterProt=1,SampleWriteAfterProt=1,CpuReadAccess=Enabled,CpuWriteAccess=Enabled,DisableSameAddressErr=Enabled,WriteActivityFactor=100,ReadActivityFactor=100,PortErrPropagate=Disabled",
    MemLogicalWidth => "14",
    rdrqsndata => { #Structure Type: MemField;
      Name => "rdrqsndata",
      RegMem => "MemField",
      Width => "14", # Excel Formula: =calc_field_width_define("QSIZE_PKT_WIDTH")
      Position => "13:0", # Excel Formula: =calc_position(F87,E88,TRUE)
    },
  },
  rdsn => { #Structure Type: Mem;
    Name => "rdsn",
    RegMem => "Mem",
    Address => "200000", # Excel Formula: =calc_mem_address(C87,A87,G89,L89)
    Description => "Read sequence number, entry per queue, each entry is initialized to the entry number. 
The sequence number is incremented every dequeue-command from the ICS and read every enqueue-command by the write-queue-manager. ",
    Width => "20", # Excel Formula: =calc_mem_width(E90:E90,M89,F90,-1)
    Type => "Dynamic",
    UsedBy => "rqm: Write,rqm: Read0 ,wqm: Read1",
    MemEntries => "3072", # Excel Formula: =calc_field_width_define("NUM_OF_CONTEXTS_FABRIC_SLICE")
    MemWrapper => "2R1W Fast Write",
    MemProtect => "ECC",
    AdditionalInfo => "SampleReadBeforeProt=2,SampleReadAfterProt=1,SampleWriteAfterProt=1,CpuReadAccess=Enabled,CpuWriteAccess=Enabled,DisableSameAddressErr=Enabled,WriteActivityFactor=100,ReadActivityFactor=100,PortErrPropagate=Disabled",
    MemLogicalWidth => "14",
    rdsndata => { #Structure Type: MemField;
      Name => "rdsndata",
      RegMem => "MemField",
      Width => "14", # Excel Formula: =calc_field_width_define("QSIZE_PKT_WIDTH")
      Position => "13:0", # Excel Formula: =calc_position(F89,E90,TRUE)
    },
  },
  rdbc => { #Structure Type: Mem;
    Name => "rdbc",
    RegMem => "Mem",
    Address => "300000", # Excel Formula: =calc_mem_address(C89,A89,G91,L91)
    Description => "Read bytes count, entry per queue, initialized to 0. The read bytes count is incremented (RMW) with the packet size every dequeue-command from the ICS, and read every enqueue-command, 2R+W memory.",
    Width => "29", # Excel Formula: =calc_mem_width(E92:E92,M91,F92,-1)
    Type => "Dynamic",
    UsedBy => "rqm: Write,rqm: Read0 ,wqm: Read1",
    MemEntries => "3072", # Excel Formula: =calc_field_width_define("NUM_OF_CONTEXTS_FABRIC_SLICE")
    MemWrapper => "2R1W Fast Write",
    MemProtect => "ECC",
    AdditionalInfo => "SampleReadBeforeProt=2,SampleReadAfterProt=1,SampleWriteAfterProt=1,CpuReadAccess=Enabled,CpuWriteAccess=Enabled,DisableSameAddressErr=Enabled,WriteActivityFactor=100,ReadActivityFactor=100,PortErrPropagate=Disabled",
    MemLogicalWidth => "23",
    rdbcdata => { #Structure Type: MemField;
      Name => "rdbcdata",
      RegMem => "MemField",
      Width => "23", # Excel Formula: =calc_field_width_define("QSIZE_BYT_WIDTH")
      Position => "22:0", # Excel Formula: =calc_position(F91,E92,TRUE)
    },
  },
  rdbufcnt => { #Structure Type: Mem;
    Name => "rdbufcnt",
    RegMem => "Mem",
    Address => "400000", # Excel Formula: =calc_mem_address(C91,A91,G93,L93)
    Description => "Similar to rdbc but in SMS buffers.
CGM need to know the queue size in SMS buffer units.
SMS buffer is 384B.",
    Width => "20", # Excel Formula: =calc_mem_width(E94:E94,M93,F94,-1)
    Type => "Dynamic",
    UsedBy => "rqm: Write,rqm: Read0 ,wqm: Read1",
    MemEntries => "3072", # Excel Formula: =calc_field_width_define("NUM_OF_CONTEXTS_FABRIC_SLICE")
    MemWrapper => "2R1W Fast Write",
    MemProtect => "ECC",
    AdditionalInfo => "SampleReadBeforeProt=2,SampleReadAfterProt=1,SampleWriteAfterProt=1,CpuReadAccess=Enabled,CpuWriteAccess=Enabled,DisableSameAddressErr=Enabled,WriteActivityFactor=100,ReadActivityFactor=100,PortErrPropagate=Disabled",
    MemLogicalWidth => "14",
    rdbufcntdata => { #Structure Type: MemField;
      Name => "rdbufcntdata",
      RegMem => "MemField",
      Width => "14", # Excel Formula: =calc_field_width_define("QSIZE_BUF_WIDTH")
      Position => "13:0", # Excel Formula: =calc_position(F93,E94,TRUE)
    },
  },
  wrrqsn => { #Structure Type: Mem;
    Name => "wrrqsn",
    RegMem => "Mem",
    Address => "500000", # Excel Formula: =calc_mem_address(C93,A93,G95,L95)
    Description => "Write request sequence number, entry per queue. Each entry is initialized to the entry number (in order to prevent pressure on the first exact-match core).

The sequence number is incremented by the write-queue-manager (RMW) every enqueue-command, R+W (Two ports) memory.",
    Width => "20", # Excel Formula: =calc_mem_width(E96:E96,M95,F96,-1)
    Type => "Dynamic",
    UsedBy => "wqm: Write,wqm: Read0 ,rqm: Read1",
    MemEntries => "3072", # Excel Formula: =calc_field_width_define("NUM_OF_CONTEXTS_FABRIC_SLICE")
    MemWrapper => "2R1W Fast Write",
    MemProtect => "ECC",
    AdditionalInfo => "SampleReadBeforeProt=2,SampleReadAfterProt=1,SampleWriteAfterProt=1,CpuReadAccess=Enabled,CpuWriteAccess=Enabled,DisableSameAddressErr=Enabled,WriteActivityFactor=100,ReadActivityFactor=100,PortErrPropagate=Disabled",
    MemLogicalWidth => "14",
    wrrqsndata => { #Structure Type: MemField;
      Name => "wrrqsndata",
      RegMem => "MemField",
      Width => "14", # Excel Formula: =calc_field_width_define("QSIZE_PKT_WIDTH")
      Position => "13:0", # Excel Formula: =calc_position(F95,E96,TRUE)
    },
  },
  wrsn => { #Structure Type: Mem;
    Name => "wrsn",
    RegMem => "Mem",
    Address => "600000", # Excel Formula: =calc_mem_address(C95,A95,G97,L97)
    Description => "Write sequence number, entry per queue, each entry is initialized to the entry number. 
The sequence number increments every write report (read-increment-write) and read every De-queue command, 2R+W memory.
",
    Width => "20", # Excel Formula: =calc_mem_width(E98:E98,M97,F98,-1)
    Type => "Dynamic",
    UsedBy => "wqm: Write ,wqm: Read",
    MemEntries => "3072", # Excel Formula: =calc_field_width_define("NUM_OF_CONTEXTS_FABRIC_SLICE")
    MemWrapper => "1R1W",
    MemProtect => "ECC",
    AdditionalInfo => "SampleReadBeforeProt=2,SampleReadAfterProt=1,SampleWriteAfterProt=1,CpuReadAccess=Enabled,CpuWriteAccess=Enabled,DisableSameAddressErr=Enabled,WriteActivityFactor=100,ReadActivityFactor=100,PortErrPropagate=Disabled",
    MemLogicalWidth => "14",
    wrsndata => { #Structure Type: MemField;
      Name => "wrsndata",
      RegMem => "MemField",
      Width => "14", # Excel Formula: =calc_field_width_define("QSIZE_PKT_WIDTH")
      Position => "13:0", # Excel Formula: =calc_position(F97,E98,TRUE)
    },
  },
  wrbc => { #Structure Type: Mem;
    Name => "wrbc",
    RegMem => "Mem",
    Address => "700000", # Excel Formula: =calc_mem_address(C97,A97,G99,L99)
    Description => "Write bytes count, entry per queue, initialized to 0. 
The write bytes count is incremented (RMW) in packet size every write-report and read every dequeue-command, 2R+W memory.",
    Width => "29", # Excel Formula: =calc_mem_width(E100:E100,M99,F100,-1)
    Type => "Dynamic",
    UsedBy => "wqm: Write,wqm: Read0 ,rqm: Read1",
    MemEntries => "3072", # Excel Formula: =calc_field_width_define("NUM_OF_CONTEXTS_FABRIC_SLICE")
    MemWrapper => "2R1W Fast Write",
    MemProtect => "ECC",
    AdditionalInfo => "SampleReadBeforeProt=2,SampleReadAfterProt=1,SampleWriteAfterProt=1,CpuReadAccess=Enabled,CpuWriteAccess=Enabled,DisableSameAddressErr=Enabled,WriteActivityFactor=100,ReadActivityFactor=100,PortErrPropagate=Disabled",
    MemLogicalWidth => "23",
    wrbcdata => { #Structure Type: MemField;
      Name => "wrbcdata",
      RegMem => "MemField",
      Width => "23", # Excel Formula: =calc_field_width_define("QSIZE_BYT_WIDTH")
      Position => "22:0", # Excel Formula: =calc_position(F99,E100,TRUE)
    },
  },
  wrbufcnt => { #Structure Type: Mem;
    Name => "wrbufcnt",
    RegMem => "Mem",
    Address => "800000", # Excel Formula: =calc_mem_address(C99,A99,G101,L101)
    Description => "Similar to wrbc but in SMS buffers.
CGM need to know the queue size in SMS buffer units.
SMS buffer is 384B.",
    Width => "20", # Excel Formula: =calc_mem_width(E102:E102,M101,F102,-1)
    Type => "Dynamic",
    UsedBy => "wqm: Write,wqm: Read0 ,rqm: Read1",
    MemEntries => "3072", # Excel Formula: =calc_field_width_define("NUM_OF_CONTEXTS_FABRIC_SLICE")
    MemWrapper => "2R1W Fast Write",
    MemProtect => "ECC",
    AdditionalInfo => "SampleReadBeforeProt=2,SampleReadAfterProt=1,SampleWriteAfterProt=1,CpuReadAccess=Enabled,CpuWriteAccess=Enabled,DisableSameAddressErr=Enabled,WriteActivityFactor=100,ReadActivityFactor=100,PortErrPropagate=Disabled",
    MemLogicalWidth => "14",
    wrbufcntdata => { #Structure Type: MemField;
      Name => "wrbufcntdata",
      RegMem => "MemField",
      Width => "14", # Excel Formula: =calc_field_width_define("QSIZE_BUF_WIDTH")
      Position => "13:0", # Excel Formula: =calc_position(F101,E102,TRUE)
    },
  },
  voq2context => { #Structure Type: Mem;
    Name => "voq2context",
    RegMem => "Mem",
    Address => "900000", # Excel Formula: =calc_mem_address(C101,A101,G103,L103)
    Description => "context per voq. Managed by the context mapper. 
Read by ICS when it receives credit-grant and need to translate the VOQ# to context.",
    Width => "18", # Excel Formula: =calc_mem_width(E104:E104,M103,F104,-1)
    Type => "Dynamic",
    UsedBy => "CMAP: Write,CMAP: Read0 ,ICS: Read1",
    MemEntries => "24576", # Excel Formula: =calc_field_width_define("NUM_OF_FABRIC_VOQS")
    MemWrapper => "2R1W Fast Write",
    MemProtect => "ECC",
    AdditionalInfo => "SampleReadAccess=1,SampleReadBeforeProt=2,SampleReadAfterProt=1,SampleWriteAfterProt=1,CpuReadAccess=Enabled,CpuWriteAccess=Enabled,DisableSameAddressErr=Enabled,WriteActivityFactor=10,ReadActivityFactor=75,PortErrPropagate=Disabled",
    MemLogicalWidth => "12",
    voq2contextData => { #Structure Type: MemField;
      Name => "voq2contextData",
      RegMem => "MemField",
      Description => "8k context - 13 bit
Valud of 13'h1FFF mean unused
",
      Width => "12", # Excel Formula: =calc_field_width_define("CONTEXT_WIDTH")
      Position => "11:0", # Excel Formula: =calc_position(F103,E104,TRUE)
    },
  },
  CandRelFifo => { #Structure Type: Mem;
    Name => "CandRelFifo",
    RegMem => "Mem",
    Address => "A00000", # Excel Formula: =calc_mem_address(C103,A103,G105,L105)
    Description => "Fifo to hold context# released by the ICS",
    Width => "18", # Excel Formula: =calc_mem_width(E106:E106,M105,F106,-1)
    Type => "Dynamic",
    UsedBy => "CMAP",
    MemEntries => "2048", # Excel Formula: =2048
    MemWrapper => "Fifo",
    MemProtect => "ECC",
    AdditionalInfo => "SampleReadAccess=1,SampleReadBeforeProt=1,SampleReadAfterProt=1,SampleWriteAfterProt=1,DisableSameAddressErr=Enabled,WriteActivityFactor=10,ReadActivityFactor=10,PortErrPropagate=Disabled,CpuReadAccess=Disabled,CpuWriteAccess=Disabled",
    MemLogicalWidth => "12",
    ContextToRelease => { #Structure Type: MemField;
      Name => "ContextToRelease",
      RegMem => "MemField",
      Width => "12", # Excel Formula: =calc_field_width_define("CONTEXT_WIDTH")
      Position => "11:0", # Excel Formula: =calc_position(F105,E106,TRUE)
    },
  },
  InCandRelFifoSet => { #Structure Type: Mem;
    Name => "InCandRelFifoSet",
    RegMem => "Mem",
    Address => "B00000", # Excel Formula: =calc_mem_address(C105,A105,G107,L107)
    Description => "The context resides in the CandRelFifo - set-clear-read to prevent double entries in the fifo",
    Width => "72", # Excel Formula: =calc_mem_width(E108:E108,M107,F108,-1)
    Type => "Dynamic",
    UsedBy => "CMAP",
    MemEntries => "64", # Excel Formula: =calc_field_width_define("NUM_OF_CONTEXTS")/E108
    MemWrapper => "2R1W Fast Write",
    MemProtect => "ECC",
    AdditionalInfo => "SampleReadBeforeProt=1,SampleReadAfterProt=1,SampleWriteAfterProt=1,DisableSameAddressErr=Enabled,WriteActivityFactor=10,ReadActivityFactor=10,PortErrPropagate=Disabled,CpuReadAccess=Disabled,CpuWriteAccess=Disabled",
    Comments => "s+c+r imp",
    MemLogicalWidth => "64",
    ctxRelSet => { #Structure Type: MemField;
      Name => "ctxRelSet",
      RegMem => "MemField",
      Width => "64",
      Position => "63:0", # Excel Formula: =calc_position(F107,E108,TRUE)
    },
  },
  InCandRelFifoClr => { #Structure Type: Mem;
    Name => "InCandRelFifoClr",
    RegMem => "Mem",
    Address => "C00000", # Excel Formula: =calc_mem_address(C107,A107,G109,L109)
    Description => "The context resides in the CandRelFifo - set-clear-read to prevent double entries in the fifo",
    Width => "72", # Excel Formula: =calc_mem_width(E110:E110,M109,F110,-1)
    Type => "Dynamic",
    UsedBy => "CMAP",
    MemEntries => "64", # Excel Formula: =calc_field_width_define("NUM_OF_CONTEXTS")/E110
    MemWrapper => "2R1W Fast Write",
    MemProtect => "ECC",
    AdditionalInfo => "SampleReadBeforeProt=1,SampleReadAfterProt=1,SampleWriteAfterProt=1,DisableSameAddressErr=Enabled,WriteActivityFactor=10,ReadActivityFactor=10,PortErrPropagate=Disabled,CpuReadAccess=Disabled,CpuWriteAccess=Disabled",
    Comments => "s+c+r imp",
    MemLogicalWidth => "64",
    ctxRelClr => { #Structure Type: MemField;
      Name => "ctxRelClr",
      RegMem => "MemField",
      Width => "64",
      Position => "63:0", # Excel Formula: =calc_position(F109,E110,TRUE)
    },
  },
  ContextReleaseEligibleSet => { #Structure Type: Mem;
    Name => "ContextReleaseEligibleSet",
    RegMem => "Mem",
    Address => "D00000", # Excel Formula: =calc_mem_address(C109,A109,G111,L111)
    Description => "The context is empty and thus ready for release SCRP",
    Width => "72", # Excel Formula: =calc_mem_width(E112:E112,M111,F112,-1)
    Type => "Dynamic",
    UsedBy => "CMAP",
    MemEntries => "64", # Excel Formula: =calc_field_width_define("NUM_OF_CONTEXTS")/E112
    MemWrapper => "3R1W Fast Write",
    MemProtect => "ECC",
    AdditionalInfo => "SampleReadBeforeProt=1,SampleReadAfterProt=1,SampleWriteAfterProt=1,DisableSameAddressErr=Enabled,WriteActivityFactor=100,ReadActivityFactor=10,PortErrPropagate=Disabled,CpuReadAccess=Disabled,CpuWriteAccess=Disabled",
    Comments => "s+c+r imp",
    MemLogicalWidth => "64",
    ctxRelElgblSet => { #Structure Type: MemField;
      Name => "ctxRelElgblSet",
      RegMem => "MemField",
      Width => "64",
      Position => "63:0", # Excel Formula: =calc_position(F111,E112,TRUE)
    },
  },
  ContextReleaseEligibleClr => { #Structure Type: Mem;
    Name => "ContextReleaseEligibleClr",
    RegMem => "Mem",
    Address => "E00000", # Excel Formula: =calc_mem_address(C111,A111,G113,L113)
    Description => "The context is empty and thus ready for release SCRP",
    Width => "72", # Excel Formula: =calc_mem_width(E114:E114,M113,F114,-1)
    Type => "Dynamic",
    UsedBy => "CMAP",
    MemEntries => "64", # Excel Formula: =calc_field_width_define("NUM_OF_CONTEXTS")/E114
    MemWrapper => "3R1W Fast Write",
    MemProtect => "ECC",
    AdditionalInfo => "SampleReadBeforeProt=1,SampleReadAfterProt=1,SampleWriteAfterProt=1,DisableSameAddressErr=Enabled,WriteActivityFactor=100,ReadActivityFactor=10,PortErrPropagate=Disabled,CpuReadAccess=Disabled,CpuWriteAccess=Disabled",
    Comments => "s+c+r imp",
    MemLogicalWidth => "64",
    ctxRelElgblClr => { #Structure Type: MemField;
      Name => "ctxRelElgblClr",
      RegMem => "MemField",
      Width => "64",
      Position => "63:0", # Excel Formula: =calc_position(F113,E114,TRUE)
    },
  },
  ContextInDramSet => { #Structure Type: Mem;
    Name => "ContextInDramSet",
    RegMem => "Mem",
    Address => "F00000", # Excel Formula: =calc_mem_address(C113,A113,G115,L115)
    Description => "The context is in the DRAM and thus it is not ready for release SCR",
    Width => "72", # Excel Formula: =calc_mem_width(E116:E116,M115,F116,-1)
    Type => "Dynamic",
    UsedBy => "CMAP",
    MemEntries => "64", # Excel Formula: =calc_field_width_define("NUM_OF_CONTEXTS")/E116
    MemWrapper => "2R1W Fast Write",
    MemProtect => "ECC",
    AdditionalInfo => "SampleReadBeforeProt=1,SampleReadAfterProt=1,SampleWriteAfterProt=1,DisableSameAddressErr=Enabled,WriteActivityFactor=10,ReadActivityFactor=10,PortErrPropagate=Disabled,CpuReadAccess=Disabled,CpuWriteAccess=Disabled",
    Comments => "s+c+r imp",
    MemLogicalWidth => "64",
    ctxInDramSet => { #Structure Type: MemField;
      Name => "ctxInDramSet",
      RegMem => "MemField",
      Width => "64",
      Position => "63:0", # Excel Formula: =calc_position(F115,E116,TRUE)
    },
  },
  ContextInDramClr => { #Structure Type: Mem;
    Name => "ContextInDramClr",
    RegMem => "Mem",
    Address => "1000000", # Excel Formula: =calc_mem_address(C115,A115,G117,L117)
    Description => "The context is in the DRAM and thus it is not ready for release SCR",
    Width => "72", # Excel Formula: =calc_mem_width(E118:E118,M117,F118,-1)
    Type => "Dynamic",
    UsedBy => "CMAP",
    MemEntries => "64", # Excel Formula: =calc_field_width_define("NUM_OF_CONTEXTS")/E118
    MemWrapper => "2R1W Fast Write",
    MemProtect => "ECC",
    AdditionalInfo => "SampleReadBeforeProt=1,SampleReadAfterProt=1,SampleWriteAfterProt=1,DisableSameAddressErr=Enabled,WriteActivityFactor=10,ReadActivityFactor=10,PortErrPropagate=Disabled,CpuReadAccess=Disabled,CpuWriteAccess=Disabled",
    Comments => "s+c+r imp",
    MemLogicalWidth => "64",
    ctxInDramClr => { #Structure Type: MemField;
      Name => "ctxInDramClr",
      RegMem => "MemField",
      Width => "64",
      Position => "63:0", # Excel Formula: =calc_position(F117,E118,TRUE)
    },
  },
  ContextMapValidSet => { #Structure Type: Mem;
    Name => "ContextMapValidSet",
    RegMem => "Mem",
    Address => "1100000", # Excel Formula: =calc_mem_address(C117,A117,G119,L119)
    Description => "The context is mapped to VOQ (SCR)",
    Width => "72", # Excel Formula: =calc_mem_width(E120:E120,M119,F120,-1)
    Type => "Dynamic",
    UsedBy => "CMAP",
    MemEntries => "64", # Excel Formula: =calc_field_width_define("NUM_OF_CONTEXTS")/E120
    MemWrapper => "2R1W Fast Write",
    MemProtect => "ECC",
    AdditionalInfo => "SampleReadBeforeProt=1,SampleReadAfterProt=1,SampleWriteAfterProt=1,DisableSameAddressErr=Enabled,WriteActivityFactor=10,ReadActivityFactor=10,PortErrPropagate=Disabled,CpuReadAccess=Disabled,CpuWriteAccess=Disabled",
    Comments => "s+c+r imp",
    MemLogicalWidth => "64",
    ctxMapValidSet => { #Structure Type: MemField;
      Name => "ctxMapValidSet",
      RegMem => "MemField",
      Width => "64",
      Position => "63:0", # Excel Formula: =calc_position(F119,E120,TRUE)
    },
  },
  ContextMapValidClr => { #Structure Type: Mem;
    Name => "ContextMapValidClr",
    RegMem => "Mem",
    Address => "1200000", # Excel Formula: =calc_mem_address(C119,A119,G121,L121)
    Description => "The context is mapped to VOQ (SCR)",
    Width => "72", # Excel Formula: =calc_mem_width(E122:E122,M121,F122,-1)
    Type => "Dynamic",
    UsedBy => "CMAP",
    MemEntries => "64", # Excel Formula: =calc_field_width_define("NUM_OF_CONTEXTS")/E122
    MemWrapper => "2R1W Fast Write",
    MemProtect => "ECC",
    AdditionalInfo => "SampleReadBeforeProt=1,SampleReadAfterProt=1,SampleWriteAfterProt=1,DisableSameAddressErr=Enabled,WriteActivityFactor=10,ReadActivityFactor=10,PortErrPropagate=Disabled,CpuReadAccess=Disabled,CpuWriteAccess=Disabled",
    Comments => "s+c+r imp",
    MemLogicalWidth => "64",
    ctxMapValidClr => { #Structure Type: MemField;
      Name => "ctxMapValidClr",
      RegMem => "MemField",
      Width => "64",
      Position => "63:0", # Excel Formula: =calc_position(F121,E122,TRUE)
    },
  },
  contextfbmBmp => { #Structure Type: Mem;
    Name => "contextfbmBmp",
    RegMem => "Mem",
    Address => "1300000", # Excel Formula: =calc_mem_address(C121,A121,G123,L123)
    Description => "bitmap memory for the free buffer manager",
    Width => "72", # Excel Formula: =calc_mem_width(E124:E124,M123,F124,-1)
    Type => "Dynamic",
    UsedBy => "CMAP: Read,CMAP: Write",
    MemEntries => "48", # Excel Formula: =calc_field_width_define("NUM_OF_CONTEXTS_FABRIC_SLICE")/E124
    MemWrapper => "1R1W",
    MemProtect => "ECC",
    AdditionalInfo => "SampleReadAccess=1,SampleReadBeforeProt=1,SampleWriteAfterProt=1,CpuReadAccess=Enabled,CpuWriteAccess=Enabled,DisableSameAddressErr=Enabled,WriteActivityFactor=10,ReadActivityFactor=10,PortErrPropagate=Disabled",
    Comments => "Note that FBM memory must be eq3 ",
    MemLogicalWidth => "64",
    contextfbmBmpdata => { #Structure Type: MemField;
      Name => "contextfbmBmpdata",
      RegMem => "MemField",
      Description => "bitmap",
      Width => "64",
      Position => "63:0", # Excel Formula: =calc_position(F123,E124,TRUE)
    },
  },
  NewVoqSet => { #Structure Type: Mem;
    Name => "NewVoqSet",
    RegMem => "Mem",
    Address => "1400000", # Excel Formula: =calc_mem_address(C123,A123,G125,L125)
    Description => "This context is a new-voq (first credit grant did not arrive / first PD was not transmitted)",
    Width => "72", # Excel Formula: =calc_mem_width(E126:E126,M125,F126,-1)
    Type => "Dynamic",
    UsedBy => "NEWVOQ",
    MemEntries => "64", # Excel Formula: =calc_field_width_define("NUM_OF_CONTEXTS")/E126
    MemWrapper => "3R1W Fast Write",
    MemProtect => "ECC",
    AdditionalInfo => "SampleReadBeforeProt=2,SampleReadAfterProt=1,SampleWriteAfterProt=1,DisableSameAddressErr=Enabled,WriteActivityFactor=0,ReadActivityFactor=100,PortErrPropagate=Disabled,CpuReadAccess=Disabled,CpuWriteAccess=Disabled",
    Comments => "s+c+r imp",
    MemLogicalWidth => "64",
    NewVoqSetBits => { #Structure Type: MemField;
      Name => "NewVoqSetBits",
      RegMem => "MemField",
      Width => "64",
      Position => "63:0", # Excel Formula: =calc_position(F125,E126,TRUE)
    },
  },
  NewVoqClr => { #Structure Type: Mem;
    Name => "NewVoqClr",
    RegMem => "Mem",
    Address => "1500000", # Excel Formula: =calc_mem_address(C125,A125,G127,L127)
    Description => "This context is a new-voq (first credit grant did not arrive / first PD was not transmitted)",
    Width => "72", # Excel Formula: =calc_mem_width(E128:E128,M127,F128,-1)
    Type => "Dynamic",
    UsedBy => "NEWVOQ",
    MemEntries => "64", # Excel Formula: =calc_field_width_define("NUM_OF_CONTEXTS")/E128
    MemWrapper => "3R1W Fast Write",
    MemProtect => "ECC",
    AdditionalInfo => "SampleReadBeforeProt=2,SampleReadAfterProt=1,SampleWriteAfterProt=1,DisableSameAddressErr=Enabled,WriteActivityFactor=0,ReadActivityFactor=100,PortErrPropagate=Disabled,CpuReadAccess=Disabled,CpuWriteAccess=Disabled",
    Comments => "s+c+r imp",
    MemLogicalWidth => "64",
    NewVoqClrBits => { #Structure Type: MemField;
      Name => "NewVoqClrBits",
      RegMem => "MemField",
      Width => "64",
      Position => "63:0", # Excel Formula: =calc_position(F127,E128,TRUE)
    },
  },
  voqProperties => { #Structure Type: Mem;
    Name => "voqProperties",
    RegMem => "Mem",
    Address => "1600000", # Excel Formula: =calc_mem_address(C127,A127,G129,L129)
    Description => "context per voq. Managed by the context mapper. 
Read by ICS when it receives credit-grant and need to translate the VOQ# to context.",
    Width => "137", # Excel Formula: =calc_mem_width(E130:E130,M129,F130,-1)
    Type => "Config",
    UsedBy => "CMAP",
    MemEntries => "1536", # Excel Formula: =calc_field_width_define("NUM_OF_FABRIC_VOQS")/16
    MemWrapper => "1P",
    MemProtect => "ECC",
    AdditionalInfo => "SampleReadBeforeProt=2,SampleReadAfterProt=1,SampleWriteAfterProt=1,CpuReadAccess=Enabled,CpuWriteAccess=Enabled,DisableSameAddressErr=Enabled,WriteActivityFactor=0,ReadActivityFactor=10,PortErrPropagate=Disabled",
    MemLogicalWidth => "128",
    Profile => { #Structure Type: MemField;
      Name => "Profile",
      RegMem => "MemField",
      Description => "16 entries of 8 bit {Type[2:0],Profile[4:0]}
Type code RLB / FLB - HP/LP MC",
      Width => "128", # Excel Formula: =16*(calc_field_width_define("ICS_TYPE_WIDTH") + calc_field_width_define("PDVOQ_QUEUE_PROFILE_WIDTH"))
      Position => "127:0", # Excel Formula: =calc_position(F129,E130,TRUE)
    },
  },
  staticMapping => { #Structure Type: Mem;
    Name => "staticMapping",
    RegMem => "Mem",
    Address => "1700000", # Excel Formula: =calc_mem_address(C129,A129,G131,L131)
    Description => "Mark the static context so they want be reused - returned to the pool",
    Width => "72", # Excel Formula: =calc_mem_width(E132:E132,M131,F132,-1)
    Type => "Config",
    UsedBy => "CMAP",
    MemEntries => "64", # Excel Formula: =calc_field_width_define("NUM_OF_CONTEXTS")/64
    MemWrapper => "1P",
    MemProtect => "ECC",
    AdditionalInfo => "SampleReadAccess=1,SampleReadBeforeProt=2,SampleWriteAfterProt=1,CpuReadAccess=Enabled,CpuWriteAccess=Enabled,DisableSameAddressErr=Enabled,WriteActivityFactor=0,ReadActivityFactor=10,PortErrPropagate=Disabled",
    MemLogicalWidth => "64",
    staticMappingBitmap => { #Structure Type: MemField;
      Name => "staticMappingBitmap",
      RegMem => "MemField",
      Description => "bitmap per 64 contexts.
'1' the context mapping is static - dont return it to the context pool
'0' the context mapping is dynamic - return the context when possible",
      Width => "64",
      Position => "63:0", # Excel Formula: =calc_position(F131,E132,TRUE)
    },
  },
  context_allocate_set_master => { #Structure Type: Mem;
    Name => "context_allocate_set_master",
    RegMem => "Mem",
    Address => "1800000", # Excel Formula: =calc_mem_address(C131,A131,G133,L133)
    Description => "VOQ is allocated to context (SCR)",
    Width => "39", # Excel Formula: =calc_mem_width(E134:E134,M133,F134,-1)
    Type => "Dynamic",
    UsedBy => "CMAP: Read,CMAP: Write",
    MemEntries => "768", # Excel Formula: =calc_field_width_define("NUM_OF_FABRIC_VOQS")/32
    MemWrapper => "1R1W",
    MemProtect => "ECC",
    AdditionalInfo => "SampleReadAccess=1,SampleReadBeforeProt=2,SampleWriteAfterProt=1,CpuReadAccess=Enabled,CpuWriteAccess=Enabled,DisableSameAddressErr=Enabled,WriteActivityFactor=10,ReadActivityFactor=10,PortErrPropagate=Disabled",
    MemLogicalWidth => "32",
    bitmap_a => { #Structure Type: MemField;
      Name => "bitmap_a",
      RegMem => "MemField",
      Width => "32",
      Position => "31:0", # Excel Formula: =calc_position(F133,E134,TRUE)
    },
  },
  context_allocate_set_slave => { #Structure Type: Mem;
    Name => "context_allocate_set_slave",
    RegMem => "Mem",
    Address => "1900000", # Excel Formula: =calc_mem_address(C133,A133,G135,L135)
    Description => "VOQ is allocated to context (SCR)",
    Width => "39", # Excel Formula: =calc_mem_width(E136:E136,M135,F136,-1)
    Type => "Dynamic",
    UsedBy => "CMAP: Read,CMAP: Write",
    MemEntries => "768", # Excel Formula: =calc_field_width_define("NUM_OF_FABRIC_VOQS")/32
    MemWrapper => "1R1W",
    MemProtect => "ECC",
    AdditionalInfo => "SampleReadAccess=1,SampleReadBeforeProt=2,SampleWriteAfterProt=1,CpuReadAccess=Enabled,CpuWriteAccess=Enabled,DisableSameAddressErr=Enabled,WriteActivityFactor=10,ReadActivityFactor=10,PortErrPropagate=Disabled",
    MemLogicalWidth => "32",
    bitmap_b => { #Structure Type: MemField;
      Name => "bitmap_b",
      RegMem => "MemField",
      Width => "32",
      Position => "31:0", # Excel Formula: =calc_position(F135,E136,TRUE)
    },
  },
  context_allocate_clr_master => { #Structure Type: Mem;
    Name => "context_allocate_clr_master",
    RegMem => "Mem",
    Address => "1A00000", # Excel Formula: =calc_mem_address(C135,A135,G137,L137)
    Description => "VOQ is allocated to context (SCR)",
    Width => "39", # Excel Formula: =calc_mem_width(E138:E138,M137,F138,-1)
    Type => "Dynamic",
    UsedBy => "CMAP: Read,CMAP: Write",
    MemEntries => "768", # Excel Formula: =calc_field_width_define("NUM_OF_FABRIC_VOQS")/32
    MemWrapper => "1R1W",
    MemProtect => "ECC",
    AdditionalInfo => "SampleReadAccess=1,SampleReadBeforeProt=2,SampleWriteAfterProt=1,CpuReadAccess=Enabled,CpuWriteAccess=Enabled,DisableSameAddressErr=Enabled,WriteActivityFactor=10,ReadActivityFactor=10,PortErrPropagate=Disabled",
    MemLogicalWidth => "32",
    bitmap_c => { #Structure Type: MemField;
      Name => "bitmap_c",
      RegMem => "MemField",
      Width => "32",
      Position => "31:0", # Excel Formula: =calc_position(F137,E138,TRUE)
    },
  },
  context_allocate_clr_slave => { #Structure Type: Mem;
    Name => "context_allocate_clr_slave",
    RegMem => "Mem",
    Address => "1B00000", # Excel Formula: =calc_mem_address(C137,A137,G139,L139)
    Description => "VOQ is allocated to context (SCR)",
    Width => "39", # Excel Formula: =calc_mem_width(E140:E140,M139,F140,-1)
    Type => "Dynamic",
    UsedBy => "CMAP: Read,CMAP: Write",
    MemEntries => "768", # Excel Formula: =calc_field_width_define("NUM_OF_FABRIC_VOQS")/32
    MemWrapper => "1R1W",
    MemProtect => "ECC",
    AdditionalInfo => "SampleReadAccess=1,SampleReadBeforeProt=2,SampleWriteAfterProt=1,CpuReadAccess=Enabled,CpuWriteAccess=Enabled,DisableSameAddressErr=Enabled,WriteActivityFactor=10,ReadActivityFactor=10,PortErrPropagate=Disabled",
    MemLogicalWidth => "32",
    bitmap_d => { #Structure Type: MemField;
      Name => "bitmap_d",
      RegMem => "MemField",
      Width => "32",
      Position => "31:0", # Excel Formula: =calc_position(F139,E140,TRUE)
    },
  },
  context_allocate_grant_set => { #Structure Type: Mem;
    Name => "context_allocate_grant_set",
    RegMem => "Mem",
    Address => "1C00000", # Excel Formula: =calc_mem_address(C139,A139,G141,L141)
    Description => "VOQ is allocated to context (SCR)",
    Width => "39", # Excel Formula: =calc_mem_width(E142:E142,M141,F142,-1)
    Type => "Dynamic",
    UsedBy => "CMAP: Read,CMAP: Write",
    MemEntries => "768", # Excel Formula: =calc_field_width_define("NUM_OF_FABRIC_VOQS")/32
    MemWrapper => "1R1W",
    MemProtect => "ECC",
    AdditionalInfo => "SampleReadAccess=1,SampleReadBeforeProt=2,SampleWriteAfterProt=1,CpuReadAccess=Enabled,CpuWriteAccess=Enabled,DisableSameAddressErr=Enabled,WriteActivityFactor=10,ReadActivityFactor=10,PortErrPropagate=Disabled",
    MemLogicalWidth => "32",
    bitmap_e => { #Structure Type: MemField;
      Name => "bitmap_e",
      RegMem => "MemField",
      Width => "32",
      Position => "31:0", # Excel Formula: =calc_position(F141,E142,TRUE)
    },
  },
  context_allocate_grant_clr => { #Structure Type: Mem;
    Name => "context_allocate_grant_clr",
    RegMem => "Mem",
    Address => "1D00000", # Excel Formula: =calc_mem_address(C141,A141,G143,L143)
    Description => "VOQ is allocated to context (SCR)",
    Width => "39", # Excel Formula: =calc_mem_width(E144:E144,M143,F144,-1)
    Type => "Dynamic",
    UsedBy => "CMAP: Read,CMAP: Write",
    MemEntries => "768", # Excel Formula: =calc_field_width_define("NUM_OF_FABRIC_VOQS")/32
    MemWrapper => "1R1W",
    MemProtect => "ECC",
    AdditionalInfo => "SampleReadAccess=1,SampleReadBeforeProt=2,SampleWriteAfterProt=1,CpuReadAccess=Enabled,CpuWriteAccess=Enabled,DisableSameAddressErr=Enabled,WriteActivityFactor=10,ReadActivityFactor=10,PortErrPropagate=Disabled",
    MemLogicalWidth => "32",
    bitmap_f => { #Structure Type: MemField;
      Name => "bitmap_f",
      RegMem => "MemField",
      Width => "32",
      Position => "31:0", # Excel Formula: =calc_position(F143,E144,TRUE)
    },
  },
  Context2voq => { #Structure Type: Mem;
    Name => "Context2voq",
    RegMem => "Mem",
    Address => "1E00000", # Excel Formula: =calc_mem_address(C143,A143,G145,L145)
    Description => "credit allocate read port for credit grant",
    Width => "22", # Excel Formula: =calc_mem_width(E146:E146,M145,F146,-1)
    Type => "Dynamic",
    UsedBy => "CMAP: Read,CMAP: Write",
    MemEntries => "3072", # Excel Formula: =calc_field_width_define("NUM_OF_CONTEXTS_FABRIC_SLICE")
    MemWrapper => "1R1W",
    MemProtect => "ECC",
    AdditionalInfo => "SampleReadAccess=1,SampleReadBeforeProt=1,SampleReadAfterProt=1,SampleWriteAfterProt=1,CpuReadAccess=Enabled,CpuWriteAccess=Enabled,DisableSameAddressErr=Enabled,WriteActivityFactor=0,ReadActivityFactor=50,PortErrPropagate=Disabled",
    MemLogicalWidth => "16",
    Context2voqBits => { #Structure Type: MemField;
      Name => "Context2voqBits",
      RegMem => "MemField",
      Description => "Some desc for mem0 field0",
      Width => "16", # Excel Formula: =calc_field_width_define("VOQ_NUMBER_WIDTH")
      Position => "15:0", # Excel Formula: =calc_position(F145,E146,TRUE)
    },
  },
  RqmFreeFifo => { #Structure Type: Mem;
    Name => "RqmFreeFifo",
    RegMem => "Mem",
    Address => "1F00000", # Excel Formula: =calc_mem_address(C145,A145,G147,L147)
    Description => "fifo for dequeue between RQM and the EMCs",
    Width => "38", # Excel Formula: =calc_mem_width(E148:E150,M147,F150,-1)
    Type => "Dynamic",
    UsedBy => "RQM",
    MemEntries => "128", # Excel Formula: =128
    MemWrapper => "Fifo",
    MemProtect => "ECC",
    AdditionalInfo => "SampleReadAccess=1,SampleReadBeforeProt=2,SampleWriteAfterProt=1,DisableSameAddressErr=Enabled,WriteActivityFactor=100,ReadActivityFactor=100,PortErrPropagate=Disabled,CpuReadAccess=Disabled,CpuWriteAccess=Disabled",
    MemLogicalWidth => "31",
    RqmFifoDatBank => { #Structure Type: MemField;
      Name => "RqmFifoDatBank",
      RegMem => "MemField",
      Description => "Some desc for mem0 field0",
      Width => "4",
      Position => "3:0", # Excel Formula: =calc_position(F147,E148,TRUE)
    },
    RqmFifoDatIdx => { #Structure Type: MemField;
      Name => "RqmFifoDatIdx",
      RegMem => "MemField",
      Description => "Some desc for mem0 field0",
      Width => "14", # Excel Formula: =calc_field_width_define("PDVOQ_EM_IDX_WIDTH")
      Position => "17:4", # Excel Formula: =calc_position(F148,E149)
    },
    RqmFifoDatBuf => { #Structure Type: MemField;
      Name => "RqmFifoDatBuf",
      RegMem => "MemField",
      Description => "Some desc for mem0 field0",
      Width => "13", # Excel Formula: =calc_field_width_define("PDVOQ_BUF_WIDTH")
      Position => "30:18", # Excel Formula: =calc_position(F149,E150)
    },
  },
  voqcgmProfile => { #Structure Type: Mem;
    Name => "voqcgmProfile",
    RegMem => "Mem",
    Address => "2000000", # Excel Formula: =calc_mem_address(C147,A147,G151,L151)
    Description => "Dynamic CGM profile per context used by voq_cgm",
    Width => "10", # Excel Formula: =calc_mem_width(E152:E152,M151,F152,-1)
    Type => "Dynamic",
    UsedBy => "CMAP: Write,RQM: Read0,RQM: Read1",
    MemEntries => "3072", # Excel Formula: =calc_field_width_define("NUM_OF_CONTEXTS_FABRIC_SLICE")
    MemWrapper => "2R1W Fast Write",
    MemProtect => "ECC",
    AdditionalInfo => "SampleReadAccess=1,SampleReadBeforeProt=2,SampleWriteAfterProt=1,CpuReadAccess=Enabled,CpuWriteAccess=Enabled,DisableSameAddressErr=Enabled,WriteActivityFactor=10,ReadActivityFactor=100,PortErrPropagate=Disabled",
    MemLogicalWidth => "5",
    cgmProfile => { #Structure Type: MemField;
      Name => "cgmProfile",
      RegMem => "MemField",
      Width => "5", # Excel Formula: =calc_field_width_define("VOQ_CGM_PROFILE_NUM_WIDTH")
      Position => "4:0", # Excel Formula: =calc_position(F151,E152,TRUE)
    },
  },
  DramCgmProfile => { #Structure Type: Mem;
    Name => "DramCgmProfile",
    RegMem => "Mem",
    Address => "2100000", # Excel Formula: =calc_mem_address(C151,A151,G153,L153)
    Description => "Global Portion of Profiles for admission test.
For every CGM profile define the action of the WRED mechanism (i.e. drop or mark) and the probabilty of the action when the queue size is in each of the WRED regions.",
    Width => "114", # Excel Formula: =calc_mem_width(E154:E162,M153,F162,-1)
    Type => "Config",
    UsedBy => "CGM_enq",
    MemEntries => "32",
    MemWrapper => "1P",
    MemProtect => "ECC",
    AdditionalInfo => "SampleReadBeforeProt=2,SampleReadAfterProt=1,SampleWriteAfterProt=1,CpuReadAccess=Enabled,CpuWriteAccess=Enabled,DisableSameAddressErr=Enabled,WriteActivityFactor=0,ReadActivityFactor=100,PortErrPropagate=Disabled",
    Comments => "VOQ_CGM",
    MemLogicalWidth => "106",
    WredAction => { #Structure Type: MemField;
      Name => "WredAction",
      RegMem => "MemField",
      Description => "Defines the impact of WRED result:
0  Disable
1  Affect admission result
2  Affect marking decision",
      Width => "2",
      Position => "1:0", # Excel Formula: =calc_position(F153,E154,TRUE)
    },
    WredProbabilityRegion0 => { #Structure Type: MemField;
      Name => "WredProbabilityRegion0",
      RegMem => "MemField",
      Description => "Defines the drop or marking (according to WRED Action) probability.
0 - No drop/mark
0x1FFF - Drop/mark probabilty is 1",
      Width => "13",
      Position => "14:2", # Excel Formula: =calc_position(F154,E155)
    },
    WredProbabilityRegion1 => { #Structure Type: MemField;
      Name => "WredProbabilityRegion1",
      RegMem => "MemField",
      Description => "Defines the drop or marking (according to WRED Action) probability.
0 - No drop/mark
0x1FFF - Drop/mark probabilty is 1",
      Width => "13",
      Position => "27:15", # Excel Formula: =calc_position(F155,E156)
    },
    WredProbabilityRegion2 => { #Structure Type: MemField;
      Name => "WredProbabilityRegion2",
      RegMem => "MemField",
      Description => "Defines the drop or marking (according to WRED Action) probability.
0 - No drop/mark
0x1FFF - Drop/mark probabilty is 1",
      Width => "13",
      Position => "40:28", # Excel Formula: =calc_position(F156,E157)
    },
    WredProbabilityRegion3 => { #Structure Type: MemField;
      Name => "WredProbabilityRegion3",
      RegMem => "MemField",
      Description => "Defines the drop or marking (according to WRED Action) probability.
0 - No drop/mark
0x1FFF - Drop/mark probabilty is 1",
      Width => "13",
      Position => "53:41", # Excel Formula: =calc_position(F157,E158)
    },
    WredProbabilityRegion4 => { #Structure Type: MemField;
      Name => "WredProbabilityRegion4",
      RegMem => "MemField",
      Description => "Defines the drop or marking (according to WRED Action) probability.
0 - No drop/mark
0x1FFF - Drop/mark probabilty is 1",
      Width => "13",
      Position => "66:54", # Excel Formula: =calc_position(F158,E159)
    },
    WredProbabilityRegion5 => { #Structure Type: MemField;
      Name => "WredProbabilityRegion5",
      RegMem => "MemField",
      Description => "Defines the drop or marking (according to WRED Action) probability.
0 - No drop/mark
0x1FFF - Drop/mark probabilty is 1",
      Width => "13",
      Position => "79:67", # Excel Formula: =calc_position(F159,E160)
    },
    WredProbabilityRegion6 => { #Structure Type: MemField;
      Name => "WredProbabilityRegion6",
      RegMem => "MemField",
      Description => "Defines the drop or marking (according to WRED Action) probability.
0 - No drop/mark
0x1FFF - Drop/mark probabilty is 1",
      Width => "13",
      Position => "92:80", # Excel Formula: =calc_position(F160,E161)
    },
    WredProbabilityRegion7 => { #Structure Type: MemField;
      Name => "WredProbabilityRegion7",
      RegMem => "MemField",
      Description => "Defines the drop or marking (according to WRED Action) probability.
0 - No drop/mark
0x1FFF - Drop/mark probabilty is 1",
      Width => "13",
      Position => "105:93", # Excel Formula: =calc_position(F161,E162)
    },
  },
  ProfileBuffRegionThresholds => { #Structure Type: Mem;
    Name => "ProfileBuffRegionThresholds",
    RegMem => "Mem",
    Address => "2200000", # Excel Formula: =calc_mem_address(C153,A153,G163,L163)
    Description => "Per Profile Thresholds for max queue size in buffers to be included in Region X.
i.e. if QsizeBuffRegion0 < QsizeBuff <= QsizeBuffRegion1 then the region is 1.
If QsizeBuffRegion6 < QsizeBuff the region is 7",
    Width => "98", # Excel Formula: =calc_mem_width(E164:E164,M163,F164,-1)
    Type => "Config",
    UsedBy => "CgmEnqRpt: Read0,CgmDeqRpt: Read1",
    MemEntries => "32", # Excel Formula: =calc_field_width_define("VOQ_CGM_NUM_OF_PROFILES")
    MemWrapper => "2R1W Fast Write",
    MemProtect => "None",
    AdditionalInfo => "CpuReadAccess=Enabled,CpuWriteAccess=Enabled,FfBased=Enabled,DisableSameAddressErr=Enabled,WriteActivityFactor=0,ReadActivityFactor=100,PortErrPropagate=Disabled",
    Comments => "VOQ_CGM",
    MemLogicalWidth => "98",
    QsizeBuffRegion => { #Structure Type: MemField;
      Name => "QsizeBuffRegion",
      RegMem => "MemField",
      Description => "

Packed as:
{QsizeBuffRegion6,,QsizeBuffRegion0}
There are 8 Regions so 7 Thresholds
Each Threshold is 14 bits",
      Width => "98", # Excel Formula: =calc_field_width_define("QSIZE_BUF_WIDTH")*7
      Position => "97:0", # Excel Formula: =calc_position(F163,E164,TRUE)
    },
  },
  ProfilePktRegionThresholds => { #Structure Type: Mem;
    Name => "ProfilePktRegionThresholds",
    RegMem => "Mem",
    Address => "2300000", # Excel Formula: =calc_mem_address(C163,A163,G165,L165)
    Description => "Per Profile Thresholds for max queue size in PDs to be included in Region X.
i.e. if QsizePktRegion0 < QsizePkts <= QsizePktRegion1 then the region is 1.
If QsizePktRegion6 < QsizePkts the region is 7",
    Width => "98", # Excel Formula: =calc_mem_width(E166:E166,M165,F166,-1)
    Type => "Config",
    UsedBy => "CgmEnqRpt: Read0,CgmDeqRpt: Read1",
    MemEntries => "32", # Excel Formula: =calc_field_width_define("VOQ_CGM_NUM_OF_PROFILES")
    MemWrapper => "2R1W Fast Write",
    MemProtect => "None",
    AdditionalInfo => "CpuReadAccess=Enabled,CpuWriteAccess=Enabled,FfBased=Enabled,DisableSameAddressErr=Enabled,WriteActivityFactor=0,ReadActivityFactor=100,PortErrPropagate=Disabled",
    Comments => "VOQ_CGM",
    MemLogicalWidth => "98",
    QsizePktRegion => { #Structure Type: MemField;
      Name => "QsizePktRegion",
      RegMem => "MemField",
      Description => "
Packed as:
{QsizePktRegion6,,QsizePktRegion0}
There are 8 Regions so 7 Thresholds
Each Threshold is 14 bits",
      Width => "98", # Excel Formula: =calc_field_width_define("QSIZE_PKT_WIDTH")*7
      Position => "97:0", # Excel Formula: =calc_position(F165,E166,TRUE)
    },
  },
  ProfilePktEnqTimeRegionThresholds => { #Structure Type: Mem;
    Name => "ProfilePktEnqTimeRegionThresholds",
    RegMem => "Mem",
    Address => "2400000", # Excel Formula: =calc_mem_address(C165,A165,G167,L167)
    Description => "Per Profile Thresholds for Voq-Delay to be in Region X.
i.e. if PdEnqTimeRegion0 < Qdelay <= PdEnqTimeRegion1 then region is 1.
If PdEnqTimeRegion14 < Qdelay region is 15",
    Width => "120", # Excel Formula: =calc_mem_width(E168:E168,M167,F168,-1)
    Type => "Config",
    UsedBy => "cgm_enq_req: Read",
    MemEntries => "32", # Excel Formula: =calc_field_width_define("VOQ_CGM_NUM_OF_PROFILES")
    MemWrapper => "1R1W",
    MemProtect => "None",
    AdditionalInfo => "CpuReadAccess=Enabled,CpuWriteAccess=Enabled,FfBased=Enabled,DisableSameAddressErr=Enabled,WriteActivityFactor=0,ReadActivityFactor=100,PortErrPropagate=Disabled",
    Comments => "VOQ_CGM",
    MemLogicalWidth => "120",
    PktEnqTimeRegion => { #Structure Type: MemField;
      Name => "PktEnqTimeRegion",
      RegMem => "MemField",
      Description => "
Packed as:
{PdEnqTimeRegion14,,QsizeBuffRegion0}
There are 16 Regions so 15 Thresholds
Each Threshold is 8 bits",
      Width => "120", # Excel Formula: =calc_field_width_define("VOQ_CGM_ENQ_TIME_WIDTH")*15
      Position => "119:0", # Excel Formula: =calc_position(F167,E168,TRUE)
    },
  },
  BuffersConsumptionLutForEnq => { #Structure Type: Mem;
    Name => "BuffersConsumptionLutForEnq",
    RegMem => "Mem",
    Address => "2500000", # Excel Formula: =calc_mem_address(C167,A167,G169,L169)
    Description => "CGM Enqueue test LUT for queue size in buffers.
The result of the test is a decision for DropGreen, DropYellow, EvictToDram and CongestionMark.
Every entry in memory holds 16 bits for each decision type and the final decision is selected based on the 4 bit quantized queue delay level.
Address in memory is:
{Profile,DramContextAvailable,RxpdrIngressCounterRegion,VoqSizeBuffersLevel}
Profile is 5 bits.
DramContextAvailable is 1 bit and is received from the ICS.
RxpdrIngressCounterRegion is 2 bits of Rxpdr's CounterA Utilization level.
VoqSizeBuffersLevel is 3 bits and is the quantized queue size in buffers based on ProfileBuffRegionThresholds Memory.",
    Width => "72", # Excel Formula: =calc_mem_width(E170:E173,M169,F173,-1)
    Type => "Config",
    UsedBy => "CGM_enq",
    MemEntries => "2048",
    MemWrapper => "1P",
    MemProtect => "ECC",
    AdditionalInfo => "SampleReadBeforeProt=2,SampleReadAfterProt=1,SampleWriteAfterProt=1,CpuReadAccess=Enabled,CpuWriteAccess=Enabled,DisableSameAddressErr=Enabled,WriteActivityFactor=0,ReadActivityFactor=100,PortErrPropagate=Disabled",
    Comments => "VOQ_CGM
CGM logic implemented in memory.
Address is {VOQ_PROFILE,Free_DRAM_cntx,Buffer_pool_available_level,Buffer_voq_size_level}
5 + 1 + 2 + 3 = 11",
    MemLogicalWidth => "64",
    DropGreen => { #Structure Type: MemField;
      Name => "DropGreen",
      RegMem => "MemField",
      Description => "VoqDelayLevel selects offset out of 16.",
      Width => "16",
      Position => "15:0", # Excel Formula: =calc_position(F169,E170,TRUE)
      Comments => "VOQ_delay_level selects offset out of 16.",
    },
    DropYellow => { #Structure Type: MemField;
      Name => "DropYellow",
      RegMem => "MemField",
      Description => "VoqDelayLevel selects offset out of 16.",
      Width => "16",
      Position => "31:16", # Excel Formula: =calc_position(F170,E171)
      Comments => "VOQ_delay_level selects offset out of 16.",
    },
    EvictToDram => { #Structure Type: MemField;
      Name => "EvictToDram",
      RegMem => "MemField",
      Description => "VoqDelayLevel selects offset out of 16.",
      Width => "16",
      Position => "47:32", # Excel Formula: =calc_position(F171,E172)
      Comments => "VOQ_delay_level selects offset out of 16.",
    },
    CongestionMark => { #Structure Type: MemField;
      Name => "CongestionMark",
      RegMem => "MemField",
      Description => "VoqDelayLevel selects offset out of 16.",
      Width => "16",
      Position => "63:48", # Excel Formula: =calc_position(F172,E173)
      Comments => "VOQ_delay_level selects offset out of 16.",
    },
  },
  PdConsumptionLutForEnq => { #Structure Type: Mem;
    Name => "PdConsumptionLutForEnq",
    RegMem => "Mem",
    Address => "2600000", # Excel Formula: =calc_mem_address(C169,A169,G174,L174)
    Description => "CGM Enqueue test LUT for queue size in PDs.
The result of the test is a decision for DropGreen, DropYellow, EvictToDram and CongestionMark.
Every entry in memory holds 16 bits for each decision type and the final decision is selected based on the 4 bit quantized queue delay level.
Address in memory is:
{Profile,PdvoqPdCounter0Level,VoqSizePdsLevel}
CGM logic implemented in memory.

Profile is 5 bits.
PdvoqPdCounter0Level is 2 bits of PDVOQ's PD Counter 0  Utilization level.
VoqSizePdsLevel is 3 bits and is the quantized queue size in PDs based on ProfilePktRegionThresholds Memory.",
    Width => "72", # Excel Formula: =calc_mem_width(E175:E178,M174,F178,-1)
    Type => "Config",
    UsedBy => "CGM_enq",
    MemEntries => "1024",
    MemWrapper => "1P",
    MemProtect => "ECC",
    AdditionalInfo => "SampleReadBeforeProt=2,SampleReadAfterProt=1,SampleWriteAfterProt=1,CpuReadAccess=Enabled,CpuWriteAccess=Enabled,DisableSameAddressErr=Enabled,WriteActivityFactor=0,ReadActivityFactor=100,PortErrPropagate=Disabled",
    Comments => "VOQ_CGM
CGM logic implemented in memory.
Address is {VOQ_PROFILE,PD_pool_available_level,PD_voq_fill_level}
5 + 2 + 3 = 10",
    MemLogicalWidth => "64",
    DropGreen => { #Structure Type: MemField;
      Name => "DropGreen",
      RegMem => "MemField",
      Description => "VoqDelayLevel selects offset out of 16.",
      Width => "16",
      Position => "15:0", # Excel Formula: =calc_position(F174,E175,TRUE)
    },
    DropYellow => { #Structure Type: MemField;
      Name => "DropYellow",
      RegMem => "MemField",
      Description => "VoqDelayLevel selects offset out of 16.",
      Width => "16",
      Position => "31:16", # Excel Formula: =calc_position(F175,E176)
    },
    EvictToDram => { #Structure Type: MemField;
      Name => "EvictToDram",
      RegMem => "MemField",
      Description => "VoqDelayLevel selects offset out of 16.",
      Width => "16",
      Position => "47:32", # Excel Formula: =calc_position(F176,E177)
    },
    CongestionMark => { #Structure Type: MemField;
      Name => "CongestionMark",
      RegMem => "MemField",
      Description => "VoqDelayLevel selects offset out of 16.",
      Width => "16",
      Position => "63:48", # Excel Formula: =calc_position(F177,E178)
    },
  },
  VoqEnqRptSizeForEnq => { #Structure Type: Mem;
    Name => "VoqEnqRptSizeForEnq",
    RegMem => "Mem",
    Address => "2700000", # Excel Formula: =calc_mem_address(C174,A174,G179,L179)
    Description => "Enq Report Qsize region per context for Enq pipe",
    Width => "11", # Excel Formula: =calc_mem_width(E180:E181,M179,F181,-1)
    Type => "Dynamic",
    UsedBy => "CgmEnq: Read,CgmEnqRpt: Write",
    MemEntries => "3072", # Excel Formula: =calc_field_width_define("NUM_OF_CONTEXTS_FABRIC_SLICE")
    MemWrapper => "1R1W",
    MemProtect => "ECC",
    AdditionalInfo => "SampleReadBeforeProt=2,SampleReadAfterProt=1,SampleWriteAfterProt=1,CpuReadAccess=Enabled,CpuWriteAccess=Enabled,DisableSameAddressErr=Enabled,WriteActivityFactor=100,ReadActivityFactor=100,PortErrPropagate=Disabled",
    Comments => "VOQ_CGM",
    MemLogicalWidth => "6",
    BuffRegion => { #Structure Type: MemField;
      Name => "BuffRegion",
      RegMem => "MemField",
      Description => "Qsize in buff region for Context",
      Width => "3",
      Position => "2:0", # Excel Formula: =calc_position(F179,E180,TRUE)
    },
    PktRegion => { #Structure Type: MemField;
      Name => "PktRegion",
      RegMem => "MemField",
      Description => "Qsize in Pkt region for Context",
      Width => "3",
      Position => "5:3", # Excel Formula: =calc_position(F180,E181)
    },
  },
  VoqDeqRptSizeForEnq => { #Structure Type: Mem;
    Name => "VoqDeqRptSizeForEnq",
    RegMem => "Mem",
    Address => "2800000", # Excel Formula: =calc_mem_address(C179,A179,G182,L182)
    Description => "Deq Report Qsize region per context for Enq pipe",
    Width => "11", # Excel Formula: =calc_mem_width(E183:E184,M182,F184,-1)
    Type => "Dynamic",
    UsedBy => "CgmEnq: Read,CgmDeqRpt: Write",
    MemEntries => "3072", # Excel Formula: =calc_field_width_define("NUM_OF_CONTEXTS_FABRIC_SLICE")
    MemWrapper => "1R1W",
    MemProtect => "ECC",
    AdditionalInfo => "SampleReadBeforeProt=2,SampleReadAfterProt=1,SampleWriteAfterProt=1,CpuReadAccess=Enabled,CpuWriteAccess=Enabled,DisableSameAddressErr=Enabled,WriteActivityFactor=100,ReadActivityFactor=100,PortErrPropagate=Disabled",
    Comments => "VOQ_CGM",
    MemLogicalWidth => "6",
    BuffRegion => { #Structure Type: MemField;
      Name => "BuffRegion",
      RegMem => "MemField",
      Description => "Qsize in buff region for Context",
      Width => "3",
      Position => "2:0", # Excel Formula: =calc_position(F182,E183,TRUE)
    },
    PktRegion => { #Structure Type: MemField;
      Name => "PktRegion",
      RegMem => "MemField",
      Description => "Qsize in Pkt region for Context",
      Width => "3",
      Position => "5:3", # Excel Formula: =calc_position(F183,E184)
    },
  },
  VoqEnqRptSizeForDeq => { #Structure Type: Mem;
    Name => "VoqEnqRptSizeForDeq",
    RegMem => "Mem",
    Address => "2900000", # Excel Formula: =calc_mem_address(C182,A182,G185,L185)
    Description => "Enq Report Qsize region per context for Enq pipe",
    Width => "7", # Excel Formula: =calc_mem_width(E186:E186,M185,F186,-1)
    Type => "Dynamic",
    UsedBy => "CgmRdReq: Read,CgmEnqRpt: Write",
    MemEntries => "3072", # Excel Formula: =calc_field_width_define("NUM_OF_CONTEXTS_FABRIC_SLICE")
    MemWrapper => "1R1W",
    MemProtect => "ECC",
    AdditionalInfo => "SampleReadBeforeProt=2,SampleReadAfterProt=1,SampleWriteAfterProt=1,CpuReadAccess=Enabled,CpuWriteAccess=Enabled,DisableSameAddressErr=Enabled,WriteActivityFactor=100,ReadActivityFactor=100,PortErrPropagate=Disabled",
    Comments => "VOQ_CGM",
    MemLogicalWidth => "3",
    BuffRegion => { #Structure Type: MemField;
      Name => "BuffRegion",
      RegMem => "MemField",
      Description => "Qsize in buff region for Context",
      Width => "3",
      Position => "2:0", # Excel Formula: =calc_position(F185,E186,TRUE)
    },
  },
  VoqDeqRptSizeForDeq => { #Structure Type: Mem;
    Name => "VoqDeqRptSizeForDeq",
    RegMem => "Mem",
    Address => "2A00000", # Excel Formula: =calc_mem_address(C185,A185,G187,L187)
    Description => "Deq Report Qsize region per context for Enq pipe",
    Width => "7", # Excel Formula: =calc_mem_width(E188:E188,M187,F188,-1)
    Type => "Dynamic",
    UsedBy => "CgmRdReq: Read,CgmDeqRpt: Write",
    MemEntries => "3072", # Excel Formula: =calc_field_width_define("NUM_OF_CONTEXTS_FABRIC_SLICE")
    MemWrapper => "1R1W",
    MemProtect => "ECC",
    AdditionalInfo => "SampleReadBeforeProt=2,SampleReadAfterProt=1,SampleWriteAfterProt=1,CpuReadAccess=Enabled,CpuWriteAccess=Enabled,DisableSameAddressErr=Enabled,WriteActivityFactor=100,ReadActivityFactor=100,PortErrPropagate=Disabled",
    Comments => "VOQ_CGM",
    MemLogicalWidth => "3",
    BuffRegion => { #Structure Type: MemField;
      Name => "BuffRegion",
      RegMem => "MemField",
      Description => "Qsize in buff region for Context",
      Width => "3",
      Position => "2:0", # Excel Formula: =calc_position(F187,E188,TRUE)
    },
  },
  LastRptEnqSetMem => { #Structure Type: Mem;
    Name => "LastRptEnqSetMem",
    RegMem => "Mem",
    Address => "2B00000", # Excel Formula: =calc_mem_address(C187,A187,G189,L189)
    Description => "Set part of Set Clear Red Memory
Needs to be initiated to 0",
    Width => "39", # Excel Formula: =calc_mem_width(E190:E190,M189,F190,-1)
    Type => "Dynamic",
    UsedBy => "CGM_SCRP",
    MemEntries => "96", # Excel Formula: =calc_field_width_define("NUM_OF_CONTEXTS_FABRIC_SLICE")/32
    MemWrapper => "3R1W Fast Write",
    MemProtect => "ECC",
    AdditionalInfo => "SampleReadBeforeProt=2,SampleReadAfterProt=1,SampleWriteAfterProt=1,CpuReadAccess=Enabled,CpuWriteAccess=Enabled,DisableSameAddressErr=Enabled,WriteActivityFactor=100,ReadActivityFactor=100,PortErrPropagate=Disabled",
    Comments => "VOQ_CGM",
    MemLogicalWidth => "32",
    EnqValid => { #Structure Type: MemField;
      Name => "EnqValid",
      RegMem => "MemField",
      Width => "32",
      Position => "31:0", # Excel Formula: =calc_position(F189,E190,TRUE)
      DefaultValue => "h0",
    },
  },
  LastRptEnqSetMemExtra => { #Structure Type: Mem;
    Name => "LastRptEnqSetMemExtra",
    RegMem => "Mem",
    Address => "2C00000", # Excel Formula: =calc_mem_address(C189,A189,G191,L191)
    Description => "Set part of Set Clear Red Memory
Needs to be initiated to 0",
    Width => "39", # Excel Formula: =calc_mem_width(E192:E192,M191,F192,-1)
    Type => "Dynamic",
    UsedBy => "CGM_SCRP",
    MemEntries => "96", # Excel Formula: =calc_field_width_define("NUM_OF_CONTEXTS_FABRIC_SLICE")/32
    MemWrapper => "1R1W",
    MemProtect => "ECC",
    AdditionalInfo => "SampleReadBeforeProt=2,SampleReadAfterProt=1,SampleWriteAfterProt=1,CpuReadAccess=Enabled,CpuWriteAccess=Enabled,DisableSameAddressErr=Enabled,WriteActivityFactor=100,ReadActivityFactor=100,PortErrPropagate=Disabled",
    Comments => "VOQ_CGM",
    MemLogicalWidth => "32",
    EnqValid => { #Structure Type: MemField;
      Name => "EnqValid",
      RegMem => "MemField",
      Width => "32",
      Position => "31:0", # Excel Formula: =calc_position(F191,E192,TRUE)
      DefaultValue => "h0",
    },
  },
  LastRptEnqClrMem => { #Structure Type: Mem;
    Name => "LastRptEnqClrMem",
    RegMem => "Mem",
    Address => "2D00000", # Excel Formula: =calc_mem_address(C191,A191,G193,L193)
    Description => "Clr part of Set Clear Red Memory
Needs to be initiated to 0",
    Width => "39", # Excel Formula: =calc_mem_width(E194:E194,M193,F194,-1)
    Type => "Dynamic",
    UsedBy => "CGM_SCRP",
    MemEntries => "96", # Excel Formula: =calc_field_width_define("NUM_OF_CONTEXTS_FABRIC_SLICE")/32
    MemWrapper => "3R1W Fast Write",
    MemProtect => "ECC",
    AdditionalInfo => "SampleReadBeforeProt=2,SampleReadAfterProt=1,SampleWriteAfterProt=1,CpuReadAccess=Enabled,CpuWriteAccess=Enabled,DisableSameAddressErr=Enabled,WriteActivityFactor=100,ReadActivityFactor=100,PortErrPropagate=Disabled",
    Comments => "VOQ_CGM",
    MemLogicalWidth => "32",
    DeqValid => { #Structure Type: MemField;
      Name => "DeqValid",
      RegMem => "MemField",
      Width => "32",
      Position => "31:0", # Excel Formula: =calc_position(F193,E194,TRUE)
      DefaultValue => "h0",
    },
  },
  LastRptEnqClrMemExtra => { #Structure Type: Mem;
    Name => "LastRptEnqClrMemExtra",
    RegMem => "Mem",
    Address => "2E00000", # Excel Formula: =calc_mem_address(C193,A193,G195,L195)
    Description => "Clr part of Set Clear Red Memory
Needs to be initiated to 0",
    Width => "39", # Excel Formula: =calc_mem_width(E196:E196,M195,F196,-1)
    Type => "Dynamic",
    UsedBy => "CGM_SCRP",
    MemEntries => "96", # Excel Formula: =calc_field_width_define("NUM_OF_CONTEXTS_FABRIC_SLICE")/32
    MemWrapper => "1R1W",
    MemProtect => "ECC",
    AdditionalInfo => "SampleReadBeforeProt=2,SampleReadAfterProt=1,SampleWriteAfterProt=1,CpuReadAccess=Enabled,CpuWriteAccess=Enabled,DisableSameAddressErr=Enabled,WriteActivityFactor=100,ReadActivityFactor=100,PortErrPropagate=Disabled",
    Comments => "VOQ_CGM",
    MemLogicalWidth => "32",
    DeqValid => { #Structure Type: MemField;
      Name => "DeqValid",
      RegMem => "MemField",
      Width => "32",
      Position => "31:0", # Excel Formula: =calc_position(F195,E196,TRUE)
      DefaultValue => "h0",
    },
  },
  VoqTenqHeadEnq => { #Structure Type: Mem;
    Name => "VoqTenqHeadEnq",
    RegMem => "Mem",
    Address => "2F00000", # Excel Formula: =calc_mem_address(C195,A195,G197,L197)
    Description => "Enq time for CGM",
    Width => "13", # Excel Formula: =calc_mem_width(E198:E198,M197,F198,-1)
    Type => "Dynamic",
    UsedBy => "CgmEnq: Read,CgmEnqRpt: Write",
    MemEntries => "3072", # Excel Formula: =calc_field_width_define("NUM_OF_CONTEXTS_FABRIC_SLICE")
    MemWrapper => "1R1W",
    MemProtect => "ECC",
    AdditionalInfo => "SampleReadBeforeProt=2,SampleReadAfterProt=1,SampleWriteAfterProt=1,CpuReadAccess=Enabled,CpuWriteAccess=Enabled,DisableSameAddressErr=Enabled,WriteActivityFactor=100,ReadActivityFactor=100,PortErrPropagate=Disabled",
    Comments => "VOQ_CGM",
    MemLogicalWidth => "8",
    TEnq => { #Structure Type: MemField;
      Name => "TEnq",
      RegMem => "MemField",
      Description => "First enq device time",
      Width => "8",
      Position => "7:0", # Excel Formula: =calc_position(F197,E198,TRUE)
    },
  },
  VoqTenqHeadRd => { #Structure Type: Mem;
    Name => "VoqTenqHeadRd",
    RegMem => "Mem",
    Address => "3000000", # Excel Formula: =calc_mem_address(C197,A197,G199,L199)
    Description => "Voq Head time for CGM",
    Width => "13", # Excel Formula: =calc_mem_width(E200:E200,M199,F200,-1)
    Type => "Dynamic",
    UsedBy => "CgmEnq: Read,CgmRdRpt: Write",
    MemEntries => "3072", # Excel Formula: =calc_field_width_define("NUM_OF_CONTEXTS_FABRIC_SLICE")
    MemWrapper => "1R1W",
    MemProtect => "ECC",
    AdditionalInfo => "SampleReadBeforeProt=2,SampleReadAfterProt=1,SampleWriteAfterProt=1,CpuReadAccess=Enabled,CpuWriteAccess=Enabled,DisableSameAddressErr=Enabled,WriteActivityFactor=100,ReadActivityFactor=100,PortErrPropagate=Disabled",
    Comments => "VOQ_CGM",
    MemLogicalWidth => "8",
    TEnq => { #Structure Type: MemField;
      Name => "TEnq",
      RegMem => "MemField",
      Description => "Voq Head time for CGM",
      Width => "8",
      Position => "7:0", # Excel Formula: =calc_position(F199,E200,TRUE)
    },
  },
  VoqTenqHeadMsbEnq => { #Structure Type: Mem;
    Name => "VoqTenqHeadMsbEnq",
    RegMem => "Mem",
    Address => "3100000", # Excel Formula: =calc_mem_address(C199,A199,G201,L201)
    Description => "Enq time for CGM",
    Width => "6", # Excel Formula: =calc_mem_width(E202:E202,M201,F202,-1)
    Type => "Dynamic",
    UsedBy => "CgmAging: Read,CgmEnqRpt: Write",
    MemEntries => "3072", # Excel Formula: =calc_field_width_define("NUM_OF_CONTEXTS_FABRIC_SLICE")
    MemWrapper => "1R1W",
    MemProtect => "ECC",
    AdditionalInfo => "SampleReadBeforeProt=2,SampleReadAfterProt=1,SampleWriteAfterProt=1,CpuReadAccess=Enabled,CpuWriteAccess=Enabled,DisableSameAddressErr=Enabled,WriteActivityFactor=100,ReadActivityFactor=100,PortErrPropagate=Disabled",
    Comments => "VOQ_CGM",
    MemLogicalWidth => "2",
    TEnq => { #Structure Type: MemField;
      Name => "TEnq",
      RegMem => "MemField",
      Description => "First enq device time",
      Width => "2",
      Position => "1:0", # Excel Formula: =calc_position(F201,E202,TRUE)
    },
  },
  VoqTenqHeadMsbRd => { #Structure Type: Mem;
    Name => "VoqTenqHeadMsbRd",
    RegMem => "Mem",
    Address => "3200000", # Excel Formula: =calc_mem_address(C201,A201,G203,L203)
    Description => "Voq Head time for CGM",
    Width => "6", # Excel Formula: =calc_mem_width(E204:E204,M203,F204,-1)
    Type => "Dynamic",
    UsedBy => "CgmAging: Read,CgmRdRpt: Write",
    MemEntries => "3072", # Excel Formula: =calc_field_width_define("NUM_OF_CONTEXTS_FABRIC_SLICE")
    MemWrapper => "1R1W",
    MemProtect => "ECC",
    AdditionalInfo => "SampleReadBeforeProt=2,SampleReadAfterProt=1,SampleWriteAfterProt=1,CpuReadAccess=Enabled,CpuWriteAccess=Enabled,DisableSameAddressErr=Enabled,WriteActivityFactor=100,ReadActivityFactor=100,PortErrPropagate=Disabled",
    Comments => "VOQ_CGM",
    MemLogicalWidth => "2",
    TEnq => { #Structure Type: MemField;
      Name => "TEnq",
      RegMem => "MemField",
      Description => "Voq Head time for CGM",
      Width => "2",
      Position => "1:0", # Excel Formula: =calc_position(F203,E204,TRUE)
    },
  },
  HeadTimeEnqSetMem => { #Structure Type: Mem;
    Name => "HeadTimeEnqSetMem",
    RegMem => "Mem",
    Address => "3300000", # Excel Formula: =calc_mem_address(C203,A203,G205,L205)
    Description => "Set part of Set Clear Red Memory
Needs to be initiated to 0",
    Width => "39", # Excel Formula: =calc_mem_width(E206:E206,M205,F206,-1)
    Type => "Dynamic",
    UsedBy => "CGM_SCRP",
    MemEntries => "96", # Excel Formula: =calc_field_width_define("NUM_OF_CONTEXTS_FABRIC_SLICE")/32
    MemWrapper => "3R1W Fast Write",
    MemProtect => "ECC",
    AdditionalInfo => "SampleReadBeforeProt=2,SampleReadAfterProt=1,SampleWriteAfterProt=1,CpuReadAccess=Enabled,CpuWriteAccess=Enabled,DisableSameAddressErr=Enabled,WriteActivityFactor=100,ReadActivityFactor=100,PortErrPropagate=Disabled",
    Comments => "VOQ_CGM",
    MemLogicalWidth => "32",
    EnqValid => { #Structure Type: MemField;
      Name => "EnqValid",
      RegMem => "MemField",
      Width => "32",
      Position => "31:0", # Excel Formula: =calc_position(F205,E206,TRUE)
      DefaultValue => "h0",
    },
  },
  HeadTimeEnqSetMemExtra => { #Structure Type: Mem;
    Name => "HeadTimeEnqSetMemExtra",
    RegMem => "Mem",
    Address => "3400000", # Excel Formula: =calc_mem_address(C205,A205,G207,L207)
    Description => "Set part of Set Clear Red Memory
Needs to be initiated to 0",
    Width => "39", # Excel Formula: =calc_mem_width(E208:E208,M207,F208,-1)
    Type => "Dynamic",
    UsedBy => "CGM_SCRP",
    MemEntries => "96", # Excel Formula: =calc_field_width_define("NUM_OF_CONTEXTS_FABRIC_SLICE")/32
    MemWrapper => "1R1W",
    MemProtect => "ECC",
    AdditionalInfo => "SampleReadBeforeProt=2,SampleReadAfterProt=1,SampleWriteAfterProt=1,CpuReadAccess=Enabled,CpuWriteAccess=Enabled,DisableSameAddressErr=Enabled,WriteActivityFactor=100,ReadActivityFactor=100,PortErrPropagate=Disabled",
    Comments => "VOQ_CGM",
    MemLogicalWidth => "32",
    EnqValid => { #Structure Type: MemField;
      Name => "EnqValid",
      RegMem => "MemField",
      Width => "32",
      Position => "31:0", # Excel Formula: =calc_position(F207,E208,TRUE)
      DefaultValue => "h0",
    },
  },
  HeadTimeEnqClrMem => { #Structure Type: Mem;
    Name => "HeadTimeEnqClrMem",
    RegMem => "Mem",
    Address => "3500000", # Excel Formula: =calc_mem_address(C207,A207,G209,L209)
    Description => "Clr part of Set Clear Red Memory
Needs to be initiated to 0",
    Width => "39", # Excel Formula: =calc_mem_width(E210:E210,M209,F210,-1)
    Type => "Dynamic",
    UsedBy => "CGM_SCRP",
    MemEntries => "96", # Excel Formula: =calc_field_width_define("NUM_OF_CONTEXTS_FABRIC_SLICE")/32
    MemWrapper => "3R1W Fast Write",
    MemProtect => "ECC",
    AdditionalInfo => "SampleReadBeforeProt=2,SampleReadAfterProt=1,SampleWriteAfterProt=1,CpuReadAccess=Enabled,CpuWriteAccess=Enabled,DisableSameAddressErr=Enabled,WriteActivityFactor=100,ReadActivityFactor=100,PortErrPropagate=Disabled",
    Comments => "VOQ_CGM",
    MemLogicalWidth => "32",
    DeqValid => { #Structure Type: MemField;
      Name => "DeqValid",
      RegMem => "MemField",
      Width => "32",
      Position => "31:0", # Excel Formula: =calc_position(F209,E210,TRUE)
      DefaultValue => "h0",
    },
  },
  HeadTimeEnqClrMemExtra => { #Structure Type: Mem;
    Name => "HeadTimeEnqClrMemExtra",
    RegMem => "Mem",
    Address => "3600000", # Excel Formula: =calc_mem_address(C209,A209,G211,L211)
    Description => "Clr part of Set Clear Red Memory
Needs to be initiated to 0",
    Width => "39", # Excel Formula: =calc_mem_width(E212:E212,M211,F212,-1)
    Type => "Dynamic",
    UsedBy => "CGM_SCRP",
    MemEntries => "96", # Excel Formula: =calc_field_width_define("NUM_OF_CONTEXTS_FABRIC_SLICE")/32
    MemWrapper => "1R1W",
    MemProtect => "ECC",
    AdditionalInfo => "SampleReadBeforeProt=2,SampleReadAfterProt=1,SampleWriteAfterProt=1,CpuReadAccess=Enabled,CpuWriteAccess=Enabled,DisableSameAddressErr=Enabled,WriteActivityFactor=100,ReadActivityFactor=100,PortErrPropagate=Disabled",
    Comments => "VOQ_CGM",
    MemLogicalWidth => "32",
    DeqValid => { #Structure Type: MemField;
      Name => "DeqValid",
      RegMem => "MemField",
      Width => "32",
      Position => "31:0", # Excel Formula: =calc_position(F211,E212,TRUE)
      DefaultValue => "h0",
    },
  },
  IsAgingSetMem => { #Structure Type: Mem;
    Name => "IsAgingSetMem",
    RegMem => "Mem",
    Address => "3700000", # Excel Formula: =calc_mem_address(C211,A211,G213,L213)
    Description => "Set part of Set Clear Red Memory
Needs to be initiated to 0",
    Width => "39", # Excel Formula: =calc_mem_width(E214:E214,M213,F214,-1)
    Type => "Dynamic",
    UsedBy => "CGM_SCRP",
    MemEntries => "96", # Excel Formula: =calc_field_width_define("NUM_OF_CONTEXTS_FABRIC_SLICE")/32
    MemWrapper => "3R1W Fast Write",
    MemProtect => "ECC",
    AdditionalInfo => "SampleReadBeforeProt=2,SampleReadAfterProt=1,SampleWriteAfterProt=1,CpuReadAccess=Enabled,CpuWriteAccess=Enabled,DisableSameAddressErr=Enabled,WriteActivityFactor=100,ReadActivityFactor=100,PortErrPropagate=Disabled",
    Comments => "VOQ_CGM",
    MemLogicalWidth => "32",
    Aging => { #Structure Type: MemField;
      Name => "Aging",
      RegMem => "MemField",
      Width => "32",
      Position => "31:0", # Excel Formula: =calc_position(F213,E214,TRUE)
      DefaultValue => "h0",
    },
  },
  IsAgingClrMem => { #Structure Type: Mem;
    Name => "IsAgingClrMem",
    RegMem => "Mem",
    Address => "3800000", # Excel Formula: =calc_mem_address(C213,A213,G215,L215)
    Description => "Set part of Set Clear Red Memory
Needs to be initiated to 0",
    Width => "39", # Excel Formula: =calc_mem_width(E216:E216,M215,F216,-1)
    Type => "Dynamic",
    UsedBy => "CGM_SCRP",
    MemEntries => "96", # Excel Formula: =calc_field_width_define("NUM_OF_CONTEXTS_FABRIC_SLICE")/32
    MemWrapper => "3R1W Fast Write",
    MemProtect => "ECC",
    AdditionalInfo => "SampleReadBeforeProt=2,SampleReadAfterProt=1,SampleWriteAfterProt=1,CpuReadAccess=Enabled,CpuWriteAccess=Enabled,DisableSameAddressErr=Enabled,WriteActivityFactor=100,ReadActivityFactor=100,PortErrPropagate=Disabled",
    Comments => "VOQ_CGM",
    MemLogicalWidth => "32",
    Aging => { #Structure Type: MemField;
      Name => "Aging",
      RegMem => "MemField",
      Width => "32",
      Position => "31:0", # Excel Formula: =calc_position(F215,E216,TRUE)
      DefaultValue => "h0",
    },
  },
  AdmissionResultDram => { #Structure Type: Mem;
    Name => "AdmissionResultDram",
    RegMem => "Mem",
    Address => "3900000", # Excel Formula: =calc_mem_address(C215,A215,G217,L217)
    Description => "Dram Admission Result Memory",
    Width => "72", # Excel Formula: =calc_mem_width(E218:E218,M217,F218,-1)
    Type => "Dynamic",
    UsedBy => "dram: Write,CgmRmw: Read0,CgmEnq: Read1",
    MemEntries => "96", # Excel Formula: =calc_field_width_define("NUM_OF_CONTEXTS_FABRIC_SLICE")/32
    MemWrapper => "2R1W Fast Write",
    MemProtect => "ECC",
    AdditionalInfo => "SampleReadBeforeProt=2,SampleReadAfterProt=1,SampleWriteAfterProt=1,CpuReadAccess=Enabled,CpuWriteAccess=Enabled,DisableSameAddressErr=Enabled,WriteActivityFactor=8,ReadActivityFactor=100,PortErrPropagate=Disabled",
    Comments => "VOQ_CGM",
    MemLogicalWidth => "64",
    AdmissionResult => { #Structure Type: MemField;
      Name => "AdmissionResult",
      RegMem => "MemField",
      Description => "Result is packed as {DropDp1,DropDp0}
DropDpx : 0 - Admit; 1 - Drop",
      Width => "64",
      Position => "63:0", # Excel Formula: =calc_position(F217,E218,TRUE)
      DefaultValue => "h0",
    },
  },
  WredRegion => { #Structure Type: Mem;
    Name => "WredRegion",
    RegMem => "Mem",
    Address => "3A00000", # Excel Formula: =calc_mem_address(C217,A217,G219,L219)
    Description => "Region for Wred mark/drop
Needs to be initiated to 0",
    Width => "104", # Excel Formula: =calc_mem_width(E220:E220,M219,F220,-1)
    Type => "Dynamic",
    UsedBy => "dram: Write,CgmEnq: Read",
    MemEntries => "96", # Excel Formula: =calc_field_width_define("NUM_OF_CONTEXTS_FABRIC_SLICE")/32
    MemWrapper => "1R1W",
    MemProtect => "ECC",
    AdditionalInfo => "SampleReadBeforeProt=2,SampleReadAfterProt=1,SampleWriteAfterProt=1,CpuReadAccess=Enabled,CpuWriteAccess=Enabled,DisableSameAddressErr=Enabled,WriteActivityFactor=8,ReadActivityFactor=100,PortErrPropagate=Disabled",
    Comments => "VOQ_CGM",
    MemLogicalWidth => "96",
    Region => { #Structure Type: MemField;
      Name => "Region",
      RegMem => "MemField",
      Description => "The region chooses the drop/mark probability from the profile
3 bits per Entry, 32 Entries in line",
      Width => "96",
      Position => "95:0", # Excel Formula: =calc_position(F219,E220,TRUE)
      DefaultValue => "h0",
    },
  },
};
